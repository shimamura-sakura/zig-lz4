'use strict';

var test = require('tape');
var forEach = require('for-each');
var v = require('es-value-fixtures');
var inspect = require('object-inspect');

var byteLength = require('../');

test('byteLength', function (t) {
	forEach(v.objects.concat(v.primitives), function (nonAB) {
		t.equal(byteLength(nonAB), NaN, inspect(nonAB) + ' is not an ArrayBuffer, and yields NaN');
	});

	t.test('ArrayBuffers', { skip: typeof ArrayBuffer !== 'function' }, function (st) {
		var ab32 = new ArrayBuffer(32);
		st.equal(byteLength(ab32), 32, 'works on an ArrayBuffer of length 32: ' + inspect(ab32));

		var ab0 = new ArrayBuffer(0);
		st.equal(byteLength(ab0), 0, 'works on an ArrayBuffer of length 0: ' + inspect(ab0));

		var dv = new DataView(ab32);
		st.equal(byteLength(dv), NaN, 'a DataView returns NaN');

		st.end();
	});

	t.end();
});
'use strict';

var implementation = require('../implementation');
var callBind = require('call-bind');
var test = require('tape');
var hasStrictMode = require('has-strict-mode')();
var runTests = require('./tests');

test('as a function', function (t) {
	t.test('ArrayBuffer support', { skip: typeof ArrayBuffer === 'undefined' }, function (st) {
		st.test('bad array/this value', { skip: !hasStrictMode }, function (s2t) {
		/* eslint no-useless-call: 0 */
			s2t['throws'](function () { implementation.call(undefined); }, TypeError, 'undefined is not an object');
			s2t['throws'](function () { implementation.call(null); }, TypeError, 'null is not an object');
			s2t.end();
		});

		runTests(callBind(implementation), st);

		st.end();
	});

	t.test('no ArrayBuffer support', { skip: typeof ArrayBuffer !== 'undefined' }, function (st) {
		st['throws'](
			function () { implementation.call({}); },
			SyntaxError,
			'ArrayBuffer is not supported'
		);
	});

	t.end();
});
'use strict';

var index = require('../');
var test = require('tape');
var runTests = require('./tests');

test('as a function', function (t) {
	t.test('ArrayBuffer support', { skip: typeof ArrayBuffer === 'undefined' }, function (st) {
		st.test('bad array/this value', function (s2t) {
			s2t['throws'](function () { index(undefined); }, TypeError, 'undefined is not an object');
			s2t['throws'](function () { index(null); }, TypeError, 'null is not an object');
			s2t.end();
		});

		runTests(index, st);

		st.end();
	});

	t.test('no ArrayBuffer support', { skip: typeof ArrayBuffer !== 'undefined' }, function (st) {
		st['throws'](
			function () { index({}); },
			SyntaxError,
			'ArrayBuffer is not supported'
		);
	});

	t.end();
});
'use strict';

require('../auto');

var test = require('tape');
var defineProperties = require('define-properties');
var callBind = require('call-bind');

var isEnumerable = Object.prototype.propertyIsEnumerable;
var functionsHaveNames = require('functions-have-names')();
var hasStrictMode = require('has-strict-mode')();

var runTests = require('./tests');

test('shimmed', function (t) {
	t.test('ArrayBuffer support', { skip: typeof ArrayBuffer === 'undefined' }, function (st) {
		var method = ArrayBuffer.prototype.slice;

		st.equal(method.length, 2, 'ArrayBuffer#slice has a length of 2');

		st.test('Function name', { skip: !functionsHaveNames }, function (s2t) {
			s2t.equal(method.name, 'slice', 'ArrayBuffer#slice name "slice"');
			s2t.end();
		});

		st.test('enumerability', { skip: !defineProperties.supportsDescriptors }, function (et) {
			et.equal(false, isEnumerable.call(ArrayBuffer.prototype, 'slice'), 'ArrayBuffer#slice is not enumerable');
			et.end();
		});

		st.test('bad array/this value', { skip: !hasStrictMode }, function (s2t) {
			/* eslint no-useless-call: 0 */
			s2t['throws'](function () { return method.call(undefined); }, TypeError, 'undefined is not an object');
			s2t['throws'](function () { return method.call(null); }, TypeError, 'null is not an object');
			s2t.end();
		});

		t.test('has the correct descriptor', { skip: !Object.getOwnPropertyDescriptor }, function (s2t) {
			var descriptor = Object.getOwnPropertyDescriptor(ArrayBuffer.prototype, 'slice');

			s2t.equal(descriptor.configurable, true);
			s2t.equal(descriptor.enumerable, false);
			s2t.equal(typeof descriptor.value, 'function');
			s2t.equal(descriptor.writable, true);
			s2t.end();
		});

		runTests(callBind(method), st);

		st.end();
	});

	t.end();
});
'use strict';

var inspect = require('object-inspect');
var IsDetachedBuffer = require('es-abstract/2024/IsDetachedBuffer');

var forEach = require('for-each');
var v = require('es-value-fixtures');

var byteLength = require('array-buffer-byte-length');

module.exports = function runTests(slice, t) {
	forEach(v.primitives.concat(v.objects), function (nonAB) {
		t['throws'](
			function () { slice(nonAB); },
			TypeError,
			inspect(nonAB) + ' is not an ArrayBuffer'
		);
	});

	t.test('ArrayBuffers', { skip: typeof ArrayBuffer === 'undefined' }, function (st) {
		var ab = new ArrayBuffer(0);

		st.equal(IsDetachedBuffer(ab), false, 'ArrayBuffer is not detached');

		try {
			var nb = slice(ab);
		} catch (e) {
			if (e instanceof SyntaxError) {
				st.skip('Detaching ArrayBuffer is not supported');
				return st.end();
			}
			console.log(e.stack);
		}

		st.notEqual(nb, ab, 'new ArrayBuffer is not the same as the original');
		st.equal(IsDetachedBuffer(ab), false, 'old ArrayBuffer is not detached');
		st.equal(IsDetachedBuffer(nb), false, 'new ArrayBuffer is not detached');

		var ab2 = new ArrayBuffer(8);
		st.equal(byteLength(ab2), 8, 'original ArrayBuffer has length 8');
		try {
			var nbLen = slice(ab2, 4);
		} catch (e) {
			if (e instanceof SyntaxError) {
				st.skip('Detaching ArrayBuffer is not supported');
				return st.end();
			}
		}
		st.equal(IsDetachedBuffer(ab2), false, 'old ArrayBuffer is not detached');
		st.equal(IsDetachedBuffer(nbLen), false, 'new ArrayBuffer is not detached');

		st.equal(byteLength(ab2), 8, 'original ArrayBuffer has length 8');
		st.equal(byteLength(nbLen), 4, 'newly sliced ArrayBuffer has length 4');

		var one = new ArrayBuffer(1);
		var arr = new Uint8Array(one);
		arr[0] = 123;

		var two = slice(one);

		var arr2 = new Uint8Array(two);
		arr2[0] = 234;

		st.deepEqual(arr, new Uint8Array([123]), 'original buffer is unchanged');
		st.deepEqual(arr2, new Uint8Array([234]), 'sliced buffer is changed');

		return st.end();
	});

	t.test('SharedArrayBuffers', { skip: typeof SharedArrayBuffer === 'undefined' }, function (st) {
		var sab = new SharedArrayBuffer(0);

		st['throws'](
			function () { slice(sab); },
			TypeError,
			inspect(sab) + ' is not an ArrayBuffer'
		);

		st.end();
	});
};
'use strict';

var test = require('tape');
var getProto = require('get-proto');
var semver = require('semver');

var getAsyncFunction = require('../');

test('getAsyncFunction', function (t) {
	var result = getAsyncFunction();

	/* eslint-env browser */
	if (typeof window === 'undefined' && typeof process !== 'undefined') {
		t.equal(
			!!result,
			semver.satisfies(process.version, '>= 7.6'),
			'result is present or absent as expected for node ' + process.version
		);
	}

	t.test('exists', { skip: !result }, function (st) {
		if (result && getProto) { // TS can't infer `skip`, or that getProto definitely exists if AsyncFunction exists
			st.equal(typeof result, 'function', 'is a function');
			st.equal(getProto(result), Function, 'extends Function');

			return result('a', 'return a')(42).then(function (a) {
				st.equal(a, 42, 'returns an async function');
			});
		}
		return st.fail('should never get here');
	});

	t.test('does not exist', { skip: !!result }, function (st) {
		st.equal(result, false, 'is false');

		st.end();
	});

	t.end();
});
'use strict';

var test = require('tape');
var isArray = require('isarray');
var every = require('array.prototype.every');

var availableTypedArrays = require('../');

test('available typed arrays', function (t) {
	t.equal(typeof availableTypedArrays, 'function', 'is a function');

	var arrays = availableTypedArrays();
	t.equal(isArray(arrays), true, 'returns an array');

	t.equal(every(arrays, function (array) { return typeof array === 'string'; }), true, 'contains only strings');

	t.end();
});
'use strict';

var callBind = require('../');
var hasStrictMode = require('has-strict-mode')();
var forEach = require('for-each');
var inspect = require('object-inspect');
var v = require('es-value-fixtures');

var test = require('tape');

test('callBindBasic', function (t) {
	forEach(v.nonFunctions, function (nonFunction) {
		t['throws'](
			// @ts-expect-error
			function () { callBind([nonFunction]); },
			TypeError,
			inspect(nonFunction) + ' is not a function'
		);
	});

	var sentinel = { sentinel: true };
	/** @type {<T, A extends number, B extends number>(this: T, a: A, b: B) => [T | undefined, A, B]} */
	var func = function (a, b) {
		// eslint-disable-next-line no-invalid-this
		return [!hasStrictMode && this === global ? undefined : this, a, b];
	};
	t.equal(func.length, 2, 'original function length is 2');

	/** type {(thisArg: unknown, a: number, b: number) => [unknown, number, number]} */
	var bound = callBind([func]);
	/** type {((a: number, b: number) => [typeof sentinel, typeof a, typeof b])} */
	var boundR = callBind([func, sentinel]);
	/** type {((b: number) => [typeof sentinel, number, typeof b])} */
	var boundArg = callBind([func, sentinel, /** @type {const} */ (1)]);

	// @ts-expect-error
	t.deepEqual(bound(), [undefined, undefined, undefined], 'bound func with no args');

	// @ts-expect-error
	t.deepEqual(func(), [undefined, undefined, undefined], 'unbound func with too few args');
	// @ts-expect-error
	t.deepEqual(bound(1, 2), [hasStrictMode ? 1 : Object(1), 2, undefined], 'bound func too few args');
	// @ts-expect-error
	t.deepEqual(boundR(), [sentinel, undefined, undefined], 'bound func with receiver, with too few args');
	// @ts-expect-error
	t.deepEqual(boundArg(), [sentinel, 1, undefined], 'bound func with receiver and arg, with too few args');

	t.deepEqual(func(1, 2), [undefined, 1, 2], 'unbound func with right args');
	t.deepEqual(bound(1, 2, 3), [hasStrictMode ? 1 : Object(1), 2, 3], 'bound func with right args');
	t.deepEqual(boundR(1, 2), [sentinel, 1, 2], 'bound func with receiver, with right args');
	t.deepEqual(boundArg(2), [sentinel, 1, 2], 'bound func with receiver and arg, with right arg');

	// @ts-expect-error
	t.deepEqual(func(1, 2, 3), [undefined, 1, 2], 'unbound func with too many args');
	// @ts-expect-error
	t.deepEqual(bound(1, 2, 3, 4), [hasStrictMode ? 1 : Object(1), 2, 3], 'bound func with too many args');
	// @ts-expect-error
	t.deepEqual(boundR(1, 2, 3), [sentinel, 1, 2], 'bound func with receiver, with too many args');
	// @ts-expect-error
	t.deepEqual(boundArg(2, 3), [sentinel, 1, 2], 'bound func with receiver and arg, with too many args');

	t.end();
});
'use strict';

var test = require('tape');

var callBound = require('../callBound');

test('callBound', function (t) {
	// static primitive
	t.equal(callBound('Array.length'), Array.length, 'Array.length yields itself');
	t.equal(callBound('%Array.length%'), Array.length, '%Array.length% yields itself');

	// static non-function object
	t.equal(callBound('Array.prototype'), Array.prototype, 'Array.prototype yields itself');
	t.equal(callBound('%Array.prototype%'), Array.prototype, '%Array.prototype% yields itself');
	t.equal(callBound('Array.constructor'), Array.constructor, 'Array.constructor yields itself');
	t.equal(callBound('%Array.constructor%'), Array.constructor, '%Array.constructor% yields itself');

	// static function
	t.equal(callBound('Date.parse'), Date.parse, 'Date.parse yields itself');
	t.equal(callBound('%Date.parse%'), Date.parse, '%Date.parse% yields itself');

	// prototype primitive
	t.equal(callBound('Error.prototype.message'), Error.prototype.message, 'Error.prototype.message yields itself');
	t.equal(callBound('%Error.prototype.message%'), Error.prototype.message, '%Error.prototype.message% yields itself');

	// prototype function
	t.notEqual(callBound('Object.prototype.toString'), Object.prototype.toString, 'Object.prototype.toString does not yield itself');
	t.notEqual(callBound('%Object.prototype.toString%'), Object.prototype.toString, '%Object.prototype.toString% does not yield itself');
	t.equal(callBound('Object.prototype.toString')(true), Object.prototype.toString.call(true), 'call-bound Object.prototype.toString calls into the original');
	t.equal(callBound('%Object.prototype.toString%')(true), Object.prototype.toString.call(true), 'call-bound %Object.prototype.toString% calls into the original');

	t['throws'](
		function () { callBound('does not exist'); },
		SyntaxError,
		'nonexistent intrinsic throws'
	);
	t['throws'](
		function () { callBound('does not exist', true); },
		SyntaxError,
		'allowMissing arg still throws for unknown intrinsic'
	);

	t.test('real but absent intrinsic', { skip: typeof WeakRef !== 'undefined' }, function (st) {
		st['throws'](
			function () { callBound('WeakRef'); },
			TypeError,
			'real but absent intrinsic throws'
		);
		st.equal(callBound('WeakRef', true), undefined, 'allowMissing arg avoids exception');
		st.end();
	});

	t.end();
});
'use strict';

var callBind = require('../');
var hasStrictMode = require('has-strict-mode')();
var forEach = require('for-each');
var inspect = require('object-inspect');
var v = require('es-value-fixtures');

var test = require('tape');

/*
 * older engines have length nonconfigurable
 * in io.js v3, it is configurable except on bound functions, hence the .bind()
 */
var boundFnsHaveConfigurableLengths = require('set-function-length/env').boundFnsHaveConfigurableLengths;

test('callBind', function (t) {
	forEach(v.nonFunctions, function (nonFunction) {
		t['throws'](
			function () { callBind(nonFunction); },
			TypeError,
			inspect(nonFunction) + ' is not a function'
		);
	});

	var sentinel = { sentinel: true };
	var func = function (a, b) {
		// eslint-disable-next-line no-invalid-this
		return [!hasStrictMode && this === global ? undefined : this, a, b];
	};
	t.equal(func.length, 2, 'original function length is 2');
	t.deepEqual(func(), [undefined, undefined, undefined], 'unbound func with too few args');
	t.deepEqual(func(1, 2), [undefined, 1, 2], 'unbound func with right args');
	t.deepEqual(func(1, 2, 3), [undefined, 1, 2], 'unbound func with too many args');

	var bound = callBind(func);
	t.equal(bound.length, func.length + 1, 'function length is preserved', { skip: !boundFnsHaveConfigurableLengths });
	t.deepEqual(bound(), [undefined, undefined, undefined], 'bound func with too few args');
	t.deepEqual(bound(1, 2), [hasStrictMode ? 1 : Object(1), 2, undefined], 'bound func with right args');
	t.deepEqual(bound(1, 2, 3), [hasStrictMode ? 1 : Object(1), 2, 3], 'bound func with too many args');

	var boundR = callBind(func, sentinel);
	t.equal(boundR.length, func.length, 'function length is preserved', { skip: !boundFnsHaveConfigurableLengths });
	t.deepEqual(boundR(), [sentinel, undefined, undefined], 'bound func with receiver, with too few args');
	t.deepEqual(boundR(1, 2), [sentinel, 1, 2], 'bound func with receiver, with right args');
	t.deepEqual(boundR(1, 2, 3), [sentinel, 1, 2], 'bound func with receiver, with too many args');

	var boundArg = callBind(func, sentinel, 1);
	t.equal(boundArg.length, func.length - 1, 'function length is preserved', { skip: !boundFnsHaveConfigurableLengths });
	t.deepEqual(boundArg(), [sentinel, 1, undefined], 'bound func with receiver and arg, with too few args');
	t.deepEqual(boundArg(2), [sentinel, 1, 2], 'bound func with receiver and arg, with right arg');
	t.deepEqual(boundArg(2, 3), [sentinel, 1, 2], 'bound func with receiver and arg, with too many args');

	t.test('callBind.apply', function (st) {
		var aBound = callBind.apply(func);
		st.deepEqual(aBound(sentinel), [sentinel, undefined, undefined], 'apply-bound func with no args');
		st.deepEqual(aBound(sentinel, [1], 4), [sentinel, 1, undefined], 'apply-bound func with too few args');
		st.deepEqual(aBound(sentinel, [1, 2], 4), [sentinel, 1, 2], 'apply-bound func with right args');

		var aBoundArg = callBind.apply(func);
		st.deepEqual(aBoundArg(sentinel, [1, 2, 3], 4), [sentinel, 1, 2], 'apply-bound func with too many args');
		st.deepEqual(aBoundArg(sentinel, [1, 2], 4), [sentinel, 1, 2], 'apply-bound func with right args');
		st.deepEqual(aBoundArg(sentinel, [1], 4), [sentinel, 1, undefined], 'apply-bound func with too few args');

		var aBoundR = callBind.apply(func, sentinel);
		st.deepEqual(aBoundR([1, 2, 3], 4), [sentinel, 1, 2], 'apply-bound func with receiver and too many args');
		st.deepEqual(aBoundR([1, 2], 4), [sentinel, 1, 2], 'apply-bound func with receiver and right args');
		st.deepEqual(aBoundR([1], 4), [sentinel, 1, undefined], 'apply-bound func with receiver and too few args');

		st.end();
	});

	t.end();
});
'use strict';

var test = require('tape');

var callBound = require('../');

/** @template {true} T @template U @typedef {T extends U ? T : never} AssertType */

test('callBound', function (t) {
	// static primitive
	t.equal(callBound('Array.length'), Array.length, 'Array.length yields itself');
	t.equal(callBound('%Array.length%'), Array.length, '%Array.length% yields itself');

	// static non-function object
	t.equal(callBound('Array.prototype'), Array.prototype, 'Array.prototype yields itself');
	t.equal(callBound('%Array.prototype%'), Array.prototype, '%Array.prototype% yields itself');
	t.equal(callBound('Array.constructor'), Array.constructor, 'Array.constructor yields itself');
	t.equal(callBound('%Array.constructor%'), Array.constructor, '%Array.constructor% yields itself');

	// static function
	t.equal(callBound('Date.parse'), Date.parse, 'Date.parse yields itself');
	t.equal(callBound('%Date.parse%'), Date.parse, '%Date.parse% yields itself');

	// prototype primitive
	t.equal(callBound('Error.prototype.message'), Error.prototype.message, 'Error.prototype.message yields itself');
	t.equal(callBound('%Error.prototype.message%'), Error.prototype.message, '%Error.prototype.message% yields itself');

	var x = callBound('Object.prototype.toString');
	var y = callBound('%Object.prototype.toString%');

	// prototype function
	t.notEqual(x, Object.prototype.toString, 'Object.prototype.toString does not yield itself');
	t.notEqual(y, Object.prototype.toString, '%Object.prototype.toString% does not yield itself');
	t.equal(x(true), Object.prototype.toString.call(true), 'call-bound Object.prototype.toString calls into the original');
	t.equal(y(true), Object.prototype.toString.call(true), 'call-bound %Object.prototype.toString% calls into the original');

	t['throws'](
		// @ts-expect-error
		function () { callBound('does not exist'); },
		SyntaxError,
		'nonexistent intrinsic throws'
	);
	t['throws'](
		// @ts-expect-error
		function () { callBound('does not exist', true); },
		SyntaxError,
		'allowMissing arg still throws for unknown intrinsic'
	);

	t.test('real but absent intrinsic', { skip: typeof WeakRef !== 'undefined' }, function (st) {
		st['throws'](
			function () { callBound('WeakRef'); },
			TypeError,
			'real but absent intrinsic throws'
		);
		st.equal(callBound('WeakRef', true), undefined, 'allowMissing arg avoids exception');
		st.end();
	});

	t.end();
});
'use strict';

var test = require('tape');
var forEach = require('for-each');
var v = require('es-value-fixtures');
var inspect = require('object-inspect');

var dataViewBuffer = require('../');

test('dataViewBuffer', function (t) {
	forEach(
		// @ts-expect-error TS sucks at [].concat
		// eslint-disable-next-line no-extra-parens
		/** @type {[...typeof v.primitives, ...typeof v.objects]} */ ([].concat(v.primitives, v.objects)),
		function (nonDV) {
			t['throws'](function () { dataViewBuffer(nonDV); }, TypeError, inspect(nonDV) + ' is not a DataView');
		}
	);

	t.test('DataView', { skip: typeof DataView !== 'function' }, function (st) {
		var ab = new ArrayBuffer(1);
		var dv = new DataView(ab);

		st.equal(dataViewBuffer(dv), ab, inspect(dv) + ' has the same buffer originally passed to the DataView');
		st.equal(dataViewBuffer(dv), dv.buffer, inspect(dv) + ' has the same buffer as its own buffer property');

		st.end();
	});

	t.end();
});
'use strict';

var test = require('tape');
var forEach = require('for-each');
var v = require('es-value-fixtures');
var inspect = require('object-inspect');

var dataViewByteLength = require('../');

test('dataViewByteLength', function (t) {
	forEach(
		// @ts-expect-error TS sucks at [].concat
		// eslint-disable-next-line no-extra-parens
		/** @type {[...typeof v.primitives, ...typeof v.objects]} */ ([].concat(v.primitives, v.objects)),
		function (nonDV) {
			t['throws'](function () { dataViewByteLength(nonDV); }, TypeError, inspect(nonDV) + ' is not a DataView');
		}
	);

	t.test('DataView', { skip: typeof DataView !== 'function' }, function (st) {
		var ab = new ArrayBuffer(42);
		var dv = new DataView(ab);

		st.equal(dataViewByteLength(dv), 42, inspect(dv) + ' has the same byteLength as the buffer originally passed to the DataView');
		st.equal(dataViewByteLength(dv), dv.buffer.byteLength, inspect(dv) + ' has the same byteLength as the buffer’s byteLength of its own buffer property');

		st.end();
	});

	t.end();
});
'use strict';

var test = require('tape');
var forEach = require('for-each');
var v = require('es-value-fixtures');
var inspect = require('object-inspect');

var dataViewByteOffset = require('../');

test('dataViewByteOffset', function (t) {
	forEach(
		// @ts-expect-error TS sucks at [].concat
		// eslint-disable-next-line no-extra-parens
		/** @type {[...typeof v.primitives, ...typeof v.objects]} */ ([].concat(v.primitives, v.objects)),
		function (nonDV) {
			t['throws'](function () { dataViewByteOffset(nonDV); }, TypeError, inspect(nonDV) + ' is not a DataView');
		}
	);

	t.test('DataView', { skip: typeof DataView !== 'function' }, function (st) {
		var ab = new ArrayBuffer(42);
		var dv = new DataView(ab, 2);

		st.equal(dataViewByteOffset(dv), 2, inspect(dv) + ' has the same byteOffset originally passed to the DataView');
		st.equal(dataViewByteOffset(dv), dv.byteOffset, inspect(dv) + ' has the same byteOffset as the buffer’s byteOffset');

		st.end();
	});

	t.end();
});
'use strict';

var test = require('tape');
var v = require('es-value-fixtures');
var forEach = require('for-each');
var inspect = require('object-inspect');
var hasOwn = require('hasown');
var hasPropertyDescriptors = require('has-property-descriptors')();
var getOwnPropertyDescriptors = require('object.getownpropertydescriptors');
var ownKeys = require('reflect.ownkeys');

var defineDataProperty = require('../');

test('defineDataProperty', function (t) {
	t.test('argument validation', function (st) {
		forEach(v.primitives, function (nonObject) {
			st['throws'](
				// @ts-expect-error
				function () { defineDataProperty(nonObject, 'key', 'value'); },
				TypeError,
				'throws on non-object input: ' + inspect(nonObject)
			);
		});

		forEach(v.nonPropertyKeys, function (nonPropertyKey) {
			st['throws'](
				// @ts-expect-error
				function () { defineDataProperty({}, nonPropertyKey, 'value'); },
				TypeError,
				'throws on non-PropertyKey input: ' + inspect(nonPropertyKey)
			);
		});

		forEach(v.nonBooleans, function (nonBoolean) {
			if (nonBoolean !== null) {
				st['throws'](
					// @ts-expect-error
					function () { defineDataProperty({}, 'key', 'value', nonBoolean); },
					TypeError,
					'throws on non-boolean nonEnumerable: ' + inspect(nonBoolean)
				);

				st['throws'](
					// @ts-expect-error
					function () { defineDataProperty({}, 'key', 'value', false, nonBoolean); },
					TypeError,
					'throws on non-boolean nonWritable: ' + inspect(nonBoolean)
				);

				st['throws'](
					// @ts-expect-error
					function () { defineDataProperty({}, 'key', 'value', false, false, nonBoolean); },
					TypeError,
					'throws on non-boolean nonConfigurable: ' + inspect(nonBoolean)
				);
			}
		});

		st.end();
	});

	t.test('normal data property', function (st) {
		/** @type {Record<PropertyKey, string>} */
		var obj = { existing: 'existing property' };
		st.ok(hasOwn(obj, 'existing'), 'has initial own property');
		st.equal(obj.existing, 'existing property', 'has expected initial value');

		var res = defineDataProperty(obj, 'added', 'added property');
		st.equal(res, void undefined, 'returns `undefined`');
		st.ok(hasOwn(obj, 'added'), 'has expected own property');
		st.equal(obj.added, 'added property', 'has expected value');

		defineDataProperty(obj, 'existing', 'new value');
		st.ok(hasOwn(obj, 'existing'), 'still has expected own property');
		st.equal(obj.existing, 'new value', 'has new expected value');

		defineDataProperty(obj, 'explicit1', 'new value', false);
		st.ok(hasOwn(obj, 'explicit1'), 'has expected own property (explicit enumerable)');
		st.equal(obj.explicit1, 'new value', 'has new expected value (explicit enumerable)');

		defineDataProperty(obj, 'explicit2', 'new value', false, false);
		st.ok(hasOwn(obj, 'explicit2'), 'has expected own property (explicit writable)');
		st.equal(obj.explicit2, 'new value', 'has new expected value (explicit writable)');

		defineDataProperty(obj, 'explicit3', 'new value', false, false, false);
		st.ok(hasOwn(obj, 'explicit3'), 'has expected own property (explicit configurable)');
		st.equal(obj.explicit3, 'new value', 'has new expected value (explicit configurable)');

		st.end();
	});

	t.test('loose mode', { skip: !hasPropertyDescriptors }, function (st) {
		var obj = { existing: 'existing property' };

		defineDataProperty(obj, 'added', 'added value 1', true, null, null, true);
		st.deepEqual(
			getOwnPropertyDescriptors(obj),
			{
				existing: {
					configurable: true,
					enumerable: true,
					value: 'existing property',
					writable: true
				},
				added: {
					configurable: true,
					enumerable: !hasPropertyDescriptors,
					value: 'added value 1',
					writable: true
				}
			},
			'in loose mode, obj still adds property 1'
		);

		defineDataProperty(obj, 'added', 'added value 2', false, true, null, true);
		st.deepEqual(
			getOwnPropertyDescriptors(obj),
			{
				existing: {
					configurable: true,
					enumerable: true,
					value: 'existing property',
					writable: true
				},
				added: {
					configurable: true,
					enumerable: true,
					value: 'added value 2',
					writable: !hasPropertyDescriptors
				}
			},
			'in loose mode, obj still adds property 2'
		);

		defineDataProperty(obj, 'added', 'added value 3', false, false, true, true);
		st.deepEqual(
			getOwnPropertyDescriptors(obj),
			{
				existing: {
					configurable: true,
					enumerable: true,
					value: 'existing property',
					writable: true
				},
				added: {
					configurable: !hasPropertyDescriptors,
					enumerable: true,
					value: 'added value 3',
					writable: true
				}
			},
			'in loose mode, obj still adds property 3'
		);

		st.end();
	});

	t.test('non-normal data property, ES3', { skip: hasPropertyDescriptors }, function (st) {
		/** @type {Record<PropertyKey, string>} */
		var obj = { existing: 'existing property' };

		st['throws'](
			function () { defineDataProperty(obj, 'added', 'added value', true); },
			SyntaxError,
			'nonEnumerable throws a Syntax Error'
		);

		st['throws'](
			function () { defineDataProperty(obj, 'added', 'added value', false, true); },
			SyntaxError,
			'nonWritable throws a Syntax Error'
		);

		st['throws'](
			function () { defineDataProperty(obj, 'added', 'added value', false, false, true); },
			SyntaxError,
			'nonWritable throws a Syntax Error'
		);

		st.deepEqual(
			ownKeys(obj),
			['existing'],
			'obj still has expected keys'
		);
		st.equal(obj.existing, 'existing property', 'obj still has expected values');

		st.end();
	});

	t.test('new non-normal data property, ES5+', { skip: !hasPropertyDescriptors }, function (st) {
		/** @type {Record<PropertyKey, string>} */
		var obj = { existing: 'existing property' };

		defineDataProperty(obj, 'nonEnum', null, true);
		defineDataProperty(obj, 'nonWrit', null, false, true);
		defineDataProperty(obj, 'nonConf', null, false, false, true);

		st.deepEqual(
			getOwnPropertyDescriptors(obj),
			{
				existing: {
					configurable: true,
					enumerable: true,
					value: 'existing property',
					writable: true
				},
				nonEnum: {
					configurable: true,
					enumerable: false,
					value: null,
					writable: true
				},
				nonWrit: {
					configurable: true,
					enumerable: true,
					value: null,
					writable: false
				},
				nonConf: {
					configurable: false,
					enumerable: true,
					value: null,
					writable: true
				}
			},
			'obj has expected property descriptors'
		);

		st.end();
	});

	t.test('existing non-normal data property, ES5+', { skip: !hasPropertyDescriptors }, function (st) {
		// test case changing an existing non-normal property

		/** @type {Record<string, null | string>} */
		var obj = {};
		Object.defineProperty(obj, 'nonEnum', { configurable: true, enumerable: false, value: null, writable: true });
		Object.defineProperty(obj, 'nonWrit', { configurable: true, enumerable: true, value: null, writable: false });
		Object.defineProperty(obj, 'nonConf', { configurable: false, enumerable: true, value: null, writable: true });

		st.deepEqual(
			getOwnPropertyDescriptors(obj),
			{
				nonEnum: {
					configurable: true,
					enumerable: false,
					value: null,
					writable: true
				},
				nonWrit: {
					configurable: true,
					enumerable: true,
					value: null,
					writable: false
				},
				nonConf: {
					configurable: false,
					enumerable: true,
					value: null,
					writable: true
				}
			},
			'obj initially has expected property descriptors'
		);

		defineDataProperty(obj, 'nonEnum', 'new value', false);
		defineDataProperty(obj, 'nonWrit', 'new value', false, false);
		st['throws'](
			function () { defineDataProperty(obj, 'nonConf', 'new value', false, false, false); },
			TypeError,
			'can not alter a nonconfigurable property'
		);

		st.deepEqual(
			getOwnPropertyDescriptors(obj),
			{
				nonEnum: {
					configurable: true,
					enumerable: true,
					value: 'new value',
					writable: true
				},
				nonWrit: {
					configurable: true,
					enumerable: true,
					value: 'new value',
					writable: true
				},
				nonConf: {
					configurable: false,
					enumerable: true,
					value: null,
					writable: true
				}
			},
			'obj ends up with expected property descriptors'
		);

		st.end();
	});

	t.test('frozen object, ES5+', { skip: !hasPropertyDescriptors }, function (st) {
		var frozen = Object.freeze({ existing: true });

		st['throws'](
			function () { defineDataProperty(frozen, 'existing', 'new value'); },
			TypeError,
			'frozen object can not modify an existing property'
		);

		st['throws'](
			function () { defineDataProperty(frozen, 'new', 'new property'); },
			TypeError,
			'frozen object can not add a new property'
		);

		st.end();
	});

	t.test('sealed object, ES5+', { skip: !hasPropertyDescriptors }, function (st) {
		var sealed = Object.seal({ existing: true });
		st.deepEqual(
			Object.getOwnPropertyDescriptor(sealed, 'existing'),
			{
				configurable: false,
				enumerable: true,
				value: true,
				writable: true
			},
			'existing value on sealed object has expected descriptor'
		);

		defineDataProperty(sealed, 'existing', 'new value');

		st.deepEqual(
			Object.getOwnPropertyDescriptor(sealed, 'existing'),
			{
				configurable: false,
				enumerable: true,
				value: 'new value',
				writable: true
			},
			'existing value on sealed object has changed descriptor'
		);

		st['throws'](
			function () { defineDataProperty(sealed, 'new', 'new property'); },
			TypeError,
			'sealed object can not add a new property'
		);

		st.end();
	});

	t.test('nonextensible object, ES5+', { skip: !hasPropertyDescriptors }, function (st) {
		var nonExt = Object.preventExtensions({ existing: true });

		st.deepEqual(
			Object.getOwnPropertyDescriptor(nonExt, 'existing'),
			{
				configurable: true,
				enumerable: true,
				value: true,
				writable: true
			},
			'existing value on non-extensible object has expected descriptor'
		);

		defineDataProperty(nonExt, 'existing', 'new value', true);

		st.deepEqual(
			Object.getOwnPropertyDescriptor(nonExt, 'existing'),
			{
				configurable: true,
				enumerable: false,
				value: 'new value',
				writable: true
			},
			'existing value on non-extensible object has changed descriptor'
		);

		st['throws'](
			function () { defineDataProperty(nonExt, 'new', 'new property'); },
			TypeError,
			'non-extensible object can not add a new property'
		);

		st.end();
	});

	t.end();
});
'use strict';

var test = require('tape');

var getDunderProto = require('../get');

test('getDunderProto', { skip: !getDunderProto }, function (t) {
	if (!getDunderProto) {
		throw 'should never happen; this is just for type narrowing'; // eslint-disable-line no-throw-literal
	}

	// @ts-expect-error
	t['throws'](function () { getDunderProto(); }, TypeError, 'throws if no argument');
	// @ts-expect-error
	t['throws'](function () { getDunderProto(undefined); }, TypeError, 'throws with undefined');
	// @ts-expect-error
	t['throws'](function () { getDunderProto(null); }, TypeError, 'throws with null');

	t.equal(getDunderProto({}), Object.prototype);
	t.equal(getDunderProto([]), Array.prototype);
	t.equal(getDunderProto(function () {}), Function.prototype);
	t.equal(getDunderProto(/./g), RegExp.prototype);
	t.equal(getDunderProto(42), Number.prototype);
	t.equal(getDunderProto(true), Boolean.prototype);
	t.equal(getDunderProto('foo'), String.prototype);

	t.end();
});

test('no dunder proto', { skip: !!getDunderProto }, function (t) {
	t.notOk('__proto__' in Object.prototype, 'no __proto__ in Object.prototype');

	t.end();
});
'use strict';

require('./get');
require('./set');
'use strict';

var test = require('tape');

var setDunderProto = require('../set');

test('setDunderProto', { skip: !setDunderProto }, function (t) {
	if (!setDunderProto) {
		throw 'should never happen; this is just for type narrowing'; // eslint-disable-line no-throw-literal
	}

	// @ts-expect-error
	t['throws'](function () { setDunderProto(); }, TypeError, 'throws if no arguments');
	// @ts-expect-error
	t['throws'](function () { setDunderProto(undefined); }, TypeError, 'throws with undefined and nothing');
	// @ts-expect-error
	t['throws'](function () { setDunderProto(undefined, undefined); }, TypeError, 'throws with undefined and undefined');
	// @ts-expect-error
	t['throws'](function () { setDunderProto(null); }, TypeError, 'throws with null and undefined');
	// @ts-expect-error
	t['throws'](function () { setDunderProto(null, undefined); }, TypeError, 'throws with null and undefined');

	/** @type {{ inherited?: boolean }} */
	var obj = {};
	t.ok('toString' in obj, 'object initially has toString');

	setDunderProto(obj, null);
	t.notOk('toString' in obj, 'object no longer has toString');

	t.notOk('inherited' in obj, 'object lacks inherited property');
	setDunderProto(obj, { inherited: true });
	t.equal(obj.inherited, true, 'object has inherited property');

	t.end();
});

test('no dunder proto', { skip: !!setDunderProto }, function (t) {
	if ('__proto__' in Object.prototype) {
		t['throws'](
			// @ts-expect-error
			function () { ({}).__proto__ = null; }, // eslint-disable-line no-proto
			Error,
			'throws when setting Object.prototype.__proto__'
		);
	} else {
		t.notOk('__proto__' in Object.prototype, 'no __proto__ in Object.prototype');
	}

	t.end();
});
'use strict';

var $abs = require('math-intrinsics/abs');

// https://262.ecma-international.org/5.1/#sec-5.2

module.exports = function abs(x) {
	return $abs(x);
};
'use strict';

var ToNumber = require('./ToNumber');
var ToPrimitive = require('./ToPrimitive');

var isSameType = require('../helpers/isSameType');

var isObject = require('es-object-atoms/isObject');

// https://262.ecma-international.org/6.0/#sec-abstract-equality-comparison

module.exports = function AbstractEqualityComparison(x, y) {
	if (isSameType(x, y)) {
		return x === y; // ES6+ specified this shortcut anyways.
	}
	if (x == null && y == null) {
		return true;
	}
	if (typeof x === 'number' && typeof y === 'string') {
		return AbstractEqualityComparison(x, ToNumber(y));
	}
	if (typeof x === 'string' && typeof y === 'number') {
		return AbstractEqualityComparison(ToNumber(x), y);
	}
	if (typeof x === 'boolean') {
		return AbstractEqualityComparison(ToNumber(x), y);
	}
	if (typeof y === 'boolean') {
		return AbstractEqualityComparison(x, ToNumber(y));
	}
	if ((typeof x === 'string' || typeof x === 'number' || typeof x === 'symbol') && isObject(y)) {
		return AbstractEqualityComparison(x, ToPrimitive(y));
	}
	if (isObject(x) && (typeof y === 'string' || typeof y === 'number' || typeof y === 'symbol')) {
		return AbstractEqualityComparison(ToPrimitive(x), y);
	}
	return false;
};
'use strict';

var GetIntrinsic = require('get-intrinsic');

var $Number = GetIntrinsic('%Number%');
var $TypeError = require('es-errors/type');
var $isNaN = require('math-intrinsics/isNaN');
var $isFinite = require('math-intrinsics/isFinite');

var isPrefixOf = require('../helpers/isPrefixOf');

var ToNumber = require('./ToNumber');
var ToPrimitive = require('./ToPrimitive');

// https://262.ecma-international.org/5.1/#sec-11.8.5

// eslint-disable-next-line max-statements
module.exports = function AbstractRelationalComparison(x, y, LeftFirst) {
	if (typeof LeftFirst !== 'boolean') {
		throw new $TypeError('Assertion failed: LeftFirst argument must be a Boolean');
	}
	var px;
	var py;
	if (LeftFirst) {
		px = ToPrimitive(x, $Number);
		py = ToPrimitive(y, $Number);
	} else {
		py = ToPrimitive(y, $Number);
		px = ToPrimitive(x, $Number);
	}
	var bothStrings = typeof px === 'string' && typeof py === 'string';
	if (!bothStrings) {
		var nx = ToNumber(px);
		var ny = ToNumber(py);
		if ($isNaN(nx) || $isNaN(ny)) {
			return undefined;
		}
		if ($isFinite(nx) && $isFinite(ny) && nx === ny) {
			return false;
		}
		if (nx === Infinity) {
			return false;
		}
		if (ny === Infinity) {
			return true;
		}
		if (ny === -Infinity) {
			return false;
		}
		if (nx === -Infinity) {
			return true;
		}
		return nx < ny; // by now, these are both nonzero, finite, and not equal
	}
	if (isPrefixOf(py, px)) {
		return false;
	}
	if (isPrefixOf(px, py)) {
		return true;
	}
	return px < py; // both strings, neither a prefix of the other. shortcut for steps c-f
};
'use strict';

var isInteger = require('math-intrinsics/isInteger');
var MAX_SAFE_INTEGER = require('math-intrinsics/constants/maxSafeInteger');

var isLeadingSurrogate = require('../helpers/isLeadingSurrogate');
var isTrailingSurrogate = require('../helpers/isTrailingSurrogate');

var $TypeError = require('es-errors/type');

var $charCodeAt = require('call-bound')('String.prototype.charCodeAt');

// https://262.ecma-international.org/6.0/#sec-advancestringindex

module.exports = function AdvanceStringIndex(S, index, unicode) {
	if (typeof S !== 'string') {
		throw new $TypeError('Assertion failed: `S` must be a String');
	}
	if (!isInteger(index) || index < 0 || index > MAX_SAFE_INTEGER) {
		throw new $TypeError('Assertion failed: `length` must be an integer >= 0 and <= 2**53');
	}
	if (typeof unicode !== 'boolean') {
		throw new $TypeError('Assertion failed: `unicode` must be a Boolean');
	}
	if (!unicode) {
		return index + 1;
	}
	var length = S.length;
	if ((index + 1) >= length) {
		return index + 1;
	}

	var first = $charCodeAt(S, index);
	if (!isLeadingSurrogate(first)) {
		return index + 1;
	}

	var second = $charCodeAt(S, index + 1);
	if (!isTrailingSurrogate(second)) {
		return index + 1;
	}

	return index + 2;
};
'use strict';

var GetIntrinsic = require('get-intrinsic');

var $ArrayPrototype = GetIntrinsic('%Array.prototype%');
var $RangeError = require('es-errors/range');
var $SyntaxError = require('es-errors/syntax');
var $TypeError = require('es-errors/type');
var isInteger = require('math-intrinsics/isInteger');
var MAX_ARRAY_LENGTH = require('math-intrinsics/constants/maxArrayLength');
var $setProto = require('set-proto');

// https://262.ecma-international.org/6.0/#sec-arraycreate

module.exports = function ArrayCreate(length) {
	if (!isInteger(length) || length < 0) {
		throw new $TypeError('Assertion failed: `length` must be an integer Number >= 0');
	}
	if (length > MAX_ARRAY_LENGTH) {
		throw new $RangeError('length is greater than (2**32 - 1)');
	}
	var proto = arguments.length > 1 ? arguments[1] : $ArrayPrototype;
	var A = []; // steps 5 - 7, and 9
	if (proto !== $ArrayPrototype) { // step 8
		if (!$setProto) {
			throw new $SyntaxError('ArrayCreate: a `proto` argument that is not `Array.prototype` is not supported in an environment that does not support setting the [[Prototype]]');
		}
		$setProto(A, proto);
	}
	if (length !== 0) { // bypasses the need for step 2
		A.length = length;
	}
	/* step 10, the above as a shortcut for the below
	OrdinaryDefineOwnProperty(A, 'length', {
		'[[Configurable]]': false,
		'[[Enumerable]]': false,
		'[[Value]]': length,
		'[[Writable]]': true
	});
	*/
	return A;
};
'use strict';

var $RangeError = require('es-errors/range');
var $TypeError = require('es-errors/type');

var assign = require('object.assign');

var isPropertyDescriptor = require('../helpers/records/property-descriptor');

var IsArray = require('./IsArray');
var IsDataDescriptor = require('./IsDataDescriptor');
var OrdinaryDefineOwnProperty = require('./OrdinaryDefineOwnProperty');
var OrdinaryGetOwnProperty = require('./OrdinaryGetOwnProperty');
var ToNumber = require('./ToNumber');
var ToString = require('./ToString');
var ToUint32 = require('./ToUint32');

// https://262.ecma-international.org/6.0/#sec-arraysetlength

// eslint-disable-next-line max-statements, max-lines-per-function
module.exports = function ArraySetLength(A, Desc) {
	if (!IsArray(A)) {
		throw new $TypeError('Assertion failed: A must be an Array');
	}
	if (!isPropertyDescriptor(Desc)) {
		throw new $TypeError('Assertion failed: Desc must be a Property Descriptor');
	}
	if (!('[[Value]]' in Desc)) {
		return OrdinaryDefineOwnProperty(A, 'length', Desc);
	}
	var newLenDesc = assign({}, Desc);
	var newLen = ToUint32(Desc['[[Value]]']);
	var numberLen = ToNumber(Desc['[[Value]]']);
	if (newLen !== numberLen) {
		throw new $RangeError('Invalid array length');
	}
	newLenDesc['[[Value]]'] = newLen;
	var oldLenDesc = OrdinaryGetOwnProperty(A, 'length');
	if (!IsDataDescriptor(oldLenDesc)) {
		throw new $TypeError('Assertion failed: an array had a non-data descriptor on `length`');
	}
	var oldLen = oldLenDesc['[[Value]]'];
	if (newLen >= oldLen) {
		return OrdinaryDefineOwnProperty(A, 'length', newLenDesc);
	}
	if (!oldLenDesc['[[Writable]]']) {
		return false;
	}
	var newWritable;
	if (!('[[Writable]]' in newLenDesc) || newLenDesc['[[Writable]]']) {
		newWritable = true;
	} else {
		newWritable = false;
		newLenDesc['[[Writable]]'] = true;
	}
	var succeeded = OrdinaryDefineOwnProperty(A, 'length', newLenDesc);
	if (!succeeded) {
		return false;
	}
	while (newLen < oldLen) {
		oldLen -= 1;
		// eslint-disable-next-line no-param-reassign
		var deleteSucceeded = delete A[ToString(oldLen)];
		if (!deleteSucceeded) {
			newLenDesc['[[Value]]'] = oldLen + 1;
			if (!newWritable) {
				newLenDesc['[[Writable]]'] = false;
				OrdinaryDefineOwnProperty(A, 'length', newLenDesc);
				return false;
			}
		}
	}
	if (!newWritable) {
		return OrdinaryDefineOwnProperty(A, 'length', { '[[Writable]]': false });
	}
	return true;
};
'use strict';

var GetIntrinsic = require('get-intrinsic');

var $Array = GetIntrinsic('%Array%');
var $species = GetIntrinsic('%Symbol.species%', true);
var $TypeError = require('es-errors/type');
var isInteger = require('math-intrinsics/isInteger');
var isObject = require('es-object-atoms/isObject');

var Get = require('./Get');
var IsArray = require('./IsArray');
var IsConstructor = require('./IsConstructor');

// https://262.ecma-international.org/6.0/#sec-arrayspeciescreate

module.exports = function ArraySpeciesCreate(originalArray, length) {
	if (!isInteger(length) || length < 0) {
		throw new $TypeError('Assertion failed: length must be an integer >= 0');
	}
	var len = length === 0 ? 0 : length;
	var C;
	var isArray = IsArray(originalArray);
	if (isArray) {
		C = Get(originalArray, 'constructor');
		// TODO: figure out how to make a cross-realm normal Array, a same-realm Array
		// if (IsConstructor(C)) {
		// 	if C is another realm's Array, C = undefined
		// 	Object.getPrototypeOf(Object.getPrototypeOf(Object.getPrototypeOf(Array))) === null ?
		// }
		if ($species && isObject(C)) {
			C = Get(C, $species);
			if (C === null) {
				C = void 0;
			}
		}
	}
	if (typeof C === 'undefined') {
		return $Array(len);
	}
	if (!IsConstructor(C)) {
		throw new $TypeError('C must be a constructor');
	}
	return new C(len); // Construct(C, len);
};

'use strict';

var GetIntrinsic = require('get-intrinsic');
var callBound = require('call-bound');

var $TypeError = require('es-errors/type');

var IsArray = require('./IsArray');

var $apply = GetIntrinsic('%Reflect.apply%', true) || callBound('Function.prototype.apply');

// https://262.ecma-international.org/6.0/#sec-call

module.exports = function Call(F, V) {
	var argumentsList = arguments.length > 2 ? arguments[2] : [];
	if (!IsArray(argumentsList)) {
		throw new $TypeError('Assertion failed: optional `argumentsList`, if provided, must be a List');
	}
	return $apply(F, V, argumentsList);
};
'use strict';

var $TypeError = require('es-errors/type');

var callBound = require('call-bound');
var hasOwn = require('hasown');

var $charCodeAt = callBound('String.prototype.charCodeAt');
var $toUpperCase = callBound('String.prototype.toUpperCase');

var caseFolding = require('../helpers/caseFolding.json');

// https://262.ecma-international.org/6.0/#sec-runtime-semantics-canonicalize-ch

module.exports = function Canonicalize(ch, IgnoreCase, Unicode) {
	if (typeof ch !== 'string') {
		throw new $TypeError('Assertion failed: `ch` must be a character');
	}

	if (typeof IgnoreCase !== 'boolean' || typeof Unicode !== 'boolean') {
		throw new $TypeError('Assertion failed: `IgnoreCase` and `Unicode` must be Booleans');
	}

	if (!IgnoreCase) {
		return ch; // step 1
	}

	if (Unicode) { // step 2
		if (hasOwn(caseFolding.C, ch)) {
			return caseFolding.C[ch];
		}
		if (hasOwn(caseFolding.S, ch)) {
			return caseFolding.S[ch];
		}
		return ch; // step 2.b
	}

	var u = $toUpperCase(ch); // step 2

	if (u.length !== 1) {
		return ch; // step 3
	}

	var cu = u; // step 4

	if ($charCodeAt(ch, 0) >= 128 && $charCodeAt(cu, 0) < 128) {
		return ch; // step 5
	}

	return cu;
};
'use strict';

var $TypeError = require('es-errors/type');

var SameValue = require('./SameValue');
var ToNumber = require('./ToNumber');
var ToString = require('./ToString');

// https://262.ecma-international.org/6.0/#sec-canonicalnumericindexstring

module.exports = function CanonicalNumericIndexString(argument) {
	if (typeof argument !== 'string') {
		throw new $TypeError('Assertion failed: `argument` must be a String');
	}
	if (argument === '-0') { return -0; }
	var n = ToNumber(argument);
	if (SameValue(ToString(n), argument)) { return n; }
	return void 0;
};
'use strict';

var GetIntrinsic = require('get-intrinsic');
var callBound = require('call-bound');

var $fromCharCode = GetIntrinsic('%String.fromCharCode%');
var $TypeError = require('es-errors/type');
var $charCodeAt = callBound('String.prototype.charCodeAt');

var CharSet = require('../helpers/CharSet').CharSet;

module.exports = function CharacterRange(A, B) {
	var a;
	var b;

	if (A instanceof CharSet || B instanceof CharSet) {
		if (!(A instanceof CharSet) || !(B instanceof CharSet)) {
			throw new $TypeError('Assertion failed: CharSets A and B are not both CharSets');
		}

		A.yield(function (c) {
			if (typeof a !== 'undefined') {
				throw new $TypeError('Assertion failed: CharSet A has more than one character');
			}
			a = c;
		});
		B.yield(function (c) {
			if (typeof b !== 'undefined') {
				throw new $TypeError('Assertion failed: CharSet B has more than one character');
			}
			b = c;
		});
	} else {
		if (A.length !== 1 || B.length !== 1) {
			throw new $TypeError('Assertion failed: CharSets A and B contain exactly one character');
		}
		a = A[0];
		b = B[0];
	}

	var i = $charCodeAt(a, 0);
	var j = $charCodeAt(b, 0);

	if (!(i <= j)) {
		throw new $TypeError('Assertion failed: i is not <= j');
	}

	var arr = [];
	for (var k = i; k <= j; k += 1) {
		arr[arr.length] = $fromCharCode(k);
	}
	return arr;
};
'use strict';

var $TypeError = require('es-errors/type');

var hasOwn = require('hasown');

var IsDataDescriptor = require('./IsDataDescriptor');
var IsGenericDescriptor = require('./IsGenericDescriptor');

var isPropertyDescriptor = require('../helpers/records/property-descriptor');

// https://262.ecma-international.org/6.0/#sec-completepropertydescriptor

module.exports = function CompletePropertyDescriptor(Desc) {
	if (!isPropertyDescriptor(Desc)) {
		throw new $TypeError('Assertion failed: `Desc` must be a Property Descriptor');
	}

	/* eslint no-param-reassign: 0 */

	if (IsGenericDescriptor(Desc) || IsDataDescriptor(Desc)) {
		if (!hasOwn(Desc, '[[Value]]')) {
			Desc['[[Value]]'] = void 0;
		}
		if (!hasOwn(Desc, '[[Writable]]')) {
			Desc['[[Writable]]'] = false;
		}
	} else {
		if (!hasOwn(Desc, '[[Get]]')) {
			Desc['[[Get]]'] = void 0;
		}
		if (!hasOwn(Desc, '[[Set]]')) {
			Desc['[[Set]]'] = void 0;
		}
	}
	if (!hasOwn(Desc, '[[Enumerable]]')) {
		Desc['[[Enumerable]]'] = false;
	}
	if (!hasOwn(Desc, '[[Configurable]]')) {
		Desc['[[Configurable]]'] = false;
	}
	return Desc;
};
'use strict';

var $SyntaxError = require('es-errors/syntax');

var SLOT = require('internal-slot');

// https://262.ecma-international.org/6.0/#sec-completion-record-specification-type

var CompletionRecord = function CompletionRecord(type, value) {
	if (!(this instanceof CompletionRecord)) {
		return new CompletionRecord(type, value);
	}
	if (type !== 'normal' && type !== 'break' && type !== 'continue' && type !== 'return' && type !== 'throw') {
		throw new $SyntaxError('Assertion failed: `type` must be one of "normal", "break", "continue", "return", or "throw"');
	}
	SLOT.set(this, '[[type]]', type);
	SLOT.set(this, '[[value]]', value);
	// [[target]] slot?
};

CompletionRecord.prototype.type = function type() {
	return SLOT.get(this, '[[type]]');
};

CompletionRecord.prototype.value = function value() {
	return SLOT.get(this, '[[value]]');
};

CompletionRecord.prototype['?'] = function ReturnIfAbrupt() {
	var type = SLOT.get(this, '[[type]]');
	var value = SLOT.get(this, '[[value]]');

	if (type === 'throw') {
		throw value;
	}
	return value;
};

CompletionRecord.prototype['!'] = function assert() {
	var type = SLOT.get(this, '[[type]]');

	if (type !== 'normal') {
		throw new $SyntaxError('Assertion failed: Completion Record is not of type "normal"');
	}
	return SLOT.get(this, '[[value]]');
};

module.exports = CompletionRecord;
'use strict';

var $TypeError = require('es-errors/type');
var isObject = require('es-object-atoms/isObject');

var isPropertyKey = require('../helpers/isPropertyKey');
var OrdinaryDefineOwnProperty = require('./OrdinaryDefineOwnProperty');

// https://262.ecma-international.org/6.0/#sec-createdataproperty

module.exports = function CreateDataProperty(O, P, V) {
	if (!isObject(O)) {
		throw new $TypeError('Assertion failed: Type(O) is not Object');
	}
	if (!isPropertyKey(P)) {
		throw new $TypeError('Assertion failed: P is not a Property Key');
	}
	var newDesc = {
		'[[Configurable]]': true,
		'[[Enumerable]]': true,
		'[[Value]]': V,
		'[[Writable]]': true
	};
	return OrdinaryDefineOwnProperty(O, P, newDesc);
};
'use strict';

var $TypeError = require('es-errors/type');
var isObject = require('es-object-atoms/isObject');

var CreateDataProperty = require('./CreateDataProperty');

var isPropertyKey = require('../helpers/isPropertyKey');

// // https://262.ecma-international.org/6.0/#sec-createdatapropertyorthrow

module.exports = function CreateDataPropertyOrThrow(O, P, V) {
	if (!isObject(O)) {
		throw new $TypeError('Assertion failed: Type(O) is not Object');
	}
	if (!isPropertyKey(P)) {
		throw new $TypeError('Assertion failed: P is not a Property Key');
	}
	var success = CreateDataProperty(O, P, V);
	if (!success) {
		throw new $TypeError('unable to create data property');
	}
	return success;
};
'use strict';

var $TypeError = require('es-errors/type');

var callBound = require('call-bound');

var $replace = callBound('String.prototype.replace');

var RequireObjectCoercible = require('./RequireObjectCoercible');
var ToString = require('./ToString');

// https://262.ecma-international.org/6.0/#sec-createhtml

module.exports = function CreateHTML(string, tag, attribute, value) {
	if (typeof tag !== 'string' || typeof attribute !== 'string') {
		throw new $TypeError('Assertion failed: `tag` and `attribute` must be strings');
	}
	var str = RequireObjectCoercible(string);
	var S = ToString(str);
	var p1 = '<' + tag;
	if (attribute !== '') {
		var V = ToString(value);
		var escapedV = $replace(V, /\x22/g, '&quot;');
		p1 += '\x20' + attribute + '\x3D\x22' + escapedV + '\x22';
	}
	return p1 + '>' + S + '</' + tag + '>';
};
'use strict';

var $TypeError = require('es-errors/type');

// https://262.ecma-international.org/6.0/#sec-createiterresultobject

module.exports = function CreateIterResultObject(value, done) {
	if (typeof done !== 'boolean') {
		throw new $TypeError('Assertion failed: Type(done) is not Boolean');
	}
	return {
		value: value,
		done: done
	};
};
'use strict';

var callBound = require('call-bound');

var $TypeError = require('es-errors/type');
var isObject = require('es-object-atoms/isObject');
var $indexOf = callBound('Array.prototype.indexOf', true) || callBound('String.prototype.indexOf');

var Get = require('./Get');
var IsArray = require('./IsArray');
var ToLength = require('./ToLength');
var ToString = require('./ToString');
var Type = require('./Type');

var defaultElementTypes = ['Undefined', 'Null', 'Boolean', 'String', 'Symbol', 'Number', 'Object'];

// https://262.ecma-international.org/6.0/#sec-createlistfromarraylike
module.exports = function CreateListFromArrayLike(obj) {
	var elementTypes = arguments.length > 1
		? arguments[1]
		: defaultElementTypes;

	if (!isObject(obj)) {
		throw new $TypeError('Assertion failed: `obj` must be an Object');
	}
	if (!IsArray(elementTypes)) {
		throw new $TypeError('Assertion failed: `elementTypes`, if provided, must be an array');
	}
	var len = ToLength(Get(obj, 'length'));
	var list = [];
	var index = 0;
	while (index < len) {
		var indexName = ToString(index);
		var next = Get(obj, indexName);
		var nextType = Type(next);
		if ($indexOf(elementTypes, nextType) < 0) {
			throw new $TypeError('item type ' + nextType + ' is not a valid elementType');
		}
		list[list.length] = next;
		index += 1;
	}
	return list;
};
'use strict';

var $TypeError = require('es-errors/type');
var isObject = require('es-object-atoms/isObject');

var DefineOwnProperty = require('../helpers/DefineOwnProperty');

var FromPropertyDescriptor = require('./FromPropertyDescriptor');
var IsDataDescriptor = require('./IsDataDescriptor');
var isPropertyKey = require('../helpers/isPropertyKey');
var SameValue = require('./SameValue');

// https://262.ecma-international.org/6.0/#sec-createmethodproperty

module.exports = function CreateMethodProperty(O, P, V) {
	if (!isObject(O)) {
		throw new $TypeError('Assertion failed: Type(O) is not Object');
	}

	if (!isPropertyKey(P)) {
		throw new $TypeError('Assertion failed: P is not a Property Key');
	}

	var newDesc = {
		'[[Configurable]]': true,
		'[[Enumerable]]': false,
		'[[Value]]': V,
		'[[Writable]]': true
	};
	return DefineOwnProperty(
		IsDataDescriptor,
		SameValue,
		FromPropertyDescriptor,
		O,
		P,
		newDesc
	);
};
'use strict';

var $EvalError = require('es-errors/eval');

var DayWithinYear = require('./DayWithinYear');
var InLeapYear = require('./InLeapYear');
var MonthFromTime = require('./MonthFromTime');

// https://262.ecma-international.org/5.1/#sec-15.9.1.5

module.exports = function DateFromTime(t) {
	var m = MonthFromTime(t);
	var d = DayWithinYear(t);
	if (m === 0) {
		return d + 1;
	}
	if (m === 1) {
		return d - 30;
	}
	var leap = InLeapYear(t);
	if (m === 2) {
		return d - 58 - leap;
	}
	if (m === 3) {
		return d - 89 - leap;
	}
	if (m === 4) {
		return d - 119 - leap;
	}
	if (m === 5) {
		return d - 150 - leap;
	}
	if (m === 6) {
		return d - 180 - leap;
	}
	if (m === 7) {
		return d - 211 - leap;
	}
	if (m === 8) {
		return d - 242 - leap;
	}
	if (m === 9) {
		return d - 272 - leap;
	}
	if (m === 10) {
		return d - 303 - leap;
	}
	if (m === 11) {
		return d - 333 - leap;
	}
	throw new $EvalError('Assertion failed: MonthFromTime returned an impossible value: ' + m);
};
'use strict';

var floor = require('./floor');

// https://262.ecma-international.org/5.1/#sec-15.9.1.3

module.exports = function DayFromYear(y) {
	return (365 * (y - 1970)) + floor((y - 1969) / 4) - floor((y - 1901) / 100) + floor((y - 1601) / 400);
};

'use strict';

var floor = require('./floor');

var msPerDay = require('../helpers/timeConstants').msPerDay;

// https://262.ecma-international.org/5.1/#sec-15.9.1.2

module.exports = function Day(t) {
	return floor(t / msPerDay);
};
'use strict';

var modulo = require('./modulo');

// https://262.ecma-international.org/5.1/#sec-15.9.1.3

module.exports = function DaysInYear(y) {
	if (modulo(y, 4) !== 0) {
		return 365;
	}
	if (modulo(y, 100) !== 0) {
		return 366;
	}
	if (modulo(y, 400) !== 0) {
		return 365;
	}
	return 366;
};
'use strict';

var Day = require('./Day');
var DayFromYear = require('./DayFromYear');
var YearFromTime = require('./YearFromTime');

// https://262.ecma-international.org/5.1/#sec-15.9.1.4

module.exports = function DayWithinYear(t) {
	return Day(t) - DayFromYear(YearFromTime(t));
};
'use strict';

var $TypeError = require('es-errors/type');
var isObject = require('es-object-atoms/isObject');

var isPropertyDescriptor = require('../helpers/records/property-descriptor');
var DefineOwnProperty = require('../helpers/DefineOwnProperty');

var FromPropertyDescriptor = require('./FromPropertyDescriptor');
var IsDataDescriptor = require('./IsDataDescriptor');
var isPropertyKey = require('../helpers/isPropertyKey');
var SameValue = require('./SameValue');
var ToPropertyDescriptor = require('./ToPropertyDescriptor');

// https://262.ecma-international.org/6.0/#sec-definepropertyorthrow

module.exports = function DefinePropertyOrThrow(O, P, desc) {
	if (!isObject(O)) {
		throw new $TypeError('Assertion failed: Type(O) is not Object');
	}

	if (!isPropertyKey(P)) {
		throw new $TypeError('Assertion failed: P is not a Property Key');
	}

	var Desc = isPropertyDescriptor(desc) ? desc : ToPropertyDescriptor(desc);
	if (!isPropertyDescriptor(Desc)) {
		throw new $TypeError('Assertion failed: Desc is not a valid Property Descriptor');
	}

	return DefineOwnProperty(
		IsDataDescriptor,
		SameValue,
		FromPropertyDescriptor,
		O,
		P,
		Desc
	);
};
'use strict';

var $TypeError = require('es-errors/type');
var isObject = require('es-object-atoms/isObject');

var isPropertyKey = require('../helpers/isPropertyKey');

// https://262.ecma-international.org/6.0/#sec-deletepropertyorthrow

module.exports = function DeletePropertyOrThrow(O, P) {
	if (!isObject(O)) {
		throw new $TypeError('Assertion failed: Type(O) is not Object');
	}

	if (!isPropertyKey(P)) {
		throw new $TypeError('Assertion failed: P is not a Property Key');
	}

	// eslint-disable-next-line no-param-reassign
	var success = delete O[P];
	if (!success) {
		throw new $TypeError('Attempt to delete property failed.');
	}
	return success;
};
'use strict';

var $SyntaxError = require('es-errors/syntax');
var $TypeError = require('es-errors/type');

var isArrayBuffer = require('is-array-buffer');

var IsDetachedBuffer = require('./IsDetachedBuffer');

var MessageChannel;
try {
	// eslint-disable-next-line global-require
	MessageChannel = require('worker_threads').MessageChannel; // node 11.7+
} catch (e) { /**/ }

// https://262.ecma-international.org/6.0/#sec-detacharraybuffer

/* globals postMessage */

module.exports = function DetachArrayBuffer(arrayBuffer) {
	if (!isArrayBuffer(arrayBuffer)) {
		throw new $TypeError('Assertion failed: `arrayBuffer` must be an Object with an [[ArrayBufferData]] internal slot');
	}

	if (!IsDetachedBuffer(arrayBuffer)) { // node v21.0.0+ throws when you structuredClone a detached buffer
		if (typeof structuredClone === 'function') {
			structuredClone(arrayBuffer, { transfer: [arrayBuffer] });
		} else if (typeof postMessage === 'function') {
			postMessage('', '/', [arrayBuffer]); // TODO: see if this might trigger listeners
		} else if (MessageChannel) {
			(new MessageChannel()).port1.postMessage(null, [arrayBuffer]);
		} else {
			throw new $SyntaxError('DetachArrayBuffer is not supported in this environment');
		}
	}

	return null;
};
'use strict';

var $TypeError = require('es-errors/type');
var isObject = require('es-object-atoms/isObject');

var keys = require('object-keys');

// https://262.ecma-international.org/6.0/#sec-enumerableownnames

module.exports = function EnumerableOwnNames(O) {
	if (!isObject(O)) {
		throw new $TypeError('Assertion failed: Type(O) is not Object');
	}

	return keys(O);
};
'use strict';

// var modulo = require('./modulo');
var $floor = require('math-intrinsics/floor');

// http://262.ecma-international.org/5.1/#sec-5.2

module.exports = function floor(x) {
	// return x - modulo(x, 1);
	return $floor(x);
};
'use strict';

var $TypeError = require('es-errors/type');

var isPropertyDescriptor = require('../helpers/records/property-descriptor');
var fromPropertyDescriptor = require('../helpers/fromPropertyDescriptor');

// https://262.ecma-international.org/6.0/#sec-frompropertydescriptor

module.exports = function FromPropertyDescriptor(Desc) {
	if (typeof Desc !== 'undefined' && !isPropertyDescriptor(Desc)) {
		throw new $TypeError('Assertion failed: `Desc` must be a Property Descriptor');
	}

	return fromPropertyDescriptor(Desc);
};
'use strict';

var getGlobal = require('globalthis/polyfill');

// https://262.ecma-international.org/6.0/#sec-getglobalobject

module.exports = function GetGlobalObject() {
	return getGlobal();
};
'use strict';

var $TypeError = require('es-errors/type');

var getIteratorMethod = require('../helpers/getIteratorMethod');
var AdvanceStringIndex = require('./AdvanceStringIndex');
var Call = require('./Call');
var GetMethod = require('./GetMethod');

var isObject = require('es-object-atoms/isObject');

var ES = {
	AdvanceStringIndex: AdvanceStringIndex,
	GetMethod: GetMethod
};

// https://262.ecma-international.org/6.0/#sec-getiterator

module.exports = function GetIterator(obj, method) {
	var actualMethod = method;
	if (arguments.length < 2) {
		actualMethod = getIteratorMethod(ES, obj);
	}
	var iterator = Call(actualMethod, obj);
	if (!isObject(iterator)) {
		throw new $TypeError('iterator must return an object');
	}

	return iterator;
};
'use strict';

var $TypeError = require('es-errors/type');

var inspect = require('object-inspect');

var isPropertyKey = require('../helpers/isPropertyKey');

var isObject = require('es-object-atoms/isObject');

// https://262.ecma-international.org/6.0/#sec-get-o-p

module.exports = function Get(O, P) {
	// 7.3.1.1
	if (!isObject(O)) {
		throw new $TypeError('Assertion failed: Type(O) is not Object');
	}
	// 7.3.1.2
	if (!isPropertyKey(P)) {
		throw new $TypeError('Assertion failed: P is not a Property Key, got ' + inspect(P));
	}
	// 7.3.1.3
	return O[P];
};
'use strict';

var $TypeError = require('es-errors/type');

var GetV = require('./GetV');
var IsCallable = require('./IsCallable');
var isPropertyKey = require('../helpers/isPropertyKey');

var inspect = require('object-inspect');

// https://262.ecma-international.org/6.0/#sec-getmethod

module.exports = function GetMethod(O, P) {
	// 7.3.9.1
	if (!isPropertyKey(P)) {
		throw new $TypeError('Assertion failed: P is not a Property Key');
	}

	// 7.3.9.2
	var func = GetV(O, P);

	// 7.3.9.4
	if (func == null) {
		return void 0;
	}

	// 7.3.9.5
	if (!IsCallable(func)) {
		throw new $TypeError(inspect(P) + ' is not a function: ' + inspect(func));
	}

	// 7.3.9.6
	return func;
};
'use strict';

var GetIntrinsic = require('get-intrinsic');

var hasSymbols = require('has-symbols')();

var $TypeError = require('es-errors/type');
var isObject = require('es-object-atoms/isObject');

var $gOPN = GetIntrinsic('%Object.getOwnPropertyNames%', true);
var $gOPS = hasSymbols && GetIntrinsic('%Object.getOwnPropertySymbols%', true);
var keys = require('object-keys');

// https://262.ecma-international.org/6.0/#sec-getownpropertykeys

module.exports = function GetOwnPropertyKeys(O, Type) {
	if (!isObject(O)) {
		throw new $TypeError('Assertion failed: Type(O) is not Object');
	}
	if (Type === 'Symbol') {
		return $gOPS ? $gOPS(O) : [];
	}
	if (Type === 'String') {
		if (!$gOPN) {
			return keys(O);
		}
		return $gOPN(O);
	}
	throw new $TypeError('Assertion failed: `Type` must be `"String"` or `"Symbol"`');
};
'use strict';

var GetIntrinsic = require('get-intrinsic');

var $Function = GetIntrinsic('%Function%');
var $TypeError = require('es-errors/type');
var $SyntaxError = require('es-errors/syntax');

var Get = require('./Get');
var IsConstructor = require('./IsConstructor');

var isObject = require('es-object-atoms/isObject');

// https://262.ecma-international.org/6.0/#sec-getprototypefromconstructor

module.exports = function GetPrototypeFromConstructor(constructor, intrinsicDefaultProto) {
	var intrinsic = GetIntrinsic(intrinsicDefaultProto); // throws if not a valid intrinsic
	if (!isObject(intrinsic)) {
		throw new $TypeError('intrinsicDefaultProto must be an object');
	}
	if (!IsConstructor(constructor)) {
		throw new $TypeError('Assertion failed: `constructor` must be a constructor');
	}
	var proto = Get(constructor, 'prototype');
	if (!isObject(proto)) {
		if (!(constructor instanceof $Function)) {
			// ignore other realms, for now
			throw new $SyntaxError('cross-realm constructors not currently supported');
		}
		proto = intrinsic;
	}
	return proto;
};

'use strict';

var GetIntrinsic = require('get-intrinsic');

var $TypeError = require('es-errors/type');
var $parseInt = GetIntrinsic('%parseInt%');

var inspect = require('object-inspect');
var isInteger = require('math-intrinsics/isInteger');
var regexTester = require('safe-regex-test');
var callBound = require('call-bound');
var every = require('../helpers/every');

var isDigit = regexTester(/^[0-9]$/);

var $charAt = callBound('String.prototype.charAt');
var $strSlice = callBound('String.prototype.slice');

var IsArray = require('./IsArray');

var isStringOrUndefined = require('../helpers/isStringOrUndefined');

// https://262.ecma-international.org/6.0/#sec-getsubstitution

// eslint-disable-next-line max-statements, max-lines-per-function
module.exports = function GetSubstitution(matched, str, position, captures, replacement) {
	if (typeof matched !== 'string') {
		throw new $TypeError('Assertion failed: `matched` must be a String');
	}
	var matchLength = matched.length;

	if (typeof str !== 'string') {
		throw new $TypeError('Assertion failed: `str` must be a String');
	}
	var stringLength = str.length;

	if (!isInteger(position) || position < 0 || position > stringLength) {
		throw new $TypeError('Assertion failed: `position` must be a nonnegative integer, and less than or equal to the length of `string`, got ' + inspect(position));
	}

	if (!IsArray(captures) || !every(captures, isStringOrUndefined)) {
		throw new $TypeError('Assertion failed: `captures` must be a List of Strings, got ' + inspect(captures));
	}

	if (typeof replacement !== 'string') {
		throw new $TypeError('Assertion failed: `replacement` must be a String');
	}

	var tailPos = position + matchLength;
	var m = captures.length;

	var result = '';
	for (var i = 0; i < replacement.length; i += 1) {
		// if this is a $, and it's not the end of the replacement
		var current = $charAt(replacement, i);
		var isLast = (i + 1) >= replacement.length;
		var nextIsLast = (i + 2) >= replacement.length;
		if (current === '$' && !isLast) {
			var next = $charAt(replacement, i + 1);
			if (next === '$') {
				result += '$';
				i += 1;
			} else if (next === '&') {
				result += matched;
				i += 1;
			} else if (next === '`') {
				result += position === 0 ? '' : $strSlice(str, 0, position - 1);
				i += 1;
			} else if (next === "'") {
				result += tailPos >= stringLength ? '' : $strSlice(str, tailPos);
				i += 1;
			} else {
				var nextNext = nextIsLast ? null : $charAt(replacement, i + 2);
				if (isDigit(next) && next !== '0' && (nextIsLast || !isDigit(nextNext))) {
					// $1 through $9, and not followed by a digit
					var n = $parseInt(next, 10);
					// if (n > m, impl-defined)
					result += n <= m && typeof captures[n - 1] === 'undefined' ? '' : captures[n - 1];
					i += 1;
				} else if (isDigit(next) && (nextIsLast || isDigit(nextNext))) {
					// $00 through $99
					var nn = next + nextNext;
					var nnI = $parseInt(nn, 10) - 1;
					// if nn === '00' or nn > m, impl-defined
					result += nn <= m && typeof captures[nnI] === 'undefined' ? '' : captures[nnI];
					i += 2;
				} else {
					result += '$';
				}
			}
		} else {
			// the final $, or else not a $
			result += $charAt(replacement, i);
		}
	}
	return result;
};
'use strict';

var GetIntrinsic = require('get-intrinsic');

var $TypeError = require('es-errors/type');
var $Uint8Array = GetIntrinsic('%Uint8Array%', true);

var isInteger = require('math-intrinsics/isInteger');
var callBound = require('call-bound');

var $charAt = callBound('String.prototype.charAt');
var $reverse = callBound('Array.prototype.reverse');
var $slice = callBound('Array.prototype.slice');

var bytesAsFloat32 = require('../helpers/bytesAsFloat32');
var bytesAsFloat64 = require('../helpers/bytesAsFloat64');
var bytesAsInteger = require('../helpers/bytesAsInteger');
var defaultEndianness = require('../helpers/defaultEndianness');

var IsDetachedBuffer = require('./IsDetachedBuffer');

var isArrayBuffer = require('is-array-buffer');
var safeConcat = require('safe-array-concat');

var tableTAO = require('./tables/typed-array-objects');

var isUnsignedElementType = function isUnsignedElementType(type) { return $charAt(type, 0) === 'U'; };

// https://262.ecma-international.org/6.0/#sec-getvaluefrombuffer

module.exports = function GetValueFromBuffer(arrayBuffer, byteIndex, type) {
	if (!isArrayBuffer(arrayBuffer)) {
		throw new $TypeError('Assertion failed: `arrayBuffer` must be an ArrayBuffer');
	}

	if (!isInteger(byteIndex)) {
		throw new $TypeError('Assertion failed: `byteIndex` must be an integer');
	}

	if (typeof type !== 'string') {
		throw new $TypeError('Assertion failed: `type` must be a string');
	}

	if (arguments.length > 3 && typeof arguments[3] !== 'boolean') {
		throw new $TypeError('Assertion failed: `isLittleEndian` must be a boolean, if present');
	}

	if (IsDetachedBuffer(arrayBuffer)) {
		throw new $TypeError('Assertion failed: ArrayBuffer is detached'); // step 1
	}

	// 2. Assert: There are sufficient bytes in arrayBuffer starting at byteIndex to represent a value of type.

	if (byteIndex < 0) {
		throw new $TypeError('Assertion failed: `byteIndex` must be non-negative'); // step 3
	}

	// 4. Let block be arrayBuffer’s [[ArrayBufferData]] internal slot.

	var elementSize = tableTAO.size['$' + type]; // step 5
	if (!elementSize) {
		throw new $TypeError('Assertion failed: `type` must be one of ' + tableTAO.choices);
	}

	// 6. Let rawValue be a List of elementSize containing, in order, the elementSize sequence of bytes starting with block[byteIndex].
	var rawValue = $slice(new $Uint8Array(arrayBuffer, byteIndex), 0, elementSize); // step 6

	// 8. If isLittleEndian is not present, set isLittleEndian to either true or false. The choice is implementation dependent and should be the alternative that is most efficient for the implementation. An implementation must use the same value each time this step is executed and the same value must be used for the corresponding step in the SetValueInBuffer abstract operation.
	var isLittleEndian = arguments.length > 3 ? arguments[3] : defaultEndianness === 'little'; // step 7

	if (!isLittleEndian) {
		$reverse(rawValue); // step 8
	}

	var bytes = $slice(safeConcat([0, 0, 0, 0, 0, 0, 0, 0], rawValue), -elementSize);

	if (type === 'Float32') { // step 3
		return bytesAsFloat32(bytes);
	}

	if (type === 'Float64') { // step 4
		return bytesAsFloat64(bytes);
	}

	return bytesAsInteger(bytes, elementSize, isUnsignedElementType(type), false);
};
'use strict';

var $TypeError = require('es-errors/type');

var inspect = require('object-inspect');

var isPropertyKey = require('../helpers/isPropertyKey');
// var ToObject = require('./ToObject');

// https://262.ecma-international.org/6.0/#sec-getv

module.exports = function GetV(V, P) {
	// 7.3.2.1
	if (!isPropertyKey(P)) {
		throw new $TypeError('Assertion failed: P is not a Property Key, got ' + inspect(P));
	}

	// 7.3.2.2-3
	// var O = ToObject(V);

	// 7.3.2.4
	return V[P];
};
'use strict';

var $TypeError = require('es-errors/type');

var hasOwn = require('hasown');
var isObject = require('es-object-atoms/isObject');

var isPropertyKey = require('../helpers/isPropertyKey');

// https://262.ecma-international.org/6.0/#sec-hasownproperty

module.exports = function HasOwnProperty(O, P) {
	if (!isObject(O)) {
		throw new $TypeError('Assertion failed: `O` must be an Object');
	}
	if (!isPropertyKey(P)) {
		throw new $TypeError('Assertion failed: `P` must be a Property Key');
	}
	return hasOwn(O, P);
};
'use strict';

var $TypeError = require('es-errors/type');
var isObject = require('es-object-atoms/isObject');

var isPropertyKey = require('../helpers/isPropertyKey');

// https://262.ecma-international.org/6.0/#sec-hasproperty

module.exports = function HasProperty(O, P) {
	if (!isObject(O)) {
		throw new $TypeError('Assertion failed: `O` must be an Object');
	}
	if (!isPropertyKey(P)) {
		throw new $TypeError('Assertion failed: `P` must be a Property Key');
	}
	return P in O;
};
'use strict';

var floor = require('./floor');
var modulo = require('./modulo');

var timeConstants = require('../helpers/timeConstants');
var msPerHour = timeConstants.msPerHour;
var HoursPerDay = timeConstants.HoursPerDay;

// https://262.ecma-international.org/5.1/#sec-15.9.1.10

module.exports = function HourFromTime(t) {
	return modulo(floor(t / msPerHour), HoursPerDay);
};
'use strict';

var $EvalError = require('es-errors/eval');

var DaysInYear = require('./DaysInYear');
var YearFromTime = require('./YearFromTime');

// https://262.ecma-international.org/5.1/#sec-15.9.1.3

module.exports = function InLeapYear(t) {
	var days = DaysInYear(YearFromTime(t));
	if (days === 365) {
		return 0;
	}
	if (days === 366) {
		return 1;
	}
	throw new $EvalError('Assertion failed: there are not 365 or 366 days in a year, got: ' + days);
};
'use strict';

var GetIntrinsic = require('get-intrinsic');

var $TypeError = require('es-errors/type');
var isObject = require('es-object-atoms/isObject');

var $hasInstance = GetIntrinsic('%Symbol.hasInstance%', true);

var Call = require('./Call');
var GetMethod = require('./GetMethod');
var IsCallable = require('./IsCallable');
var OrdinaryHasInstance = require('./OrdinaryHasInstance');
var ToBoolean = require('./ToBoolean');

// https://262.ecma-international.org/6.0/#sec-instanceofoperator

module.exports = function InstanceofOperator(O, C) {
	if (!isObject(O)) {
		throw new $TypeError('Assertion failed: Type(O) is not Object');
	}
	var instOfHandler = $hasInstance ? GetMethod(C, $hasInstance) : void 0;
	if (typeof instOfHandler !== 'undefined') {
		return ToBoolean(Call(instOfHandler, C, [O]));
	}
	if (!IsCallable(C)) {
		throw new $TypeError('`C` is not Callable');
	}
	return OrdinaryHasInstance(C, O);
};
'use strict';

var $SyntaxError = require('es-errors/syntax');
var $TypeError = require('es-errors/type');
var isNegativeZero = require('math-intrinsics/isNegativeZero');

var GetValueFromBuffer = require('./GetValueFromBuffer');
var IsDetachedBuffer = require('./IsDetachedBuffer');
var IsInteger = require('./IsInteger');

var typedArrayLength = require('typed-array-length');
var typedArrayBuffer = require('typed-array-buffer');
var typedArrayByteOffset = require('typed-array-byte-offset');
var whichTypedArray = require('which-typed-array');

var tableTAO = require('./tables/typed-array-objects');

// https://262.ecma-international.org/6.0/#sec-integerindexedelementget

module.exports = function IntegerIndexedElementGet(O, index) {
	if (typeof index !== 'number') {
		throw new $TypeError('`index` must be a Number'); // step 1
	}
	var arrayTypeName = whichTypedArray(O); // step 10
	if (!arrayTypeName) {
		throw new $TypeError('`O` must be a TypedArray'); // step 2
	}
	if (arrayTypeName === 'BigInt64Array' || arrayTypeName === 'BigUint64Array') {
		throw new $SyntaxError('BigInt64Array and BigUint64Array do not exist until ES2020');
	}

	var buffer = typedArrayBuffer(O); // step 3

	if (IsDetachedBuffer(buffer)) {
		throw new $TypeError('`O` has a detached buffer'); // step 4
	}

	if (!IsInteger(index) || isNegativeZero(index)) {
		return void undefined; // steps 5 - 6
	}

	var length = typedArrayLength(O); // step 7

	if (index < 0 || index >= length) {
		return void undefined; // step 8
	}

	var offset = typedArrayByteOffset(O); // step 9

	var elementType = tableTAO.name['$' + arrayTypeName]; // step 13

	var elementSize = tableTAO.size['$' + elementType]; // step 11

	var indexedPosition = (index * elementSize) + offset; // step 12

	return GetValueFromBuffer(buffer, indexedPosition, elementType); // step 14
};
'use strict';

var $SyntaxError = require('es-errors/syntax');
var $TypeError = require('es-errors/type');

var IsDetachedBuffer = require('./IsDetachedBuffer');
var IsInteger = require('./IsInteger');
var SetValueInBuffer = require('./SetValueInBuffer');
var ToNumber = require('./ToNumber');

var isNegativeZero = require('math-intrinsics/isNegativeZero');
var typedArrayBuffer = require('typed-array-buffer');
var typedArrayByteOffset = require('typed-array-byte-offset');
var typedArrayLength = require('typed-array-length');
var whichTypedArray = require('which-typed-array');

var tableTAO = require('./tables/typed-array-objects');

// https://262.ecma-international.org/6.0/#sec-integerindexedelementset

module.exports = function IntegerIndexedElementSet(O, index, value) {
	if (typeof index !== 'number') {
		throw new $TypeError('`index` must be a Number'); // step 1
	}
	var arrayTypeName = whichTypedArray(O); // step 12
	if (!arrayTypeName) {
		throw new $TypeError('`O` must be a TypedArray'); // step 2
	}
	if (arrayTypeName === 'BigInt64Array' || arrayTypeName === 'BigUint64Array') {
		throw new $SyntaxError('BigInt64Array and BigUint64Array do not exist until ES2020'); // step 2
	}

	var numValue = ToNumber(value); // step 3

	var buffer = typedArrayBuffer(O); // step 5

	if (IsDetachedBuffer(buffer)) {
		throw new $TypeError('`O` has a detached buffer'); // step 6
	}

	if (!IsInteger(index) || isNegativeZero(index)) {
		return false; // steps 7 - 8
	}

	var length = typedArrayLength(O); // step 9

	if (index < 0 || index >= length) {
		return false; // step 10
	}

	var offset = typedArrayByteOffset(O); // step 11

	var elementType = tableTAO.name['$' + arrayTypeName]; // step 15

	var elementSize = tableTAO.size['$' + elementType]; // step 13

	var indexedPosition = (index * elementSize) + offset; // step 14

	SetValueInBuffer(buffer, indexedPosition, elementType, numValue); // step 16

	return true; // step 17
};
'use strict';

var $TypeError = require('es-errors/type');
var isObject = require('es-object-atoms/isObject');

var Call = require('./Call');
var CreateDataProperty = require('./CreateDataProperty');
var EnumerableOwnNames = require('./EnumerableOwnNames');
var Get = require('./Get');
var IsArray = require('./IsArray');
var ToLength = require('./ToLength');
var ToString = require('./ToString');

var forEach = require('../helpers/forEach');

// https://262.ecma-international.org/6.0/#sec-internalizejsonproperty

// note: `reviver` was implicitly closed-over until ES2020, where it becomes a third argument

module.exports = function InternalizeJSONProperty(holder, name, reviver) {
	if (!isObject(holder)) {
		throw new $TypeError('Assertion failed: `holder` is not an Object');
	}
	if (typeof name !== 'string') {
		throw new $TypeError('Assertion failed: `name` is not a String');
	}
	if (typeof reviver !== 'function') {
		throw new $TypeError('Assertion failed: `reviver` is not a Function');
	}

	var val = Get(holder, name); // step 1

	if (isObject(val)) { // step 3
		var isArray = IsArray(val); // step 3.a
		if (isArray) { // step 3.c
			var I = 0; // step 3.c.i

			var len = ToLength(Get(val, 'length')); // step 3.b.ii

			while (I < len) { // step 3.b.iv
				var newElement = InternalizeJSONProperty(val, ToString(I), reviver); // step 3.b.iv.1

				if (typeof newElement === 'undefined') { // step 3.b.iv.3
					delete val[ToString(I)]; // step 3.b.iv.3.a
				} else { // step 3.b.iv.4
					CreateDataProperty(val, ToString(I), newElement); // step 3.b.iv.4.a
				}

				I += 1; // step 3.b.iv.6
			}
		} else {
			var keys = EnumerableOwnNames(val); // step 3.d.i

			forEach(keys, function (P) { // step 3.d.iii
				// eslint-disable-next-line no-shadow
				var newElement = InternalizeJSONProperty(val, P, reviver); // step 3.d.iii.1

				if (typeof newElement === 'undefined') { // step 3.d.iii.3
					delete val[P]; // step 3.d.iii.3.a
				} else { // step 3.d.iii.4
					CreateDataProperty(val, P, newElement); // step 3.d.iii.4.a
				}
			});
		}
	}

	return Call(reviver, holder, [name, val]); // step 4
};
'use strict';

var $TypeError = require('es-errors/type');

var Call = require('./Call');
var IsArray = require('./IsArray');
var GetV = require('./GetV');
var isPropertyKey = require('../helpers/isPropertyKey');

// https://262.ecma-international.org/6.0/#sec-invoke

module.exports = function Invoke(O, P) {
	if (!isPropertyKey(P)) {
		throw new $TypeError('Assertion failed: P must be a Property Key');
	}
	var argumentsList = arguments.length > 2 ? arguments[2] : [];
	if (!IsArray(argumentsList)) {
		throw new $TypeError('Assertion failed: optional `argumentsList`, if provided, must be a List');
	}
	var func = GetV(O, P);
	return Call(func, O, argumentsList);
};
'use strict';

var $TypeError = require('es-errors/type');

var hasOwn = require('hasown');

var isPropertyDescriptor = require('../helpers/records/property-descriptor');

// https://262.ecma-international.org/5.1/#sec-8.10.1

module.exports = function IsAccessorDescriptor(Desc) {
	if (typeof Desc === 'undefined') {
		return false;
	}

	if (!isPropertyDescriptor(Desc)) {
		throw new $TypeError('Assertion failed: `Desc` must be a Property Descriptor');
	}

	if (!hasOwn(Desc, '[[Get]]') && !hasOwn(Desc, '[[Set]]')) {
		return false;
	}

	return true;
};
'use strict';

// https://262.ecma-international.org/6.0/#sec-isarray
module.exports = require('../helpers/IsArray');
'use strict';

// http://262.ecma-international.org/5.1/#sec-9.11

module.exports = require('is-callable');
'use strict';

var ValidateAndApplyPropertyDescriptor = require('./ValidateAndApplyPropertyDescriptor');

// https://262.ecma-international.org/6.0/#sec-iscompatiblepropertydescriptor

module.exports = function IsCompatiblePropertyDescriptor(Extensible, Desc, Current) {
	return ValidateAndApplyPropertyDescriptor(undefined, undefined, Extensible, Desc, Current);
};
'use strict';

var GetIntrinsic = require('get-intrinsic');

var $isConcatSpreadable = GetIntrinsic('%Symbol.isConcatSpreadable%', true);

var Get = require('./Get');
var IsArray = require('./IsArray');
var ToBoolean = require('./ToBoolean');

var isObject = require('es-object-atoms/isObject');

// https://262.ecma-international.org/6.0/#sec-isconcatspreadable

module.exports = function IsConcatSpreadable(O) {
	if (!isObject(O)) {
		return false;
	}
	if ($isConcatSpreadable) {
		var spreadable = Get(O, $isConcatSpreadable);
		if (typeof spreadable !== 'undefined') {
			return ToBoolean(spreadable);
		}
	}
	return IsArray(O);
};
'use strict';

var GetIntrinsic = require('../GetIntrinsic.js');

var $construct = GetIntrinsic('%Reflect.construct%', true);

var DefinePropertyOrThrow = require('./DefinePropertyOrThrow');
try {
	DefinePropertyOrThrow({}, '', { '[[Get]]': function () {} });
} catch (e) {
	// Accessor properties aren't supported
	DefinePropertyOrThrow = null;
}

// https://262.ecma-international.org/6.0/#sec-isconstructor

if (DefinePropertyOrThrow && $construct) {
	var isConstructorMarker = {};
	var badArrayLike = {};
	DefinePropertyOrThrow(badArrayLike, 'length', {
		'[[Get]]': function () {
			throw isConstructorMarker;
		},
		'[[Enumerable]]': true
	});

	module.exports = function IsConstructor(argument) {
		try {
			// `Reflect.construct` invokes `IsConstructor(target)` before `Get(args, 'length')`:
			$construct(argument, badArrayLike);
		} catch (err) {
			return err === isConstructorMarker;
		}
	};
} else {
	module.exports = function IsConstructor(argument) {
		// unfortunately there's no way to truly check this without try/catch `new argument` in old environments
		return typeof argument === 'function' && !!argument.prototype;
	};
}
'use strict';

var $TypeError = require('es-errors/type');

var hasOwn = require('hasown');

var isPropertyDescriptor = require('../helpers/records/property-descriptor');

// https://262.ecma-international.org/5.1/#sec-8.10.2

module.exports = function IsDataDescriptor(Desc) {
	if (typeof Desc === 'undefined') {
		return false;
	}

	if (!isPropertyDescriptor(Desc)) {
		throw new $TypeError('Assertion failed: `Desc` must be a Property Descriptor');
	}

	if (!hasOwn(Desc, '[[Value]]') && !hasOwn(Desc, '[[Writable]]')) {
		return false;
	}

	return true;
};
'use strict';

var $TypeError = require('es-errors/type');

var $byteLength = require('array-buffer-byte-length');

var isArrayBuffer = require('is-array-buffer');

var availableTypedArrays = require('available-typed-arrays')();

// https://262.ecma-international.org/6.0/#sec-isdetachedbuffer

module.exports = function IsDetachedBuffer(arrayBuffer) {
	if (!isArrayBuffer(arrayBuffer)) {
		throw new $TypeError('Assertion failed: `arrayBuffer` must be an Object with an [[ArrayBufferData]] internal slot');
	}
	if ($byteLength(arrayBuffer) === 0) {
		try {
			new global[availableTypedArrays[0]](arrayBuffer); // eslint-disable-line no-new
		} catch (error) {
			return !!error && error.name === 'TypeError';
		}
	}
	return false;
};
'use strict';

var GetIntrinsic = require('get-intrinsic');

var $preventExtensions = GetIntrinsic('%Object.preventExtensions%', true);
var $isExtensible = GetIntrinsic('%Object.isExtensible%', true);

var isPrimitive = require('../helpers/isPrimitive');

// https://262.ecma-international.org/6.0/#sec-isextensible-o

module.exports = $preventExtensions
	? function IsExtensible(obj) {
		return !isPrimitive(obj) && $isExtensible(obj);
	}
	: function IsExtensible(obj) {
		return !isPrimitive(obj);
	};
'use strict';

var $TypeError = require('es-errors/type');

var IsAccessorDescriptor = require('./IsAccessorDescriptor');
var IsDataDescriptor = require('./IsDataDescriptor');

var isPropertyDescriptor = require('../helpers/records/property-descriptor');

// https://262.ecma-international.org/6.0/#sec-isgenericdescriptor

module.exports = function IsGenericDescriptor(Desc) {
	if (typeof Desc === 'undefined') {
		return false;
	}

	if (!isPropertyDescriptor(Desc)) {
		throw new $TypeError('Assertion failed: `Desc` must be a Property Descriptor');
	}

	if (!IsAccessorDescriptor(Desc) && !IsDataDescriptor(Desc)) {
		return true;
	}

	return false;
};
'use strict';

var isInteger = require('math-intrinsics/isInteger');

// https://262.ecma-international.org/6.0/#sec-isinteger

module.exports = function IsInteger(argument) {
	return isInteger(argument);
};
'use strict';

var callBound = require('call-bound');

var $PromiseThen = callBound('Promise.prototype.then', true);

var isObject = require('es-object-atoms/isObject');

// https://262.ecma-international.org/6.0/#sec-ispromise

module.exports = function IsPromise(x) {
	if (!isObject(x)) {
		return false;
	}
	if (!$PromiseThen) { // Promises are not supported
		return false;
	}
	try {
		$PromiseThen(x); // throws if not a promise
	} catch (e) {
		return false;
	}
	return true;
};
'use strict';

// TODO, semver-major: delete this

var isPropertyDescriptor = require('../helpers/records/property-descriptor');

// https://262.ecma-international.org/6.0/#sec-property-descriptor-specification-type

module.exports = function IsPropertyDescriptor(Desc) {
	return isPropertyDescriptor(Desc);
};
'use strict';

var isPropertyKey = require('../helpers/isPropertyKey');

// https://262.ecma-international.org/6.0/#sec-ispropertykey

module.exports = function IsPropertyKey(argument) {
	return isPropertyKey(argument);
};
'use strict';

var GetIntrinsic = require('get-intrinsic');

var $match = GetIntrinsic('%Symbol.match%', true);

var hasRegExpMatcher = require('is-regex');
var isObject = require('es-object-atoms/isObject');

var ToBoolean = require('./ToBoolean');

// https://262.ecma-international.org/6.0/#sec-isregexp

module.exports = function IsRegExp(argument) {
	if (!isObject(argument)) {
		return false;
	}
	if ($match) {
		var isRegExp = argument[$match];
		if (typeof isRegExp !== 'undefined') {
			return ToBoolean(isRegExp);
		}
	}
	return hasRegExpMatcher(argument);
};
'use strict';

var $TypeError = require('es-errors/type');

var IsArray = require('./IsArray');
var IsInteger = require('./IsInteger');

var every = require('../helpers/every');
var regexTester = require('safe-regex-test');

var isChar = function isChar(c) {
	return typeof c === 'string' && c.length === 1;
};

var isWordCharacter = regexTester(/^[a-zA-Z0-9_]$/);

// https://262.ecma-international.org/6.0/#sec-runtime-semantics-iswordchar-abstract-operation

// note: prior to ES2023, this AO erroneously omitted the latter of its arguments.
module.exports = function IsWordChar(e, InputLength, Input) {
	if (!IsInteger(e)) {
		throw new $TypeError('Assertion failed: `e` must be an integer');
	}
	if (!IsInteger(InputLength)) {
		throw new $TypeError('Assertion failed: `InputLength` must be an integer');
	}
	if (!IsArray(Input) || !every(Input, isChar)) {
		throw new $TypeError('Assertion failed: `Input` must be a List of characters');
	}
	if (e === -1 || e === InputLength) {
		return false; // step 1
	}

	var c = Input[e]; // step 2

	return isWordCharacter(c); // steps 3-4
};
'use strict';

var $TypeError = require('es-errors/type');
var isObject = require('es-object-atoms/isObject');

var Call = require('./Call');
var CompletionRecord = require('./CompletionRecord');
var GetMethod = require('./GetMethod');
var IsCallable = require('./IsCallable');

// https://262.ecma-international.org/6.0/#sec-iteratorclose

module.exports = function IteratorClose(iterator, completion) {
	if (!isObject(iterator)) {
		throw new $TypeError('Assertion failed: Type(iterator) is not Object');
	}
	if (!IsCallable(completion) && !(completion instanceof CompletionRecord)) {
		throw new $TypeError('Assertion failed: completion is not a thunk representing a Completion Record, nor a Completion Record instance');
	}
	var completionThunk = completion instanceof CompletionRecord ? function () { return completion['?'](); } : completion;

	var iteratorReturn = GetMethod(iterator, 'return');

	if (typeof iteratorReturn === 'undefined') {
		return completionThunk();
	}

	var completionRecord;
	try {
		var innerResult = Call(iteratorReturn, iterator, []);
	} catch (e) {
		// if we hit here, then "e" is the innerResult completion that needs re-throwing

		// if the completion is of type "throw", this will throw.
		completionThunk();
		completionThunk = null; // ensure it's not called twice.

		// if not, then return the innerResult completion
		throw e;
	}
	completionRecord = completionThunk(); // if innerResult worked, then throw if the completion does
	completionThunk = null; // ensure it's not called twice.

	if (!isObject(innerResult)) {
		throw new $TypeError('iterator .return must return an object');
	}

	return completionRecord;
};
'use strict';

var $TypeError = require('es-errors/type');
var isObject = require('es-object-atoms/isObject');

var Get = require('./Get');
var ToBoolean = require('./ToBoolean');

// https://262.ecma-international.org/6.0/#sec-iteratorcomplete

module.exports = function IteratorComplete(iterResult) {
	if (!isObject(iterResult)) {
		throw new $TypeError('Assertion failed: Type(iterResult) is not Object');
	}
	return ToBoolean(Get(iterResult, 'done'));
};
'use strict';

var $TypeError = require('es-errors/type');
var isObject = require('es-object-atoms/isObject');

var Invoke = require('./Invoke');

// https://262.ecma-international.org/6.0/#sec-iteratornext

module.exports = function IteratorNext(iterator, value) {
	var result = Invoke(iterator, 'next', arguments.length < 2 ? [] : [value]);
	if (!isObject(result)) {
		throw new $TypeError('iterator next must return an object');
	}
	return result;
};
'use strict';

var IteratorComplete = require('./IteratorComplete');
var IteratorNext = require('./IteratorNext');

// https://262.ecma-international.org/6.0/#sec-iteratorstep

module.exports = function IteratorStep(iterator) {
	var result = IteratorNext(iterator);
	var done = IteratorComplete(result);
	return done === true ? false : result;
};

'use strict';

var $TypeError = require('es-errors/type');
var isObject = require('es-object-atoms/isObject');

var Get = require('./Get');

// https://262.ecma-international.org/6.0/#sec-iteratorvalue

module.exports = function IteratorValue(iterResult) {
	if (!isObject(iterResult)) {
		throw new $TypeError('Assertion failed: Type(iterResult) is not Object');
	}
	return Get(iterResult, 'value');
};

'use strict';

var $isFinite = require('math-intrinsics/isFinite');

var msPerDay = require('../helpers/timeConstants').msPerDay;

// https://262.ecma-international.org/5.1/#sec-15.9.1.13

module.exports = function MakeDate(day, time) {
	if (!$isFinite(day) || !$isFinite(time)) {
		return NaN;
	}
	return (day * msPerDay) + time;
};
'use strict';

var GetIntrinsic = require('get-intrinsic');

var $DateUTC = GetIntrinsic('%Date.UTC%');

var $isFinite = require('math-intrinsics/isFinite');

var DateFromTime = require('./DateFromTime');
var Day = require('./Day');
var floor = require('./floor');
var modulo = require('./modulo');
var MonthFromTime = require('./MonthFromTime');
var ToInteger = require('./ToInteger');
var YearFromTime = require('./YearFromTime');

// https://262.ecma-international.org/5.1/#sec-15.9.1.12

module.exports = function MakeDay(year, month, date) {
	if (!$isFinite(year) || !$isFinite(month) || !$isFinite(date)) {
		return NaN;
	}
	var y = ToInteger(year);
	var m = ToInteger(month);
	var dt = ToInteger(date);
	var ym = y + floor(m / 12);
	var mn = modulo(m, 12);
	var t = $DateUTC(ym, mn, 1);
	if (YearFromTime(t) !== ym || MonthFromTime(t) !== mn || DateFromTime(t) !== 1) {
		return NaN;
	}
	return Day(t) + dt - 1;
};
'use strict';

var $isFinite = require('math-intrinsics/isFinite');

var timeConstants = require('../helpers/timeConstants');
var msPerSecond = timeConstants.msPerSecond;
var msPerMinute = timeConstants.msPerMinute;
var msPerHour = timeConstants.msPerHour;

var ToInteger = require('./ToInteger');

// https://262.ecma-international.org/5.1/#sec-15.9.1.11

module.exports = function MakeTime(hour, min, sec, ms) {
	if (!$isFinite(hour) || !$isFinite(min) || !$isFinite(sec) || !$isFinite(ms)) {
		return NaN;
	}
	var h = ToInteger(hour);
	var m = ToInteger(min);
	var s = ToInteger(sec);
	var milli = ToInteger(ms);
	var t = (h * msPerHour) + (m * msPerMinute) + (s * msPerSecond) + milli;
	return t;
};
'use strict';

// https://262.ecma-international.org/6.0/#sec-algorithm-conventions

module.exports = require('math-intrinsics/max');
'use strict';

var floor = require('./floor');
var modulo = require('./modulo');

var timeConstants = require('../helpers/timeConstants');
var msPerMinute = timeConstants.msPerMinute;
var MinutesPerHour = timeConstants.MinutesPerHour;

// https://262.ecma-international.org/5.1/#sec-15.9.1.10

module.exports = function MinFromTime(t) {
	return modulo(floor(t / msPerMinute), MinutesPerHour);
};
'use strict';

// https://262.ecma-international.org/6.0/#sec-algorithm-conventions

module.exports = require('math-intrinsics/min');
'use strict';

var mod = require('../helpers/mod');

// https://262.ecma-international.org/5.1/#sec-5.2

module.exports = function modulo(x, y) {
	return mod(x, y);
};
'use strict';

var $RangeError = require('es-errors/range');

var DayWithinYear = require('./DayWithinYear');
var InLeapYear = require('./InLeapYear');

// https://262.ecma-international.org/5.1/#sec-15.9.1.4

module.exports = function MonthFromTime(t) {
	var day = DayWithinYear(t);
	if (0 <= day && day < 31) {
		return 0;
	}
	var leap = InLeapYear(t);
	if (31 <= day && day < (59 + leap)) {
		return 1;
	}
	if ((59 + leap) <= day && day < (90 + leap)) {
		return 2;
	}
	if ((90 + leap) <= day && day < (120 + leap)) {
		return 3;
	}
	if ((120 + leap) <= day && day < (151 + leap)) {
		return 4;
	}
	if ((151 + leap) <= day && day < (181 + leap)) {
		return 5;
	}
	if ((181 + leap) <= day && day < (212 + leap)) {
		return 6;
	}
	if ((212 + leap) <= day && day < (243 + leap)) {
		return 7;
	}
	if ((243 + leap) <= day && day < (273 + leap)) {
		return 8;
	}
	if ((273 + leap) <= day && day < (304 + leap)) {
		return 9;
	}
	if ((304 + leap) <= day && day < (334 + leap)) {
		return 10;
	}
	if ((334 + leap) <= day && day < (365 + leap)) {
		return 11;
	}

	throw new $RangeError('Assertion failed: `day` is out of range');
};
'use strict';

var modulo = require('./modulo');

var msPerSecond = require('../helpers/timeConstants').msPerSecond;

// https://262.ecma-international.org/5.1/#sec-15.9.1.10

module.exports = function msFromTime(t) {
	return modulo(t, msPerSecond);
};
'use strict';

var $TypeError = require('es-errors/type');

var IsCallable = require('./IsCallable');
var IsConstructor = require('./IsConstructor');

// https://262.ecma-international.org/6.0/#sec-newpromisecapability

module.exports = function NewPromiseCapability(C) {
	if (!IsConstructor(C)) {
		throw new $TypeError('C must be a constructor'); // step 1
	}

	var resolvingFunctions = { '[[Resolve]]': void undefined, '[[Reject]]': void undefined }; // step 3

	var promise = new C(function (resolve, reject) { // steps 4-5
		if (typeof resolvingFunctions['[[Resolve]]'] !== 'undefined' || typeof resolvingFunctions['[[Reject]]'] !== 'undefined') {
			throw new $TypeError('executor has already been called'); // step 4.a, 4.b
		}
		resolvingFunctions['[[Resolve]]'] = resolve; // step 4.c
		resolvingFunctions['[[Reject]]'] = reject; // step 4.d
	}); // step 4-6

	if (!IsCallable(resolvingFunctions['[[Resolve]]']) || !IsCallable(resolvingFunctions['[[Reject]]'])) {
		throw new $TypeError('executor must provide valid resolve and reject functions'); // steps 7-8
	}

	return {
		'[[Promise]]': promise,
		'[[Resolve]]': resolvingFunctions['[[Resolve]]'],
		'[[Reject]]': resolvingFunctions['[[Reject]]']
	}; // step 9
};
'use strict';

var CompletionRecord = require('./CompletionRecord');

// https://262.ecma-international.org/6.0/#sec-normalcompletion

module.exports = function NormalCompletion(value) {
	return new CompletionRecord('normal', value);
};
'use strict';

var GetIntrinsic = require('get-intrinsic');

var $ObjectCreate = GetIntrinsic('%Object.create%', true);
var $TypeError = require('es-errors/type');
var $SyntaxError = require('es-errors/syntax');
var isObject = require('es-object-atoms/isObject');

var IsArray = require('./IsArray');

var forEach = require('../helpers/forEach');

var SLOT = require('internal-slot');

var hasProto = require('has-proto')();

// https://262.ecma-international.org/6.0/#sec-objectcreate

module.exports = function ObjectCreate(proto, internalSlotsList) {
	if (proto !== null && !isObject(proto)) {
		throw new $TypeError('Assertion failed: `proto` must be null or an object');
	}
	var slots = arguments.length < 2 ? [] : internalSlotsList; // step 1
	if (arguments.length >= 2 && !IsArray(slots)) {
		throw new $TypeError('Assertion failed: `internalSlotsList` must be an Array');
	}

	var O;
	if (hasProto) {
		O = { __proto__: proto };
	} else if ($ObjectCreate) {
		O = $ObjectCreate(proto);
	} else {
		if (proto === null) {
			throw new $SyntaxError('native Object.create support is required to create null objects');
		}
		var T = function T() {};
		T.prototype = proto;
		O = new T();
	}

	if (slots.length > 0) {
		forEach(slots, function (slot) {
			SLOT.set(O, slot, void undefined);
		});
	}

	return O; // step 6
};
'use strict';

var DefinePropertyOrThrow = require('./DefinePropertyOrThrow');
var Get = require('./Get');
var OrdinaryGetOwnProperty = require('./OrdinaryGetOwnProperty');
var ToObject = require('./ToObject');
var ToPropertyDescriptor = require('./ToPropertyDescriptor');

var forEach = require('../helpers/forEach');
var OwnPropertyKeys = require('own-keys');

// https://262.ecma-international.org/6.0/#sec-objectdefineproperties

/** @type {<T extends Record<PropertyKey, unknown> = {}>(O: T, Properties: object) => T} */
module.exports = function ObjectDefineProperties(O, Properties) {
	var props = ToObject(Properties); // step 1
	var keys = OwnPropertyKeys(props); // step 2
	/** @type {[string | symbol, import('../types').Descriptor][]} */
	var descriptors = []; // step 3

	forEach(keys, function (nextKey) { // step 4
		var propDesc = OrdinaryGetOwnProperty(props, nextKey); // ToPropertyDescriptor(getOwnPropertyDescriptor(props, nextKey)); // step 4.a
		if (typeof propDesc !== 'undefined' && propDesc['[[Enumerable]]']) { // step 4.b
			var descObj = Get(props, nextKey); // step 4.b.i
			var desc = ToPropertyDescriptor(descObj); // step 4.b.ii
			descriptors[descriptors.length] = [nextKey, desc]; // step 4.b.iii
		}
	});

	forEach(descriptors, function (pair) { // step 5
		var P = pair[0]; // step 5.a
		var desc = pair[1]; // step 5.b
		DefinePropertyOrThrow(O, P, desc); // step 5.c
	});

	return O; // step 6
};
'use strict';

var GetIntrinsic = require('get-intrinsic');
var $TypeError = require('es-errors/type');

var GetPrototypeFromConstructor = require('./GetPrototypeFromConstructor');
var IsArray = require('./IsArray');
var ObjectCreate = require('./ObjectCreate');

// https://262.ecma-international.org/6.0/#sec-ordinarycreatefromconstructor

module.exports = function OrdinaryCreateFromConstructor(constructor, intrinsicDefaultProto) {
	GetIntrinsic(intrinsicDefaultProto); // throws if not a valid intrinsic
	var proto = GetPrototypeFromConstructor(constructor, intrinsicDefaultProto);
	var slots = arguments.length < 3 ? [] : arguments[2];
	if (!IsArray(slots)) {
		throw new $TypeError('Assertion failed: if provided, `internalSlotsList` must be a List');
	}
	return ObjectCreate(proto, slots);
};
'use strict';

var $gOPD = require('gopd');
var $SyntaxError = require('es-errors/syntax');
var $TypeError = require('es-errors/type');
var isObject = require('es-object-atoms/isObject');

var isPropertyDescriptor = require('../helpers/records/property-descriptor');

var IsAccessorDescriptor = require('./IsAccessorDescriptor');
var IsExtensible = require('./IsExtensible');
var isPropertyKey = require('../helpers/isPropertyKey');
var ToPropertyDescriptor = require('./ToPropertyDescriptor');
var SameValue = require('./SameValue');
var ValidateAndApplyPropertyDescriptor = require('./ValidateAndApplyPropertyDescriptor');

// https://262.ecma-international.org/6.0/#sec-ordinarydefineownproperty

module.exports = function OrdinaryDefineOwnProperty(O, P, Desc) {
	if (!isObject(O)) {
		throw new $TypeError('Assertion failed: O must be an Object');
	}
	if (!isPropertyKey(P)) {
		throw new $TypeError('Assertion failed: P must be a Property Key');
	}
	if (!isPropertyDescriptor(Desc)) {
		throw new $TypeError('Assertion failed: Desc must be a Property Descriptor');
	}
	if (!$gOPD) {
		// ES3/IE 8 fallback
		if (IsAccessorDescriptor(Desc)) {
			throw new $SyntaxError('This environment does not support accessor property descriptors.');
		}
		var creatingNormalDataProperty = !(P in O)
			&& Desc['[[Writable]]']
			&& Desc['[[Enumerable]]']
			&& Desc['[[Configurable]]']
			&& '[[Value]]' in Desc;
		var settingExistingDataProperty = (P in O)
			&& (!('[[Configurable]]' in Desc) || Desc['[[Configurable]]'])
			&& (!('[[Enumerable]]' in Desc) || Desc['[[Enumerable]]'])
			&& (!('[[Writable]]' in Desc) || Desc['[[Writable]]'])
			&& '[[Value]]' in Desc;
		if (creatingNormalDataProperty || settingExistingDataProperty) {
			O[P] = Desc['[[Value]]']; // eslint-disable-line no-param-reassign
			return SameValue(O[P], Desc['[[Value]]']);
		}
		throw new $SyntaxError('This environment does not support defining non-writable, non-enumerable, or non-configurable properties');
	}
	var desc = $gOPD(O, P);
	var current = desc && ToPropertyDescriptor(desc);
	var extensible = IsExtensible(O);
	return ValidateAndApplyPropertyDescriptor(O, P, extensible, Desc, current);
};
'use strict';

var $gOPD = require('gopd');
var $TypeError = require('es-errors/type');
var isObject = require('es-object-atoms/isObject');
var hasOwn = require('hasown');
var callBound = require('call-bound');

var $isEnumerable = callBound('Object.prototype.propertyIsEnumerable');

var IsArray = require('./IsArray');
var isPropertyKey = require('../helpers/isPropertyKey');
var IsRegExp = require('./IsRegExp');
var ToPropertyDescriptor = require('./ToPropertyDescriptor');

// https://262.ecma-international.org/6.0/#sec-ordinarygetownproperty

module.exports = function OrdinaryGetOwnProperty(O, P) {
	if (!isObject(O)) {
		throw new $TypeError('Assertion failed: O must be an Object');
	}
	if (!isPropertyKey(P)) {
		throw new $TypeError('Assertion failed: P must be a Property Key');
	}
	if (!hasOwn(O, P)) {
		return void 0;
	}
	if (!$gOPD) {
		// ES3 / IE 8 fallback
		var arrayLength = IsArray(O) && P === 'length';
		var regexLastIndex = IsRegExp(O) && P === 'lastIndex';
		return {
			'[[Configurable]]': !(arrayLength || regexLastIndex),
			'[[Enumerable]]': $isEnumerable(O, P),
			'[[Value]]': O[P],
			'[[Writable]]': true
		};
	}
	return ToPropertyDescriptor($gOPD(O, P));
};
'use strict';

var $TypeError = require('es-errors/type');
var isObject = require('es-object-atoms/isObject');

var Get = require('./Get');
var IsCallable = require('./IsCallable');

// https://262.ecma-international.org/6.0/#sec-ordinaryhasinstance

module.exports = function OrdinaryHasInstance(C, O) {
	if (!IsCallable(C)) {
		return false;
	}
	if (!isObject(O)) {
		return false;
	}
	var P = Get(C, 'prototype');
	if (!isObject(P)) {
		throw new $TypeError('OrdinaryHasInstance called on an object with an invalid prototype property.');
	}
	return O instanceof C;
};
'use strict';

var $TypeError = require('es-errors/type');
var isObject = require('es-object-atoms/isObject');

var isPropertyKey = require('../helpers/isPropertyKey');

// https://262.ecma-international.org/6.0/#sec-ordinaryhasproperty

module.exports = function OrdinaryHasProperty(O, P) {
	if (!isObject(O)) {
		throw new $TypeError('Assertion failed: Type(O) is not Object');
	}
	if (!isPropertyKey(P)) {
		throw new $TypeError('Assertion failed: P must be a Property Key');
	}
	return P in O;
};
'use strict';

var $TypeError = require('es-errors/type');

var callBound = require('call-bound');
var forEach = require('../helpers/forEach');

var $charCodeAt = callBound('String.prototype.charCodeAt');
var $numberToString = callBound('Number.prototype.toString');
var $toLowerCase = callBound('String.prototype.toLowerCase');
var $strSlice = callBound('String.prototype.slice');
var $strSplit = callBound('String.prototype.split');

// https://262.ecma-international.org/6.0/#sec-quotejsonstring

var escapes = {
	'\u0008': 'b',
	'\u000C': 'f',
	'\u000A': 'n',
	'\u000D': 'r',
	'\u0009': 't'
};

module.exports = function QuoteJSONString(value) {
	if (typeof value !== 'string') {
		throw new $TypeError('Assertion failed: `value` must be a String');
	}
	var product = '"';
	if (value) {
		forEach($strSplit(value, ''), function (C) {
			if (C === '"' || C === '\\') {
				product += '\u005C' + C;
			} else if (C === '\u0008' || C === '\u000C' || C === '\u000A' || C === '\u000D' || C === '\u0009') {
				var abbrev = escapes[C];
				product += '\u005C' + abbrev;
			} else {
				var cCharCode = $charCodeAt(C, 0);
				if (cCharCode < 0x20) {
					product += '\u005Cu' + $toLowerCase($strSlice('0000' + $numberToString(cCharCode, 16), -4));
				} else {
					product += C;
				}
			}
		});
	}
	product += '"';
	return product;
};
'use strict';

var GetIntrinsic = require('get-intrinsic');

var $RegExp = GetIntrinsic('%RegExp%');

// var RegExpAlloc = require('./RegExpAlloc');
// var RegExpInitialize = require('./RegExpInitialize');
var ToString = require('./ToString');

// https://262.ecma-international.org/6.0/#sec-regexpcreate

module.exports = function RegExpCreate(P, F) {
	// var obj = RegExpAlloc($RegExp);
	// return RegExpInitialize(obj, P, F);

	// covers spec mechanics; bypass regex brand checking
	var pattern = typeof P === 'undefined' ? '' : ToString(P);
	var flags = typeof F === 'undefined' ? '' : ToString(F);
	return new $RegExp(pattern, flags);
};
'use strict';

var $TypeError = require('es-errors/type');
var isObject = require('es-object-atoms/isObject');
var regexExec = require('call-bound')('RegExp.prototype.exec');

var Call = require('./Call');
var Get = require('./Get');
var IsCallable = require('./IsCallable');

// https://262.ecma-international.org/6.0/#sec-regexpexec

module.exports = function RegExpExec(R, S) {
	if (!isObject(R)) {
		throw new $TypeError('Assertion failed: `R` must be an Object');
	}
	if (typeof S !== 'string') {
		throw new $TypeError('Assertion failed: `S` must be a String');
	}
	var exec = Get(R, 'exec');
	if (IsCallable(exec)) {
		var result = Call(exec, R, [S]);
		if (result === null || isObject(result)) {
			return result;
		}
		throw new $TypeError('"exec" method must return `null` or an Object');
	}
	return regexExec(R, S);
};
'use strict';

module.exports = require('es-object-atoms/RequireObjectCoercible');
'use strict';

var $isNaN = require('math-intrinsics/isNaN');

// http://262.ecma-international.org/5.1/#sec-9.12

module.exports = function SameValue(x, y) {
	if (x === y) { // 0 === -0, but they are not identical.
		if (x === 0) { return 1 / x === 1 / y; }
		return true;
	}
	return $isNaN(x) && $isNaN(y);
};
'use strict';

var $isNaN = require('math-intrinsics/isNaN');

// https://262.ecma-international.org/6.0/#sec-samevaluezero

module.exports = function SameValueZero(x, y) {
	return (x === y) || ($isNaN(x) && $isNaN(y));
};
'use strict';

var floor = require('./floor');
var modulo = require('./modulo');

var timeConstants = require('../helpers/timeConstants');
var msPerSecond = timeConstants.msPerSecond;
var SecondsPerMinute = timeConstants.SecondsPerMinute;

// https://262.ecma-international.org/5.1/#sec-15.9.1.10

module.exports = function SecFromTime(t) {
	return modulo(floor(t / msPerSecond), SecondsPerMinute);
};
'use strict';

var hasOwn = require('hasown');

var $TypeError = require('es-errors/type');

var getSymbolDescription = require('get-symbol-description');

var DefinePropertyOrThrow = require('./DefinePropertyOrThrow');
var IsExtensible = require('./IsExtensible');

// https://262.ecma-international.org/6.0/#sec-setfunctionname

module.exports = function SetFunctionName(F, name) {
	if (typeof F !== 'function') {
		throw new $TypeError('Assertion failed: `F` must be a function');
	}
	if (!IsExtensible(F) || hasOwn(F, 'name')) {
		throw new $TypeError('Assertion failed: `F` must be extensible, and must not have a `name` own property');
	}
	if (typeof name !== 'symbol' && typeof name !== 'string') {
		throw new $TypeError('Assertion failed: `name` must be a Symbol or a String');
	}
	if (typeof name === 'symbol') {
		var description = getSymbolDescription(name);
		// eslint-disable-next-line no-param-reassign
		name = typeof description === 'undefined' ? '' : '[' + description + ']';
	}
	if (arguments.length > 2) {
		var prefix = arguments[2];
		// eslint-disable-next-line no-param-reassign
		name = prefix + ' ' + name;
	}
	return DefinePropertyOrThrow(F, 'name', {
		'[[Value]]': name,
		'[[Writable]]': false,
		'[[Enumerable]]': false,
		'[[Configurable]]': true
	});
};
'use strict';

var GetIntrinsic = require('get-intrinsic');

var $SyntaxError = require('es-errors/syntax');
var $TypeError = require('es-errors/type');
var isObject = require('es-object-atoms/isObject');
var $gOPD = require('gopd');
var $preventExtensions = GetIntrinsic('%Object.preventExtensions%', true);
var $gOPN = GetIntrinsic('%Object.getOwnPropertyNames%', true);

var forEach = require('../helpers/forEach');

var DefinePropertyOrThrow = require('./DefinePropertyOrThrow');
var IsAccessorDescriptor = require('./IsAccessorDescriptor');
var ToPropertyDescriptor = require('./ToPropertyDescriptor');

// https://262.ecma-international.org/6.0/#sec-setintegritylevel

module.exports = function SetIntegrityLevel(O, level) {
	if (!isObject(O)) {
		throw new $TypeError('Assertion failed: Type(O) is not Object');
	}
	if (level !== 'sealed' && level !== 'frozen') {
		throw new $TypeError('Assertion failed: `level` must be `"sealed"` or `"frozen"`');
	}
	if (!$preventExtensions) {
		throw new $SyntaxError('SetIntegrityLevel requires native `Object.preventExtensions` support');
	}
	var status = $preventExtensions(O);
	if (!status) {
		return false;
	}
	if (!$gOPN) {
		throw new $SyntaxError('SetIntegrityLevel requires native `Object.getOwnPropertyNames` support');
	}
	var theKeys = $gOPN(O);
	if (level === 'sealed') {
		forEach(theKeys, function (k) {
			DefinePropertyOrThrow(O, k, { configurable: false });
		});
	} else if (level === 'frozen') {
		forEach(theKeys, function (k) {
			var currentDesc = $gOPD(O, k);
			if (typeof currentDesc !== 'undefined') {
				var desc;
				if (IsAccessorDescriptor(ToPropertyDescriptor(currentDesc))) {
					desc = { configurable: false };
				} else {
					desc = { configurable: false, writable: false };
				}
				DefinePropertyOrThrow(O, k, desc);
			}
		});
	}
	return true;
};
'use strict';

var $TypeError = require('es-errors/type');
var isObject = require('es-object-atoms/isObject');

var isPropertyKey = require('../helpers/isPropertyKey');
var SameValue = require('./SameValue');

// IE 9 does not throw in strict mode when writability/configurability/extensibility is violated
var noThrowOnStrictViolation = (function () {
	try {
		delete [].length;
		return true;
	} catch (e) {
		return false;
	}
}());

// https://262.ecma-international.org/6.0/#sec-set-o-p-v-throw

module.exports = function Set(O, P, V, Throw) {
	if (!isObject(O)) {
		throw new $TypeError('Assertion failed: `O` must be an Object');
	}
	if (!isPropertyKey(P)) {
		throw new $TypeError('Assertion failed: `P` must be a Property Key');
	}
	if (typeof Throw !== 'boolean') {
		throw new $TypeError('Assertion failed: `Throw` must be a Boolean');
	}
	if (Throw) {
		O[P] = V; // eslint-disable-line no-param-reassign
		if (noThrowOnStrictViolation && !SameValue(O[P], V)) {
			throw new $TypeError('Attempted to assign to readonly property.');
		}
		return true;
	}
	try {
		O[P] = V; // eslint-disable-line no-param-reassign
		return noThrowOnStrictViolation ? SameValue(O[P], V) : true;
	} catch (e) {
		return false;
	}

};
'use strict';

var GetIntrinsic = require('get-intrinsic');

var $TypeError = require('es-errors/type');
var $Uint8Array = GetIntrinsic('%Uint8Array%', true);

var isInteger = require('math-intrinsics/isInteger');

var IsDetachedBuffer = require('./IsDetachedBuffer');
var ToInt16 = require('./ToInt16');
var ToInt32 = require('./ToInt32');
var ToInt8 = require('./ToInt8');
var ToUint16 = require('./ToUint16');
var ToUint32 = require('./ToUint32');
var ToUint8 = require('./ToUint8');
var ToUint8Clamp = require('./ToUint8Clamp');

var isArrayBuffer = require('is-array-buffer');
var hasOwn = require('hasown');

var tableTAO = require('./tables/typed-array-objects');

var TypeToAO = {
	__proto__: null,
	$Int8: ToInt8,
	$Uint8: ToUint8,
	$Uint8C: ToUint8Clamp,
	$Int16: ToInt16,
	$Uint16: ToUint16,
	$Int32: ToInt32,
	$Uint32: ToUint32
};

var defaultEndianness = require('../helpers/defaultEndianness');
var forEach = require('../helpers/forEach');
var integerToNBytes = require('../helpers/integerToNBytes');
var valueToFloat32Bytes = require('../helpers/valueToFloat32Bytes');
var valueToFloat64Bytes = require('../helpers/valueToFloat64Bytes');

// https://262.ecma-international.org/6.0/#sec-setvalueinbuffer

module.exports = function SetValueInBuffer(arrayBuffer, byteIndex, type, value) {
	if (!isArrayBuffer(arrayBuffer)) {
		throw new $TypeError('Assertion failed: `arrayBuffer` must be an ArrayBuffer');
	}

	if (!isInteger(byteIndex)) {
		throw new $TypeError('Assertion failed: `byteIndex` must be an integer');
	}

	if (typeof type !== 'string' || !hasOwn(tableTAO.size, '$' + type)) {
		throw new $TypeError('Assertion failed: `type` must be one of ' + tableTAO.choices);
	}

	if (typeof value !== 'number') {
		throw new $TypeError('Assertion failed: `value` must be a number');
	}

	if (arguments.length > 4 && typeof arguments[4] !== 'boolean') {
		throw new $TypeError('Assertion failed: `isLittleEndian` must be a boolean, if present');
	}

	if (IsDetachedBuffer(arrayBuffer)) {
		throw new $TypeError('Assertion failed: ArrayBuffer is detached'); // step 1
	}

	// 2. Assert: There are sufficient bytes in arrayBuffer starting at byteIndex to represent a value of type.

	if (byteIndex < 0) {
		throw new $TypeError('Assertion failed: `byteIndex` must be non-negative'); // step 3
	}

	// 4. Assert: Type(value) is Number.

	// 5. Let block be arrayBuffer’s [[ArrayBufferData]] internal slot.

	// 6. Assert: block is not undefined.

	var elementSize = tableTAO.size['$' + type]; // step 7
	if (!elementSize) {
		throw new $TypeError('Assertion failed: `type` must be one of ' + tableTAO.choices);
	}

	// 8. If isLittleEndian is not present, set isLittleEndian to either true or false. The choice is implementation dependent and should be the alternative that is most efficient for the implementation. An implementation must use the same value each time this step is executed and the same value must be used for the corresponding step in the GetValueFromBuffer abstract operation.
	var isLittleEndian = arguments.length > 4 ? arguments[4] : defaultEndianness === 'little'; // step 8

	var rawBytes;
	if (type === 'Float32') { // step 1
		rawBytes = valueToFloat32Bytes(value, isLittleEndian);
	} else if (type === 'Float64') { // step 2
		rawBytes = valueToFloat64Bytes(value, isLittleEndian);
	} else {
		var n = elementSize; // step 3.a

		var convOp = TypeToAO['$' + type]; // step 3.b

		var intValue = convOp(value); // step 3.c

		rawBytes = integerToNBytes(intValue, n, isLittleEndian); // step 3.d, 3.e, 4
	}

	// 12. Store the individual bytes of rawBytes into block, in order, starting at block[byteIndex].
	var arr = new $Uint8Array(arrayBuffer, byteIndex, elementSize);
	forEach(rawBytes, function (rawByte, i) {
		arr[i] = rawByte;
	});

	// 13. Return NormalCompletion(undefined).
};
'use strict';

var GetIntrinsic = require('get-intrinsic');

var $species = GetIntrinsic('%Symbol.species%', true);
var $TypeError = require('es-errors/type');
var isObject = require('es-object-atoms/isObject');

var IsConstructor = require('./IsConstructor');

// https://262.ecma-international.org/6.0/#sec-speciesconstructor

module.exports = function SpeciesConstructor(O, defaultConstructor) {
	if (!isObject(O)) {
		throw new $TypeError('Assertion failed: Type(O) is not Object');
	}
	var C = O.constructor;
	if (typeof C === 'undefined') {
		return defaultConstructor;
	}
	if (!isObject(C)) {
		throw new $TypeError('O.constructor is not an Object');
	}
	var S = $species ? C[$species] : void 0;
	if (S == null) {
		return defaultConstructor;
	}
	if (IsConstructor(S)) {
		return S;
	}
	throw new $TypeError('no constructor found');
};
'use strict';

var callBound = require('call-bound');

var $TypeError = require('es-errors/type');
var isInteger = require('math-intrinsics/isInteger');

var $charAt = callBound('String.prototype.charAt');

// https://262.ecma-international.org/6.0/#sec-splitmatch

module.exports = function SplitMatch(S, q, R) {
	if (typeof S !== 'string') {
		throw new $TypeError('Assertion failed: `S` must be a String');
	}
	if (!isInteger(q)) {
		throw new $TypeError('Assertion failed: `q` must be an integer');
	}
	if (typeof R !== 'string') {
		throw new $TypeError('Assertion failed: `R` must be a String');
	}
	var r = R.length;
	var s = S.length;
	if (q + r > s) {
		return false;
	}

	for (var i = 0; i < r; i += 1) {
		if ($charAt(S, q + i) !== $charAt(R, i)) {
			return false;
		}
	}

	return q + r;
};
'use strict';

var Type = require('./Type');

// https://262.ecma-international.org/5.1/#sec-11.9.6

module.exports = function StrictEqualityComparison(x, y) {
	if (Type(x) !== Type(y)) {
		return false;
	}
	if (typeof x === 'undefined' || x === null) {
		return true;
	}
	return x === y; // shortcut for steps 4-7
};
'use strict';

var GetIntrinsic = require('get-intrinsic');

var $Object = require('es-object-atoms');
var $StringPrototype = GetIntrinsic('%String.prototype%');
var $SyntaxError = require('es-errors/syntax');
var $TypeError = require('es-errors/type');
var setProto = require('set-proto');

var DefinePropertyOrThrow = require('./DefinePropertyOrThrow');

// https://262.ecma-international.org/6.0/#sec-stringcreate

module.exports = function StringCreate(value, prototype) {
	if (typeof value !== 'string') {
		throw new $TypeError('Assertion failed: `S` must be a String');
	}

	var S = $Object(value);
	if (prototype !== $StringPrototype) {
		if (setProto) {
			setProto(S, prototype);
		} else {
			throw new $SyntaxError('StringCreate: a `proto` argument that is not `String.prototype` is not supported in an environment that does not support setting the [[Prototype]]');
		}
	}

	var length = value.length;
	DefinePropertyOrThrow(S, 'length', {
		'[[Configurable]]': false,
		'[[Enumerable]]': false,
		'[[Value]]': length,
		'[[Writable]]': false
	});

	return S;
};
'use strict';

var callBound = require('call-bound');

var $TypeError = require('es-errors/type');

var $charAt = callBound('String.prototype.charAt');

var isString = require('is-string');
var isNegativeZero = require('math-intrinsics/isNegativeZero');
var unbox = require('unbox-primitive');

var CanonicalNumericIndexString = require('./CanonicalNumericIndexString');
var IsInteger = require('./IsInteger');
var isPropertyKey = require('../helpers/isPropertyKey');

// https://262.ecma-international.org/6.0/#sec-stringgetindexproperty

module.exports = function StringGetIndexProperty(S, P) {
	if (typeof S === 'string' || !isString(S)) {
		throw new $TypeError('Assertion failed: `S` must be a boxed String Object');
	}
	if (!isPropertyKey(P)) {
		throw new $TypeError('Assertion failed: `P` must be a Property Key');
	}

	if (typeof P !== 'string') {
		return void undefined;
	}

	var index = CanonicalNumericIndexString(P);
	if (typeof index === 'undefined' || !IsInteger(index) || isNegativeZero(index)) {
		return void undefined;
	}

	var str = unbox(S);
	var len = str.length;
	if (index < 0 || len <= index) {
		return void undefined;
	}

	var resultStr = $charAt(str, index);

	return {
		'[[Configurable]]': false,
		'[[Enumerable]]': true,
		'[[Value]]': resultStr,
		'[[Writable]]': false
	};
};
'use strict';

var $TypeError = require('es-errors/type');

var callBound = require('call-bound');

var $SymbolToString = callBound('Symbol.prototype.toString', true);

// https://262.ecma-international.org/6.0/#sec-symboldescriptivestring

module.exports = function SymbolDescriptiveString(sym) {
	if (typeof sym !== 'symbol') {
		throw new $TypeError('Assertion failed: `sym` must be a Symbol');
	}
	return $SymbolToString(sym);
};
'use strict';

var $gOPD = require('gopd');
var $TypeError = require('es-errors/type');

var every = require('../helpers/every');
var OwnPropertyKeys = require('own-keys');
var isObject = require('es-object-atoms/isObject');

var IsDataDescriptor = require('./IsDataDescriptor');
var IsExtensible = require('./IsExtensible');
var ToPropertyDescriptor = require('./ToPropertyDescriptor');

// https://262.ecma-international.org/6.0/#sec-testintegritylevel

module.exports = function TestIntegrityLevel(O, level) {
	if (!isObject(O)) {
		throw new $TypeError('Assertion failed: Type(O) is not Object');
	}
	if (level !== 'sealed' && level !== 'frozen') {
		throw new $TypeError('Assertion failed: `level` must be `"sealed"` or `"frozen"`');
	}
	var status = IsExtensible(O);
	if (status || !$gOPD) {
		return false;
	}
	var theKeys = OwnPropertyKeys(O);
	return theKeys.length === 0 || every(theKeys, function (k) {
		var currentDesc = $gOPD(O, k);
		if (typeof currentDesc !== 'undefined') {
			if (currentDesc.configurable) {
				return false;
			}
			if (level === 'frozen' && IsDataDescriptor(ToPropertyDescriptor(currentDesc)) && currentDesc.writable) {
				return false;
			}
		}
		return true;
	});
};
'use strict';

var $BooleanValueOf = require('call-bound')('Boolean.prototype.valueOf');

// https://262.ecma-international.org/6.0/#sec-properties-of-the-boolean-prototype-object

module.exports = function thisBooleanValue(value) {
	if (typeof value === 'boolean') {
		return value;
	}

	return $BooleanValueOf(value);
};
'use strict';

var callBound = require('call-bound');

var $NumberValueOf = callBound('Number.prototype.valueOf');

// https://262.ecma-international.org/6.0/#sec-properties-of-the-number-prototype-object

module.exports = function thisNumberValue(value) {
	if (typeof value === 'number') {
		return value;
	}

	return $NumberValueOf(value);
};

'use strict';

var $StringValueOf = require('call-bound')('String.prototype.valueOf');

// https://262.ecma-international.org/6.0/#sec-properties-of-the-string-prototype-object

module.exports = function thisStringValue(value) {
	if (typeof value === 'string') {
		return value;
	}

	return $StringValueOf(value);
};
'use strict';

var timeValue = require('../helpers/timeValue');

// https://262.ecma-international.org/6.0/#sec-properties-of-the-date-prototype-object

module.exports = function thisTimeValue(value) {
	return timeValue(value);
};
'use strict';

var GetIntrinsic = require('get-intrinsic');

var $Date = GetIntrinsic('%Date%');

var $isFinite = require('math-intrinsics/isFinite');
var abs = require('math-intrinsics/abs');

var ToNumber = require('./ToNumber');

// https://262.ecma-international.org/5.1/#sec-15.9.1.14

module.exports = function TimeClip(time) {
	if (!$isFinite(time) || abs(time) > 8.64e15) {
		return NaN;
	}
	return +new $Date(ToNumber(time));
};

'use strict';

var msPerDay = require('../helpers/timeConstants').msPerDay;

var DayFromYear = require('./DayFromYear');

// https://262.ecma-international.org/5.1/#sec-15.9.1.3

module.exports = function TimeFromYear(y) {
	return msPerDay * DayFromYear(y);
};
'use strict';

var modulo = require('./modulo');

var msPerDay = require('../helpers/timeConstants').msPerDay;

// https://262.ecma-international.org/5.1/#sec-15.9.1.2

module.exports = function TimeWithinDay(t) {
	return modulo(t, msPerDay);
};

'use strict';

// http://262.ecma-international.org/5.1/#sec-9.2

module.exports = function ToBoolean(value) { return !!value; };
'use strict';

var GetIntrinsic = require('get-intrinsic');

var $TypeError = require('es-errors/type');
var $Date = GetIntrinsic('%Date%');
var $String = GetIntrinsic('%String%');

var $isNaN = require('math-intrinsics/isNaN');

// https://262.ecma-international.org/6.0/#sec-todatestring

module.exports = function ToDateString(tv) {
	if (typeof tv !== 'number') {
		throw new $TypeError('Assertion failed: `tv` must be a Number');
	}
	if ($isNaN(tv)) {
		return 'Invalid Date';
	}
	return $String(new $Date(tv));
};
'use strict';

var ToUint16 = require('./ToUint16');

// https://262.ecma-international.org/6.0/#sec-toint16

module.exports = function ToInt16(argument) {
	var int16bit = ToUint16(argument);
	return int16bit >= 0x8000 ? int16bit - 0x10000 : int16bit;
};
'use strict';

var ToNumber = require('./ToNumber');

// http://262.ecma-international.org/5.1/#sec-9.5

module.exports = function ToInt32(x) {
	return ToNumber(x) >> 0;
};
'use strict';

var ToUint8 = require('./ToUint8');

// https://262.ecma-international.org/6.0/#sec-toint8

module.exports = function ToInt8(argument) {
	var int8bit = ToUint8(argument);
	return int8bit >= 0x80 ? int8bit - 0x100 : int8bit;
};
'use strict';

var ES5ToInteger = require('../5/ToInteger');

var ToNumber = require('./ToNumber');

// https://262.ecma-international.org/6.0/#sec-tointeger

module.exports = function ToInteger(value) {
	var number = ToNumber(value);
	return ES5ToInteger(number);
};
'use strict';

var MAX_SAFE_INTEGER = require('math-intrinsics/constants/maxSafeInteger');

var ToInteger = require('./ToInteger');

// https://262.ecma-international.org/6.0/#sec-tolength

module.exports = function ToLength(argument) {
	var len = ToInteger(argument);
	if (len <= 0) { return 0; } // includes converting -0 to +0
	if (len > MAX_SAFE_INTEGER) { return MAX_SAFE_INTEGER; }
	return len;
};
'use strict';

var GetIntrinsic = require('get-intrinsic');

var $TypeError = require('es-errors/type');
var $Number = GetIntrinsic('%Number%');
var $RegExp = GetIntrinsic('%RegExp%');
var $parseInteger = GetIntrinsic('%parseInt%');

var callBound = require('call-bound');
var regexTester = require('safe-regex-test');
var isPrimitive = require('../helpers/isPrimitive');

var $strSlice = callBound('String.prototype.slice');
var isBinary = regexTester(/^0b[01]+$/i);
var isOctal = regexTester(/^0o[0-7]+$/i);
var isInvalidHexLiteral = regexTester(/^[-+]0x[0-9a-f]+$/i);
var nonWS = ['\u0085', '\u200b', '\ufffe'].join('');
var nonWSregex = new $RegExp('[' + nonWS + ']', 'g');
var hasNonWS = regexTester(nonWSregex);

var $trim = require('string.prototype.trim');

var ToPrimitive = require('./ToPrimitive');

// https://262.ecma-international.org/6.0/#sec-tonumber

module.exports = function ToNumber(argument) {
	var value = isPrimitive(argument) ? argument : ToPrimitive(argument, $Number);
	if (typeof value === 'symbol') {
		throw new $TypeError('Cannot convert a Symbol value to a number');
	}
	if (typeof value === 'string') {
		if (isBinary(value)) {
			return ToNumber($parseInteger($strSlice(value, 2), 2));
		} else if (isOctal(value)) {
			return ToNumber($parseInteger($strSlice(value, 2), 8));
		} else if (hasNonWS(value) || isInvalidHexLiteral(value)) {
			return NaN;
		}
		var trimmed = $trim(value);
		if (trimmed !== value) {
			return ToNumber(trimmed);
		}

	}
	return +value;
};
'use strict';

// https://262.ecma-international.org/6.0/#sec-toobject

module.exports = require('es-object-atoms/ToObject');
'use strict';

var toPrimitive = require('es-to-primitive/es2015');

// https://262.ecma-international.org/6.0/#sec-toprimitive

module.exports = function ToPrimitive(input) {
	if (arguments.length > 1) {
		return toPrimitive(input, arguments[1]);
	}
	return toPrimitive(input);
};
'use strict';

var hasOwn = require('hasown');

var $TypeError = require('es-errors/type');
var isObject = require('es-object-atoms/isObject');

var IsCallable = require('./IsCallable');
var ToBoolean = require('./ToBoolean');

// https://262.ecma-international.org/5.1/#sec-8.10.5

module.exports = function ToPropertyDescriptor(Obj) {
	if (!isObject(Obj)) {
		throw new $TypeError('ToPropertyDescriptor requires an object');
	}

	var desc = {};
	if (hasOwn(Obj, 'enumerable')) {
		desc['[[Enumerable]]'] = ToBoolean(Obj.enumerable);
	}
	if (hasOwn(Obj, 'configurable')) {
		desc['[[Configurable]]'] = ToBoolean(Obj.configurable);
	}
	if (hasOwn(Obj, 'value')) {
		desc['[[Value]]'] = Obj.value;
	}
	if (hasOwn(Obj, 'writable')) {
		desc['[[Writable]]'] = ToBoolean(Obj.writable);
	}
	if (hasOwn(Obj, 'get')) {
		var getter = Obj.get;
		if (typeof getter !== 'undefined' && !IsCallable(getter)) {
			throw new $TypeError('getter must be a function');
		}
		desc['[[Get]]'] = getter;
	}
	if (hasOwn(Obj, 'set')) {
		var setter = Obj.set;
		if (typeof setter !== 'undefined' && !IsCallable(setter)) {
			throw new $TypeError('setter must be a function');
		}
		desc['[[Set]]'] = setter;
	}

	if ((hasOwn(desc, '[[Get]]') || hasOwn(desc, '[[Set]]')) && (hasOwn(desc, '[[Value]]') || hasOwn(desc, '[[Writable]]'))) {
		throw new $TypeError('Invalid property descriptor. Cannot both specify accessors and a value or writable attribute');
	}
	return desc;
};
'use strict';

var GetIntrinsic = require('get-intrinsic');

var $String = GetIntrinsic('%String%');

var ToPrimitive = require('./ToPrimitive');
var ToString = require('./ToString');

// https://262.ecma-international.org/6.0/#sec-topropertykey

module.exports = function ToPropertyKey(argument) {
	var key = ToPrimitive(argument, $String);
	return typeof key === 'symbol' ? key : ToString(key);
};
'use strict';

var GetIntrinsic = require('get-intrinsic');

var $String = GetIntrinsic('%String%');
var $TypeError = require('es-errors/type');

// https://262.ecma-international.org/6.0/#sec-tostring

module.exports = function ToString(argument) {
	if (typeof argument === 'symbol') {
		throw new $TypeError('Cannot convert a Symbol value to a string');
	}
	return $String(argument);
};
'use strict';

var modulo = require('./modulo');
var ToNumber = require('./ToNumber');

var abs = require('math-intrinsics/abs');
var floor = require('math-intrinsics/floor');
var $isNaN = require('math-intrinsics/isNaN');
var $isFinite = require('math-intrinsics/isFinite');
var $sign = require('math-intrinsics/sign');

// http://262.ecma-international.org/5.1/#sec-9.7

module.exports = function ToUint16(value) {
	var number = ToNumber(value);
	if ($isNaN(number) || number === 0 || !$isFinite(number)) { return 0; }
	var posInt = $sign(number) * floor(abs(number));
	return modulo(posInt, 0x10000);
};
'use strict';

var ToNumber = require('./ToNumber');

// http://262.ecma-international.org/5.1/#sec-9.6

module.exports = function ToUint32(x) {
	return ToNumber(x) >>> 0;
};
'use strict';

var ToNumber = require('./ToNumber');
var floor = require('./floor');

var $isNaN = require('math-intrinsics/isNaN');

// https://262.ecma-international.org/6.0/#sec-touint8clamp

module.exports = function ToUint8Clamp(argument) {
	var number = ToNumber(argument);
	if ($isNaN(number) || number <= 0) { return 0; }
	if (number >= 0xFF) { return 0xFF; }
	var f = floor(number);
	if (f + 0.5 < number) { return f + 1; }
	if (number < f + 0.5) { return f; }
	if (f % 2 !== 0) { return f + 1; }
	return f;
};
'use strict';

var ToNumber = require('./ToNumber');

var $isNaN = require('math-intrinsics/isNaN');
var $isFinite = require('math-intrinsics/isFinite');
var $sign = require('math-intrinsics/sign');
var abs = require('math-intrinsics/abs');
var floor = require('math-intrinsics/floor');
var modulo = require('math-intrinsics/mod');

// https://262.ecma-international.org/6.0/#sec-touint8

module.exports = function ToUint8(argument) {
	var number = ToNumber(argument);
	if ($isNaN(number) || number === 0 || !$isFinite(number)) { return 0; }
	var posInt = $sign(number) * floor(abs(number));
	return modulo(posInt, 0x100);
};
'use strict';

var ES5Type = require('../5/Type');

// https://262.ecma-international.org/6.0/#sec-ecmascript-data-types-and-values

module.exports = function Type(x) {
	if (typeof x === 'symbol') {
		return 'Symbol';
	}
	return ES5Type(x);
};
'use strict';

var $TypeError = require('es-errors/type');
var isObject = require('es-object-atoms/isObject');

var DefineOwnProperty = require('../helpers/DefineOwnProperty');
var isPropertyDescriptor = require('../helpers/records/property-descriptor');
var isSamePropertyDescriptor = require('../helpers/isSamePropertyDescriptor');

var FromPropertyDescriptor = require('./FromPropertyDescriptor');
var IsAccessorDescriptor = require('./IsAccessorDescriptor');
var IsDataDescriptor = require('./IsDataDescriptor');
var IsGenericDescriptor = require('./IsGenericDescriptor');
var isPropertyKey = require('../helpers/isPropertyKey');
var SameValue = require('./SameValue');

// https://262.ecma-international.org/6.0/#sec-validateandapplypropertydescriptor
// https://262.ecma-international.org/8.0/#sec-validateandapplypropertydescriptor

// eslint-disable-next-line max-lines-per-function, max-statements
module.exports = function ValidateAndApplyPropertyDescriptor(O, P, extensible, Desc, current) {
	// this uses the ES2017+ logic, since it fixes a number of bugs in the ES2015 logic.
	if (typeof O !== 'undefined' && !isObject(O)) {
		throw new $TypeError('Assertion failed: O must be undefined or an Object');
	}
	if (typeof extensible !== 'boolean') {
		throw new $TypeError('Assertion failed: extensible must be a Boolean');
	}
	if (!isPropertyDescriptor(Desc)) {
		throw new $TypeError('Assertion failed: Desc must be a Property Descriptor');
	}
	if (typeof current !== 'undefined' && !isPropertyDescriptor(current)) {
		throw new $TypeError('Assertion failed: current must be a Property Descriptor, or undefined');
	}
	if (typeof O !== 'undefined' && !isPropertyKey(P)) {
		throw new $TypeError('Assertion failed: if O is not undefined, P must be a Property Key');
	}
	if (typeof current === 'undefined') {
		if (!extensible) {
			return false;
		}
		if (IsGenericDescriptor(Desc) || IsDataDescriptor(Desc)) {
			if (typeof O !== 'undefined') {
				DefineOwnProperty(
					IsDataDescriptor,
					SameValue,
					FromPropertyDescriptor,
					O,
					P,
					{
						'[[Configurable]]': Desc['[[Configurable]]'],
						'[[Enumerable]]': Desc['[[Enumerable]]'],
						'[[Value]]': Desc['[[Value]]'],
						'[[Writable]]': Desc['[[Writable]]']
					}
				);
			}
		} else {
			if (!IsAccessorDescriptor(Desc)) {
				throw new $TypeError('Assertion failed: Desc is not an accessor descriptor');
			}
			if (typeof O !== 'undefined') {
				return DefineOwnProperty(
					IsDataDescriptor,
					SameValue,
					FromPropertyDescriptor,
					O,
					P,
					Desc
				);
			}
		}
		return true;
	}
	if (IsGenericDescriptor(Desc) && !('[[Configurable]]' in Desc) && !('[[Enumerable]]' in Desc)) {
		return true;
	}
	if (isSamePropertyDescriptor({ SameValue: SameValue }, Desc, current)) {
		return true; // removed by ES2017, but should still be correct
	}
	// "if every field in Desc is absent, return true" can't really match the assertion that it's a Property Descriptor
	if (!current['[[Configurable]]']) {
		if (Desc['[[Configurable]]']) {
			return false;
		}
		if ('[[Enumerable]]' in Desc && !Desc['[[Enumerable]]'] === !!current['[[Enumerable]]']) {
			return false;
		}
	}
	if (IsGenericDescriptor(Desc)) {
		// no further validation is required.
	} else if (IsDataDescriptor(current) !== IsDataDescriptor(Desc)) {
		if (!current['[[Configurable]]']) {
			return false;
		}
		if (IsDataDescriptor(current)) {
			if (typeof O !== 'undefined') {
				DefineOwnProperty(
					IsDataDescriptor,
					SameValue,
					FromPropertyDescriptor,
					O,
					P,
					{
						'[[Configurable]]': current['[[Configurable]]'],
						'[[Enumerable]]': current['[[Enumerable]]'],
						'[[Get]]': undefined
					}
				);
			}
		} else if (typeof O !== 'undefined') {
			DefineOwnProperty(
				IsDataDescriptor,
				SameValue,
				FromPropertyDescriptor,
				O,
				P,
				{
					'[[Configurable]]': current['[[Configurable]]'],
					'[[Enumerable]]': current['[[Enumerable]]'],
					'[[Value]]': undefined
				}
			);
		}
	} else if (IsDataDescriptor(current) && IsDataDescriptor(Desc)) {
		if (!current['[[Configurable]]'] && !current['[[Writable]]']) {
			if ('[[Writable]]' in Desc && Desc['[[Writable]]']) {
				return false;
			}
			if ('[[Value]]' in Desc && !SameValue(Desc['[[Value]]'], current['[[Value]]'])) {
				return false;
			}
			return true;
		}
	} else if (IsAccessorDescriptor(current) && IsAccessorDescriptor(Desc)) {
		if (!current['[[Configurable]]']) {
			if ('[[Set]]' in Desc && !SameValue(Desc['[[Set]]'], current['[[Set]]'])) {
				return false;
			}
			if ('[[Get]]' in Desc && !SameValue(Desc['[[Get]]'], current['[[Get]]'])) {
				return false;
			}
			return true;
		}
	} else {
		throw new $TypeError('Assertion failed: current and Desc are not both data, both accessors, or one accessor and one data.');
	}
	if (typeof O !== 'undefined') {
		return DefineOwnProperty(
			IsDataDescriptor,
			SameValue,
			FromPropertyDescriptor,
			O,
			P,
			Desc
		);
	}
	return true;
};
'use strict';

var $TypeError = require('es-errors/type');
var isObject = require('es-object-atoms/isObject');

var IsDetachedBuffer = require('./IsDetachedBuffer');

var isTypedArray = require('is-typed-array');
var typedArrayBuffer = require('typed-array-buffer');

// https://262.ecma-international.org/6.0/#sec-validatetypedarray

module.exports = function ValidateTypedArray(O) {
	if (!isObject(O)) {
		throw new $TypeError('Assertion failed: `O` must be an Object'); // step 1
	}
	if (!isTypedArray(O)) {
		throw new $TypeError('Assertion failed: `O` must be a Typed Array'); // steps 2 - 3
	}

	var buffer = typedArrayBuffer(O); // step 4

	if (IsDetachedBuffer(buffer)) {
		throw new $TypeError('`O` must be backed by a non-detached buffer'); // step 5
	}

	return buffer; // step 6
};
'use strict';

var Day = require('./Day');
var modulo = require('./modulo');

// https://262.ecma-international.org/5.1/#sec-15.9.1.6

module.exports = function WeekDay(t) {
	return modulo(Day(t) + 4, 7);
};
'use strict';

var GetIntrinsic = require('get-intrinsic');

var $Date = GetIntrinsic('%Date%');

var callBound = require('call-bound');

var $getUTCFullYear = callBound('Date.prototype.getUTCFullYear');

// https://262.ecma-international.org/5.1/#sec-15.9.1.3

module.exports = function YearFromTime(t) {
	// largest y such that this.TimeFromYear(y) <= t
	return $getUTCFullYear(new $Date(t));
};
'use strict';

var $abs = require('math-intrinsics/abs');

// https://262.ecma-international.org/5.1/#sec-5.2

module.exports = function abs(x) {
	return $abs(x);
};
'use strict';

var ToNumber = require('./ToNumber');
var ToPrimitive = require('./ToPrimitive');

var isSameType = require('../helpers/isSameType');

var isObject = require('es-object-atoms/isObject');

// https://262.ecma-international.org/6.0/#sec-abstract-equality-comparison

module.exports = function AbstractEqualityComparison(x, y) {
	if (isSameType(x, y)) {
		return x === y; // ES6+ specified this shortcut anyways.
	}
	if (x == null && y == null) {
		return true;
	}
	if (typeof x === 'number' && typeof y === 'string') {
		return AbstractEqualityComparison(x, ToNumber(y));
	}
	if (typeof x === 'string' && typeof y === 'number') {
		return AbstractEqualityComparison(ToNumber(x), y);
	}
	if (typeof x === 'boolean') {
		return AbstractEqualityComparison(ToNumber(x), y);
	}
	if (typeof y === 'boolean') {
		return AbstractEqualityComparison(x, ToNumber(y));
	}
	if ((typeof x === 'string' || typeof x === 'number' || typeof x === 'symbol') && isObject(y)) {
		return AbstractEqualityComparison(x, ToPrimitive(y));
	}
	if (isObject(x) && (typeof y === 'string' || typeof y === 'number' || typeof y === 'symbol')) {
		return AbstractEqualityComparison(ToPrimitive(x), y);
	}
	return false;
};
'use strict';

var GetIntrinsic = require('get-intrinsic');

var $Number = GetIntrinsic('%Number%');
var $TypeError = require('es-errors/type');
var $isNaN = require('math-intrinsics/isNaN');
var $isFinite = require('math-intrinsics/isFinite');

var isPrefixOf = require('../helpers/isPrefixOf');

var ToNumber = require('./ToNumber');
var ToPrimitive = require('./ToPrimitive');

// https://262.ecma-international.org/5.1/#sec-11.8.5

// eslint-disable-next-line max-statements
module.exports = function AbstractRelationalComparison(x, y, LeftFirst) {
	if (typeof LeftFirst !== 'boolean') {
		throw new $TypeError('Assertion failed: LeftFirst argument must be a Boolean');
	}
	var px;
	var py;
	if (LeftFirst) {
		px = ToPrimitive(x, $Number);
		py = ToPrimitive(y, $Number);
	} else {
		py = ToPrimitive(y, $Number);
		px = ToPrimitive(x, $Number);
	}
	var bothStrings = typeof px === 'string' && typeof py === 'string';
	if (!bothStrings) {
		var nx = ToNumber(px);
		var ny = ToNumber(py);
		if ($isNaN(nx) || $isNaN(ny)) {
			return undefined;
		}
		if ($isFinite(nx) && $isFinite(ny) && nx === ny) {
			return false;
		}
		if (nx === Infinity) {
			return false;
		}
		if (ny === Infinity) {
			return true;
		}
		if (ny === -Infinity) {
			return false;
		}
		if (nx === -Infinity) {
			return true;
		}
		return nx < ny; // by now, these are both nonzero, finite, and not equal
	}
	if (isPrefixOf(py, px)) {
		return false;
	}
	if (isPrefixOf(px, py)) {
		return true;
	}
	return px < py; // both strings, neither a prefix of the other. shortcut for steps c-f
};
'use strict';

var isInteger = require('math-intrinsics/isInteger');
var MAX_SAFE_INTEGER = require('math-intrinsics/constants/maxSafeInteger');

var isLeadingSurrogate = require('../helpers/isLeadingSurrogate');
var isTrailingSurrogate = require('../helpers/isTrailingSurrogate');

var $TypeError = require('es-errors/type');

var $charCodeAt = require('call-bound')('String.prototype.charCodeAt');

// https://262.ecma-international.org/6.0/#sec-advancestringindex

module.exports = function AdvanceStringIndex(S, index, unicode) {
	if (typeof S !== 'string') {
		throw new $TypeError('Assertion failed: `S` must be a String');
	}
	if (!isInteger(index) || index < 0 || index > MAX_SAFE_INTEGER) {
		throw new $TypeError('Assertion failed: `length` must be an integer >= 0 and <= 2**53');
	}
	if (typeof unicode !== 'boolean') {
		throw new $TypeError('Assertion failed: `unicode` must be a Boolean');
	}
	if (!unicode) {
		return index + 1;
	}
	var length = S.length;
	if ((index + 1) >= length) {
		return index + 1;
	}

	var first = $charCodeAt(S, index);
	if (!isLeadingSurrogate(first)) {
		return index + 1;
	}

	var second = $charCodeAt(S, index + 1);
	if (!isTrailingSurrogate(second)) {
		return index + 1;
	}

	return index + 2;
};
'use strict';

var GetIntrinsic = require('get-intrinsic');

var $ArrayPrototype = GetIntrinsic('%Array.prototype%');
var $RangeError = require('es-errors/range');
var $SyntaxError = require('es-errors/syntax');
var $TypeError = require('es-errors/type');
var isInteger = require('math-intrinsics/isInteger');
var MAX_ARRAY_LENGTH = require('math-intrinsics/constants/maxArrayLength');
var $setProto = require('set-proto');

// https://262.ecma-international.org/6.0/#sec-arraycreate

module.exports = function ArrayCreate(length) {
	if (!isInteger(length) || length < 0) {
		throw new $TypeError('Assertion failed: `length` must be an integer Number >= 0');
	}
	if (length > MAX_ARRAY_LENGTH) {
		throw new $RangeError('length is greater than (2**32 - 1)');
	}
	var proto = arguments.length > 1 ? arguments[1] : $ArrayPrototype;
	var A = []; // steps 5 - 7, and 9
	if (proto !== $ArrayPrototype) { // step 8
		if (!$setProto) {
			throw new $SyntaxError('ArrayCreate: a `proto` argument that is not `Array.prototype` is not supported in an environment that does not support setting the [[Prototype]]');
		}
		$setProto(A, proto);
	}
	if (length !== 0) { // bypasses the need for step 2
		A.length = length;
	}
	/* step 10, the above as a shortcut for the below
	OrdinaryDefineOwnProperty(A, 'length', {
		'[[Configurable]]': false,
		'[[Enumerable]]': false,
		'[[Value]]': length,
		'[[Writable]]': true
	});
	*/
	return A;
};
'use strict';

var $RangeError = require('es-errors/range');
var $TypeError = require('es-errors/type');

var assign = require('object.assign');

var isPropertyDescriptor = require('../helpers/records/property-descriptor');

var IsArray = require('./IsArray');
var IsDataDescriptor = require('./IsDataDescriptor');
var OrdinaryDefineOwnProperty = require('./OrdinaryDefineOwnProperty');
var OrdinaryGetOwnProperty = require('./OrdinaryGetOwnProperty');
var ToNumber = require('./ToNumber');
var ToString = require('./ToString');
var ToUint32 = require('./ToUint32');

// https://262.ecma-international.org/6.0/#sec-arraysetlength

// eslint-disable-next-line max-statements, max-lines-per-function
module.exports = function ArraySetLength(A, Desc) {
	if (!IsArray(A)) {
		throw new $TypeError('Assertion failed: A must be an Array');
	}
	if (!isPropertyDescriptor(Desc)) {
		throw new $TypeError('Assertion failed: Desc must be a Property Descriptor');
	}
	if (!('[[Value]]' in Desc)) {
		return OrdinaryDefineOwnProperty(A, 'length', Desc);
	}
	var newLenDesc = assign({}, Desc);
	var newLen = ToUint32(Desc['[[Value]]']);
	var numberLen = ToNumber(Desc['[[Value]]']);
	if (newLen !== numberLen) {
		throw new $RangeError('Invalid array length');
	}
	newLenDesc['[[Value]]'] = newLen;
	var oldLenDesc = OrdinaryGetOwnProperty(A, 'length');
	if (!IsDataDescriptor(oldLenDesc)) {
		throw new $TypeError('Assertion failed: an array had a non-data descriptor on `length`');
	}
	var oldLen = oldLenDesc['[[Value]]'];
	if (newLen >= oldLen) {
		return OrdinaryDefineOwnProperty(A, 'length', newLenDesc);
	}
	if (!oldLenDesc['[[Writable]]']) {
		return false;
	}
	var newWritable;
	if (!('[[Writable]]' in newLenDesc) || newLenDesc['[[Writable]]']) {
		newWritable = true;
	} else {
		newWritable = false;
		newLenDesc['[[Writable]]'] = true;
	}
	var succeeded = OrdinaryDefineOwnProperty(A, 'length', newLenDesc);
	if (!succeeded) {
		return false;
	}
	while (newLen < oldLen) {
		oldLen -= 1;
		// eslint-disable-next-line no-param-reassign
		var deleteSucceeded = delete A[ToString(oldLen)];
		if (!deleteSucceeded) {
			newLenDesc['[[Value]]'] = oldLen + 1;
			if (!newWritable) {
				newLenDesc['[[Writable]]'] = false;
				OrdinaryDefineOwnProperty(A, 'length', newLenDesc);
				return false;
			}
		}
	}
	if (!newWritable) {
		return OrdinaryDefineOwnProperty(A, 'length', { '[[Writable]]': false });
	}
	return true;
};
'use strict';

var GetIntrinsic = require('get-intrinsic');

var $Array = GetIntrinsic('%Array%');
var $species = GetIntrinsic('%Symbol.species%', true);
var $TypeError = require('es-errors/type');
var isInteger = require('math-intrinsics/isInteger');
var isObject = require('es-object-atoms/isObject');

var Get = require('./Get');
var IsArray = require('./IsArray');
var IsConstructor = require('./IsConstructor');

// https://262.ecma-international.org/6.0/#sec-arrayspeciescreate

module.exports = function ArraySpeciesCreate(originalArray, length) {
	if (!isInteger(length) || length < 0) {
		throw new $TypeError('Assertion failed: length must be an integer >= 0');
	}
	var len = length === 0 ? 0 : length;
	var C;
	var isArray = IsArray(originalArray);
	if (isArray) {
		C = Get(originalArray, 'constructor');
		// TODO: figure out how to make a cross-realm normal Array, a same-realm Array
		// if (IsConstructor(C)) {
		// 	if C is another realm's Array, C = undefined
		// 	Object.getPrototypeOf(Object.getPrototypeOf(Object.getPrototypeOf(Array))) === null ?
		// }
		if ($species && isObject(C)) {
			C = Get(C, $species);
			if (C === null) {
				C = void 0;
			}
		}
	}
	if (typeof C === 'undefined') {
		return $Array(len);
	}
	if (!IsConstructor(C)) {
		throw new $TypeError('C must be a constructor');
	}
	return new C(len); // Construct(C, len);
};

'use strict';

var GetIntrinsic = require('get-intrinsic');
var callBound = require('call-bound');

var $TypeError = require('es-errors/type');

var IsArray = require('./IsArray');

var $apply = GetIntrinsic('%Reflect.apply%', true) || callBound('Function.prototype.apply');

// https://262.ecma-international.org/6.0/#sec-call

module.exports = function Call(F, V) {
	var argumentsList = arguments.length > 2 ? arguments[2] : [];
	if (!IsArray(argumentsList)) {
		throw new $TypeError('Assertion failed: optional `argumentsList`, if provided, must be a List');
	}
	return $apply(F, V, argumentsList);
};
'use strict';

var $TypeError = require('es-errors/type');

var callBound = require('call-bound');
var hasOwn = require('hasown');

var $charCodeAt = callBound('String.prototype.charCodeAt');
var $toUpperCase = callBound('String.prototype.toUpperCase');

var caseFolding = require('../helpers/caseFolding.json');

// https://262.ecma-international.org/6.0/#sec-runtime-semantics-canonicalize-ch

module.exports = function Canonicalize(ch, IgnoreCase, Unicode) {
	if (typeof ch !== 'string') {
		throw new $TypeError('Assertion failed: `ch` must be a character');
	}

	if (typeof IgnoreCase !== 'boolean' || typeof Unicode !== 'boolean') {
		throw new $TypeError('Assertion failed: `IgnoreCase` and `Unicode` must be Booleans');
	}

	if (!IgnoreCase) {
		return ch; // step 1
	}

	if (Unicode) { // step 2
		if (hasOwn(caseFolding.C, ch)) {
			return caseFolding.C[ch];
		}
		if (hasOwn(caseFolding.S, ch)) {
			return caseFolding.S[ch];
		}
		return ch; // step 2.b
	}

	var u = $toUpperCase(ch); // step 2

	if (u.length !== 1) {
		return ch; // step 3
	}

	var cu = u; // step 4

	if ($charCodeAt(ch, 0) >= 128 && $charCodeAt(cu, 0) < 128) {
		return ch; // step 5
	}

	return cu;
};
'use strict';

var $TypeError = require('es-errors/type');

var SameValue = require('./SameValue');
var ToNumber = require('./ToNumber');
var ToString = require('./ToString');

// https://262.ecma-international.org/6.0/#sec-canonicalnumericindexstring

module.exports = function CanonicalNumericIndexString(argument) {
	if (typeof argument !== 'string') {
		throw new $TypeError('Assertion failed: `argument` must be a String');
	}
	if (argument === '-0') { return -0; }
	var n = ToNumber(argument);
	if (SameValue(ToString(n), argument)) { return n; }
	return void 0;
};
'use strict';

var GetIntrinsic = require('get-intrinsic');
var callBound = require('call-bound');

var $fromCharCode = GetIntrinsic('%String.fromCharCode%');
var $TypeError = require('es-errors/type');
var $charCodeAt = callBound('String.prototype.charCodeAt');

var CharSet = require('../helpers/CharSet').CharSet;

module.exports = function CharacterRange(A, B) {
	var a;
	var b;

	if (A instanceof CharSet || B instanceof CharSet) {
		if (!(A instanceof CharSet) || !(B instanceof CharSet)) {
			throw new $TypeError('Assertion failed: CharSets A and B are not both CharSets');
		}

		A.yield(function (c) {
			if (typeof a !== 'undefined') {
				throw new $TypeError('Assertion failed: CharSet A has more than one character');
			}
			a = c;
		});
		B.yield(function (c) {
			if (typeof b !== 'undefined') {
				throw new $TypeError('Assertion failed: CharSet B has more than one character');
			}
			b = c;
		});
	} else {
		if (A.length !== 1 || B.length !== 1) {
			throw new $TypeError('Assertion failed: CharSets A and B contain exactly one character');
		}
		a = A[0];
		b = B[0];
	}

	var i = $charCodeAt(a, 0);
	var j = $charCodeAt(b, 0);

	if (!(i <= j)) {
		throw new $TypeError('Assertion failed: i is not <= j');
	}

	var arr = [];
	for (var k = i; k <= j; k += 1) {
		arr[arr.length] = $fromCharCode(k);
	}
	return arr;
};
'use strict';

var $TypeError = require('es-errors/type');

var hasOwn = require('hasown');

var IsDataDescriptor = require('./IsDataDescriptor');
var IsGenericDescriptor = require('./IsGenericDescriptor');

var isPropertyDescriptor = require('../helpers/records/property-descriptor');

// https://262.ecma-international.org/6.0/#sec-completepropertydescriptor

module.exports = function CompletePropertyDescriptor(Desc) {
	if (!isPropertyDescriptor(Desc)) {
		throw new $TypeError('Assertion failed: `Desc` must be a Property Descriptor');
	}

	/* eslint no-param-reassign: 0 */

	if (IsGenericDescriptor(Desc) || IsDataDescriptor(Desc)) {
		if (!hasOwn(Desc, '[[Value]]')) {
			Desc['[[Value]]'] = void 0;
		}
		if (!hasOwn(Desc, '[[Writable]]')) {
			Desc['[[Writable]]'] = false;
		}
	} else {
		if (!hasOwn(Desc, '[[Get]]')) {
			Desc['[[Get]]'] = void 0;
		}
		if (!hasOwn(Desc, '[[Set]]')) {
			Desc['[[Set]]'] = void 0;
		}
	}
	if (!hasOwn(Desc, '[[Enumerable]]')) {
		Desc['[[Enumerable]]'] = false;
	}
	if (!hasOwn(Desc, '[[Configurable]]')) {
		Desc['[[Configurable]]'] = false;
	}
	return Desc;
};
'use strict';

var $SyntaxError = require('es-errors/syntax');

var SLOT = require('internal-slot');

// https://262.ecma-international.org/7.0/#sec-completion-record-specification-type

var CompletionRecord = function CompletionRecord(type, value) {
	if (!(this instanceof CompletionRecord)) {
		return new CompletionRecord(type, value);
	}
	if (type !== 'normal' && type !== 'break' && type !== 'continue' && type !== 'return' && type !== 'throw') {
		throw new $SyntaxError('Assertion failed: `type` must be one of "normal", "break", "continue", "return", or "throw"');
	}
	SLOT.set(this, '[[Type]]', type);
	SLOT.set(this, '[[Value]]', value);
	// [[Target]] slot?
};

CompletionRecord.prototype.type = function Type() {
	return SLOT.get(this, '[[Type]]');
};

CompletionRecord.prototype.value = function Value() {
	return SLOT.get(this, '[[Value]]');
};

CompletionRecord.prototype['?'] = function ReturnIfAbrupt() {
	var type = SLOT.get(this, '[[Type]]');
	var value = SLOT.get(this, '[[Value]]');

	if (type === 'throw') {
		throw value;
	}
	return value;
};

CompletionRecord.prototype['!'] = function assert() {
	var type = SLOT.get(this, '[[Type]]');

	if (type !== 'normal') {
		throw new $SyntaxError('Assertion failed: Completion Record is not of type "normal"');
	}
	return SLOT.get(this, '[[Value]]');
};

module.exports = CompletionRecord;
'use strict';

var $TypeError = require('es-errors/type');
var isObject = require('es-object-atoms/isObject');

var isPropertyKey = require('../helpers/isPropertyKey');
var OrdinaryDefineOwnProperty = require('./OrdinaryDefineOwnProperty');

// https://262.ecma-international.org/6.0/#sec-createdataproperty

module.exports = function CreateDataProperty(O, P, V) {
	if (!isObject(O)) {
		throw new $TypeError('Assertion failed: Type(O) is not Object');
	}
	if (!isPropertyKey(P)) {
		throw new $TypeError('Assertion failed: P is not a Property Key');
	}
	var newDesc = {
		'[[Configurable]]': true,
		'[[Enumerable]]': true,
		'[[Value]]': V,
		'[[Writable]]': true
	};
	return OrdinaryDefineOwnProperty(O, P, newDesc);
};
'use strict';

var $TypeError = require('es-errors/type');
var isObject = require('es-object-atoms/isObject');

var CreateDataProperty = require('./CreateDataProperty');

var isPropertyKey = require('../helpers/isPropertyKey');

// // https://262.ecma-international.org/6.0/#sec-createdatapropertyorthrow

module.exports = function CreateDataPropertyOrThrow(O, P, V) {
	if (!isObject(O)) {
		throw new $TypeError('Assertion failed: Type(O) is not Object');
	}
	if (!isPropertyKey(P)) {
		throw new $TypeError('Assertion failed: P is not a Property Key');
	}
	var success = CreateDataProperty(O, P, V);
	if (!success) {
		throw new $TypeError('unable to create data property');
	}
	return success;
};
'use strict';

var $TypeError = require('es-errors/type');

var callBound = require('call-bound');

var $replace = callBound('String.prototype.replace');

var RequireObjectCoercible = require('./RequireObjectCoercible');
var ToString = require('./ToString');

// https://262.ecma-international.org/6.0/#sec-createhtml

module.exports = function CreateHTML(string, tag, attribute, value) {
	if (typeof tag !== 'string' || typeof attribute !== 'string') {
		throw new $TypeError('Assertion failed: `tag` and `attribute` must be strings');
	}
	var str = RequireObjectCoercible(string);
	var S = ToString(str);
	var p1 = '<' + tag;
	if (attribute !== '') {
		var V = ToString(value);
		var escapedV = $replace(V, /\x22/g, '&quot;');
		p1 += '\x20' + attribute + '\x3D\x22' + escapedV + '\x22';
	}
	return p1 + '>' + S + '</' + tag + '>';
};
'use strict';

var $TypeError = require('es-errors/type');

// https://262.ecma-international.org/6.0/#sec-createiterresultobject

module.exports = function CreateIterResultObject(value, done) {
	if (typeof done !== 'boolean') {
		throw new $TypeError('Assertion failed: Type(done) is not Boolean');
	}
	return {
		value: value,
		done: done
	};
};
'use strict';

var callBound = require('call-bound');

var $TypeError = require('es-errors/type');
var isObject = require('es-object-atoms/isObject');
var $indexOf = callBound('Array.prototype.indexOf', true) || callBound('String.prototype.indexOf');

var Get = require('./Get');
var IsArray = require('./IsArray');
var ToLength = require('./ToLength');
var ToString = require('./ToString');
var Type = require('./Type');

var defaultElementTypes = ['Undefined', 'Null', 'Boolean', 'String', 'Symbol', 'Number', 'Object'];

// https://262.ecma-international.org/6.0/#sec-createlistfromarraylike
module.exports = function CreateListFromArrayLike(obj) {
	var elementTypes = arguments.length > 1
		? arguments[1]
		: defaultElementTypes;

	if (!isObject(obj)) {
		throw new $TypeError('Assertion failed: `obj` must be an Object');
	}
	if (!IsArray(elementTypes)) {
		throw new $TypeError('Assertion failed: `elementTypes`, if provided, must be an array');
	}
	var len = ToLength(Get(obj, 'length'));
	var list = [];
	var index = 0;
	while (index < len) {
		var indexName = ToString(index);
		var next = Get(obj, indexName);
		var nextType = Type(next);
		if ($indexOf(elementTypes, nextType) < 0) {
			throw new $TypeError('item type ' + nextType + ' is not a valid elementType');
		}
		list[list.length] = next;
		index += 1;
	}
	return list;
};
'use strict';

var $TypeError = require('es-errors/type');
var isObject = require('es-object-atoms/isObject');

var DefineOwnProperty = require('../helpers/DefineOwnProperty');

var FromPropertyDescriptor = require('./FromPropertyDescriptor');
var IsDataDescriptor = require('./IsDataDescriptor');
var isPropertyKey = require('../helpers/isPropertyKey');
var SameValue = require('./SameValue');

// https://262.ecma-international.org/6.0/#sec-createmethodproperty

module.exports = function CreateMethodProperty(O, P, V) {
	if (!isObject(O)) {
		throw new $TypeError('Assertion failed: Type(O) is not Object');
	}

	if (!isPropertyKey(P)) {
		throw new $TypeError('Assertion failed: P is not a Property Key');
	}

	var newDesc = {
		'[[Configurable]]': true,
		'[[Enumerable]]': false,
		'[[Value]]': V,
		'[[Writable]]': true
	};
	return DefineOwnProperty(
		IsDataDescriptor,
		SameValue,
		FromPropertyDescriptor,
		O,
		P,
		newDesc
	);
};
'use strict';

var $EvalError = require('es-errors/eval');

var DayWithinYear = require('./DayWithinYear');
var InLeapYear = require('./InLeapYear');
var MonthFromTime = require('./MonthFromTime');

// https://262.ecma-international.org/5.1/#sec-15.9.1.5

module.exports = function DateFromTime(t) {
	var m = MonthFromTime(t);
	var d = DayWithinYear(t);
	if (m === 0) {
		return d + 1;
	}
	if (m === 1) {
		return d - 30;
	}
	var leap = InLeapYear(t);
	if (m === 2) {
		return d - 58 - leap;
	}
	if (m === 3) {
		return d - 89 - leap;
	}
	if (m === 4) {
		return d - 119 - leap;
	}
	if (m === 5) {
		return d - 150 - leap;
	}
	if (m === 6) {
		return d - 180 - leap;
	}
	if (m === 7) {
		return d - 211 - leap;
	}
	if (m === 8) {
		return d - 242 - leap;
	}
	if (m === 9) {
		return d - 272 - leap;
	}
	if (m === 10) {
		return d - 303 - leap;
	}
	if (m === 11) {
		return d - 333 - leap;
	}
	throw new $EvalError('Assertion failed: MonthFromTime returned an impossible value: ' + m);
};
'use strict';

var floor = require('./floor');

// https://262.ecma-international.org/5.1/#sec-15.9.1.3

module.exports = function DayFromYear(y) {
	return (365 * (y - 1970)) + floor((y - 1969) / 4) - floor((y - 1901) / 100) + floor((y - 1601) / 400);
};

'use strict';

var floor = require('./floor');

var msPerDay = require('../helpers/timeConstants').msPerDay;

// https://262.ecma-international.org/5.1/#sec-15.9.1.2

module.exports = function Day(t) {
	return floor(t / msPerDay);
};
'use strict';

var modulo = require('./modulo');

// https://262.ecma-international.org/5.1/#sec-15.9.1.3

module.exports = function DaysInYear(y) {
	if (modulo(y, 4) !== 0) {
		return 365;
	}
	if (modulo(y, 100) !== 0) {
		return 366;
	}
	if (modulo(y, 400) !== 0) {
		return 365;
	}
	return 366;
};
'use strict';

var Day = require('./Day');
var DayFromYear = require('./DayFromYear');
var YearFromTime = require('./YearFromTime');

// https://262.ecma-international.org/5.1/#sec-15.9.1.4

module.exports = function DayWithinYear(t) {
	return Day(t) - DayFromYear(YearFromTime(t));
};
'use strict';

var $TypeError = require('es-errors/type');
var isObject = require('es-object-atoms/isObject');

var isPropertyDescriptor = require('../helpers/records/property-descriptor');
var DefineOwnProperty = require('../helpers/DefineOwnProperty');

var FromPropertyDescriptor = require('./FromPropertyDescriptor');
var IsDataDescriptor = require('./IsDataDescriptor');
var isPropertyKey = require('../helpers/isPropertyKey');
var SameValue = require('./SameValue');
var ToPropertyDescriptor = require('./ToPropertyDescriptor');

// https://262.ecma-international.org/6.0/#sec-definepropertyorthrow

module.exports = function DefinePropertyOrThrow(O, P, desc) {
	if (!isObject(O)) {
		throw new $TypeError('Assertion failed: Type(O) is not Object');
	}

	if (!isPropertyKey(P)) {
		throw new $TypeError('Assertion failed: P is not a Property Key');
	}

	var Desc = isPropertyDescriptor(desc) ? desc : ToPropertyDescriptor(desc);
	if (!isPropertyDescriptor(Desc)) {
		throw new $TypeError('Assertion failed: Desc is not a valid Property Descriptor');
	}

	return DefineOwnProperty(
		IsDataDescriptor,
		SameValue,
		FromPropertyDescriptor,
		O,
		P,
		Desc
	);
};
'use strict';

var $TypeError = require('es-errors/type');
var isObject = require('es-object-atoms/isObject');

var isPropertyKey = require('../helpers/isPropertyKey');

// https://262.ecma-international.org/6.0/#sec-deletepropertyorthrow

module.exports = function DeletePropertyOrThrow(O, P) {
	if (!isObject(O)) {
		throw new $TypeError('Assertion failed: Type(O) is not Object');
	}

	if (!isPropertyKey(P)) {
		throw new $TypeError('Assertion failed: P is not a Property Key');
	}

	// eslint-disable-next-line no-param-reassign
	var success = delete O[P];
	if (!success) {
		throw new $TypeError('Attempt to delete property failed.');
	}
	return success;
};
'use strict';

var $SyntaxError = require('es-errors/syntax');
var $TypeError = require('es-errors/type');

var isArrayBuffer = require('is-array-buffer');

var IsDetachedBuffer = require('./IsDetachedBuffer');

var MessageChannel;
try {
	// eslint-disable-next-line global-require
	MessageChannel = require('worker_threads').MessageChannel; // node 11.7+
} catch (e) { /**/ }

// https://262.ecma-international.org/6.0/#sec-detacharraybuffer

/* globals postMessage */

module.exports = function DetachArrayBuffer(arrayBuffer) {
	if (!isArrayBuffer(arrayBuffer)) {
		throw new $TypeError('Assertion failed: `arrayBuffer` must be an Object with an [[ArrayBufferData]] internal slot');
	}

	if (!IsDetachedBuffer(arrayBuffer)) { // node v21.0.0+ throws when you structuredClone a detached buffer
		if (typeof structuredClone === 'function') {
			structuredClone(arrayBuffer, { transfer: [arrayBuffer] });
		} else if (typeof postMessage === 'function') {
			postMessage('', '/', [arrayBuffer]); // TODO: see if this might trigger listeners
		} else if (MessageChannel) {
			(new MessageChannel()).port1.postMessage(null, [arrayBuffer]);
		} else {
			throw new $SyntaxError('DetachArrayBuffer is not supported in this environment');
		}
	}

	return null;
};
'use strict';

var $TypeError = require('es-errors/type');
var isObject = require('es-object-atoms/isObject');

var keys = require('object-keys');

// https://262.ecma-international.org/6.0/#sec-enumerableownnames

module.exports = function EnumerableOwnNames(O) {
	if (!isObject(O)) {
		throw new $TypeError('Assertion failed: Type(O) is not Object');
	}

	return keys(O);
};
'use strict';

// var modulo = require('./modulo');
var $floor = require('math-intrinsics/floor');

// http://262.ecma-international.org/5.1/#sec-5.2

module.exports = function floor(x) {
	// return x - modulo(x, 1);
	return $floor(x);
};
'use strict';

var $TypeError = require('es-errors/type');

var isPropertyDescriptor = require('../helpers/records/property-descriptor');
var fromPropertyDescriptor = require('../helpers/fromPropertyDescriptor');

// https://262.ecma-international.org/6.0/#sec-frompropertydescriptor

module.exports = function FromPropertyDescriptor(Desc) {
	if (typeof Desc !== 'undefined' && !isPropertyDescriptor(Desc)) {
		throw new $TypeError('Assertion failed: `Desc` must be a Property Descriptor');
	}

	return fromPropertyDescriptor(Desc);
};
'use strict';

var getGlobal = require('globalthis/polyfill');

// https://262.ecma-international.org/6.0/#sec-getglobalobject

module.exports = function GetGlobalObject() {
	return getGlobal();
};
'use strict';

var $TypeError = require('es-errors/type');

var getIteratorMethod = require('../helpers/getIteratorMethod');
var AdvanceStringIndex = require('./AdvanceStringIndex');
var Call = require('./Call');
var GetMethod = require('./GetMethod');

var isObject = require('es-object-atoms/isObject');

var ES = {
	AdvanceStringIndex: AdvanceStringIndex,
	GetMethod: GetMethod
};

// https://262.ecma-international.org/6.0/#sec-getiterator

module.exports = function GetIterator(obj, method) {
	var actualMethod = method;
	if (arguments.length < 2) {
		actualMethod = getIteratorMethod(ES, obj);
	}
	var iterator = Call(actualMethod, obj);
	if (!isObject(iterator)) {
		throw new $TypeError('iterator must return an object');
	}

	return iterator;
};
'use strict';

var $TypeError = require('es-errors/type');

var inspect = require('object-inspect');

var isPropertyKey = require('../helpers/isPropertyKey');

var isObject = require('es-object-atoms/isObject');

// https://262.ecma-international.org/6.0/#sec-get-o-p

module.exports = function Get(O, P) {
	// 7.3.1.1
	if (!isObject(O)) {
		throw new $TypeError('Assertion failed: Type(O) is not Object');
	}
	// 7.3.1.2
	if (!isPropertyKey(P)) {
		throw new $TypeError('Assertion failed: P is not a Property Key, got ' + inspect(P));
	}
	// 7.3.1.3
	return O[P];
};
'use strict';

var $TypeError = require('es-errors/type');

var GetV = require('./GetV');
var IsCallable = require('./IsCallable');
var isPropertyKey = require('../helpers/isPropertyKey');

var inspect = require('object-inspect');

// https://262.ecma-international.org/6.0/#sec-getmethod

module.exports = function GetMethod(O, P) {
	// 7.3.9.1
	if (!isPropertyKey(P)) {
		throw new $TypeError('Assertion failed: P is not a Property Key');
	}

	// 7.3.9.2
	var func = GetV(O, P);

	// 7.3.9.4
	if (func == null) {
		return void 0;
	}

	// 7.3.9.5
	if (!IsCallable(func)) {
		throw new $TypeError(inspect(P) + ' is not a function: ' + inspect(func));
	}

	// 7.3.9.6
	return func;
};
'use strict';

var GetIntrinsic = require('get-intrinsic');

var hasSymbols = require('has-symbols')();

var $TypeError = require('es-errors/type');
var isObject = require('es-object-atoms/isObject');

var $gOPN = GetIntrinsic('%Object.getOwnPropertyNames%', true);
var $gOPS = hasSymbols && GetIntrinsic('%Object.getOwnPropertySymbols%', true);
var keys = require('object-keys');

// https://262.ecma-international.org/6.0/#sec-getownpropertykeys

module.exports = function GetOwnPropertyKeys(O, Type) {
	if (!isObject(O)) {
		throw new $TypeError('Assertion failed: Type(O) is not Object');
	}
	if (Type === 'Symbol') {
		return $gOPS ? $gOPS(O) : [];
	}
	if (Type === 'String') {
		if (!$gOPN) {
			return keys(O);
		}
		return $gOPN(O);
	}
	throw new $TypeError('Assertion failed: `Type` must be `"String"` or `"Symbol"`');
};
'use strict';

var GetIntrinsic = require('get-intrinsic');

var $Function = GetIntrinsic('%Function%');
var $TypeError = require('es-errors/type');
var $SyntaxError = require('es-errors/syntax');

var Get = require('./Get');
var IsConstructor = require('./IsConstructor');

var isObject = require('es-object-atoms/isObject');

// https://262.ecma-international.org/6.0/#sec-getprototypefromconstructor

module.exports = function GetPrototypeFromConstructor(constructor, intrinsicDefaultProto) {
	var intrinsic = GetIntrinsic(intrinsicDefaultProto); // throws if not a valid intrinsic
	if (!isObject(intrinsic)) {
		throw new $TypeError('intrinsicDefaultProto must be an object');
	}
	if (!IsConstructor(constructor)) {
		throw new $TypeError('Assertion failed: `constructor` must be a constructor');
	}
	var proto = Get(constructor, 'prototype');
	if (!isObject(proto)) {
		if (!(constructor instanceof $Function)) {
			// ignore other realms, for now
			throw new $SyntaxError('cross-realm constructors not currently supported');
		}
		proto = intrinsic;
	}
	return proto;
};

'use strict';

var GetIntrinsic = require('get-intrinsic');

var $TypeError = require('es-errors/type');
var $parseInt = GetIntrinsic('%parseInt%');

var inspect = require('object-inspect');
var isInteger = require('math-intrinsics/isInteger');
var regexTester = require('safe-regex-test');
var callBound = require('call-bound');
var every = require('../helpers/every');

var isDigit = regexTester(/^[0-9]$/);

var $charAt = callBound('String.prototype.charAt');
var $strSlice = callBound('String.prototype.slice');

var IsArray = require('./IsArray');

var isStringOrUndefined = require('../helpers/isStringOrUndefined');

// https://262.ecma-international.org/6.0/#sec-getsubstitution

// eslint-disable-next-line max-statements, max-lines-per-function
module.exports = function GetSubstitution(matched, str, position, captures, replacement) {
	if (typeof matched !== 'string') {
		throw new $TypeError('Assertion failed: `matched` must be a String');
	}
	var matchLength = matched.length;

	if (typeof str !== 'string') {
		throw new $TypeError('Assertion failed: `str` must be a String');
	}
	var stringLength = str.length;

	if (!isInteger(position) || position < 0 || position > stringLength) {
		throw new $TypeError('Assertion failed: `position` must be a nonnegative integer, and less than or equal to the length of `string`, got ' + inspect(position));
	}

	if (!IsArray(captures) || !every(captures, isStringOrUndefined)) {
		throw new $TypeError('Assertion failed: `captures` must be a List of Strings, got ' + inspect(captures));
	}

	if (typeof replacement !== 'string') {
		throw new $TypeError('Assertion failed: `replacement` must be a String');
	}

	var tailPos = position + matchLength;
	var m = captures.length;

	var result = '';
	for (var i = 0; i < replacement.length; i += 1) {
		// if this is a $, and it's not the end of the replacement
		var current = $charAt(replacement, i);
		var isLast = (i + 1) >= replacement.length;
		var nextIsLast = (i + 2) >= replacement.length;
		if (current === '$' && !isLast) {
			var next = $charAt(replacement, i + 1);
			if (next === '$') {
				result += '$';
				i += 1;
			} else if (next === '&') {
				result += matched;
				i += 1;
			} else if (next === '`') {
				result += position === 0 ? '' : $strSlice(str, 0, position - 1);
				i += 1;
			} else if (next === "'") {
				result += tailPos >= stringLength ? '' : $strSlice(str, tailPos);
				i += 1;
			} else {
				var nextNext = nextIsLast ? null : $charAt(replacement, i + 2);
				if (isDigit(next) && next !== '0' && (nextIsLast || !isDigit(nextNext))) {
					// $1 through $9, and not followed by a digit
					var n = $parseInt(next, 10);
					// if (n > m, impl-defined)
					result += n <= m && typeof captures[n - 1] === 'undefined' ? '' : captures[n - 1];
					i += 1;
				} else if (isDigit(next) && (nextIsLast || isDigit(nextNext))) {
					// $00 through $99
					var nn = next + nextNext;
					var nnI = $parseInt(nn, 10) - 1;
					// if nn === '00' or nn > m, impl-defined
					result += nn <= m && typeof captures[nnI] === 'undefined' ? '' : captures[nnI];
					i += 2;
				} else {
					result += '$';
				}
			}
		} else {
			// the final $, or else not a $
			result += $charAt(replacement, i);
		}
	}
	return result;
};
'use strict';

var GetIntrinsic = require('get-intrinsic');

var $TypeError = require('es-errors/type');
var $Uint8Array = GetIntrinsic('%Uint8Array%', true);

var isInteger = require('math-intrinsics/isInteger');
var callBound = require('call-bound');

var $charAt = callBound('String.prototype.charAt');
var $reverse = callBound('Array.prototype.reverse');
var $slice = callBound('Array.prototype.slice');

var bytesAsFloat32 = require('../helpers/bytesAsFloat32');
var bytesAsFloat64 = require('../helpers/bytesAsFloat64');
var bytesAsInteger = require('../helpers/bytesAsInteger');
var defaultEndianness = require('../helpers/defaultEndianness');

var IsDetachedBuffer = require('./IsDetachedBuffer');

var isArrayBuffer = require('is-array-buffer');
var safeConcat = require('safe-array-concat');

var tableTAO = require('./tables/typed-array-objects');

var isUnsignedElementType = function isUnsignedElementType(type) { return $charAt(type, 0) === 'U'; };

// https://262.ecma-international.org/6.0/#sec-getvaluefrombuffer

module.exports = function GetValueFromBuffer(arrayBuffer, byteIndex, type) {
	if (!isArrayBuffer(arrayBuffer)) {
		throw new $TypeError('Assertion failed: `arrayBuffer` must be an ArrayBuffer');
	}

	if (!isInteger(byteIndex)) {
		throw new $TypeError('Assertion failed: `byteIndex` must be an integer');
	}

	if (typeof type !== 'string') {
		throw new $TypeError('Assertion failed: `type` must be a string');
	}

	if (arguments.length > 3 && typeof arguments[3] !== 'boolean') {
		throw new $TypeError('Assertion failed: `isLittleEndian` must be a boolean, if present');
	}

	if (IsDetachedBuffer(arrayBuffer)) {
		throw new $TypeError('Assertion failed: ArrayBuffer is detached'); // step 1
	}

	// 2. Assert: There are sufficient bytes in arrayBuffer starting at byteIndex to represent a value of type.

	if (byteIndex < 0) {
		throw new $TypeError('Assertion failed: `byteIndex` must be non-negative'); // step 3
	}

	// 4. Let block be arrayBuffer’s [[ArrayBufferData]] internal slot.

	var elementSize = tableTAO.size['$' + type]; // step 5
	if (!elementSize) {
		throw new $TypeError('Assertion failed: `type` must be one of ' + tableTAO.choices);
	}

	// 6. Let rawValue be a List of elementSize containing, in order, the elementSize sequence of bytes starting with block[byteIndex].
	var rawValue = $slice(new $Uint8Array(arrayBuffer, byteIndex), 0, elementSize); // step 6

	// 8. If isLittleEndian is not present, set isLittleEndian to either true or false. The choice is implementation dependent and should be the alternative that is most efficient for the implementation. An implementation must use the same value each time this step is executed and the same value must be used for the corresponding step in the SetValueInBuffer abstract operation.
	var isLittleEndian = arguments.length > 3 ? arguments[3] : defaultEndianness === 'little'; // step 7

	if (!isLittleEndian) {
		$reverse(rawValue); // step 8
	}

	var bytes = $slice(safeConcat([0, 0, 0, 0, 0, 0, 0, 0], rawValue), -elementSize);

	if (type === 'Float32') { // step 3
		return bytesAsFloat32(bytes);
	}

	if (type === 'Float64') { // step 4
		return bytesAsFloat64(bytes);
	}

	return bytesAsInteger(bytes, elementSize, isUnsignedElementType(type), false);
};
'use strict';

var $TypeError = require('es-errors/type');

var inspect = require('object-inspect');

var isPropertyKey = require('../helpers/isPropertyKey');
// var ToObject = require('./ToObject');

// https://262.ecma-international.org/6.0/#sec-getv

module.exports = function GetV(V, P) {
	// 7.3.2.1
	if (!isPropertyKey(P)) {
		throw new $TypeError('Assertion failed: P is not a Property Key, got ' + inspect(P));
	}

	// 7.3.2.2-3
	// var O = ToObject(V);

	// 7.3.2.4
	return V[P];
};
'use strict';

var $TypeError = require('es-errors/type');

var hasOwn = require('hasown');
var isObject = require('es-object-atoms/isObject');

var isPropertyKey = require('../helpers/isPropertyKey');

// https://262.ecma-international.org/6.0/#sec-hasownproperty

module.exports = function HasOwnProperty(O, P) {
	if (!isObject(O)) {
		throw new $TypeError('Assertion failed: `O` must be an Object');
	}
	if (!isPropertyKey(P)) {
		throw new $TypeError('Assertion failed: `P` must be a Property Key');
	}
	return hasOwn(O, P);
};
'use strict';

var $TypeError = require('es-errors/type');
var isObject = require('es-object-atoms/isObject');

var isPropertyKey = require('../helpers/isPropertyKey');

// https://262.ecma-international.org/6.0/#sec-hasproperty

module.exports = function HasProperty(O, P) {
	if (!isObject(O)) {
		throw new $TypeError('Assertion failed: `O` must be an Object');
	}
	if (!isPropertyKey(P)) {
		throw new $TypeError('Assertion failed: `P` must be a Property Key');
	}
	return P in O;
};
'use strict';

var floor = require('./floor');
var modulo = require('./modulo');

var timeConstants = require('../helpers/timeConstants');
var msPerHour = timeConstants.msPerHour;
var HoursPerDay = timeConstants.HoursPerDay;

// https://262.ecma-international.org/5.1/#sec-15.9.1.10

module.exports = function HourFromTime(t) {
	return modulo(floor(t / msPerHour), HoursPerDay);
};
'use strict';

var $EvalError = require('es-errors/eval');

var DaysInYear = require('./DaysInYear');
var YearFromTime = require('./YearFromTime');

// https://262.ecma-international.org/5.1/#sec-15.9.1.3

module.exports = function InLeapYear(t) {
	var days = DaysInYear(YearFromTime(t));
	if (days === 365) {
		return 0;
	}
	if (days === 366) {
		return 1;
	}
	throw new $EvalError('Assertion failed: there are not 365 or 366 days in a year, got: ' + days);
};
'use strict';

var GetIntrinsic = require('get-intrinsic');

var $TypeError = require('es-errors/type');
var isObject = require('es-object-atoms/isObject');

var $hasInstance = GetIntrinsic('%Symbol.hasInstance%', true);

var Call = require('./Call');
var GetMethod = require('./GetMethod');
var IsCallable = require('./IsCallable');
var OrdinaryHasInstance = require('./OrdinaryHasInstance');
var ToBoolean = require('./ToBoolean');

// https://262.ecma-international.org/6.0/#sec-instanceofoperator

module.exports = function InstanceofOperator(O, C) {
	if (!isObject(O)) {
		throw new $TypeError('Assertion failed: Type(O) is not Object');
	}
	var instOfHandler = $hasInstance ? GetMethod(C, $hasInstance) : void 0;
	if (typeof instOfHandler !== 'undefined') {
		return ToBoolean(Call(instOfHandler, C, [O]));
	}
	if (!IsCallable(C)) {
		throw new $TypeError('`C` is not Callable');
	}
	return OrdinaryHasInstance(C, O);
};
'use strict';

var $SyntaxError = require('es-errors/syntax');
var $TypeError = require('es-errors/type');
var isNegativeZero = require('math-intrinsics/isNegativeZero');

var GetValueFromBuffer = require('./GetValueFromBuffer');
var IsDetachedBuffer = require('./IsDetachedBuffer');
var IsInteger = require('./IsInteger');

var typedArrayLength = require('typed-array-length');
var typedArrayBuffer = require('typed-array-buffer');
var typedArrayByteOffset = require('typed-array-byte-offset');
var whichTypedArray = require('which-typed-array');

var tableTAO = require('./tables/typed-array-objects');

// https://262.ecma-international.org/6.0/#sec-integerindexedelementget

module.exports = function IntegerIndexedElementGet(O, index) {
	if (typeof index !== 'number') {
		throw new $TypeError('`index` must be a Number'); // step 1
	}
	var arrayTypeName = whichTypedArray(O); // step 10
	if (!arrayTypeName) {
		throw new $TypeError('`O` must be a TypedArray'); // step 2
	}
	if (arrayTypeName === 'BigInt64Array' || arrayTypeName === 'BigUint64Array') {
		throw new $SyntaxError('BigInt64Array and BigUint64Array do not exist until ES2020');
	}

	var buffer = typedArrayBuffer(O); // step 3

	if (IsDetachedBuffer(buffer)) {
		throw new $TypeError('`O` has a detached buffer'); // step 4
	}

	if (!IsInteger(index) || isNegativeZero(index)) {
		return void undefined; // steps 5 - 6
	}

	var length = typedArrayLength(O); // step 7

	if (index < 0 || index >= length) {
		return void undefined; // step 8
	}

	var offset = typedArrayByteOffset(O); // step 9

	var elementType = tableTAO.name['$' + arrayTypeName]; // step 13

	var elementSize = tableTAO.size['$' + elementType]; // step 11

	var indexedPosition = (index * elementSize) + offset; // step 12

	return GetValueFromBuffer(buffer, indexedPosition, elementType); // step 14
};
'use strict';

var $SyntaxError = require('es-errors/syntax');
var $TypeError = require('es-errors/type');

var IsDetachedBuffer = require('./IsDetachedBuffer');
var IsInteger = require('./IsInteger');
var SetValueInBuffer = require('./SetValueInBuffer');
var ToNumber = require('./ToNumber');

var isNegativeZero = require('math-intrinsics/isNegativeZero');
var typedArrayBuffer = require('typed-array-buffer');
var typedArrayByteOffset = require('typed-array-byte-offset');
var typedArrayLength = require('typed-array-length');
var whichTypedArray = require('which-typed-array');

var tableTAO = require('./tables/typed-array-objects');

// https://262.ecma-international.org/6.0/#sec-integerindexedelementset

module.exports = function IntegerIndexedElementSet(O, index, value) {
	if (typeof index !== 'number') {
		throw new $TypeError('`index` must be a Number'); // step 1
	}
	var arrayTypeName = whichTypedArray(O); // step 12
	if (!arrayTypeName) {
		throw new $TypeError('`O` must be a TypedArray'); // step 2
	}
	if (arrayTypeName === 'BigInt64Array' || arrayTypeName === 'BigUint64Array') {
		throw new $SyntaxError('BigInt64Array and BigUint64Array do not exist until ES2020'); // step 2
	}

	var numValue = ToNumber(value); // step 3

	var buffer = typedArrayBuffer(O); // step 5

	if (IsDetachedBuffer(buffer)) {
		throw new $TypeError('`O` has a detached buffer'); // step 6
	}

	if (!IsInteger(index) || isNegativeZero(index)) {
		return false; // steps 7 - 8
	}

	var length = typedArrayLength(O); // step 9

	if (index < 0 || index >= length) {
		return false; // step 10
	}

	var offset = typedArrayByteOffset(O); // step 11

	var elementType = tableTAO.name['$' + arrayTypeName]; // step 15

	var elementSize = tableTAO.size['$' + elementType]; // step 13

	var indexedPosition = (index * elementSize) + offset; // step 14

	SetValueInBuffer(buffer, indexedPosition, elementType, numValue); // step 16

	return true; // step 17
};
'use strict';

var $TypeError = require('es-errors/type');
var isObject = require('es-object-atoms/isObject');

var Call = require('./Call');
var CreateDataProperty = require('./CreateDataProperty');
var EnumerableOwnNames = require('./EnumerableOwnNames');
var Get = require('./Get');
var IsArray = require('./IsArray');
var ToLength = require('./ToLength');
var ToString = require('./ToString');

var forEach = require('../helpers/forEach');

// https://262.ecma-international.org/6.0/#sec-internalizejsonproperty

// note: `reviver` was implicitly closed-over until ES2020, where it becomes a third argument

module.exports = function InternalizeJSONProperty(holder, name, reviver) {
	if (!isObject(holder)) {
		throw new $TypeError('Assertion failed: `holder` is not an Object');
	}
	if (typeof name !== 'string') {
		throw new $TypeError('Assertion failed: `name` is not a String');
	}
	if (typeof reviver !== 'function') {
		throw new $TypeError('Assertion failed: `reviver` is not a Function');
	}

	var val = Get(holder, name); // step 1

	if (isObject(val)) { // step 3
		var isArray = IsArray(val); // step 3.a
		if (isArray) { // step 3.c
			var I = 0; // step 3.c.i

			var len = ToLength(Get(val, 'length')); // step 3.b.ii

			while (I < len) { // step 3.b.iv
				var newElement = InternalizeJSONProperty(val, ToString(I), reviver); // step 3.b.iv.1

				if (typeof newElement === 'undefined') { // step 3.b.iv.3
					delete val[ToString(I)]; // step 3.b.iv.3.a
				} else { // step 3.b.iv.4
					CreateDataProperty(val, ToString(I), newElement); // step 3.b.iv.4.a
				}

				I += 1; // step 3.b.iv.6
			}
		} else {
			var keys = EnumerableOwnNames(val); // step 3.d.i

			forEach(keys, function (P) { // step 3.d.iii
				// eslint-disable-next-line no-shadow
				var newElement = InternalizeJSONProperty(val, P, reviver); // step 3.d.iii.1

				if (typeof newElement === 'undefined') { // step 3.d.iii.3
					delete val[P]; // step 3.d.iii.3.a
				} else { // step 3.d.iii.4
					CreateDataProperty(val, P, newElement); // step 3.d.iii.4.a
				}
			});
		}
	}

	return Call(reviver, holder, [name, val]); // step 4
};
'use strict';

var $TypeError = require('es-errors/type');

var Call = require('./Call');
var IsArray = require('./IsArray');
var GetV = require('./GetV');
var isPropertyKey = require('../helpers/isPropertyKey');

// https://262.ecma-international.org/6.0/#sec-invoke

module.exports = function Invoke(O, P) {
	if (!isPropertyKey(P)) {
		throw new $TypeError('Assertion failed: P must be a Property Key');
	}
	var argumentsList = arguments.length > 2 ? arguments[2] : [];
	if (!IsArray(argumentsList)) {
		throw new $TypeError('Assertion failed: optional `argumentsList`, if provided, must be a List');
	}
	var func = GetV(O, P);
	return Call(func, O, argumentsList);
};
'use strict';

var $TypeError = require('es-errors/type');

var hasOwn = require('hasown');

var isPropertyDescriptor = require('../helpers/records/property-descriptor');

// https://262.ecma-international.org/5.1/#sec-8.10.1

module.exports = function IsAccessorDescriptor(Desc) {
	if (typeof Desc === 'undefined') {
		return false;
	}

	if (!isPropertyDescriptor(Desc)) {
		throw new $TypeError('Assertion failed: `Desc` must be a Property Descriptor');
	}

	if (!hasOwn(Desc, '[[Get]]') && !hasOwn(Desc, '[[Set]]')) {
		return false;
	}

	return true;
};
'use strict';

// https://262.ecma-international.org/6.0/#sec-isarray
module.exports = require('../helpers/IsArray');
'use strict';

// http://262.ecma-international.org/5.1/#sec-9.11

module.exports = require('is-callable');
'use strict';

var ValidateAndApplyPropertyDescriptor = require('./ValidateAndApplyPropertyDescriptor');

// https://262.ecma-international.org/6.0/#sec-iscompatiblepropertydescriptor

module.exports = function IsCompatiblePropertyDescriptor(Extensible, Desc, Current) {
	return ValidateAndApplyPropertyDescriptor(undefined, undefined, Extensible, Desc, Current);
};
'use strict';

var GetIntrinsic = require('get-intrinsic');

var $isConcatSpreadable = GetIntrinsic('%Symbol.isConcatSpreadable%', true);

var Get = require('./Get');
var IsArray = require('./IsArray');
var ToBoolean = require('./ToBoolean');

var isObject = require('es-object-atoms/isObject');

// https://262.ecma-international.org/6.0/#sec-isconcatspreadable

module.exports = function IsConcatSpreadable(O) {
	if (!isObject(O)) {
		return false;
	}
	if ($isConcatSpreadable) {
		var spreadable = Get(O, $isConcatSpreadable);
		if (typeof spreadable !== 'undefined') {
			return ToBoolean(spreadable);
		}
	}
	return IsArray(O);
};
'use strict';

var GetIntrinsic = require('../GetIntrinsic.js');

var $construct = GetIntrinsic('%Reflect.construct%', true);

var DefinePropertyOrThrow = require('./DefinePropertyOrThrow');
try {
	DefinePropertyOrThrow({}, '', { '[[Get]]': function () {} });
} catch (e) {
	// Accessor properties aren't supported
	DefinePropertyOrThrow = null;
}

// https://262.ecma-international.org/6.0/#sec-isconstructor

if (DefinePropertyOrThrow && $construct) {
	var isConstructorMarker = {};
	var badArrayLike = {};
	DefinePropertyOrThrow(badArrayLike, 'length', {
		'[[Get]]': function () {
			throw isConstructorMarker;
		},
		'[[Enumerable]]': true
	});

	module.exports = function IsConstructor(argument) {
		try {
			// `Reflect.construct` invokes `IsConstructor(target)` before `Get(args, 'length')`:
			$construct(argument, badArrayLike);
		} catch (err) {
			return err === isConstructorMarker;
		}
	};
} else {
	module.exports = function IsConstructor(argument) {
		// unfortunately there's no way to truly check this without try/catch `new argument` in old environments
		return typeof argument === 'function' && !!argument.prototype;
	};
}
'use strict';

var $TypeError = require('es-errors/type');

var hasOwn = require('hasown');

var isPropertyDescriptor = require('../helpers/records/property-descriptor');

// https://262.ecma-international.org/5.1/#sec-8.10.2

module.exports = function IsDataDescriptor(Desc) {
	if (typeof Desc === 'undefined') {
		return false;
	}

	if (!isPropertyDescriptor(Desc)) {
		throw new $TypeError('Assertion failed: `Desc` must be a Property Descriptor');
	}

	if (!hasOwn(Desc, '[[Value]]') && !hasOwn(Desc, '[[Writable]]')) {
		return false;
	}

	return true;
};
'use strict';

var $TypeError = require('es-errors/type');

var $byteLength = require('array-buffer-byte-length');

var isArrayBuffer = require('is-array-buffer');

var availableTypedArrays = require('available-typed-arrays')();

// https://262.ecma-international.org/6.0/#sec-isdetachedbuffer

module.exports = function IsDetachedBuffer(arrayBuffer) {
	if (!isArrayBuffer(arrayBuffer)) {
		throw new $TypeError('Assertion failed: `arrayBuffer` must be an Object with an [[ArrayBufferData]] internal slot');
	}
	if ($byteLength(arrayBuffer) === 0) {
		try {
			new global[availableTypedArrays[0]](arrayBuffer); // eslint-disable-line no-new
		} catch (error) {
			return !!error && error.name === 'TypeError';
		}
	}
	return false;
};
'use strict';

var GetIntrinsic = require('get-intrinsic');

var $preventExtensions = GetIntrinsic('%Object.preventExtensions%', true);
var $isExtensible = GetIntrinsic('%Object.isExtensible%', true);

var isPrimitive = require('../helpers/isPrimitive');

// https://262.ecma-international.org/6.0/#sec-isextensible-o

module.exports = $preventExtensions
	? function IsExtensible(obj) {
		return !isPrimitive(obj) && $isExtensible(obj);
	}
	: function IsExtensible(obj) {
		return !isPrimitive(obj);
	};
'use strict';

var $TypeError = require('es-errors/type');

var IsAccessorDescriptor = require('./IsAccessorDescriptor');
var IsDataDescriptor = require('./IsDataDescriptor');

var isPropertyDescriptor = require('../helpers/records/property-descriptor');

// https://262.ecma-international.org/6.0/#sec-isgenericdescriptor

module.exports = function IsGenericDescriptor(Desc) {
	if (typeof Desc === 'undefined') {
		return false;
	}

	if (!isPropertyDescriptor(Desc)) {
		throw new $TypeError('Assertion failed: `Desc` must be a Property Descriptor');
	}

	if (!IsAccessorDescriptor(Desc) && !IsDataDescriptor(Desc)) {
		return true;
	}

	return false;
};
'use strict';

var isInteger = require('math-intrinsics/isInteger');

// https://262.ecma-international.org/6.0/#sec-isinteger

module.exports = function IsInteger(argument) {
	return isInteger(argument);
};
'use strict';

var callBound = require('call-bound');

var $PromiseThen = callBound('Promise.prototype.then', true);

var isObject = require('es-object-atoms/isObject');

// https://262.ecma-international.org/6.0/#sec-ispromise

module.exports = function IsPromise(x) {
	if (!isObject(x)) {
		return false;
	}
	if (!$PromiseThen) { // Promises are not supported
		return false;
	}
	try {
		$PromiseThen(x); // throws if not a promise
	} catch (e) {
		return false;
	}
	return true;
};
'use strict';

// TODO, semver-major: delete this

var isPropertyDescriptor = require('../helpers/records/property-descriptor');

// https://262.ecma-international.org/6.0/#sec-property-descriptor-specification-type

module.exports = function IsPropertyDescriptor(Desc) {
	return isPropertyDescriptor(Desc);
};
'use strict';

var isPropertyKey = require('../helpers/isPropertyKey');

// https://262.ecma-international.org/6.0/#sec-ispropertykey

module.exports = function IsPropertyKey(argument) {
	return isPropertyKey(argument);
};
'use strict';

var GetIntrinsic = require('get-intrinsic');

var $match = GetIntrinsic('%Symbol.match%', true);

var hasRegExpMatcher = require('is-regex');
var isObject = require('es-object-atoms/isObject');

var ToBoolean = require('./ToBoolean');

// https://262.ecma-international.org/6.0/#sec-isregexp

module.exports = function IsRegExp(argument) {
	if (!isObject(argument)) {
		return false;
	}
	if ($match) {
		var isRegExp = argument[$match];
		if (typeof isRegExp !== 'undefined') {
			return ToBoolean(isRegExp);
		}
	}
	return hasRegExpMatcher(argument);
};
'use strict';

var $TypeError = require('es-errors/type');

var IsArray = require('./IsArray');
var IsInteger = require('./IsInteger');

var every = require('../helpers/every');
var regexTester = require('safe-regex-test');

var isChar = function isChar(c) {
	return typeof c === 'string' && c.length === 1;
};

var isWordCharacter = regexTester(/^[a-zA-Z0-9_]$/);

// https://262.ecma-international.org/6.0/#sec-runtime-semantics-iswordchar-abstract-operation

// note: prior to ES2023, this AO erroneously omitted the latter of its arguments.
module.exports = function IsWordChar(e, InputLength, Input) {
	if (!IsInteger(e)) {
		throw new $TypeError('Assertion failed: `e` must be an integer');
	}
	if (!IsInteger(InputLength)) {
		throw new $TypeError('Assertion failed: `InputLength` must be an integer');
	}
	if (!IsArray(Input) || !every(Input, isChar)) {
		throw new $TypeError('Assertion failed: `Input` must be a List of characters');
	}
	if (e === -1 || e === InputLength) {
		return false; // step 1
	}

	var c = Input[e]; // step 2

	return isWordCharacter(c); // steps 3-4
};
'use strict';

var getIteratorMethod = require('../helpers/getIteratorMethod');
var AdvanceStringIndex = require('./AdvanceStringIndex');
var GetIterator = require('./GetIterator');
var GetMethod = require('./GetMethod');
var IteratorStep = require('./IteratorStep');
var IteratorValue = require('./IteratorValue');
var ToObject = require('./ToObject');
var ES = {
	AdvanceStringIndex: AdvanceStringIndex,
	GetMethod: GetMethod
};

// https://262.ecma-international.org/7.0/#sec-iterabletoarraylike

module.exports = function IterableToArrayLike(items) {
	var usingIterator = getIteratorMethod(ES, items);
	if (typeof usingIterator !== 'undefined') {
		var iterator = GetIterator(items, usingIterator);
		var values = [];
		var next = true;
		while (next) {
			next = IteratorStep(iterator);
			if (next) {
				var nextValue = IteratorValue(next);
				values[values.length] = nextValue;
			}
		}
		return values;
	}

	return ToObject(items);
};
'use strict';

var $TypeError = require('es-errors/type');
var isObject = require('es-object-atoms/isObject');

var Call = require('./Call');
var CompletionRecord = require('./CompletionRecord');
var GetMethod = require('./GetMethod');
var IsCallable = require('./IsCallable');

// https://262.ecma-international.org/6.0/#sec-iteratorclose

module.exports = function IteratorClose(iterator, completion) {
	if (!isObject(iterator)) {
		throw new $TypeError('Assertion failed: Type(iterator) is not Object');
	}
	if (!IsCallable(completion) && !(completion instanceof CompletionRecord)) {
		throw new $TypeError('Assertion failed: completion is not a thunk representing a Completion Record, nor a Completion Record instance');
	}
	var completionThunk = completion instanceof CompletionRecord ? function () { return completion['?'](); } : completion;

	var iteratorReturn = GetMethod(iterator, 'return');

	if (typeof iteratorReturn === 'undefined') {
		return completionThunk();
	}

	var completionRecord;
	try {
		var innerResult = Call(iteratorReturn, iterator, []);
	} catch (e) {
		// if we hit here, then "e" is the innerResult completion that needs re-throwing

		// if the completion is of type "throw", this will throw.
		completionThunk();
		completionThunk = null; // ensure it's not called twice.

		// if not, then return the innerResult completion
		throw e;
	}
	completionRecord = completionThunk(); // if innerResult worked, then throw if the completion does
	completionThunk = null; // ensure it's not called twice.

	if (!isObject(innerResult)) {
		throw new $TypeError('iterator .return must return an object');
	}

	return completionRecord;
};
'use strict';

var $TypeError = require('es-errors/type');
var isObject = require('es-object-atoms/isObject');

var Get = require('./Get');
var ToBoolean = require('./ToBoolean');

// https://262.ecma-international.org/6.0/#sec-iteratorcomplete

module.exports = function IteratorComplete(iterResult) {
	if (!isObject(iterResult)) {
		throw new $TypeError('Assertion failed: Type(iterResult) is not Object');
	}
	return ToBoolean(Get(iterResult, 'done'));
};
'use strict';

var $TypeError = require('es-errors/type');
var isObject = require('es-object-atoms/isObject');

var Invoke = require('./Invoke');

// https://262.ecma-international.org/6.0/#sec-iteratornext

module.exports = function IteratorNext(iterator, value) {
	var result = Invoke(iterator, 'next', arguments.length < 2 ? [] : [value]);
	if (!isObject(result)) {
		throw new $TypeError('iterator next must return an object');
	}
	return result;
};
'use strict';

var IteratorComplete = require('./IteratorComplete');
var IteratorNext = require('./IteratorNext');

// https://262.ecma-international.org/6.0/#sec-iteratorstep

module.exports = function IteratorStep(iterator) {
	var result = IteratorNext(iterator);
	var done = IteratorComplete(result);
	return done === true ? false : result;
};

'use strict';

var $TypeError = require('es-errors/type');
var isObject = require('es-object-atoms/isObject');

var Get = require('./Get');

// https://262.ecma-international.org/6.0/#sec-iteratorvalue

module.exports = function IteratorValue(iterResult) {
	if (!isObject(iterResult)) {
		throw new $TypeError('Assertion failed: Type(iterResult) is not Object');
	}
	return Get(iterResult, 'value');
};

'use strict';

var $isFinite = require('math-intrinsics/isFinite');

var msPerDay = require('../helpers/timeConstants').msPerDay;

// https://262.ecma-international.org/5.1/#sec-15.9.1.13

module.exports = function MakeDate(day, time) {
	if (!$isFinite(day) || !$isFinite(time)) {
		return NaN;
	}
	return (day * msPerDay) + time;
};
'use strict';

var GetIntrinsic = require('get-intrinsic');

var $DateUTC = GetIntrinsic('%Date.UTC%');

var $isFinite = require('math-intrinsics/isFinite');

var DateFromTime = require('./DateFromTime');
var Day = require('./Day');
var floor = require('./floor');
var modulo = require('./modulo');
var MonthFromTime = require('./MonthFromTime');
var ToInteger = require('./ToInteger');
var YearFromTime = require('./YearFromTime');

// https://262.ecma-international.org/5.1/#sec-15.9.1.12

module.exports = function MakeDay(year, month, date) {
	if (!$isFinite(year) || !$isFinite(month) || !$isFinite(date)) {
		return NaN;
	}
	var y = ToInteger(year);
	var m = ToInteger(month);
	var dt = ToInteger(date);
	var ym = y + floor(m / 12);
	var mn = modulo(m, 12);
	var t = $DateUTC(ym, mn, 1);
	if (YearFromTime(t) !== ym || MonthFromTime(t) !== mn || DateFromTime(t) !== 1) {
		return NaN;
	}
	return Day(t) + dt - 1;
};
'use strict';

var $isFinite = require('math-intrinsics/isFinite');

var timeConstants = require('../helpers/timeConstants');
var msPerSecond = timeConstants.msPerSecond;
var msPerMinute = timeConstants.msPerMinute;
var msPerHour = timeConstants.msPerHour;

var ToInteger = require('./ToInteger');

// https://262.ecma-international.org/5.1/#sec-15.9.1.11

module.exports = function MakeTime(hour, min, sec, ms) {
	if (!$isFinite(hour) || !$isFinite(min) || !$isFinite(sec) || !$isFinite(ms)) {
		return NaN;
	}
	var h = ToInteger(hour);
	var m = ToInteger(min);
	var s = ToInteger(sec);
	var milli = ToInteger(ms);
	var t = (h * msPerHour) + (m * msPerMinute) + (s * msPerSecond) + milli;
	return t;
};
'use strict';

// https://262.ecma-international.org/6.0/#sec-algorithm-conventions

module.exports = require('math-intrinsics/max');
'use strict';

var floor = require('./floor');
var modulo = require('./modulo');

var timeConstants = require('../helpers/timeConstants');
var msPerMinute = timeConstants.msPerMinute;
var MinutesPerHour = timeConstants.MinutesPerHour;

// https://262.ecma-international.org/5.1/#sec-15.9.1.10

module.exports = function MinFromTime(t) {
	return modulo(floor(t / msPerMinute), MinutesPerHour);
};
'use strict';

// https://262.ecma-international.org/6.0/#sec-algorithm-conventions

module.exports = require('math-intrinsics/min');
'use strict';

var mod = require('../helpers/mod');

// https://262.ecma-international.org/5.1/#sec-5.2

module.exports = function modulo(x, y) {
	return mod(x, y);
};
'use strict';

var $RangeError = require('es-errors/range');

var DayWithinYear = require('./DayWithinYear');
var InLeapYear = require('./InLeapYear');

// https://262.ecma-international.org/5.1/#sec-15.9.1.4

module.exports = function MonthFromTime(t) {
	var day = DayWithinYear(t);
	if (0 <= day && day < 31) {
		return 0;
	}
	var leap = InLeapYear(t);
	if (31 <= day && day < (59 + leap)) {
		return 1;
	}
	if ((59 + leap) <= day && day < (90 + leap)) {
		return 2;
	}
	if ((90 + leap) <= day && day < (120 + leap)) {
		return 3;
	}
	if ((120 + leap) <= day && day < (151 + leap)) {
		return 4;
	}
	if ((151 + leap) <= day && day < (181 + leap)) {
		return 5;
	}
	if ((181 + leap) <= day && day < (212 + leap)) {
		return 6;
	}
	if ((212 + leap) <= day && day < (243 + leap)) {
		return 7;
	}
	if ((243 + leap) <= day && day < (273 + leap)) {
		return 8;
	}
	if ((273 + leap) <= day && day < (304 + leap)) {
		return 9;
	}
	if ((304 + leap) <= day && day < (334 + leap)) {
		return 10;
	}
	if ((334 + leap) <= day && day < (365 + leap)) {
		return 11;
	}

	throw new $RangeError('Assertion failed: `day` is out of range');
};
'use strict';

var modulo = require('./modulo');

var msPerSecond = require('../helpers/timeConstants').msPerSecond;

// https://262.ecma-international.org/5.1/#sec-15.9.1.10

module.exports = function msFromTime(t) {
	return modulo(t, msPerSecond);
};
'use strict';

var $TypeError = require('es-errors/type');

var IsCallable = require('./IsCallable');
var IsConstructor = require('./IsConstructor');

// https://262.ecma-international.org/6.0/#sec-newpromisecapability

module.exports = function NewPromiseCapability(C) {
	if (!IsConstructor(C)) {
		throw new $TypeError('C must be a constructor'); // step 1
	}

	var resolvingFunctions = { '[[Resolve]]': void undefined, '[[Reject]]': void undefined }; // step 3

	var promise = new C(function (resolve, reject) { // steps 4-5
		if (typeof resolvingFunctions['[[Resolve]]'] !== 'undefined' || typeof resolvingFunctions['[[Reject]]'] !== 'undefined') {
			throw new $TypeError('executor has already been called'); // step 4.a, 4.b
		}
		resolvingFunctions['[[Resolve]]'] = resolve; // step 4.c
		resolvingFunctions['[[Reject]]'] = reject; // step 4.d
	}); // step 4-6

	if (!IsCallable(resolvingFunctions['[[Resolve]]']) || !IsCallable(resolvingFunctions['[[Reject]]'])) {
		throw new $TypeError('executor must provide valid resolve and reject functions'); // steps 7-8
	}

	return {
		'[[Promise]]': promise,
		'[[Resolve]]': resolvingFunctions['[[Resolve]]'],
		'[[Reject]]': resolvingFunctions['[[Reject]]']
	}; // step 9
};
'use strict';

var CompletionRecord = require('./CompletionRecord');

// https://262.ecma-international.org/6.0/#sec-normalcompletion

module.exports = function NormalCompletion(value) {
	return new CompletionRecord('normal', value);
};
'use strict';

var GetIntrinsic = require('get-intrinsic');

var $ObjectCreate = GetIntrinsic('%Object.create%', true);
var $TypeError = require('es-errors/type');
var $SyntaxError = require('es-errors/syntax');
var isObject = require('es-object-atoms/isObject');

var IsArray = require('./IsArray');

var forEach = require('../helpers/forEach');

var SLOT = require('internal-slot');

var hasProto = require('has-proto')();

// https://262.ecma-international.org/6.0/#sec-objectcreate

module.exports = function ObjectCreate(proto, internalSlotsList) {
	if (proto !== null && !isObject(proto)) {
		throw new $TypeError('Assertion failed: `proto` must be null or an object');
	}
	var slots = arguments.length < 2 ? [] : internalSlotsList; // step 1
	if (arguments.length >= 2 && !IsArray(slots)) {
		throw new $TypeError('Assertion failed: `internalSlotsList` must be an Array');
	}

	var O;
	if (hasProto) {
		O = { __proto__: proto };
	} else if ($ObjectCreate) {
		O = $ObjectCreate(proto);
	} else {
		if (proto === null) {
			throw new $SyntaxError('native Object.create support is required to create null objects');
		}
		var T = function T() {};
		T.prototype = proto;
		O = new T();
	}

	if (slots.length > 0) {
		forEach(slots, function (slot) {
			SLOT.set(O, slot, void undefined);
		});
	}

	return O; // step 6
};
'use strict';

var DefinePropertyOrThrow = require('./DefinePropertyOrThrow');
var Get = require('./Get');
var OrdinaryGetOwnProperty = require('./OrdinaryGetOwnProperty');
var ToObject = require('./ToObject');
var ToPropertyDescriptor = require('./ToPropertyDescriptor');

var forEach = require('../helpers/forEach');
var OwnPropertyKeys = require('own-keys');

// https://262.ecma-international.org/6.0/#sec-objectdefineproperties

/** @type {<T extends Record<PropertyKey, unknown> = {}>(O: T, Properties: object) => T} */
module.exports = function ObjectDefineProperties(O, Properties) {
	var props = ToObject(Properties); // step 1
	var keys = OwnPropertyKeys(props); // step 2
	/** @type {[string | symbol, import('../types').Descriptor][]} */
	var descriptors = []; // step 3

	forEach(keys, function (nextKey) { // step 4
		var propDesc = OrdinaryGetOwnProperty(props, nextKey); // ToPropertyDescriptor(getOwnPropertyDescriptor(props, nextKey)); // step 4.a
		if (typeof propDesc !== 'undefined' && propDesc['[[Enumerable]]']) { // step 4.b
			var descObj = Get(props, nextKey); // step 4.b.i
			var desc = ToPropertyDescriptor(descObj); // step 4.b.ii
			descriptors[descriptors.length] = [nextKey, desc]; // step 4.b.iii
		}
	});

	forEach(descriptors, function (pair) { // step 5
		var P = pair[0]; // step 5.a
		var desc = pair[1]; // step 5.b
		DefinePropertyOrThrow(O, P, desc); // step 5.c
	});

	return O; // step 6
};
'use strict';

var GetIntrinsic = require('get-intrinsic');
var $TypeError = require('es-errors/type');

var GetPrototypeFromConstructor = require('./GetPrototypeFromConstructor');
var IsArray = require('./IsArray');
var ObjectCreate = require('./ObjectCreate');

// https://262.ecma-international.org/6.0/#sec-ordinarycreatefromconstructor

module.exports = function OrdinaryCreateFromConstructor(constructor, intrinsicDefaultProto) {
	GetIntrinsic(intrinsicDefaultProto); // throws if not a valid intrinsic
	var proto = GetPrototypeFromConstructor(constructor, intrinsicDefaultProto);
	var slots = arguments.length < 3 ? [] : arguments[2];
	if (!IsArray(slots)) {
		throw new $TypeError('Assertion failed: if provided, `internalSlotsList` must be a List');
	}
	return ObjectCreate(proto, slots);
};
'use strict';

var $gOPD = require('gopd');
var $SyntaxError = require('es-errors/syntax');
var $TypeError = require('es-errors/type');
var isObject = require('es-object-atoms/isObject');

var isPropertyDescriptor = require('../helpers/records/property-descriptor');

var IsAccessorDescriptor = require('./IsAccessorDescriptor');
var IsExtensible = require('./IsExtensible');
var isPropertyKey = require('../helpers/isPropertyKey');
var ToPropertyDescriptor = require('./ToPropertyDescriptor');
var SameValue = require('./SameValue');
var ValidateAndApplyPropertyDescriptor = require('./ValidateAndApplyPropertyDescriptor');

// https://262.ecma-international.org/6.0/#sec-ordinarydefineownproperty

module.exports = function OrdinaryDefineOwnProperty(O, P, Desc) {
	if (!isObject(O)) {
		throw new $TypeError('Assertion failed: O must be an Object');
	}
	if (!isPropertyKey(P)) {
		throw new $TypeError('Assertion failed: P must be a Property Key');
	}
	if (!isPropertyDescriptor(Desc)) {
		throw new $TypeError('Assertion failed: Desc must be a Property Descriptor');
	}
	if (!$gOPD) {
		// ES3/IE 8 fallback
		if (IsAccessorDescriptor(Desc)) {
			throw new $SyntaxError('This environment does not support accessor property descriptors.');
		}
		var creatingNormalDataProperty = !(P in O)
			&& Desc['[[Writable]]']
			&& Desc['[[Enumerable]]']
			&& Desc['[[Configurable]]']
			&& '[[Value]]' in Desc;
		var settingExistingDataProperty = (P in O)
			&& (!('[[Configurable]]' in Desc) || Desc['[[Configurable]]'])
			&& (!('[[Enumerable]]' in Desc) || Desc['[[Enumerable]]'])
			&& (!('[[Writable]]' in Desc) || Desc['[[Writable]]'])
			&& '[[Value]]' in Desc;
		if (creatingNormalDataProperty || settingExistingDataProperty) {
			O[P] = Desc['[[Value]]']; // eslint-disable-line no-param-reassign
			return SameValue(O[P], Desc['[[Value]]']);
		}
		throw new $SyntaxError('This environment does not support defining non-writable, non-enumerable, or non-configurable properties');
	}
	var desc = $gOPD(O, P);
	var current = desc && ToPropertyDescriptor(desc);
	var extensible = IsExtensible(O);
	return ValidateAndApplyPropertyDescriptor(O, P, extensible, Desc, current);
};
'use strict';

var $gOPD = require('gopd');
var $TypeError = require('es-errors/type');
var isObject = require('es-object-atoms/isObject');
var hasOwn = require('hasown');
var callBound = require('call-bound');

var $isEnumerable = callBound('Object.prototype.propertyIsEnumerable');

var IsArray = require('./IsArray');
var isPropertyKey = require('../helpers/isPropertyKey');
var IsRegExp = require('./IsRegExp');
var ToPropertyDescriptor = require('./ToPropertyDescriptor');

// https://262.ecma-international.org/6.0/#sec-ordinarygetownproperty

module.exports = function OrdinaryGetOwnProperty(O, P) {
	if (!isObject(O)) {
		throw new $TypeError('Assertion failed: O must be an Object');
	}
	if (!isPropertyKey(P)) {
		throw new $TypeError('Assertion failed: P must be a Property Key');
	}
	if (!hasOwn(O, P)) {
		return void 0;
	}
	if (!$gOPD) {
		// ES3 / IE 8 fallback
		var arrayLength = IsArray(O) && P === 'length';
		var regexLastIndex = IsRegExp(O) && P === 'lastIndex';
		return {
			'[[Configurable]]': !(arrayLength || regexLastIndex),
			'[[Enumerable]]': $isEnumerable(O, P),
			'[[Value]]': O[P],
			'[[Writable]]': true
		};
	}
	return ToPropertyDescriptor($gOPD(O, P));
};
'use strict';

var $TypeError = require('es-errors/type');
var isObject = require('es-object-atoms/isObject');

var $getProto = require('get-proto');

// https://262.ecma-international.org/7.0/#sec-ordinarygetprototypeof

module.exports = function OrdinaryGetPrototypeOf(O) {
	if (!isObject(O)) {
		throw new $TypeError('Assertion failed: O must be an Object');
	}
	if (!$getProto) {
		throw new $TypeError('This environment does not support fetching prototypes.');
	}
	return $getProto(O);
};
'use strict';

var $TypeError = require('es-errors/type');
var isObject = require('es-object-atoms/isObject');

var Get = require('./Get');
var IsCallable = require('./IsCallable');

// https://262.ecma-international.org/6.0/#sec-ordinaryhasinstance

module.exports = function OrdinaryHasInstance(C, O) {
	if (!IsCallable(C)) {
		return false;
	}
	if (!isObject(O)) {
		return false;
	}
	var P = Get(C, 'prototype');
	if (!isObject(P)) {
		throw new $TypeError('OrdinaryHasInstance called on an object with an invalid prototype property.');
	}
	return O instanceof C;
};
'use strict';

var $TypeError = require('es-errors/type');
var isObject = require('es-object-atoms/isObject');

var isPropertyKey = require('../helpers/isPropertyKey');

// https://262.ecma-international.org/6.0/#sec-ordinaryhasproperty

module.exports = function OrdinaryHasProperty(O, P) {
	if (!isObject(O)) {
		throw new $TypeError('Assertion failed: Type(O) is not Object');
	}
	if (!isPropertyKey(P)) {
		throw new $TypeError('Assertion failed: P must be a Property Key');
	}
	return P in O;
};
'use strict';

var $TypeError = require('es-errors/type');
var $setProto = require('set-proto');
var isObject = require('es-object-atoms/isObject');

var OrdinaryGetPrototypeOf = require('./OrdinaryGetPrototypeOf');

// https://262.ecma-international.org/7.0/#sec-ordinarysetprototypeof

module.exports = function OrdinarySetPrototypeOf(O, V) {
	if (V !== null && !isObject(V)) {
		throw new $TypeError('Assertion failed: V must be Object or Null');
	}
	/*
	var extensible = IsExtensible(O);
	var current = OrdinaryGetPrototypeOf(O);
	if (SameValue(V, current)) {
		return true;
	}
	if (!extensible) {
		return false;
	}
	*/
	try {
		$setProto(O, V);
	} catch (e) {
		return false;
	}
	return OrdinaryGetPrototypeOf(O) === V;
	/*
	var p = V;
	var done = false;
	while (!done) {
		if (p === null) {
			done = true;
		} else if (SameValue(p, O)) {
			return false;
		} else {
			if (wat) {
				done = true;
			} else {
				p = p.[[Prototype]];
			}
		}
	}
	O.[[Prototype]] = V;
	return true;
	*/
};
'use strict';

var $TypeError = require('es-errors/type');

var callBound = require('call-bound');
var forEach = require('../helpers/forEach');

var $charCodeAt = callBound('String.prototype.charCodeAt');
var $numberToString = callBound('Number.prototype.toString');
var $toLowerCase = callBound('String.prototype.toLowerCase');
var $strSlice = callBound('String.prototype.slice');
var $strSplit = callBound('String.prototype.split');

// https://262.ecma-international.org/6.0/#sec-quotejsonstring

var escapes = {
	'\u0008': 'b',
	'\u000C': 'f',
	'\u000A': 'n',
	'\u000D': 'r',
	'\u0009': 't'
};

module.exports = function QuoteJSONString(value) {
	if (typeof value !== 'string') {
		throw new $TypeError('Assertion failed: `value` must be a String');
	}
	var product = '"';
	if (value) {
		forEach($strSplit(value, ''), function (C) {
			if (C === '"' || C === '\\') {
				product += '\u005C' + C;
			} else if (C === '\u0008' || C === '\u000C' || C === '\u000A' || C === '\u000D' || C === '\u0009') {
				var abbrev = escapes[C];
				product += '\u005C' + abbrev;
			} else {
				var cCharCode = $charCodeAt(C, 0);
				if (cCharCode < 0x20) {
					product += '\u005Cu' + $toLowerCase($strSlice('0000' + $numberToString(cCharCode, 16), -4));
				} else {
					product += C;
				}
			}
		});
	}
	product += '"';
	return product;
};
'use strict';

var GetIntrinsic = require('get-intrinsic');

var $RegExp = GetIntrinsic('%RegExp%');

// var RegExpAlloc = require('./RegExpAlloc');
// var RegExpInitialize = require('./RegExpInitialize');
var ToString = require('./ToString');

// https://262.ecma-international.org/6.0/#sec-regexpcreate

module.exports = function RegExpCreate(P, F) {
	// var obj = RegExpAlloc($RegExp);
	// return RegExpInitialize(obj, P, F);

	// covers spec mechanics; bypass regex brand checking
	var pattern = typeof P === 'undefined' ? '' : ToString(P);
	var flags = typeof F === 'undefined' ? '' : ToString(F);
	return new $RegExp(pattern, flags);
};
'use strict';

var $TypeError = require('es-errors/type');
var isObject = require('es-object-atoms/isObject');
var regexExec = require('call-bound')('RegExp.prototype.exec');

var Call = require('./Call');
var Get = require('./Get');
var IsCallable = require('./IsCallable');

// https://262.ecma-international.org/6.0/#sec-regexpexec

module.exports = function RegExpExec(R, S) {
	if (!isObject(R)) {
		throw new $TypeError('Assertion failed: `R` must be an Object');
	}
	if (typeof S !== 'string') {
		throw new $TypeError('Assertion failed: `S` must be a String');
	}
	var exec = Get(R, 'exec');
	if (IsCallable(exec)) {
		var result = Call(exec, R, [S]);
		if (result === null || isObject(result)) {
			return result;
		}
		throw new $TypeError('"exec" method must return `null` or an Object');
	}
	return regexExec(R, S);
};
'use strict';

module.exports = require('es-object-atoms/RequireObjectCoercible');
'use strict';

var $isNaN = require('math-intrinsics/isNaN');

// http://262.ecma-international.org/5.1/#sec-9.12

module.exports = function SameValue(x, y) {
	if (x === y) { // 0 === -0, but they are not identical.
		if (x === 0) { return 1 / x === 1 / y; }
		return true;
	}
	return $isNaN(x) && $isNaN(y);
};
'use strict';

var $TypeError = require('es-errors/type');

var SameValue = require('./SameValue');

// https://262.ecma-international.org/7.0/#sec-samevaluenonnumber

module.exports = function SameValueNonNumber(x, y) {
	if (typeof x === 'number' || typeof x !== typeof y) {
		throw new $TypeError('SameValueNonNumber requires two non-number values of the same type.');
	}
	return SameValue(x, y);
};
'use strict';

var $isNaN = require('math-intrinsics/isNaN');

// https://262.ecma-international.org/6.0/#sec-samevaluezero

module.exports = function SameValueZero(x, y) {
	return (x === y) || ($isNaN(x) && $isNaN(y));
};
'use strict';

var floor = require('./floor');
var modulo = require('./modulo');

var timeConstants = require('../helpers/timeConstants');
var msPerSecond = timeConstants.msPerSecond;
var SecondsPerMinute = timeConstants.SecondsPerMinute;

// https://262.ecma-international.org/5.1/#sec-15.9.1.10

module.exports = function SecFromTime(t) {
	return modulo(floor(t / msPerSecond), SecondsPerMinute);
};
'use strict';

var hasOwn = require('hasown');

var $TypeError = require('es-errors/type');

var getSymbolDescription = require('get-symbol-description');

var DefinePropertyOrThrow = require('./DefinePropertyOrThrow');
var IsExtensible = require('./IsExtensible');

// https://262.ecma-international.org/6.0/#sec-setfunctionname

module.exports = function SetFunctionName(F, name) {
	if (typeof F !== 'function') {
		throw new $TypeError('Assertion failed: `F` must be a function');
	}
	if (!IsExtensible(F) || hasOwn(F, 'name')) {
		throw new $TypeError('Assertion failed: `F` must be extensible, and must not have a `name` own property');
	}
	if (typeof name !== 'symbol' && typeof name !== 'string') {
		throw new $TypeError('Assertion failed: `name` must be a Symbol or a String');
	}
	if (typeof name === 'symbol') {
		var description = getSymbolDescription(name);
		// eslint-disable-next-line no-param-reassign
		name = typeof description === 'undefined' ? '' : '[' + description + ']';
	}
	if (arguments.length > 2) {
		var prefix = arguments[2];
		// eslint-disable-next-line no-param-reassign
		name = prefix + ' ' + name;
	}
	return DefinePropertyOrThrow(F, 'name', {
		'[[Value]]': name,
		'[[Writable]]': false,
		'[[Enumerable]]': false,
		'[[Configurable]]': true
	});
};
'use strict';

var GetIntrinsic = require('get-intrinsic');

var $SyntaxError = require('es-errors/syntax');
var $TypeError = require('es-errors/type');
var isObject = require('es-object-atoms/isObject');
var $gOPD = require('gopd');
var $preventExtensions = GetIntrinsic('%Object.preventExtensions%', true);
var $gOPN = GetIntrinsic('%Object.getOwnPropertyNames%', true);

var forEach = require('../helpers/forEach');

var DefinePropertyOrThrow = require('./DefinePropertyOrThrow');
var IsAccessorDescriptor = require('./IsAccessorDescriptor');
var ToPropertyDescriptor = require('./ToPropertyDescriptor');

// https://262.ecma-international.org/6.0/#sec-setintegritylevel

module.exports = function SetIntegrityLevel(O, level) {
	if (!isObject(O)) {
		throw new $TypeError('Assertion failed: Type(O) is not Object');
	}
	if (level !== 'sealed' && level !== 'frozen') {
		throw new $TypeError('Assertion failed: `level` must be `"sealed"` or `"frozen"`');
	}
	if (!$preventExtensions) {
		throw new $SyntaxError('SetIntegrityLevel requires native `Object.preventExtensions` support');
	}
	var status = $preventExtensions(O);
	if (!status) {
		return false;
	}
	if (!$gOPN) {
		throw new $SyntaxError('SetIntegrityLevel requires native `Object.getOwnPropertyNames` support');
	}
	var theKeys = $gOPN(O);
	if (level === 'sealed') {
		forEach(theKeys, function (k) {
			DefinePropertyOrThrow(O, k, { configurable: false });
		});
	} else if (level === 'frozen') {
		forEach(theKeys, function (k) {
			var currentDesc = $gOPD(O, k);
			if (typeof currentDesc !== 'undefined') {
				var desc;
				if (IsAccessorDescriptor(ToPropertyDescriptor(currentDesc))) {
					desc = { configurable: false };
				} else {
					desc = { configurable: false, writable: false };
				}
				DefinePropertyOrThrow(O, k, desc);
			}
		});
	}
	return true;
};
'use strict';

var $TypeError = require('es-errors/type');
var isObject = require('es-object-atoms/isObject');

var isPropertyKey = require('../helpers/isPropertyKey');
var SameValue = require('./SameValue');

// IE 9 does not throw in strict mode when writability/configurability/extensibility is violated
var noThrowOnStrictViolation = (function () {
	try {
		delete [].length;
		return true;
	} catch (e) {
		return false;
	}
}());

// https://262.ecma-international.org/6.0/#sec-set-o-p-v-throw

module.exports = function Set(O, P, V, Throw) {
	if (!isObject(O)) {
		throw new $TypeError('Assertion failed: `O` must be an Object');
	}
	if (!isPropertyKey(P)) {
		throw new $TypeError('Assertion failed: `P` must be a Property Key');
	}
	if (typeof Throw !== 'boolean') {
		throw new $TypeError('Assertion failed: `Throw` must be a Boolean');
	}
	if (Throw) {
		O[P] = V; // eslint-disable-line no-param-reassign
		if (noThrowOnStrictViolation && !SameValue(O[P], V)) {
			throw new $TypeError('Attempted to assign to readonly property.');
		}
		return true;
	}
	try {
		O[P] = V; // eslint-disable-line no-param-reassign
		return noThrowOnStrictViolation ? SameValue(O[P], V) : true;
	} catch (e) {
		return false;
	}

};
'use strict';

var GetIntrinsic = require('get-intrinsic');

var $TypeError = require('es-errors/type');
var $Uint8Array = GetIntrinsic('%Uint8Array%', true);

var isInteger = require('math-intrinsics/isInteger');

var IsDetachedBuffer = require('./IsDetachedBuffer');
var ToInt16 = require('./ToInt16');
var ToInt32 = require('./ToInt32');
var ToInt8 = require('./ToInt8');
var ToUint16 = require('./ToUint16');
var ToUint32 = require('./ToUint32');
var ToUint8 = require('./ToUint8');
var ToUint8Clamp = require('./ToUint8Clamp');

var isArrayBuffer = require('is-array-buffer');
var hasOwn = require('hasown');

var tableTAO = require('./tables/typed-array-objects');

var TypeToAO = {
	__proto__: null,
	$Int8: ToInt8,
	$Uint8: ToUint8,
	$Uint8C: ToUint8Clamp,
	$Int16: ToInt16,
	$Uint16: ToUint16,
	$Int32: ToInt32,
	$Uint32: ToUint32
};

var defaultEndianness = require('../helpers/defaultEndianness');
var forEach = require('../helpers/forEach');
var integerToNBytes = require('../helpers/integerToNBytes');
var valueToFloat32Bytes = require('../helpers/valueToFloat32Bytes');
var valueToFloat64Bytes = require('../helpers/valueToFloat64Bytes');

// https://262.ecma-international.org/6.0/#sec-setvalueinbuffer

module.exports = function SetValueInBuffer(arrayBuffer, byteIndex, type, value) {
	if (!isArrayBuffer(arrayBuffer)) {
		throw new $TypeError('Assertion failed: `arrayBuffer` must be an ArrayBuffer');
	}

	if (!isInteger(byteIndex)) {
		throw new $TypeError('Assertion failed: `byteIndex` must be an integer');
	}

	if (typeof type !== 'string' || !hasOwn(tableTAO.size, '$' + type)) {
		throw new $TypeError('Assertion failed: `type` must be one of ' + tableTAO.choices);
	}

	if (typeof value !== 'number') {
		throw new $TypeError('Assertion failed: `value` must be a number');
	}

	if (arguments.length > 4 && typeof arguments[4] !== 'boolean') {
		throw new $TypeError('Assertion failed: `isLittleEndian` must be a boolean, if present');
	}

	if (IsDetachedBuffer(arrayBuffer)) {
		throw new $TypeError('Assertion failed: ArrayBuffer is detached'); // step 1
	}

	// 2. Assert: There are sufficient bytes in arrayBuffer starting at byteIndex to represent a value of type.

	if (byteIndex < 0) {
		throw new $TypeError('Assertion failed: `byteIndex` must be non-negative'); // step 3
	}

	// 4. Assert: Type(value) is Number.

	// 5. Let block be arrayBuffer’s [[ArrayBufferData]] internal slot.

	// 6. Assert: block is not undefined.

	var elementSize = tableTAO.size['$' + type]; // step 7
	if (!elementSize) {
		throw new $TypeError('Assertion failed: `type` must be one of ' + tableTAO.choices);
	}

	// 8. If isLittleEndian is not present, set isLittleEndian to either true or false. The choice is implementation dependent and should be the alternative that is most efficient for the implementation. An implementation must use the same value each time this step is executed and the same value must be used for the corresponding step in the GetValueFromBuffer abstract operation.
	var isLittleEndian = arguments.length > 4 ? arguments[4] : defaultEndianness === 'little'; // step 8

	var rawBytes;
	if (type === 'Float32') { // step 1
		rawBytes = valueToFloat32Bytes(value, isLittleEndian);
	} else if (type === 'Float64') { // step 2
		rawBytes = valueToFloat64Bytes(value, isLittleEndian);
	} else {
		var n = elementSize; // step 3.a

		var convOp = TypeToAO['$' + type]; // step 3.b

		var intValue = convOp(value); // step 3.c

		rawBytes = integerToNBytes(intValue, n, isLittleEndian); // step 3.d, 3.e, 4
	}

	// 12. Store the individual bytes of rawBytes into block, in order, starting at block[byteIndex].
	var arr = new $Uint8Array(arrayBuffer, byteIndex, elementSize);
	forEach(rawBytes, function (rawByte, i) {
		arr[i] = rawByte;
	});

	// 13. Return NormalCompletion(undefined).
};
'use strict';

var GetIntrinsic = require('get-intrinsic');

var $species = GetIntrinsic('%Symbol.species%', true);
var $TypeError = require('es-errors/type');
var isObject = require('es-object-atoms/isObject');

var IsConstructor = require('./IsConstructor');

// https://262.ecma-international.org/6.0/#sec-speciesconstructor

module.exports = function SpeciesConstructor(O, defaultConstructor) {
	if (!isObject(O)) {
		throw new $TypeError('Assertion failed: Type(O) is not Object');
	}
	var C = O.constructor;
	if (typeof C === 'undefined') {
		return defaultConstructor;
	}
	if (!isObject(C)) {
		throw new $TypeError('O.constructor is not an Object');
	}
	var S = $species ? C[$species] : void 0;
	if (S == null) {
		return defaultConstructor;
	}
	if (IsConstructor(S)) {
		return S;
	}
	throw new $TypeError('no constructor found');
};
'use strict';

var callBound = require('call-bound');

var $TypeError = require('es-errors/type');
var isInteger = require('math-intrinsics/isInteger');

var $charAt = callBound('String.prototype.charAt');

// https://262.ecma-international.org/6.0/#sec-splitmatch

module.exports = function SplitMatch(S, q, R) {
	if (typeof S !== 'string') {
		throw new $TypeError('Assertion failed: `S` must be a String');
	}
	if (!isInteger(q)) {
		throw new $TypeError('Assertion failed: `q` must be an integer');
	}
	if (typeof R !== 'string') {
		throw new $TypeError('Assertion failed: `R` must be a String');
	}
	var r = R.length;
	var s = S.length;
	if (q + r > s) {
		return false;
	}

	for (var i = 0; i < r; i += 1) {
		if ($charAt(S, q + i) !== $charAt(R, i)) {
			return false;
		}
	}

	return q + r;
};
'use strict';

var Type = require('./Type');

// https://262.ecma-international.org/5.1/#sec-11.9.6

module.exports = function StrictEqualityComparison(x, y) {
	if (Type(x) !== Type(y)) {
		return false;
	}
	if (typeof x === 'undefined' || x === null) {
		return true;
	}
	return x === y; // shortcut for steps 4-7
};
'use strict';

var GetIntrinsic = require('get-intrinsic');

var $Object = require('es-object-atoms');
var $StringPrototype = GetIntrinsic('%String.prototype%');
var $SyntaxError = require('es-errors/syntax');
var $TypeError = require('es-errors/type');
var setProto = require('set-proto');

var DefinePropertyOrThrow = require('./DefinePropertyOrThrow');

// https://262.ecma-international.org/6.0/#sec-stringcreate

module.exports = function StringCreate(value, prototype) {
	if (typeof value !== 'string') {
		throw new $TypeError('Assertion failed: `S` must be a String');
	}

	var S = $Object(value);
	if (prototype !== $StringPrototype) {
		if (setProto) {
			setProto(S, prototype);
		} else {
			throw new $SyntaxError('StringCreate: a `proto` argument that is not `String.prototype` is not supported in an environment that does not support setting the [[Prototype]]');
		}
	}

	var length = value.length;
	DefinePropertyOrThrow(S, 'length', {
		'[[Configurable]]': false,
		'[[Enumerable]]': false,
		'[[Value]]': length,
		'[[Writable]]': false
	});

	return S;
};
'use strict';

var $TypeError = require('es-errors/type');

var callBound = require('call-bound');

var $SymbolToString = callBound('Symbol.prototype.toString', true);

// https://262.ecma-international.org/6.0/#sec-symboldescriptivestring

module.exports = function SymbolDescriptiveString(sym) {
	if (typeof sym !== 'symbol') {
		throw new $TypeError('Assertion failed: `sym` must be a Symbol');
	}
	return $SymbolToString(sym);
};
'use strict';

var $gOPD = require('gopd');
var $TypeError = require('es-errors/type');

var every = require('../helpers/every');
var OwnPropertyKeys = require('own-keys');
var isObject = require('es-object-atoms/isObject');

var IsDataDescriptor = require('./IsDataDescriptor');
var IsExtensible = require('./IsExtensible');
var ToPropertyDescriptor = require('./ToPropertyDescriptor');

// https://262.ecma-international.org/6.0/#sec-testintegritylevel

module.exports = function TestIntegrityLevel(O, level) {
	if (!isObject(O)) {
		throw new $TypeError('Assertion failed: Type(O) is not Object');
	}
	if (level !== 'sealed' && level !== 'frozen') {
		throw new $TypeError('Assertion failed: `level` must be `"sealed"` or `"frozen"`');
	}
	var status = IsExtensible(O);
	if (status || !$gOPD) {
		return false;
	}
	var theKeys = OwnPropertyKeys(O);
	return theKeys.length === 0 || every(theKeys, function (k) {
		var currentDesc = $gOPD(O, k);
		if (typeof currentDesc !== 'undefined') {
			if (currentDesc.configurable) {
				return false;
			}
			if (level === 'frozen' && IsDataDescriptor(ToPropertyDescriptor(currentDesc)) && currentDesc.writable) {
				return false;
			}
		}
		return true;
	});
};
'use strict';

var $BooleanValueOf = require('call-bound')('Boolean.prototype.valueOf');

// https://262.ecma-international.org/6.0/#sec-properties-of-the-boolean-prototype-object

module.exports = function thisBooleanValue(value) {
	if (typeof value === 'boolean') {
		return value;
	}

	return $BooleanValueOf(value);
};
'use strict';

var callBound = require('call-bound');

var $NumberValueOf = callBound('Number.prototype.valueOf');

// https://262.ecma-international.org/6.0/#sec-properties-of-the-number-prototype-object

module.exports = function thisNumberValue(value) {
	if (typeof value === 'number') {
		return value;
	}

	return $NumberValueOf(value);
};

'use strict';

var $StringValueOf = require('call-bound')('String.prototype.valueOf');

// https://262.ecma-international.org/6.0/#sec-properties-of-the-string-prototype-object

module.exports = function thisStringValue(value) {
	if (typeof value === 'string') {
		return value;
	}

	return $StringValueOf(value);
};
'use strict';

var timeValue = require('../helpers/timeValue');

// https://262.ecma-international.org/6.0/#sec-properties-of-the-date-prototype-object

module.exports = function thisTimeValue(value) {
	return timeValue(value);
};
'use strict';

var GetIntrinsic = require('get-intrinsic');

var $Date = GetIntrinsic('%Date%');

var $isFinite = require('math-intrinsics/isFinite');
var abs = require('math-intrinsics/abs');

var ToNumber = require('./ToNumber');

// https://262.ecma-international.org/5.1/#sec-15.9.1.14

module.exports = function TimeClip(time) {
	if (!$isFinite(time) || abs(time) > 8.64e15) {
		return NaN;
	}
	return +new $Date(ToNumber(time));
};

'use strict';

var msPerDay = require('../helpers/timeConstants').msPerDay;

var DayFromYear = require('./DayFromYear');

// https://262.ecma-international.org/5.1/#sec-15.9.1.3

module.exports = function TimeFromYear(y) {
	return msPerDay * DayFromYear(y);
};
'use strict';

var modulo = require('./modulo');

var msPerDay = require('../helpers/timeConstants').msPerDay;

// https://262.ecma-international.org/5.1/#sec-15.9.1.2

module.exports = function TimeWithinDay(t) {
	return modulo(t, msPerDay);
};

'use strict';

// http://262.ecma-international.org/5.1/#sec-9.2

module.exports = function ToBoolean(value) { return !!value; };
'use strict';

var GetIntrinsic = require('get-intrinsic');

var $TypeError = require('es-errors/type');
var $Date = GetIntrinsic('%Date%');
var $String = GetIntrinsic('%String%');

var $isNaN = require('math-intrinsics/isNaN');

// https://262.ecma-international.org/6.0/#sec-todatestring

module.exports = function ToDateString(tv) {
	if (typeof tv !== 'number') {
		throw new $TypeError('Assertion failed: `tv` must be a Number');
	}
	if ($isNaN(tv)) {
		return 'Invalid Date';
	}
	return $String(new $Date(tv));
};
'use strict';

var ToUint16 = require('./ToUint16');

// https://262.ecma-international.org/6.0/#sec-toint16

module.exports = function ToInt16(argument) {
	var int16bit = ToUint16(argument);
	return int16bit >= 0x8000 ? int16bit - 0x10000 : int16bit;
};
'use strict';

var ToNumber = require('./ToNumber');

// http://262.ecma-international.org/5.1/#sec-9.5

module.exports = function ToInt32(x) {
	return ToNumber(x) >> 0;
};
'use strict';

var ToUint8 = require('./ToUint8');

// https://262.ecma-international.org/6.0/#sec-toint8

module.exports = function ToInt8(argument) {
	var int8bit = ToUint8(argument);
	return int8bit >= 0x80 ? int8bit - 0x100 : int8bit;
};
'use strict';

var ES5ToInteger = require('../5/ToInteger');

var ToNumber = require('./ToNumber');

// https://262.ecma-international.org/6.0/#sec-tointeger

module.exports = function ToInteger(value) {
	var number = ToNumber(value);
	return ES5ToInteger(number);
};
'use strict';

var MAX_SAFE_INTEGER = require('math-intrinsics/constants/maxSafeInteger');

var ToInteger = require('./ToInteger');

// https://262.ecma-international.org/6.0/#sec-tolength

module.exports = function ToLength(argument) {
	var len = ToInteger(argument);
	if (len <= 0) { return 0; } // includes converting -0 to +0
	if (len > MAX_SAFE_INTEGER) { return MAX_SAFE_INTEGER; }
	return len;
};
'use strict';

var GetIntrinsic = require('get-intrinsic');

var $TypeError = require('es-errors/type');
var $Number = GetIntrinsic('%Number%');
var $RegExp = GetIntrinsic('%RegExp%');
var $parseInteger = GetIntrinsic('%parseInt%');

var callBound = require('call-bound');
var regexTester = require('safe-regex-test');
var isPrimitive = require('../helpers/isPrimitive');

var $strSlice = callBound('String.prototype.slice');
var isBinary = regexTester(/^0b[01]+$/i);
var isOctal = regexTester(/^0o[0-7]+$/i);
var isInvalidHexLiteral = regexTester(/^[-+]0x[0-9a-f]+$/i);
var nonWS = ['\u0085', '\u200b', '\ufffe'].join('');
var nonWSregex = new $RegExp('[' + nonWS + ']', 'g');
var hasNonWS = regexTester(nonWSregex);

var $trim = require('string.prototype.trim');

var ToPrimitive = require('./ToPrimitive');

// https://262.ecma-international.org/6.0/#sec-tonumber

module.exports = function ToNumber(argument) {
	var value = isPrimitive(argument) ? argument : ToPrimitive(argument, $Number);
	if (typeof value === 'symbol') {
		throw new $TypeError('Cannot convert a Symbol value to a number');
	}
	if (typeof value === 'string') {
		if (isBinary(value)) {
			return ToNumber($parseInteger($strSlice(value, 2), 2));
		} else if (isOctal(value)) {
			return ToNumber($parseInteger($strSlice(value, 2), 8));
		} else if (hasNonWS(value) || isInvalidHexLiteral(value)) {
			return NaN;
		}
		var trimmed = $trim(value);
		if (trimmed !== value) {
			return ToNumber(trimmed);
		}

	}
	return +value;
};
'use strict';

// https://262.ecma-international.org/6.0/#sec-toobject

module.exports = require('es-object-atoms/ToObject');
'use strict';

var toPrimitive = require('es-to-primitive/es2015');

// https://262.ecma-international.org/6.0/#sec-toprimitive

module.exports = function ToPrimitive(input) {
	if (arguments.length > 1) {
		return toPrimitive(input, arguments[1]);
	}
	return toPrimitive(input);
};
'use strict';

var hasOwn = require('hasown');

var $TypeError = require('es-errors/type');
var isObject = require('es-object-atoms/isObject');

var IsCallable = require('./IsCallable');
var ToBoolean = require('./ToBoolean');

// https://262.ecma-international.org/5.1/#sec-8.10.5

module.exports = function ToPropertyDescriptor(Obj) {
	if (!isObject(Obj)) {
		throw new $TypeError('ToPropertyDescriptor requires an object');
	}

	var desc = {};
	if (hasOwn(Obj, 'enumerable')) {
		desc['[[Enumerable]]'] = ToBoolean(Obj.enumerable);
	}
	if (hasOwn(Obj, 'configurable')) {
		desc['[[Configurable]]'] = ToBoolean(Obj.configurable);
	}
	if (hasOwn(Obj, 'value')) {
		desc['[[Value]]'] = Obj.value;
	}
	if (hasOwn(Obj, 'writable')) {
		desc['[[Writable]]'] = ToBoolean(Obj.writable);
	}
	if (hasOwn(Obj, 'get')) {
		var getter = Obj.get;
		if (typeof getter !== 'undefined' && !IsCallable(getter)) {
			throw new $TypeError('getter must be a function');
		}
		desc['[[Get]]'] = getter;
	}
	if (hasOwn(Obj, 'set')) {
		var setter = Obj.set;
		if (typeof setter !== 'undefined' && !IsCallable(setter)) {
			throw new $TypeError('setter must be a function');
		}
		desc['[[Set]]'] = setter;
	}

	if ((hasOwn(desc, '[[Get]]') || hasOwn(desc, '[[Set]]')) && (hasOwn(desc, '[[Value]]') || hasOwn(desc, '[[Writable]]'))) {
		throw new $TypeError('Invalid property descriptor. Cannot both specify accessors and a value or writable attribute');
	}
	return desc;
};
'use strict';

var GetIntrinsic = require('get-intrinsic');

var $String = GetIntrinsic('%String%');

var ToPrimitive = require('./ToPrimitive');
var ToString = require('./ToString');

// https://262.ecma-international.org/6.0/#sec-topropertykey

module.exports = function ToPropertyKey(argument) {
	var key = ToPrimitive(argument, $String);
	return typeof key === 'symbol' ? key : ToString(key);
};
'use strict';

var GetIntrinsic = require('get-intrinsic');

var $String = GetIntrinsic('%String%');
var $TypeError = require('es-errors/type');

// https://262.ecma-international.org/6.0/#sec-tostring

module.exports = function ToString(argument) {
	if (typeof argument === 'symbol') {
		throw new $TypeError('Cannot convert a Symbol value to a string');
	}
	return $String(argument);
};
'use strict';

var modulo = require('./modulo');
var ToNumber = require('./ToNumber');

var abs = require('math-intrinsics/abs');
var floor = require('math-intrinsics/floor');
var $isNaN = require('math-intrinsics/isNaN');
var $isFinite = require('math-intrinsics/isFinite');
var $sign = require('math-intrinsics/sign');

// http://262.ecma-international.org/5.1/#sec-9.7

module.exports = function ToUint16(value) {
	var number = ToNumber(value);
	if ($isNaN(number) || number === 0 || !$isFinite(number)) { return 0; }
	var posInt = $sign(number) * floor(abs(number));
	return modulo(posInt, 0x10000);
};
'use strict';

var ToNumber = require('./ToNumber');

// http://262.ecma-international.org/5.1/#sec-9.6

module.exports = function ToUint32(x) {
	return ToNumber(x) >>> 0;
};
'use strict';

var ToNumber = require('./ToNumber');
var floor = require('./floor');

var $isNaN = require('math-intrinsics/isNaN');

// https://262.ecma-international.org/6.0/#sec-touint8clamp

module.exports = function ToUint8Clamp(argument) {
	var number = ToNumber(argument);
	if ($isNaN(number) || number <= 0) { return 0; }
	if (number >= 0xFF) { return 0xFF; }
	var f = floor(number);
	if (f + 0.5 < number) { return f + 1; }
	if (number < f + 0.5) { return f; }
	if (f % 2 !== 0) { return f + 1; }
	return f;
};
'use strict';

var ToNumber = require('./ToNumber');

var $isNaN = require('math-intrinsics/isNaN');
var $isFinite = require('math-intrinsics/isFinite');
var $sign = require('math-intrinsics/sign');
var abs = require('math-intrinsics/abs');
var floor = require('math-intrinsics/floor');
var modulo = require('math-intrinsics/mod');

// https://262.ecma-international.org/6.0/#sec-touint8

module.exports = function ToUint8(argument) {
	var number = ToNumber(argument);
	if ($isNaN(number) || number === 0 || !$isFinite(number)) { return 0; }
	var posInt = $sign(number) * floor(abs(number));
	return modulo(posInt, 0x100);
};
'use strict';

var $SyntaxError = require('es-errors/syntax');
var $TypeError = require('es-errors/type');

var IsArray = require('./IsArray');
var IsConstructor = require('./IsConstructor');
var ValidateTypedArray = require('./ValidateTypedArray');

var availableTypedArrays = require('available-typed-arrays')();
var typedArrayLength = require('typed-array-length');

// https://262.ecma-international.org/7.0/#typedarray-create

module.exports = function TypedArrayCreate(constructor, argumentList) {
	if (!IsConstructor(constructor)) {
		throw new $TypeError('Assertion failed: `constructor` must be a constructor');
	}
	if (!IsArray(argumentList)) {
		throw new $TypeError('Assertion failed: `argumentList` must be a List');
	}
	if (availableTypedArrays.length === 0) {
		throw new $SyntaxError('Assertion failed: Typed Arrays are not supported in this environment');
	}

	// var newTypedArray = Construct(constructor, argumentList); // step 1
	var newTypedArray;
	if (argumentList.length === 0) {
		newTypedArray = new constructor();
	} else if (argumentList.length === 1) {
		newTypedArray = new constructor(argumentList[0]);
	} else if (argumentList.length === 2) {
		newTypedArray = new constructor(argumentList[0], argumentList[1]);
	} else {
		newTypedArray = new constructor(argumentList[0], argumentList[1], argumentList[2]);
	}

	ValidateTypedArray(newTypedArray); // step 2

	if (argumentList.length === 1 && typeof argumentList[0] === 'number') { // step 3
		if (typedArrayLength(newTypedArray) < argumentList[0]) {
			throw new $TypeError('Assertion failed: `argumentList[0]` must be <= `newTypedArray.length`'); // step 3.a
		}
	}

	return newTypedArray; // step 4
};
'use strict';

var $SyntaxError = require('es-errors/syntax');
var $TypeError = require('es-errors/type');

var whichTypedArray = require('which-typed-array');
var availableTypedArrays = require('available-typed-arrays')();

var IsArray = require('./IsArray');
var SpeciesConstructor = require('./SpeciesConstructor');
var TypedArrayCreate = require('./TypedArrayCreate');

var getConstructor = require('../helpers/typedArrayConstructors');

// https://262.ecma-international.org/7.0/#typedarray-species-create

module.exports = function TypedArraySpeciesCreate(exemplar, argumentList) {
	if (availableTypedArrays.length === 0) {
		throw new $SyntaxError('Assertion failed: Typed Arrays are not supported in this environment');
	}

	var kind = whichTypedArray(exemplar);
	if (!kind) {
		throw new $TypeError('Assertion failed: exemplar must be a TypedArray'); // step 1
	}
	if (!IsArray(argumentList)) {
		throw new $TypeError('Assertion failed: `argumentList` must be a List'); // step 1
	}

	var defaultConstructor = getConstructor(kind); // step 2
	if (typeof defaultConstructor !== 'function') {
		throw new $SyntaxError('Assertion failed: `constructor` of `exemplar` (' + kind + ') must exist. Please report this!');
	}
	var constructor = SpeciesConstructor(exemplar, defaultConstructor); // step 3

	return TypedArrayCreate(constructor, argumentList); // step 4
};
'use strict';

var ES5Type = require('../5/Type');

// https://262.ecma-international.org/6.0/#sec-ecmascript-data-types-and-values

module.exports = function Type(x) {
	if (typeof x === 'symbol') {
		return 'Symbol';
	}
	return ES5Type(x);
};
'use strict';

var GetIntrinsic = require('get-intrinsic');

var $TypeError = require('es-errors/type');
var $fromCharCode = GetIntrinsic('%String.fromCharCode%');

// https://262.ecma-international.org/7.0/#sec-utf16decode

var isLeadingSurrogate = require('../helpers/isLeadingSurrogate');
var isTrailingSurrogate = require('../helpers/isTrailingSurrogate');

// https://262.ecma-international.org/11.0/#sec-utf16decodesurrogatepair

module.exports = function UTF16Decode(lead, trail) {
	if (!isLeadingSurrogate(lead) || !isTrailingSurrogate(trail)) {
		throw new $TypeError('Assertion failed: `lead` must be a leading surrogate char code, and `trail` must be a trailing surrogate char code');
	}
	// var cp = (lead - 0xD800) * 0x400 + (trail - 0xDC00) + 0x10000;
	return $fromCharCode(lead) + $fromCharCode(trail);
};
'use strict';

var GetIntrinsic = require('get-intrinsic');

var $TypeError = require('es-errors/type');
var $fromCharCode = GetIntrinsic('%String.fromCharCode%');

var floor = require('./floor');
var modulo = require('./modulo');

var isCodePoint = require('../helpers/isCodePoint');

// https://262.ecma-international.org/7.0/#sec-utf16encoding

module.exports = function UTF16Encoding(cp) {
	if (!isCodePoint(cp)) {
		throw new $TypeError('Assertion failed: `cp` must be >= 0 and <= 0x10FFFF');
	}
	if (cp <= 65535) {
		return $fromCharCode(cp);
	}
	var cu1 = $fromCharCode(floor((cp - 65536) / 1024) + 0xD800);
	var cu2 = $fromCharCode(modulo(cp - 65536, 1024) + 0xDC00);
	return cu1 + cu2;
};
'use strict';

var $TypeError = require('es-errors/type');
var isObject = require('es-object-atoms/isObject');

var DefineOwnProperty = require('../helpers/DefineOwnProperty');
var isPropertyDescriptor = require('../helpers/records/property-descriptor');
var isSamePropertyDescriptor = require('../helpers/isSamePropertyDescriptor');

var FromPropertyDescriptor = require('./FromPropertyDescriptor');
var IsAccessorDescriptor = require('./IsAccessorDescriptor');
var IsDataDescriptor = require('./IsDataDescriptor');
var IsGenericDescriptor = require('./IsGenericDescriptor');
var isPropertyKey = require('../helpers/isPropertyKey');
var SameValue = require('./SameValue');

// https://262.ecma-international.org/6.0/#sec-validateandapplypropertydescriptor
// https://262.ecma-international.org/8.0/#sec-validateandapplypropertydescriptor

// eslint-disable-next-line max-lines-per-function, max-statements
module.exports = function ValidateAndApplyPropertyDescriptor(O, P, extensible, Desc, current) {
	// this uses the ES2017+ logic, since it fixes a number of bugs in the ES2015 logic.
	if (typeof O !== 'undefined' && !isObject(O)) {
		throw new $TypeError('Assertion failed: O must be undefined or an Object');
	}
	if (typeof extensible !== 'boolean') {
		throw new $TypeError('Assertion failed: extensible must be a Boolean');
	}
	if (!isPropertyDescriptor(Desc)) {
		throw new $TypeError('Assertion failed: Desc must be a Property Descriptor');
	}
	if (typeof current !== 'undefined' && !isPropertyDescriptor(current)) {
		throw new $TypeError('Assertion failed: current must be a Property Descriptor, or undefined');
	}
	if (typeof O !== 'undefined' && !isPropertyKey(P)) {
		throw new $TypeError('Assertion failed: if O is not undefined, P must be a Property Key');
	}
	if (typeof current === 'undefined') {
		if (!extensible) {
			return false;
		}
		if (IsGenericDescriptor(Desc) || IsDataDescriptor(Desc)) {
			if (typeof O !== 'undefined') {
				DefineOwnProperty(
					IsDataDescriptor,
					SameValue,
					FromPropertyDescriptor,
					O,
					P,
					{
						'[[Configurable]]': Desc['[[Configurable]]'],
						'[[Enumerable]]': Desc['[[Enumerable]]'],
						'[[Value]]': Desc['[[Value]]'],
						'[[Writable]]': Desc['[[Writable]]']
					}
				);
			}
		} else {
			if (!IsAccessorDescriptor(Desc)) {
				throw new $TypeError('Assertion failed: Desc is not an accessor descriptor');
			}
			if (typeof O !== 'undefined') {
				return DefineOwnProperty(
					IsDataDescriptor,
					SameValue,
					FromPropertyDescriptor,
					O,
					P,
					Desc
				);
			}
		}
		return true;
	}
	if (IsGenericDescriptor(Desc) && !('[[Configurable]]' in Desc) && !('[[Enumerable]]' in Desc)) {
		return true;
	}
	if (isSamePropertyDescriptor({ SameValue: SameValue }, Desc, current)) {
		return true; // removed by ES2017, but should still be correct
	}
	// "if every field in Desc is absent, return true" can't really match the assertion that it's a Property Descriptor
	if (!current['[[Configurable]]']) {
		if (Desc['[[Configurable]]']) {
			return false;
		}
		if ('[[Enumerable]]' in Desc && !Desc['[[Enumerable]]'] === !!current['[[Enumerable]]']) {
			return false;
		}
	}
	if (IsGenericDescriptor(Desc)) {
		// no further validation is required.
	} else if (IsDataDescriptor(current) !== IsDataDescriptor(Desc)) {
		if (!current['[[Configurable]]']) {
			return false;
		}
		if (IsDataDescriptor(current)) {
			if (typeof O !== 'undefined') {
				DefineOwnProperty(
					IsDataDescriptor,
					SameValue,
					FromPropertyDescriptor,
					O,
					P,
					{
						'[[Configurable]]': current['[[Configurable]]'],
						'[[Enumerable]]': current['[[Enumerable]]'],
						'[[Get]]': undefined
					}
				);
			}
		} else if (typeof O !== 'undefined') {
			DefineOwnProperty(
				IsDataDescriptor,
				SameValue,
				FromPropertyDescriptor,
				O,
				P,
				{
					'[[Configurable]]': current['[[Configurable]]'],
					'[[Enumerable]]': current['[[Enumerable]]'],
					'[[Value]]': undefined
				}
			);
		}
	} else if (IsDataDescriptor(current) && IsDataDescriptor(Desc)) {
		if (!current['[[Configurable]]'] && !current['[[Writable]]']) {
			if ('[[Writable]]' in Desc && Desc['[[Writable]]']) {
				return false;
			}
			if ('[[Value]]' in Desc && !SameValue(Desc['[[Value]]'], current['[[Value]]'])) {
				return false;
			}
			return true;
		}
	} else if (IsAccessorDescriptor(current) && IsAccessorDescriptor(Desc)) {
		if (!current['[[Configurable]]']) {
			if ('[[Set]]' in Desc && !SameValue(Desc['[[Set]]'], current['[[Set]]'])) {
				return false;
			}
			if ('[[Get]]' in Desc && !SameValue(Desc['[[Get]]'], current['[[Get]]'])) {
				return false;
			}
			return true;
		}
	} else {
		throw new $TypeError('Assertion failed: current and Desc are not both data, both accessors, or one accessor and one data.');
	}
	if (typeof O !== 'undefined') {
		return DefineOwnProperty(
			IsDataDescriptor,
			SameValue,
			FromPropertyDescriptor,
			O,
			P,
			Desc
		);
	}
	return true;
};
'use strict';

var $TypeError = require('es-errors/type');
var isObject = require('es-object-atoms/isObject');

var IsDetachedBuffer = require('./IsDetachedBuffer');

var isTypedArray = require('is-typed-array');
var typedArrayBuffer = require('typed-array-buffer');

// https://262.ecma-international.org/6.0/#sec-validatetypedarray

module.exports = function ValidateTypedArray(O) {
	if (!isObject(O)) {
		throw new $TypeError('Assertion failed: `O` must be an Object'); // step 1
	}
	if (!isTypedArray(O)) {
		throw new $TypeError('Assertion failed: `O` must be a Typed Array'); // steps 2 - 3
	}

	var buffer = typedArrayBuffer(O); // step 4

	if (IsDetachedBuffer(buffer)) {
		throw new $TypeError('`O` must be backed by a non-detached buffer'); // step 5
	}

	return buffer; // step 6
};
'use strict';

var Day = require('./Day');
var modulo = require('./modulo');

// https://262.ecma-international.org/5.1/#sec-15.9.1.6

module.exports = function WeekDay(t) {
	return modulo(Day(t) + 4, 7);
};
'use strict';

var GetIntrinsic = require('get-intrinsic');

var $Date = GetIntrinsic('%Date%');

var callBound = require('call-bound');

var $getUTCFullYear = callBound('Date.prototype.getUTCFullYear');

// https://262.ecma-international.org/5.1/#sec-15.9.1.3

module.exports = function YearFromTime(t) {
	// largest y such that this.TimeFromYear(y) <= t
	return $getUTCFullYear(new $Date(t));
};
'use strict';

var $abs = require('math-intrinsics/abs');

// https://262.ecma-international.org/5.1/#sec-5.2

module.exports = function abs(x) {
	return $abs(x);
};
'use strict';

var ToNumber = require('./ToNumber');
var ToPrimitive = require('./ToPrimitive');

var isSameType = require('../helpers/isSameType');

var isObject = require('es-object-atoms/isObject');

// https://262.ecma-international.org/6.0/#sec-abstract-equality-comparison

module.exports = function AbstractEqualityComparison(x, y) {
	if (isSameType(x, y)) {
		return x === y; // ES6+ specified this shortcut anyways.
	}
	if (x == null && y == null) {
		return true;
	}
	if (typeof x === 'number' && typeof y === 'string') {
		return AbstractEqualityComparison(x, ToNumber(y));
	}
	if (typeof x === 'string' && typeof y === 'number') {
		return AbstractEqualityComparison(ToNumber(x), y);
	}
	if (typeof x === 'boolean') {
		return AbstractEqualityComparison(ToNumber(x), y);
	}
	if (typeof y === 'boolean') {
		return AbstractEqualityComparison(x, ToNumber(y));
	}
	if ((typeof x === 'string' || typeof x === 'number' || typeof x === 'symbol') && isObject(y)) {
		return AbstractEqualityComparison(x, ToPrimitive(y));
	}
	if (isObject(x) && (typeof y === 'string' || typeof y === 'number' || typeof y === 'symbol')) {
		return AbstractEqualityComparison(ToPrimitive(x), y);
	}
	return false;
};
'use strict';

var GetIntrinsic = require('get-intrinsic');

var $Number = GetIntrinsic('%Number%');
var $TypeError = require('es-errors/type');
var $isNaN = require('math-intrinsics/isNaN');
var $isFinite = require('math-intrinsics/isFinite');

var isPrefixOf = require('../helpers/isPrefixOf');

var ToNumber = require('./ToNumber');
var ToPrimitive = require('./ToPrimitive');

// https://262.ecma-international.org/5.1/#sec-11.8.5

// eslint-disable-next-line max-statements
module.exports = function AbstractRelationalComparison(x, y, LeftFirst) {
	if (typeof LeftFirst !== 'boolean') {
		throw new $TypeError('Assertion failed: LeftFirst argument must be a Boolean');
	}
	var px;
	var py;
	if (LeftFirst) {
		px = ToPrimitive(x, $Number);
		py = ToPrimitive(y, $Number);
	} else {
		py = ToPrimitive(y, $Number);
		px = ToPrimitive(x, $Number);
	}
	var bothStrings = typeof px === 'string' && typeof py === 'string';
	if (!bothStrings) {
		var nx = ToNumber(px);
		var ny = ToNumber(py);
		if ($isNaN(nx) || $isNaN(ny)) {
			return undefined;
		}
		if ($isFinite(nx) && $isFinite(ny) && nx === ny) {
			return false;
		}
		if (nx === Infinity) {
			return false;
		}
		if (ny === Infinity) {
			return true;
		}
		if (ny === -Infinity) {
			return false;
		}
		if (nx === -Infinity) {
			return true;
		}
		return nx < ny; // by now, these are both nonzero, finite, and not equal
	}
	if (isPrefixOf(py, px)) {
		return false;
	}
	if (isPrefixOf(px, py)) {
		return true;
	}
	return px < py; // both strings, neither a prefix of the other. shortcut for steps c-f
};
'use strict';

var isInteger = require('math-intrinsics/isInteger');
var MAX_SAFE_INTEGER = require('math-intrinsics/constants/maxSafeInteger');

var isLeadingSurrogate = require('../helpers/isLeadingSurrogate');
var isTrailingSurrogate = require('../helpers/isTrailingSurrogate');

var $TypeError = require('es-errors/type');

var $charCodeAt = require('call-bound')('String.prototype.charCodeAt');

// https://262.ecma-international.org/6.0/#sec-advancestringindex

module.exports = function AdvanceStringIndex(S, index, unicode) {
	if (typeof S !== 'string') {
		throw new $TypeError('Assertion failed: `S` must be a String');
	}
	if (!isInteger(index) || index < 0 || index > MAX_SAFE_INTEGER) {
		throw new $TypeError('Assertion failed: `length` must be an integer >= 0 and <= 2**53');
	}
	if (typeof unicode !== 'boolean') {
		throw new $TypeError('Assertion failed: `unicode` must be a Boolean');
	}
	if (!unicode) {
		return index + 1;
	}
	var length = S.length;
	if ((index + 1) >= length) {
		return index + 1;
	}

	var first = $charCodeAt(S, index);
	if (!isLeadingSurrogate(first)) {
		return index + 1;
	}

	var second = $charCodeAt(S, index + 1);
	if (!isTrailingSurrogate(second)) {
		return index + 1;
	}

	return index + 2;
};
'use strict';

var GetIntrinsic = require('get-intrinsic');

var $ArrayPrototype = GetIntrinsic('%Array.prototype%');
var $RangeError = require('es-errors/range');
var $SyntaxError = require('es-errors/syntax');
var $TypeError = require('es-errors/type');
var isInteger = require('math-intrinsics/isInteger');
var MAX_ARRAY_LENGTH = require('math-intrinsics/constants/maxArrayLength');
var $setProto = require('set-proto');

// https://262.ecma-international.org/6.0/#sec-arraycreate

module.exports = function ArrayCreate(length) {
	if (!isInteger(length) || length < 0) {
		throw new $TypeError('Assertion failed: `length` must be an integer Number >= 0');
	}
	if (length > MAX_ARRAY_LENGTH) {
		throw new $RangeError('length is greater than (2**32 - 1)');
	}
	var proto = arguments.length > 1 ? arguments[1] : $ArrayPrototype;
	var A = []; // steps 5 - 7, and 9
	if (proto !== $ArrayPrototype) { // step 8
		if (!$setProto) {
			throw new $SyntaxError('ArrayCreate: a `proto` argument that is not `Array.prototype` is not supported in an environment that does not support setting the [[Prototype]]');
		}
		$setProto(A, proto);
	}
	if (length !== 0) { // bypasses the need for step 2
		A.length = length;
	}
	/* step 10, the above as a shortcut for the below
	OrdinaryDefineOwnProperty(A, 'length', {
		'[[Configurable]]': false,
		'[[Enumerable]]': false,
		'[[Value]]': length,
		'[[Writable]]': true
	});
	*/
	return A;
};
'use strict';

var $RangeError = require('es-errors/range');
var $TypeError = require('es-errors/type');

var assign = require('object.assign');

var isPropertyDescriptor = require('../helpers/records/property-descriptor');

var IsArray = require('./IsArray');
var IsDataDescriptor = require('./IsDataDescriptor');
var OrdinaryDefineOwnProperty = require('./OrdinaryDefineOwnProperty');
var OrdinaryGetOwnProperty = require('./OrdinaryGetOwnProperty');
var ToNumber = require('./ToNumber');
var ToString = require('./ToString');
var ToUint32 = require('./ToUint32');

// https://262.ecma-international.org/6.0/#sec-arraysetlength

// eslint-disable-next-line max-statements, max-lines-per-function
module.exports = function ArraySetLength(A, Desc) {
	if (!IsArray(A)) {
		throw new $TypeError('Assertion failed: A must be an Array');
	}
	if (!isPropertyDescriptor(Desc)) {
		throw new $TypeError('Assertion failed: Desc must be a Property Descriptor');
	}
	if (!('[[Value]]' in Desc)) {
		return OrdinaryDefineOwnProperty(A, 'length', Desc);
	}
	var newLenDesc = assign({}, Desc);
	var newLen = ToUint32(Desc['[[Value]]']);
	var numberLen = ToNumber(Desc['[[Value]]']);
	if (newLen !== numberLen) {
		throw new $RangeError('Invalid array length');
	}
	newLenDesc['[[Value]]'] = newLen;
	var oldLenDesc = OrdinaryGetOwnProperty(A, 'length');
	if (!IsDataDescriptor(oldLenDesc)) {
		throw new $TypeError('Assertion failed: an array had a non-data descriptor on `length`');
	}
	var oldLen = oldLenDesc['[[Value]]'];
	if (newLen >= oldLen) {
		return OrdinaryDefineOwnProperty(A, 'length', newLenDesc);
	}
	if (!oldLenDesc['[[Writable]]']) {
		return false;
	}
	var newWritable;
	if (!('[[Writable]]' in newLenDesc) || newLenDesc['[[Writable]]']) {
		newWritable = true;
	} else {
		newWritable = false;
		newLenDesc['[[Writable]]'] = true;
	}
	var succeeded = OrdinaryDefineOwnProperty(A, 'length', newLenDesc);
	if (!succeeded) {
		return false;
	}
	while (newLen < oldLen) {
		oldLen -= 1;
		// eslint-disable-next-line no-param-reassign
		var deleteSucceeded = delete A[ToString(oldLen)];
		if (!deleteSucceeded) {
			newLenDesc['[[Value]]'] = oldLen + 1;
			if (!newWritable) {
				newLenDesc['[[Writable]]'] = false;
				OrdinaryDefineOwnProperty(A, 'length', newLenDesc);
				return false;
			}
		}
	}
	if (!newWritable) {
		return OrdinaryDefineOwnProperty(A, 'length', { '[[Writable]]': false });
	}
	return true;
};
'use strict';

var GetIntrinsic = require('get-intrinsic');

var $Array = GetIntrinsic('%Array%');
var $species = GetIntrinsic('%Symbol.species%', true);
var $TypeError = require('es-errors/type');
var isInteger = require('math-intrinsics/isInteger');
var isObject = require('es-object-atoms/isObject');

var Get = require('./Get');
var IsArray = require('./IsArray');
var IsConstructor = require('./IsConstructor');

// https://262.ecma-international.org/6.0/#sec-arrayspeciescreate

module.exports = function ArraySpeciesCreate(originalArray, length) {
	if (!isInteger(length) || length < 0) {
		throw new $TypeError('Assertion failed: length must be an integer >= 0');
	}
	var len = length === 0 ? 0 : length;
	var C;
	var isArray = IsArray(originalArray);
	if (isArray) {
		C = Get(originalArray, 'constructor');
		// TODO: figure out how to make a cross-realm normal Array, a same-realm Array
		// if (IsConstructor(C)) {
		// 	if C is another realm's Array, C = undefined
		// 	Object.getPrototypeOf(Object.getPrototypeOf(Object.getPrototypeOf(Array))) === null ?
		// }
		if ($species && isObject(C)) {
			C = Get(C, $species);
			if (C === null) {
				C = void 0;
			}
		}
	}
	if (typeof C === 'undefined') {
		return $Array(len);
	}
	if (!IsConstructor(C)) {
		throw new $TypeError('C must be a constructor');
	}
	return new C(len); // Construct(C, len);
};

'use strict';

var GetIntrinsic = require('get-intrinsic');
var callBound = require('call-bound');

var $TypeError = require('es-errors/type');

var IsArray = require('./IsArray');

var $apply = GetIntrinsic('%Reflect.apply%', true) || callBound('Function.prototype.apply');

// https://262.ecma-international.org/6.0/#sec-call

module.exports = function Call(F, V) {
	var argumentsList = arguments.length > 2 ? arguments[2] : [];
	if (!IsArray(argumentsList)) {
		throw new $TypeError('Assertion failed: optional `argumentsList`, if provided, must be a List');
	}
	return $apply(F, V, argumentsList);
};
'use strict';

var $TypeError = require('es-errors/type');

var callBound = require('call-bound');
var hasOwn = require('hasown');

var $charCodeAt = callBound('String.prototype.charCodeAt');
var $toUpperCase = callBound('String.prototype.toUpperCase');

var caseFolding = require('../helpers/caseFolding.json');

// https://262.ecma-international.org/6.0/#sec-runtime-semantics-canonicalize-ch

module.exports = function Canonicalize(ch, IgnoreCase, Unicode) {
	if (typeof ch !== 'string') {
		throw new $TypeError('Assertion failed: `ch` must be a character');
	}

	if (typeof IgnoreCase !== 'boolean' || typeof Unicode !== 'boolean') {
		throw new $TypeError('Assertion failed: `IgnoreCase` and `Unicode` must be Booleans');
	}

	if (!IgnoreCase) {
		return ch; // step 1
	}

	if (Unicode) { // step 2
		if (hasOwn(caseFolding.C, ch)) {
			return caseFolding.C[ch];
		}
		if (hasOwn(caseFolding.S, ch)) {
			return caseFolding.S[ch];
		}
		return ch; // step 2.b
	}

	var u = $toUpperCase(ch); // step 2

	if (u.length !== 1) {
		return ch; // step 3
	}

	var cu = u; // step 4

	if ($charCodeAt(ch, 0) >= 128 && $charCodeAt(cu, 0) < 128) {
		return ch; // step 5
	}

	return cu;
};
'use strict';

var $TypeError = require('es-errors/type');

var SameValue = require('./SameValue');
var ToNumber = require('./ToNumber');
var ToString = require('./ToString');

// https://262.ecma-international.org/6.0/#sec-canonicalnumericindexstring

module.exports = function CanonicalNumericIndexString(argument) {
	if (typeof argument !== 'string') {
		throw new $TypeError('Assertion failed: `argument` must be a String');
	}
	if (argument === '-0') { return -0; }
	var n = ToNumber(argument);
	if (SameValue(ToString(n), argument)) { return n; }
	return void 0;
};
'use strict';

var GetIntrinsic = require('get-intrinsic');
var callBound = require('call-bound');

var $fromCharCode = GetIntrinsic('%String.fromCharCode%');
var $TypeError = require('es-errors/type');
var $charCodeAt = callBound('String.prototype.charCodeAt');

var CharSet = require('../helpers/CharSet').CharSet;

module.exports = function CharacterRange(A, B) {
	var a;
	var b;

	if (A instanceof CharSet || B instanceof CharSet) {
		if (!(A instanceof CharSet) || !(B instanceof CharSet)) {
			throw new $TypeError('Assertion failed: CharSets A and B are not both CharSets');
		}

		A.yield(function (c) {
			if (typeof a !== 'undefined') {
				throw new $TypeError('Assertion failed: CharSet A has more than one character');
			}
			a = c;
		});
		B.yield(function (c) {
			if (typeof b !== 'undefined') {
				throw new $TypeError('Assertion failed: CharSet B has more than one character');
			}
			b = c;
		});
	} else {
		if (A.length !== 1 || B.length !== 1) {
			throw new $TypeError('Assertion failed: CharSets A and B contain exactly one character');
		}
		a = A[0];
		b = B[0];
	}

	var i = $charCodeAt(a, 0);
	var j = $charCodeAt(b, 0);

	if (!(i <= j)) {
		throw new $TypeError('Assertion failed: i is not <= j');
	}

	var arr = [];
	for (var k = i; k <= j; k += 1) {
		arr[arr.length] = $fromCharCode(k);
	}
	return arr;
};
'use strict';

var $TypeError = require('es-errors/type');

var hasOwn = require('hasown');

var IsDataDescriptor = require('./IsDataDescriptor');
var IsGenericDescriptor = require('./IsGenericDescriptor');

var isPropertyDescriptor = require('../helpers/records/property-descriptor');

// https://262.ecma-international.org/6.0/#sec-completepropertydescriptor

module.exports = function CompletePropertyDescriptor(Desc) {
	if (!isPropertyDescriptor(Desc)) {
		throw new $TypeError('Assertion failed: `Desc` must be a Property Descriptor');
	}

	/* eslint no-param-reassign: 0 */

	if (IsGenericDescriptor(Desc) || IsDataDescriptor(Desc)) {
		if (!hasOwn(Desc, '[[Value]]')) {
			Desc['[[Value]]'] = void 0;
		}
		if (!hasOwn(Desc, '[[Writable]]')) {
			Desc['[[Writable]]'] = false;
		}
	} else {
		if (!hasOwn(Desc, '[[Get]]')) {
			Desc['[[Get]]'] = void 0;
		}
		if (!hasOwn(Desc, '[[Set]]')) {
			Desc['[[Set]]'] = void 0;
		}
	}
	if (!hasOwn(Desc, '[[Enumerable]]')) {
		Desc['[[Enumerable]]'] = false;
	}
	if (!hasOwn(Desc, '[[Configurable]]')) {
		Desc['[[Configurable]]'] = false;
	}
	return Desc;
};
'use strict';

var $SyntaxError = require('es-errors/syntax');

var SLOT = require('internal-slot');

// https://262.ecma-international.org/7.0/#sec-completion-record-specification-type

var CompletionRecord = function CompletionRecord(type, value) {
	if (!(this instanceof CompletionRecord)) {
		return new CompletionRecord(type, value);
	}
	if (type !== 'normal' && type !== 'break' && type !== 'continue' && type !== 'return' && type !== 'throw') {
		throw new $SyntaxError('Assertion failed: `type` must be one of "normal", "break", "continue", "return", or "throw"');
	}
	SLOT.set(this, '[[Type]]', type);
	SLOT.set(this, '[[Value]]', value);
	// [[Target]] slot?
};

CompletionRecord.prototype.type = function Type() {
	return SLOT.get(this, '[[Type]]');
};

CompletionRecord.prototype.value = function Value() {
	return SLOT.get(this, '[[Value]]');
};

CompletionRecord.prototype['?'] = function ReturnIfAbrupt() {
	var type = SLOT.get(this, '[[Type]]');
	var value = SLOT.get(this, '[[Value]]');

	if (type === 'throw') {
		throw value;
	}
	return value;
};

CompletionRecord.prototype['!'] = function assert() {
	var type = SLOT.get(this, '[[Type]]');

	if (type !== 'normal') {
		throw new $SyntaxError('Assertion failed: Completion Record is not of type "normal"');
	}
	return SLOT.get(this, '[[Value]]');
};

module.exports = CompletionRecord;
'use strict';

var $TypeError = require('es-errors/type');
var isObject = require('es-object-atoms/isObject');

var isPropertyKey = require('../helpers/isPropertyKey');
var OrdinaryDefineOwnProperty = require('./OrdinaryDefineOwnProperty');

// https://262.ecma-international.org/6.0/#sec-createdataproperty

module.exports = function CreateDataProperty(O, P, V) {
	if (!isObject(O)) {
		throw new $TypeError('Assertion failed: Type(O) is not Object');
	}
	if (!isPropertyKey(P)) {
		throw new $TypeError('Assertion failed: P is not a Property Key');
	}
	var newDesc = {
		'[[Configurable]]': true,
		'[[Enumerable]]': true,
		'[[Value]]': V,
		'[[Writable]]': true
	};
	return OrdinaryDefineOwnProperty(O, P, newDesc);
};
'use strict';

var $TypeError = require('es-errors/type');
var isObject = require('es-object-atoms/isObject');

var CreateDataProperty = require('./CreateDataProperty');

var isPropertyKey = require('../helpers/isPropertyKey');

// // https://262.ecma-international.org/6.0/#sec-createdatapropertyorthrow

module.exports = function CreateDataPropertyOrThrow(O, P, V) {
	if (!isObject(O)) {
		throw new $TypeError('Assertion failed: Type(O) is not Object');
	}
	if (!isPropertyKey(P)) {
		throw new $TypeError('Assertion failed: P is not a Property Key');
	}
	var success = CreateDataProperty(O, P, V);
	if (!success) {
		throw new $TypeError('unable to create data property');
	}
	return success;
};
'use strict';

var $TypeError = require('es-errors/type');

var callBound = require('call-bound');

var $replace = callBound('String.prototype.replace');

var RequireObjectCoercible = require('./RequireObjectCoercible');
var ToString = require('./ToString');

// https://262.ecma-international.org/6.0/#sec-createhtml

module.exports = function CreateHTML(string, tag, attribute, value) {
	if (typeof tag !== 'string' || typeof attribute !== 'string') {
		throw new $TypeError('Assertion failed: `tag` and `attribute` must be strings');
	}
	var str = RequireObjectCoercible(string);
	var S = ToString(str);
	var p1 = '<' + tag;
	if (attribute !== '') {
		var V = ToString(value);
		var escapedV = $replace(V, /\x22/g, '&quot;');
		p1 += '\x20' + attribute + '\x3D\x22' + escapedV + '\x22';
	}
	return p1 + '>' + S + '</' + tag + '>';
};
'use strict';

var $TypeError = require('es-errors/type');

// https://262.ecma-international.org/6.0/#sec-createiterresultobject

module.exports = function CreateIterResultObject(value, done) {
	if (typeof done !== 'boolean') {
		throw new $TypeError('Assertion failed: Type(done) is not Boolean');
	}
	return {
		value: value,
		done: done
	};
};
'use strict';

var callBound = require('call-bound');

var $TypeError = require('es-errors/type');
var isObject = require('es-object-atoms/isObject');
var $indexOf = callBound('Array.prototype.indexOf', true) || callBound('String.prototype.indexOf');

var Get = require('./Get');
var IsArray = require('./IsArray');
var ToLength = require('./ToLength');
var ToString = require('./ToString');
var Type = require('./Type');

var defaultElementTypes = ['Undefined', 'Null', 'Boolean', 'String', 'Symbol', 'Number', 'Object'];

// https://262.ecma-international.org/6.0/#sec-createlistfromarraylike
module.exports = function CreateListFromArrayLike(obj) {
	var elementTypes = arguments.length > 1
		? arguments[1]
		: defaultElementTypes;

	if (!isObject(obj)) {
		throw new $TypeError('Assertion failed: `obj` must be an Object');
	}
	if (!IsArray(elementTypes)) {
		throw new $TypeError('Assertion failed: `elementTypes`, if provided, must be an array');
	}
	var len = ToLength(Get(obj, 'length'));
	var list = [];
	var index = 0;
	while (index < len) {
		var indexName = ToString(index);
		var next = Get(obj, indexName);
		var nextType = Type(next);
		if ($indexOf(elementTypes, nextType) < 0) {
			throw new $TypeError('item type ' + nextType + ' is not a valid elementType');
		}
		list[list.length] = next;
		index += 1;
	}
	return list;
};
'use strict';

var $TypeError = require('es-errors/type');
var isObject = require('es-object-atoms/isObject');

var DefineOwnProperty = require('../helpers/DefineOwnProperty');

var FromPropertyDescriptor = require('./FromPropertyDescriptor');
var IsDataDescriptor = require('./IsDataDescriptor');
var isPropertyKey = require('../helpers/isPropertyKey');
var SameValue = require('./SameValue');

// https://262.ecma-international.org/6.0/#sec-createmethodproperty

module.exports = function CreateMethodProperty(O, P, V) {
	if (!isObject(O)) {
		throw new $TypeError('Assertion failed: Type(O) is not Object');
	}

	if (!isPropertyKey(P)) {
		throw new $TypeError('Assertion failed: P is not a Property Key');
	}

	var newDesc = {
		'[[Configurable]]': true,
		'[[Enumerable]]': false,
		'[[Value]]': V,
		'[[Writable]]': true
	};
	return DefineOwnProperty(
		IsDataDescriptor,
		SameValue,
		FromPropertyDescriptor,
		O,
		P,
		newDesc
	);
};
'use strict';

var $EvalError = require('es-errors/eval');

var DayWithinYear = require('./DayWithinYear');
var InLeapYear = require('./InLeapYear');
var MonthFromTime = require('./MonthFromTime');

// https://262.ecma-international.org/5.1/#sec-15.9.1.5

module.exports = function DateFromTime(t) {
	var m = MonthFromTime(t);
	var d = DayWithinYear(t);
	if (m === 0) {
		return d + 1;
	}
	if (m === 1) {
		return d - 30;
	}
	var leap = InLeapYear(t);
	if (m === 2) {
		return d - 58 - leap;
	}
	if (m === 3) {
		return d - 89 - leap;
	}
	if (m === 4) {
		return d - 119 - leap;
	}
	if (m === 5) {
		return d - 150 - leap;
	}
	if (m === 6) {
		return d - 180 - leap;
	}
	if (m === 7) {
		return d - 211 - leap;
	}
	if (m === 8) {
		return d - 242 - leap;
	}
	if (m === 9) {
		return d - 272 - leap;
	}
	if (m === 10) {
		return d - 303 - leap;
	}
	if (m === 11) {
		return d - 333 - leap;
	}
	throw new $EvalError('Assertion failed: MonthFromTime returned an impossible value: ' + m);
};
'use strict';

var floor = require('./floor');

// https://262.ecma-international.org/5.1/#sec-15.9.1.3

module.exports = function DayFromYear(y) {
	return (365 * (y - 1970)) + floor((y - 1969) / 4) - floor((y - 1901) / 100) + floor((y - 1601) / 400);
};

'use strict';

var floor = require('./floor');

var msPerDay = require('../helpers/timeConstants').msPerDay;

// https://262.ecma-international.org/5.1/#sec-15.9.1.2

module.exports = function Day(t) {
	return floor(t / msPerDay);
};
'use strict';

var modulo = require('./modulo');

// https://262.ecma-international.org/5.1/#sec-15.9.1.3

module.exports = function DaysInYear(y) {
	if (modulo(y, 4) !== 0) {
		return 365;
	}
	if (modulo(y, 100) !== 0) {
		return 366;
	}
	if (modulo(y, 400) !== 0) {
		return 365;
	}
	return 366;
};
'use strict';

var Day = require('./Day');
var DayFromYear = require('./DayFromYear');
var YearFromTime = require('./YearFromTime');

// https://262.ecma-international.org/5.1/#sec-15.9.1.4

module.exports = function DayWithinYear(t) {
	return Day(t) - DayFromYear(YearFromTime(t));
};
'use strict';

var $TypeError = require('es-errors/type');
var isObject = require('es-object-atoms/isObject');

var isPropertyDescriptor = require('../helpers/records/property-descriptor');
var DefineOwnProperty = require('../helpers/DefineOwnProperty');

var FromPropertyDescriptor = require('./FromPropertyDescriptor');
var IsDataDescriptor = require('./IsDataDescriptor');
var isPropertyKey = require('../helpers/isPropertyKey');
var SameValue = require('./SameValue');
var ToPropertyDescriptor = require('./ToPropertyDescriptor');

// https://262.ecma-international.org/6.0/#sec-definepropertyorthrow

module.exports = function DefinePropertyOrThrow(O, P, desc) {
	if (!isObject(O)) {
		throw new $TypeError('Assertion failed: Type(O) is not Object');
	}

	if (!isPropertyKey(P)) {
		throw new $TypeError('Assertion failed: P is not a Property Key');
	}

	var Desc = isPropertyDescriptor(desc) ? desc : ToPropertyDescriptor(desc);
	if (!isPropertyDescriptor(Desc)) {
		throw new $TypeError('Assertion failed: Desc is not a valid Property Descriptor');
	}

	return DefineOwnProperty(
		IsDataDescriptor,
		SameValue,
		FromPropertyDescriptor,
		O,
		P,
		Desc
	);
};
'use strict';

var $TypeError = require('es-errors/type');
var isObject = require('es-object-atoms/isObject');

var isPropertyKey = require('../helpers/isPropertyKey');

// https://262.ecma-international.org/6.0/#sec-deletepropertyorthrow

module.exports = function DeletePropertyOrThrow(O, P) {
	if (!isObject(O)) {
		throw new $TypeError('Assertion failed: Type(O) is not Object');
	}

	if (!isPropertyKey(P)) {
		throw new $TypeError('Assertion failed: P is not a Property Key');
	}

	// eslint-disable-next-line no-param-reassign
	var success = delete O[P];
	if (!success) {
		throw new $TypeError('Attempt to delete property failed.');
	}
	return success;
};
'use strict';

var $SyntaxError = require('es-errors/syntax');
var $TypeError = require('es-errors/type');

var IsDetachedBuffer = require('./IsDetachedBuffer');

var isArrayBuffer = require('is-array-buffer');
var isSharedArrayBuffer = require('is-shared-array-buffer');

var MessageChannel;
try {
	// eslint-disable-next-line global-require
	MessageChannel = require('worker_threads').MessageChannel; // node 11.7+
} catch (e) { /**/ }

// https://262.ecma-international.org/8.0/#sec-detacharraybuffer

/* globals postMessage */

module.exports = function DetachArrayBuffer(arrayBuffer) {
	if (!isArrayBuffer(arrayBuffer) || isSharedArrayBuffer(arrayBuffer)) {
		throw new $TypeError('Assertion failed: `arrayBuffer` must be an Object with an [[ArrayBufferData]] internal slot, and not a Shared Array Buffer');
	}

	if (!IsDetachedBuffer(arrayBuffer)) { // node v21.0.0+ throws when you structuredClone a detached buffer
		if (typeof structuredClone === 'function') {
			structuredClone(arrayBuffer, { transfer: [arrayBuffer] });
		} else if (typeof postMessage === 'function') {
			postMessage('', '/', [arrayBuffer]); // TODO: see if this might trigger listeners
		} else if (MessageChannel) {
			(new MessageChannel()).port1.postMessage(null, [arrayBuffer]);
		} else {
			throw new $SyntaxError('DetachArrayBuffer is not supported in this environment');
		}
	}

	return null;
};
'use strict';

var $TypeError = require('es-errors/type');
var isObject = require('es-object-atoms/isObject');

var objectKeys = require('object-keys');
var callBound = require('call-bound');
var safePushApply = require('safe-push-apply');

var $isEnumerable = callBound('Object.prototype.propertyIsEnumerable');

var forEach = require('../helpers/forEach');

// https://262.ecma-international.org/8.0/#sec-enumerableownproperties

module.exports = function EnumerableOwnProperties(O, kind) {
	if (!isObject(O)) {
		throw new $TypeError('Assertion failed: Type(O) is not Object');
	}

	var keys = objectKeys(O);
	if (kind === 'key') {
		return keys;
	}
	if (kind === 'value' || kind === 'key+value') {
		var results = [];
		forEach(keys, function (key) {
			if ($isEnumerable(O, key)) {
				safePushApply(results, [
					kind === 'value' ? O[key] : [key, O[key]]
				]);
			}
		});
		return results;
	}
	throw new $TypeError('Assertion failed: "kind" is not "key", "value", or "key+value": ' + kind);
};
'use strict';

// var modulo = require('./modulo');
var $floor = require('math-intrinsics/floor');

// http://262.ecma-international.org/5.1/#sec-5.2

module.exports = function floor(x) {
	// return x - modulo(x, 1);
	return $floor(x);
};
'use strict';

var $TypeError = require('es-errors/type');

var isPropertyDescriptor = require('../helpers/records/property-descriptor');
var fromPropertyDescriptor = require('../helpers/fromPropertyDescriptor');

// https://262.ecma-international.org/6.0/#sec-frompropertydescriptor

module.exports = function FromPropertyDescriptor(Desc) {
	if (typeof Desc !== 'undefined' && !isPropertyDescriptor(Desc)) {
		throw new $TypeError('Assertion failed: `Desc` must be a Property Descriptor');
	}

	return fromPropertyDescriptor(Desc);
};
'use strict';

var getGlobal = require('globalthis/polyfill');

// https://262.ecma-international.org/6.0/#sec-getglobalobject

module.exports = function GetGlobalObject() {
	return getGlobal();
};
'use strict';

var $TypeError = require('es-errors/type');

var getIteratorMethod = require('../helpers/getIteratorMethod');
var AdvanceStringIndex = require('./AdvanceStringIndex');
var Call = require('./Call');
var GetMethod = require('./GetMethod');

var isObject = require('es-object-atoms/isObject');

var ES = {
	AdvanceStringIndex: AdvanceStringIndex,
	GetMethod: GetMethod
};

// https://262.ecma-international.org/6.0/#sec-getiterator

module.exports = function GetIterator(obj, method) {
	var actualMethod = method;
	if (arguments.length < 2) {
		actualMethod = getIteratorMethod(ES, obj);
	}
	var iterator = Call(actualMethod, obj);
	if (!isObject(iterator)) {
		throw new $TypeError('iterator must return an object');
	}

	return iterator;
};
'use strict';

var $TypeError = require('es-errors/type');

var inspect = require('object-inspect');

var isPropertyKey = require('../helpers/isPropertyKey');

var isObject = require('es-object-atoms/isObject');

// https://262.ecma-international.org/6.0/#sec-get-o-p

module.exports = function Get(O, P) {
	// 7.3.1.1
	if (!isObject(O)) {
		throw new $TypeError('Assertion failed: Type(O) is not Object');
	}
	// 7.3.1.2
	if (!isPropertyKey(P)) {
		throw new $TypeError('Assertion failed: P is not a Property Key, got ' + inspect(P));
	}
	// 7.3.1.3
	return O[P];
};
'use strict';

var $TypeError = require('es-errors/type');

var GetV = require('./GetV');
var IsCallable = require('./IsCallable');
var isPropertyKey = require('../helpers/isPropertyKey');

var inspect = require('object-inspect');

// https://262.ecma-international.org/6.0/#sec-getmethod

module.exports = function GetMethod(O, P) {
	// 7.3.9.1
	if (!isPropertyKey(P)) {
		throw new $TypeError('Assertion failed: P is not a Property Key');
	}

	// 7.3.9.2
	var func = GetV(O, P);

	// 7.3.9.4
	if (func == null) {
		return void 0;
	}

	// 7.3.9.5
	if (!IsCallable(func)) {
		throw new $TypeError(inspect(P) + ' is not a function: ' + inspect(func));
	}

	// 7.3.9.6
	return func;
};
'use strict';

var GetIntrinsic = require('get-intrinsic');

var hasSymbols = require('has-symbols')();

var $TypeError = require('es-errors/type');
var isObject = require('es-object-atoms/isObject');

var $gOPN = GetIntrinsic('%Object.getOwnPropertyNames%', true);
var $gOPS = hasSymbols && GetIntrinsic('%Object.getOwnPropertySymbols%', true);
var keys = require('object-keys');

// https://262.ecma-international.org/6.0/#sec-getownpropertykeys

module.exports = function GetOwnPropertyKeys(O, Type) {
	if (!isObject(O)) {
		throw new $TypeError('Assertion failed: Type(O) is not Object');
	}
	if (Type === 'Symbol') {
		return $gOPS ? $gOPS(O) : [];
	}
	if (Type === 'String') {
		if (!$gOPN) {
			return keys(O);
		}
		return $gOPN(O);
	}
	throw new $TypeError('Assertion failed: `Type` must be `"String"` or `"Symbol"`');
};
'use strict';

var GetIntrinsic = require('get-intrinsic');

var $Function = GetIntrinsic('%Function%');
var $TypeError = require('es-errors/type');
var $SyntaxError = require('es-errors/syntax');

var Get = require('./Get');
var IsConstructor = require('./IsConstructor');

var isObject = require('es-object-atoms/isObject');

// https://262.ecma-international.org/6.0/#sec-getprototypefromconstructor

module.exports = function GetPrototypeFromConstructor(constructor, intrinsicDefaultProto) {
	var intrinsic = GetIntrinsic(intrinsicDefaultProto); // throws if not a valid intrinsic
	if (!isObject(intrinsic)) {
		throw new $TypeError('intrinsicDefaultProto must be an object');
	}
	if (!IsConstructor(constructor)) {
		throw new $TypeError('Assertion failed: `constructor` must be a constructor');
	}
	var proto = Get(constructor, 'prototype');
	if (!isObject(proto)) {
		if (!(constructor instanceof $Function)) {
			// ignore other realms, for now
			throw new $SyntaxError('cross-realm constructors not currently supported');
		}
		proto = intrinsic;
	}
	return proto;
};

'use strict';

var GetIntrinsic = require('get-intrinsic');

var $TypeError = require('es-errors/type');
var $parseInt = GetIntrinsic('%parseInt%');

var inspect = require('object-inspect');
var isInteger = require('math-intrinsics/isInteger');
var regexTester = require('safe-regex-test');
var callBound = require('call-bound');
var every = require('../helpers/every');

var isDigit = regexTester(/^[0-9]$/);

var $charAt = callBound('String.prototype.charAt');
var $strSlice = callBound('String.prototype.slice');

var IsArray = require('./IsArray');

var isStringOrUndefined = require('../helpers/isStringOrUndefined');

// https://262.ecma-international.org/6.0/#sec-getsubstitution

// eslint-disable-next-line max-statements, max-lines-per-function
module.exports = function GetSubstitution(matched, str, position, captures, replacement) {
	if (typeof matched !== 'string') {
		throw new $TypeError('Assertion failed: `matched` must be a String');
	}
	var matchLength = matched.length;

	if (typeof str !== 'string') {
		throw new $TypeError('Assertion failed: `str` must be a String');
	}
	var stringLength = str.length;

	if (!isInteger(position) || position < 0 || position > stringLength) {
		throw new $TypeError('Assertion failed: `position` must be a nonnegative integer, and less than or equal to the length of `string`, got ' + inspect(position));
	}

	if (!IsArray(captures) || !every(captures, isStringOrUndefined)) {
		throw new $TypeError('Assertion failed: `captures` must be a List of Strings, got ' + inspect(captures));
	}

	if (typeof replacement !== 'string') {
		throw new $TypeError('Assertion failed: `replacement` must be a String');
	}

	var tailPos = position + matchLength;
	var m = captures.length;

	var result = '';
	for (var i = 0; i < replacement.length; i += 1) {
		// if this is a $, and it's not the end of the replacement
		var current = $charAt(replacement, i);
		var isLast = (i + 1) >= replacement.length;
		var nextIsLast = (i + 2) >= replacement.length;
		if (current === '$' && !isLast) {
			var next = $charAt(replacement, i + 1);
			if (next === '$') {
				result += '$';
				i += 1;
			} else if (next === '&') {
				result += matched;
				i += 1;
			} else if (next === '`') {
				result += position === 0 ? '' : $strSlice(str, 0, position - 1);
				i += 1;
			} else if (next === "'") {
				result += tailPos >= stringLength ? '' : $strSlice(str, tailPos);
				i += 1;
			} else {
				var nextNext = nextIsLast ? null : $charAt(replacement, i + 2);
				if (isDigit(next) && next !== '0' && (nextIsLast || !isDigit(nextNext))) {
					// $1 through $9, and not followed by a digit
					var n = $parseInt(next, 10);
					// if (n > m, impl-defined)
					result += n <= m && typeof captures[n - 1] === 'undefined' ? '' : captures[n - 1];
					i += 1;
				} else if (isDigit(next) && (nextIsLast || isDigit(nextNext))) {
					// $00 through $99
					var nn = next + nextNext;
					var nnI = $parseInt(nn, 10) - 1;
					// if nn === '00' or nn > m, impl-defined
					result += nn <= m && typeof captures[nnI] === 'undefined' ? '' : captures[nnI];
					i += 2;
				} else {
					result += '$';
				}
			}
		} else {
			// the final $, or else not a $
			result += $charAt(replacement, i);
		}
	}
	return result;
};
'use strict';

var GetIntrinsic = require('get-intrinsic');

var $SyntaxError = require('es-errors/syntax');
var $TypeError = require('es-errors/type');
var isInteger = require('math-intrinsics/isInteger');
var $Uint8Array = GetIntrinsic('%Uint8Array%', true);

var callBound = require('call-bound');

var $slice = callBound('Array.prototype.slice');

var IsDetachedBuffer = require('./IsDetachedBuffer');
var RawBytesToNumber = require('./RawBytesToNumber');

var isArrayBuffer = require('is-array-buffer');
var isSharedArrayBuffer = require('is-shared-array-buffer');
var safeConcat = require('safe-array-concat');

var tableTAO = require('./tables/typed-array-objects');

var defaultEndianness = require('../helpers/defaultEndianness');

// https://262.ecma-international.org/8.0/#sec-getvaluefrombuffer

module.exports = function GetValueFromBuffer(arrayBuffer, byteIndex, type, isTypedArray, order) {
	var isSAB = isSharedArrayBuffer(arrayBuffer);
	if (!isArrayBuffer(arrayBuffer) && !isSAB) {
		throw new $TypeError('Assertion failed: `arrayBuffer` must be an ArrayBuffer or a SharedArrayBuffer');
	}

	if (!isInteger(byteIndex)) {
		throw new $TypeError('Assertion failed: `byteIndex` must be an integer');
	}

	if (typeof type !== 'string') {
		throw new $TypeError('Assertion failed: `type` must be a string');
	}

	if (typeof isTypedArray !== 'boolean') {
		throw new $TypeError('Assertion failed: `isTypedArray` must be a boolean');
	}

	if (typeof order !== 'string') {
		throw new $TypeError('Assertion failed: `order` must be a string');
	}

	if (arguments.length > 5 && typeof arguments[5] !== 'boolean') {
		throw new $TypeError('Assertion failed: `isLittleEndian` must be a boolean, if present');
	}

	if (IsDetachedBuffer(arrayBuffer)) {
		throw new $TypeError('Assertion failed: `arrayBuffer` is detached'); // step 1
	}

	// 2. Assert: There are sufficient bytes in arrayBuffer starting at byteIndex to represent a value of type.

	if (byteIndex < 0) {
		throw new $TypeError('Assertion failed: `byteIndex` must be non-negative'); // step 3
	}

	// 4. Let block be arrayBuffer.[[ArrayBufferData]].

	var elementSize = tableTAO.size['$' + type]; // step 5
	if (!elementSize) {
		throw new $TypeError('Assertion failed: `type` must be one of ' + tableTAO.choices);
	}

	var rawValue;
	if (isSAB) { // step 6
		/*
		a. Let execution be the [[CandidateExecution]] field of the surrounding agent's Agent Record.
		b. Let eventList be the [[EventList]] field of the element in execution.[[EventLists]] whose [[AgentSignifier]] is AgentSignifier().
		c. If isTypedArray is true and type is "Int8", "Uint8", "Int16", "Uint16", "Int32", or "Uint32", let noTear be true; otherwise let noTear be false.
		d. Let rawValue be a List of length elementSize of nondeterministically chosen byte values.
		e. NOTE: In implementations, rawValue is the result of a non-atomic or atomic read instruction on the underlying hardware. The nondeterminism is a semantic prescription of the memory model to describe observable behaviour of hardware with weak consistency.
		f. Let readEvent be ReadSharedMemory{ [[Order]]: order, [[NoTear]]: noTear, [[Block]]: block, [[ByteIndex]]: byteIndex, [[ElementSize]]: elementSize }.
		g. Append readEvent to eventList.
		h. Append Chosen Value Record { [[Event]]: readEvent, [[ChosenValue]]: rawValue } to execution.[[ChosenValues]].
		*/
		throw new $SyntaxError('TODO: support SharedArrayBuffers');
	} else {
		// 7. Let rawValue be a List of elementSize containing, in order, the elementSize sequence of bytes starting with block[byteIndex].
		rawValue = $slice(new $Uint8Array(arrayBuffer, byteIndex), 0, elementSize); // step 6
	}

	// 8. If isLittleEndian is not present, set isLittleEndian to either true or false. The choice is implementation dependent and should be the alternative that is most efficient for the implementation. An implementation must use the same value each time this step is executed and the same value must be used for the corresponding step in the SetValueInBuffer abstract operation.
	var isLittleEndian = arguments.length > 5 ? arguments[5] : defaultEndianness === 'little'; // step 8

	var bytes = isLittleEndian
		? $slice(safeConcat([0, 0, 0, 0, 0, 0, 0, 0], rawValue), -elementSize)
		: $slice(safeConcat(rawValue, [0, 0, 0, 0, 0, 0, 0, 0]), 0, elementSize);

	return RawBytesToNumber(type, bytes, isLittleEndian);
};
'use strict';

var $TypeError = require('es-errors/type');

var inspect = require('object-inspect');

var isPropertyKey = require('../helpers/isPropertyKey');
// var ToObject = require('./ToObject');

// https://262.ecma-international.org/6.0/#sec-getv

module.exports = function GetV(V, P) {
	// 7.3.2.1
	if (!isPropertyKey(P)) {
		throw new $TypeError('Assertion failed: P is not a Property Key, got ' + inspect(P));
	}

	// 7.3.2.2-3
	// var O = ToObject(V);

	// 7.3.2.4
	return V[P];
};
'use strict';

var $TypeError = require('es-errors/type');

var hasOwn = require('hasown');
var isObject = require('es-object-atoms/isObject');

var isPropertyKey = require('../helpers/isPropertyKey');

// https://262.ecma-international.org/6.0/#sec-hasownproperty

module.exports = function HasOwnProperty(O, P) {
	if (!isObject(O)) {
		throw new $TypeError('Assertion failed: `O` must be an Object');
	}
	if (!isPropertyKey(P)) {
		throw new $TypeError('Assertion failed: `P` must be a Property Key');
	}
	return hasOwn(O, P);
};
'use strict';

var $TypeError = require('es-errors/type');
var isObject = require('es-object-atoms/isObject');

var isPropertyKey = require('../helpers/isPropertyKey');

// https://262.ecma-international.org/6.0/#sec-hasproperty

module.exports = function HasProperty(O, P) {
	if (!isObject(O)) {
		throw new $TypeError('Assertion failed: `O` must be an Object');
	}
	if (!isPropertyKey(P)) {
		throw new $TypeError('Assertion failed: `P` must be a Property Key');
	}
	return P in O;
};
'use strict';

var floor = require('./floor');
var modulo = require('./modulo');

var timeConstants = require('../helpers/timeConstants');
var msPerHour = timeConstants.msPerHour;
var HoursPerDay = timeConstants.HoursPerDay;

// https://262.ecma-international.org/5.1/#sec-15.9.1.10

module.exports = function HourFromTime(t) {
	return modulo(floor(t / msPerHour), HoursPerDay);
};
'use strict';

var $EvalError = require('es-errors/eval');

var DaysInYear = require('./DaysInYear');
var YearFromTime = require('./YearFromTime');

// https://262.ecma-international.org/5.1/#sec-15.9.1.3

module.exports = function InLeapYear(t) {
	var days = DaysInYear(YearFromTime(t));
	if (days === 365) {
		return 0;
	}
	if (days === 366) {
		return 1;
	}
	throw new $EvalError('Assertion failed: there are not 365 or 366 days in a year, got: ' + days);
};
'use strict';

var GetIntrinsic = require('get-intrinsic');

var $TypeError = require('es-errors/type');
var isObject = require('es-object-atoms/isObject');

var $hasInstance = GetIntrinsic('%Symbol.hasInstance%', true);

var Call = require('./Call');
var GetMethod = require('./GetMethod');
var IsCallable = require('./IsCallable');
var OrdinaryHasInstance = require('./OrdinaryHasInstance');
var ToBoolean = require('./ToBoolean');

// https://262.ecma-international.org/6.0/#sec-instanceofoperator

module.exports = function InstanceofOperator(O, C) {
	if (!isObject(O)) {
		throw new $TypeError('Assertion failed: Type(O) is not Object');
	}
	var instOfHandler = $hasInstance ? GetMethod(C, $hasInstance) : void 0;
	if (typeof instOfHandler !== 'undefined') {
		return ToBoolean(Call(instOfHandler, C, [O]));
	}
	if (!IsCallable(C)) {
		throw new $TypeError('`C` is not Callable');
	}
	return OrdinaryHasInstance(C, O);
};
'use strict';

var $SyntaxError = require('es-errors/syntax');
var $TypeError = require('es-errors/type');

var GetValueFromBuffer = require('./GetValueFromBuffer');
var IsDetachedBuffer = require('./IsDetachedBuffer');
var IsInteger = require('./IsInteger');

var isNegativeZero = require('math-intrinsics/isNegativeZero');

var typedArrayLength = require('typed-array-length');
var typedArrayBuffer = require('typed-array-buffer');
var typedArrayByteOffset = require('typed-array-byte-offset');
var whichTypedArray = require('which-typed-array');

var tableTAO = require('./tables/typed-array-objects');

// https://262.ecma-international.org/8.0/#sec-integerindexedelementget

module.exports = function IntegerIndexedElementGet(O, index) {
	if (typeof index !== 'number') {
		throw new $TypeError('`index` must be a Number'); // step 1
	}
	var arrayTypeName = whichTypedArray(O); // step 10
	if (!arrayTypeName) {
		throw new $TypeError('`O` must be a TypedArray'); // step 2
	}
	if (arrayTypeName === 'BigInt64Array' || arrayTypeName === 'BigUint64Array') {
		throw new $SyntaxError('BigInt64Array and BigUint64Array do not exist until ES2020');
	}

	var buffer = typedArrayBuffer(O); // step 3

	if (IsDetachedBuffer(buffer)) {
		throw new $TypeError('`O` has a detached buffer'); // step 4
	}

	if (!IsInteger(index) || isNegativeZero(index)) {
		return void undefined; // steps 5 - 6
	}

	var length = typedArrayLength(O); // step 7

	if (index < 0 || index >= length) {
		return void undefined; // step 8
	}

	var offset = typedArrayByteOffset(O); // step 9

	var elementType = tableTAO.name['$' + arrayTypeName]; // step 13

	var elementSize = tableTAO.size['$' + elementType]; // step 11

	var indexedPosition = (index * elementSize) + offset; // step 12

	return GetValueFromBuffer(buffer, indexedPosition, elementType, true, 'Unordered'); // step 14
};
'use strict';

var $SyntaxError = require('es-errors/syntax');
var $TypeError = require('es-errors/type');

var IsDetachedBuffer = require('./IsDetachedBuffer');
var IsInteger = require('./IsInteger');
var SetValueInBuffer = require('./SetValueInBuffer');
var ToNumber = require('./ToNumber');

var isNegativeZero = require('math-intrinsics/isNegativeZero');
var typedArrayBuffer = require('typed-array-buffer');
var typedArrayByteOffset = require('typed-array-byte-offset');
var typedArrayLength = require('typed-array-length');
var whichTypedArray = require('which-typed-array');

var tableTAO = require('./tables/typed-array-objects');

// https://262.ecma-international.org/8.0/#sec-integerindexedelementset

module.exports = function IntegerIndexedElementSet(O, index, value) {
	if (typeof index !== 'number') {
		throw new $TypeError('`index` must be a Number'); // step 1
	}
	var arrayTypeName = whichTypedArray(O); // step 12
	if (!arrayTypeName) {
		throw new $TypeError('`O` must be a TypedArray'); // step 2
	}
	if (arrayTypeName === 'BigInt64Array' || arrayTypeName === 'BigUint64Array') {
		throw new $SyntaxError('BigInt64Array and BigUint64Array do not exist until ES2020'); // step 2
	}

	var numValue = ToNumber(value); // step 3

	var buffer = typedArrayBuffer(O); // step 5

	if (IsDetachedBuffer(buffer)) {
		throw new $TypeError('`O` has a detached buffer'); // step 6
	}

	if (!IsInteger(index) || isNegativeZero(index)) {
		return false; // steps 7 - 8
	}

	var length = typedArrayLength(O); // step 9

	if (index < 0 || index >= length) {
		return false; // step 10
	}

	var offset = typedArrayByteOffset(O); // step 11

	var elementType = tableTAO.name['$' + arrayTypeName]; // step 15

	var elementSize = tableTAO.size['$' + elementType]; // step 13

	var indexedPosition = (index * elementSize) + offset; // step 14

	SetValueInBuffer(buffer, indexedPosition, elementType, numValue, true, 'Unordered'); // step 16

	return true; // step 17
};
'use strict';

var $TypeError = require('es-errors/type');
var isObject = require('es-object-atoms/isObject');

var Call = require('./Call');
var CreateDataProperty = require('./CreateDataProperty');
var EnumerableOwnProperties = require('./EnumerableOwnProperties');
var Get = require('./Get');
var IsArray = require('./IsArray');
var ToLength = require('./ToLength');
var ToString = require('./ToString');

var forEach = require('../helpers/forEach');

// https://262.ecma-international.org/8.0/#sec-internalizejsonproperty

// note: `reviver` was implicitly closed-over until ES2020, where it becomes a third argument

module.exports = function InternalizeJSONProperty(holder, name, reviver) {
	if (!isObject(holder)) {
		throw new $TypeError('Assertion failed: `holder` is not an Object');
	}
	if (typeof name !== 'string') {
		throw new $TypeError('Assertion failed: `name` is not a String');
	}
	if (typeof reviver !== 'function') {
		throw new $TypeError('Assertion failed: `reviver` is not a Function');
	}

	var val = Get(holder, name); // step 1

	if (isObject(val)) { // step 2
		var isArray = IsArray(val); // step 2.a
		if (isArray) { // step 2.b
			var I = 0; // step 2.b.i

			var len = ToLength(Get(val, 'length')); // step 2.b.ii

			while (I < len) { // step 2.b.iii
				var newElement = InternalizeJSONProperty(val, ToString(I), reviver); // step 2.b.iv.1

				if (typeof newElement === 'undefined') { // step 2.b.iii.2
					delete val[ToString(I)]; // step 2.b.iii.2.a
				} else { // step 2.b.iii.3
					CreateDataProperty(val, ToString(I), newElement); // step 2.b.iii.3.a
				}

				I += 1; // step 2.b.iii.4
			}
		} else { // step 2.c
			var keys = EnumerableOwnProperties(val, 'key'); // step 2.c.i

			forEach(keys, function (P) { // step 2.c.ii
				// eslint-disable-next-line no-shadow
				var newElement = InternalizeJSONProperty(val, P, reviver); // step 2.c.ii.1

				if (typeof newElement === 'undefined') { // step 2.c.ii.2
					delete val[P]; // step 2.c.ii.2.a
				} else { // step 2.c.ii.3
					CreateDataProperty(val, P, newElement); // step 2.c.ii.3.a
				}
			});
		}
	}

	return Call(reviver, holder, [name, val]); // step 3
};
'use strict';

var $TypeError = require('es-errors/type');

var Call = require('./Call');
var IsArray = require('./IsArray');
var GetV = require('./GetV');
var isPropertyKey = require('../helpers/isPropertyKey');

// https://262.ecma-international.org/6.0/#sec-invoke

module.exports = function Invoke(O, P) {
	if (!isPropertyKey(P)) {
		throw new $TypeError('Assertion failed: P must be a Property Key');
	}
	var argumentsList = arguments.length > 2 ? arguments[2] : [];
	if (!IsArray(argumentsList)) {
		throw new $TypeError('Assertion failed: optional `argumentsList`, if provided, must be a List');
	}
	var func = GetV(O, P);
	return Call(func, O, argumentsList);
};
'use strict';

var $TypeError = require('es-errors/type');

var hasOwn = require('hasown');

var isPropertyDescriptor = require('../helpers/records/property-descriptor');

// https://262.ecma-international.org/5.1/#sec-8.10.1

module.exports = function IsAccessorDescriptor(Desc) {
	if (typeof Desc === 'undefined') {
		return false;
	}

	if (!isPropertyDescriptor(Desc)) {
		throw new $TypeError('Assertion failed: `Desc` must be a Property Descriptor');
	}

	if (!hasOwn(Desc, '[[Get]]') && !hasOwn(Desc, '[[Set]]')) {
		return false;
	}

	return true;
};
'use strict';

// https://262.ecma-international.org/6.0/#sec-isarray
module.exports = require('../helpers/IsArray');
'use strict';

// http://262.ecma-international.org/5.1/#sec-9.11

module.exports = require('is-callable');
'use strict';

var ValidateAndApplyPropertyDescriptor = require('./ValidateAndApplyPropertyDescriptor');

// https://262.ecma-international.org/6.0/#sec-iscompatiblepropertydescriptor

module.exports = function IsCompatiblePropertyDescriptor(Extensible, Desc, Current) {
	return ValidateAndApplyPropertyDescriptor(undefined, undefined, Extensible, Desc, Current);
};
'use strict';

var GetIntrinsic = require('get-intrinsic');

var $isConcatSpreadable = GetIntrinsic('%Symbol.isConcatSpreadable%', true);

var Get = require('./Get');
var IsArray = require('./IsArray');
var ToBoolean = require('./ToBoolean');

var isObject = require('es-object-atoms/isObject');

// https://262.ecma-international.org/6.0/#sec-isconcatspreadable

module.exports = function IsConcatSpreadable(O) {
	if (!isObject(O)) {
		return false;
	}
	if ($isConcatSpreadable) {
		var spreadable = Get(O, $isConcatSpreadable);
		if (typeof spreadable !== 'undefined') {
			return ToBoolean(spreadable);
		}
	}
	return IsArray(O);
};
'use strict';

var GetIntrinsic = require('../GetIntrinsic.js');

var $construct = GetIntrinsic('%Reflect.construct%', true);

var DefinePropertyOrThrow = require('./DefinePropertyOrThrow');
try {
	DefinePropertyOrThrow({}, '', { '[[Get]]': function () {} });
} catch (e) {
	// Accessor properties aren't supported
	DefinePropertyOrThrow = null;
}

// https://262.ecma-international.org/6.0/#sec-isconstructor

if (DefinePropertyOrThrow && $construct) {
	var isConstructorMarker = {};
	var badArrayLike = {};
	DefinePropertyOrThrow(badArrayLike, 'length', {
		'[[Get]]': function () {
			throw isConstructorMarker;
		},
		'[[Enumerable]]': true
	});

	module.exports = function IsConstructor(argument) {
		try {
			// `Reflect.construct` invokes `IsConstructor(target)` before `Get(args, 'length')`:
			$construct(argument, badArrayLike);
		} catch (err) {
			return err === isConstructorMarker;
		}
	};
} else {
	module.exports = function IsConstructor(argument) {
		// unfortunately there's no way to truly check this without try/catch `new argument` in old environments
		return typeof argument === 'function' && !!argument.prototype;
	};
}
'use strict';

var $TypeError = require('es-errors/type');

var hasOwn = require('hasown');

var isPropertyDescriptor = require('../helpers/records/property-descriptor');

// https://262.ecma-international.org/5.1/#sec-8.10.2

module.exports = function IsDataDescriptor(Desc) {
	if (typeof Desc === 'undefined') {
		return false;
	}

	if (!isPropertyDescriptor(Desc)) {
		throw new $TypeError('Assertion failed: `Desc` must be a Property Descriptor');
	}

	if (!hasOwn(Desc, '[[Value]]') && !hasOwn(Desc, '[[Writable]]')) {
		return false;
	}

	return true;
};
'use strict';

var $TypeError = require('es-errors/type');

var $byteLength = require('array-buffer-byte-length');
var availableTypedArrays = require('available-typed-arrays')();
var callBound = require('call-bound');
var isArrayBuffer = require('is-array-buffer');
var isSharedArrayBuffer = require('is-shared-array-buffer');

var $sabByteLength = callBound('SharedArrayBuffer.prototype.byteLength', true);

// https://262.ecma-international.org/8.0/#sec-isdetachedbuffer

module.exports = function IsDetachedBuffer(arrayBuffer) {
	var isSAB = isSharedArrayBuffer(arrayBuffer);
	if (!isArrayBuffer(arrayBuffer) && !isSAB) {
		throw new $TypeError('Assertion failed: `arrayBuffer` must be an Object with an [[ArrayBufferData]] internal slot');
	}
	if ((isSAB ? $sabByteLength : $byteLength)(arrayBuffer) === 0) {
		try {
			new global[availableTypedArrays[0]](arrayBuffer); // eslint-disable-line no-new
		} catch (error) {
			return !!error && error.name === 'TypeError';
		}
	}
	return false;
};
'use strict';

var GetIntrinsic = require('get-intrinsic');

var $preventExtensions = GetIntrinsic('%Object.preventExtensions%', true);
var $isExtensible = GetIntrinsic('%Object.isExtensible%', true);

var isPrimitive = require('../helpers/isPrimitive');

// https://262.ecma-international.org/6.0/#sec-isextensible-o

module.exports = $preventExtensions
	? function IsExtensible(obj) {
		return !isPrimitive(obj) && $isExtensible(obj);
	}
	: function IsExtensible(obj) {
		return !isPrimitive(obj);
	};
'use strict';

var $TypeError = require('es-errors/type');

var IsAccessorDescriptor = require('./IsAccessorDescriptor');
var IsDataDescriptor = require('./IsDataDescriptor');

var isPropertyDescriptor = require('../helpers/records/property-descriptor');

// https://262.ecma-international.org/6.0/#sec-isgenericdescriptor

module.exports = function IsGenericDescriptor(Desc) {
	if (typeof Desc === 'undefined') {
		return false;
	}

	if (!isPropertyDescriptor(Desc)) {
		throw new $TypeError('Assertion failed: `Desc` must be a Property Descriptor');
	}

	if (!IsAccessorDescriptor(Desc) && !IsDataDescriptor(Desc)) {
		return true;
	}

	return false;
};
'use strict';

var isInteger = require('math-intrinsics/isInteger');

// https://262.ecma-international.org/6.0/#sec-isinteger

module.exports = function IsInteger(argument) {
	return isInteger(argument);
};
'use strict';

var callBound = require('call-bound');

var $PromiseThen = callBound('Promise.prototype.then', true);

var isObject = require('es-object-atoms/isObject');

// https://262.ecma-international.org/6.0/#sec-ispromise

module.exports = function IsPromise(x) {
	if (!isObject(x)) {
		return false;
	}
	if (!$PromiseThen) { // Promises are not supported
		return false;
	}
	try {
		$PromiseThen(x); // throws if not a promise
	} catch (e) {
		return false;
	}
	return true;
};
'use strict';

// TODO, semver-major: delete this

var isPropertyDescriptor = require('../helpers/records/property-descriptor');

// https://262.ecma-international.org/6.0/#sec-property-descriptor-specification-type

module.exports = function IsPropertyDescriptor(Desc) {
	return isPropertyDescriptor(Desc);
};
'use strict';

var isPropertyKey = require('../helpers/isPropertyKey');

// https://262.ecma-international.org/6.0/#sec-ispropertykey

module.exports = function IsPropertyKey(argument) {
	return isPropertyKey(argument);
};
'use strict';

var GetIntrinsic = require('get-intrinsic');

var $match = GetIntrinsic('%Symbol.match%', true);

var hasRegExpMatcher = require('is-regex');
var isObject = require('es-object-atoms/isObject');

var ToBoolean = require('./ToBoolean');

// https://262.ecma-international.org/6.0/#sec-isregexp

module.exports = function IsRegExp(argument) {
	if (!isObject(argument)) {
		return false;
	}
	if ($match) {
		var isRegExp = argument[$match];
		if (typeof isRegExp !== 'undefined') {
			return ToBoolean(isRegExp);
		}
	}
	return hasRegExpMatcher(argument);
};
'use strict';

var $TypeError = require('es-errors/type');
var isObject = require('es-object-atoms/isObject');

var isSharedArrayBuffer = require('is-shared-array-buffer');

// https://262.ecma-international.org/8.0/#sec-issharedarraybuffer

module.exports = function IsSharedArrayBuffer(obj) {
	if (!isObject(obj)) {
		throw new $TypeError('Assertion failed: Type(O) is not Object');
	}

	return isSharedArrayBuffer(obj);
};
'use strict';

var $TypeError = require('es-errors/type');

var callBound = require('call-bound');

var $indexOf = callBound('String.prototype.indexOf');

var IsArray = require('./IsArray');
var IsInteger = require('./IsInteger');
var WordCharacters = require('./WordCharacters');

var every = require('../helpers/every');

var isChar = function isChar(c) {
	return typeof c === 'string';
};

// https://262.ecma-international.org/8.0/#sec-runtime-semantics-iswordchar-abstract-operation

// note: prior to ES2023, this AO erroneously omitted the latter of its arguments.
module.exports = function IsWordChar(e, InputLength, Input, IgnoreCase, Unicode) {
	if (!IsInteger(e)) {
		throw new $TypeError('Assertion failed: `e` must be an integer');
	}
	if (!IsInteger(InputLength)) {
		throw new $TypeError('Assertion failed: `InputLength` must be an integer');
	}
	if (!IsArray(Input) || !every(Input, isChar)) {
		throw new $TypeError('Assertion failed: `Input` must be a List of characters');
	}
	if (typeof IgnoreCase !== 'boolean' || typeof Unicode !== 'boolean') {
		throw new $TypeError('Assertion failed: `IgnoreCase` and `Unicode` must be booleans');
	}

	if (e === -1 || e === InputLength) {
		return false; // step 1
	}

	var c = Input[e]; // step 2

	var wordChars = WordCharacters(IgnoreCase, Unicode);

	return $indexOf(wordChars, c) > -1; // steps 3-4
};
'use strict';

var GetIterator = require('./GetIterator');
var IteratorStep = require('./IteratorStep');
var IteratorValue = require('./IteratorValue');

// https://262.ecma-international.org/8.0/#sec-iterabletolist

module.exports = function IterableToList(items, method) {
	var iterator = GetIterator(items, method);
	var values = [];
	var next = true;
	while (next) {
		next = IteratorStep(iterator);
		if (next) {
			var nextValue = IteratorValue(next);
			values[values.length] = nextValue;
		}
	}
	return values;
};
'use strict';

var $TypeError = require('es-errors/type');
var isObject = require('es-object-atoms/isObject');

var Call = require('./Call');
var CompletionRecord = require('./CompletionRecord');
var GetMethod = require('./GetMethod');
var IsCallable = require('./IsCallable');

// https://262.ecma-international.org/6.0/#sec-iteratorclose

module.exports = function IteratorClose(iterator, completion) {
	if (!isObject(iterator)) {
		throw new $TypeError('Assertion failed: Type(iterator) is not Object');
	}
	if (!IsCallable(completion) && !(completion instanceof CompletionRecord)) {
		throw new $TypeError('Assertion failed: completion is not a thunk representing a Completion Record, nor a Completion Record instance');
	}
	var completionThunk = completion instanceof CompletionRecord ? function () { return completion['?'](); } : completion;

	var iteratorReturn = GetMethod(iterator, 'return');

	if (typeof iteratorReturn === 'undefined') {
		return completionThunk();
	}

	var completionRecord;
	try {
		var innerResult = Call(iteratorReturn, iterator, []);
	} catch (e) {
		// if we hit here, then "e" is the innerResult completion that needs re-throwing

		// if the completion is of type "throw", this will throw.
		completionThunk();
		completionThunk = null; // ensure it's not called twice.

		// if not, then return the innerResult completion
		throw e;
	}
	completionRecord = completionThunk(); // if innerResult worked, then throw if the completion does
	completionThunk = null; // ensure it's not called twice.

	if (!isObject(innerResult)) {
		throw new $TypeError('iterator .return must return an object');
	}

	return completionRecord;
};
'use strict';

var $TypeError = require('es-errors/type');
var isObject = require('es-object-atoms/isObject');

var Get = require('./Get');
var ToBoolean = require('./ToBoolean');

// https://262.ecma-international.org/6.0/#sec-iteratorcomplete

module.exports = function IteratorComplete(iterResult) {
	if (!isObject(iterResult)) {
		throw new $TypeError('Assertion failed: Type(iterResult) is not Object');
	}
	return ToBoolean(Get(iterResult, 'done'));
};
'use strict';

var $TypeError = require('es-errors/type');
var isObject = require('es-object-atoms/isObject');

var Invoke = require('./Invoke');

// https://262.ecma-international.org/6.0/#sec-iteratornext

module.exports = function IteratorNext(iterator, value) {
	var result = Invoke(iterator, 'next', arguments.length < 2 ? [] : [value]);
	if (!isObject(result)) {
		throw new $TypeError('iterator next must return an object');
	}
	return result;
};
'use strict';

var IteratorComplete = require('./IteratorComplete');
var IteratorNext = require('./IteratorNext');

// https://262.ecma-international.org/6.0/#sec-iteratorstep

module.exports = function IteratorStep(iterator) {
	var result = IteratorNext(iterator);
	var done = IteratorComplete(result);
	return done === true ? false : result;
};

'use strict';

var $TypeError = require('es-errors/type');
var isObject = require('es-object-atoms/isObject');

var Get = require('./Get');

// https://262.ecma-international.org/6.0/#sec-iteratorvalue

module.exports = function IteratorValue(iterResult) {
	if (!isObject(iterResult)) {
		throw new $TypeError('Assertion failed: Type(iterResult) is not Object');
	}
	return Get(iterResult, 'value');
};

'use strict';

var $isFinite = require('math-intrinsics/isFinite');

var msPerDay = require('../helpers/timeConstants').msPerDay;

// https://262.ecma-international.org/5.1/#sec-15.9.1.13

module.exports = function MakeDate(day, time) {
	if (!$isFinite(day) || !$isFinite(time)) {
		return NaN;
	}
	return (day * msPerDay) + time;
};
'use strict';

var GetIntrinsic = require('get-intrinsic');

var $DateUTC = GetIntrinsic('%Date.UTC%');

var $isFinite = require('math-intrinsics/isFinite');

var DateFromTime = require('./DateFromTime');
var Day = require('./Day');
var floor = require('./floor');
var modulo = require('./modulo');
var MonthFromTime = require('./MonthFromTime');
var ToInteger = require('./ToInteger');
var YearFromTime = require('./YearFromTime');

// https://262.ecma-international.org/5.1/#sec-15.9.1.12

module.exports = function MakeDay(year, month, date) {
	if (!$isFinite(year) || !$isFinite(month) || !$isFinite(date)) {
		return NaN;
	}
	var y = ToInteger(year);
	var m = ToInteger(month);
	var dt = ToInteger(date);
	var ym = y + floor(m / 12);
	var mn = modulo(m, 12);
	var t = $DateUTC(ym, mn, 1);
	if (YearFromTime(t) !== ym || MonthFromTime(t) !== mn || DateFromTime(t) !== 1) {
		return NaN;
	}
	return Day(t) + dt - 1;
};
'use strict';

var $isFinite = require('math-intrinsics/isFinite');

var timeConstants = require('../helpers/timeConstants');
var msPerSecond = timeConstants.msPerSecond;
var msPerMinute = timeConstants.msPerMinute;
var msPerHour = timeConstants.msPerHour;

var ToInteger = require('./ToInteger');

// https://262.ecma-international.org/5.1/#sec-15.9.1.11

module.exports = function MakeTime(hour, min, sec, ms) {
	if (!$isFinite(hour) || !$isFinite(min) || !$isFinite(sec) || !$isFinite(ms)) {
		return NaN;
	}
	var h = ToInteger(hour);
	var m = ToInteger(min);
	var s = ToInteger(sec);
	var milli = ToInteger(ms);
	var t = (h * msPerHour) + (m * msPerMinute) + (s * msPerSecond) + milli;
	return t;
};
'use strict';

// https://262.ecma-international.org/6.0/#sec-algorithm-conventions

module.exports = require('math-intrinsics/max');
'use strict';

var floor = require('./floor');
var modulo = require('./modulo');

var timeConstants = require('../helpers/timeConstants');
var msPerMinute = timeConstants.msPerMinute;
var MinutesPerHour = timeConstants.MinutesPerHour;

// https://262.ecma-international.org/5.1/#sec-15.9.1.10

module.exports = function MinFromTime(t) {
	return modulo(floor(t / msPerMinute), MinutesPerHour);
};
'use strict';

// https://262.ecma-international.org/6.0/#sec-algorithm-conventions

module.exports = require('math-intrinsics/min');
'use strict';

var mod = require('../helpers/mod');

// https://262.ecma-international.org/5.1/#sec-5.2

module.exports = function modulo(x, y) {
	return mod(x, y);
};
'use strict';

var $RangeError = require('es-errors/range');

var DayWithinYear = require('./DayWithinYear');
var InLeapYear = require('./InLeapYear');

// https://262.ecma-international.org/5.1/#sec-15.9.1.4

module.exports = function MonthFromTime(t) {
	var day = DayWithinYear(t);
	if (0 <= day && day < 31) {
		return 0;
	}
	var leap = InLeapYear(t);
	if (31 <= day && day < (59 + leap)) {
		return 1;
	}
	if ((59 + leap) <= day && day < (90 + leap)) {
		return 2;
	}
	if ((90 + leap) <= day && day < (120 + leap)) {
		return 3;
	}
	if ((120 + leap) <= day && day < (151 + leap)) {
		return 4;
	}
	if ((151 + leap) <= day && day < (181 + leap)) {
		return 5;
	}
	if ((181 + leap) <= day && day < (212 + leap)) {
		return 6;
	}
	if ((212 + leap) <= day && day < (243 + leap)) {
		return 7;
	}
	if ((243 + leap) <= day && day < (273 + leap)) {
		return 8;
	}
	if ((273 + leap) <= day && day < (304 + leap)) {
		return 9;
	}
	if ((304 + leap) <= day && day < (334 + leap)) {
		return 10;
	}
	if ((334 + leap) <= day && day < (365 + leap)) {
		return 11;
	}

	throw new $RangeError('Assertion failed: `day` is out of range');
};
'use strict';

var modulo = require('./modulo');

var msPerSecond = require('../helpers/timeConstants').msPerSecond;

// https://262.ecma-international.org/5.1/#sec-15.9.1.10

module.exports = function msFromTime(t) {
	return modulo(t, msPerSecond);
};
'use strict';

var $TypeError = require('es-errors/type');

var IsCallable = require('./IsCallable');
var IsConstructor = require('./IsConstructor');

// https://262.ecma-international.org/6.0/#sec-newpromisecapability

module.exports = function NewPromiseCapability(C) {
	if (!IsConstructor(C)) {
		throw new $TypeError('C must be a constructor'); // step 1
	}

	var resolvingFunctions = { '[[Resolve]]': void undefined, '[[Reject]]': void undefined }; // step 3

	var promise = new C(function (resolve, reject) { // steps 4-5
		if (typeof resolvingFunctions['[[Resolve]]'] !== 'undefined' || typeof resolvingFunctions['[[Reject]]'] !== 'undefined') {
			throw new $TypeError('executor has already been called'); // step 4.a, 4.b
		}
		resolvingFunctions['[[Resolve]]'] = resolve; // step 4.c
		resolvingFunctions['[[Reject]]'] = reject; // step 4.d
	}); // step 4-6

	if (!IsCallable(resolvingFunctions['[[Resolve]]']) || !IsCallable(resolvingFunctions['[[Reject]]'])) {
		throw new $TypeError('executor must provide valid resolve and reject functions'); // steps 7-8
	}

	return {
		'[[Promise]]': promise,
		'[[Resolve]]': resolvingFunctions['[[Resolve]]'],
		'[[Reject]]': resolvingFunctions['[[Reject]]']
	}; // step 9
};
'use strict';

var CompletionRecord = require('./CompletionRecord');

// https://262.ecma-international.org/6.0/#sec-normalcompletion

module.exports = function NormalCompletion(value) {
	return new CompletionRecord('normal', value);
};
'use strict';

var $TypeError = require('es-errors/type');

var hasOwnProperty = require('./HasOwnProperty');
var ToInt16 = require('./ToInt16');
var ToInt32 = require('./ToInt32');
var ToInt8 = require('./ToInt8');
var ToUint16 = require('./ToUint16');
var ToUint32 = require('./ToUint32');
var ToUint8 = require('./ToUint8');
var ToUint8Clamp = require('./ToUint8Clamp');

var valueToFloat32Bytes = require('../helpers/valueToFloat32Bytes');
var valueToFloat64Bytes = require('../helpers/valueToFloat64Bytes');
var integerToNBytes = require('../helpers/integerToNBytes');

var tableTAO = require('./tables/typed-array-objects');

// https://262.ecma-international.org/8.0/#table-50

var TypeToAO = {
	__proto__: null,
	$Int8: ToInt8,
	$Uint8: ToUint8,
	$Uint8C: ToUint8Clamp,
	$Int16: ToInt16,
	$Uint16: ToUint16,
	$Int32: ToInt32,
	$Uint32: ToUint32
};

// https://262.ecma-international.org/8.0/#sec-numbertorawbytes

module.exports = function NumberToRawBytes(type, value, isLittleEndian) {
	if (typeof type !== 'string' || !hasOwnProperty(tableTAO.size, '$' + type)) {
		throw new $TypeError('Assertion failed: `type` must be a TypedArray element type');
	}
	if (typeof value !== 'number') {
		throw new $TypeError('Assertion failed: `value` must be a Number');
	}
	if (typeof isLittleEndian !== 'boolean') {
		throw new $TypeError('Assertion failed: `isLittleEndian` must be a Boolean');
	}

	if (type === 'Float32') { // step 1
		return valueToFloat32Bytes(value, isLittleEndian);
	} else if (type === 'Float64') { // step 2
		return valueToFloat64Bytes(value, isLittleEndian);
	} // step 3

	var n = tableTAO.size['$' + type]; // step 3.a

	var convOp = TypeToAO['$' + type]; // step 3.b

	var intValue = convOp(value); // step 3.c

	return integerToNBytes(intValue, n, isLittleEndian); // step 3.d, 3.e, 4
};
'use strict';

var GetIntrinsic = require('get-intrinsic');

var $ObjectCreate = GetIntrinsic('%Object.create%', true);
var $TypeError = require('es-errors/type');
var $SyntaxError = require('es-errors/syntax');
var isObject = require('es-object-atoms/isObject');

var IsArray = require('./IsArray');

var forEach = require('../helpers/forEach');

var SLOT = require('internal-slot');

var hasProto = require('has-proto')();

// https://262.ecma-international.org/6.0/#sec-objectcreate

module.exports = function ObjectCreate(proto, internalSlotsList) {
	if (proto !== null && !isObject(proto)) {
		throw new $TypeError('Assertion failed: `proto` must be null or an object');
	}
	var slots = arguments.length < 2 ? [] : internalSlotsList; // step 1
	if (arguments.length >= 2 && !IsArray(slots)) {
		throw new $TypeError('Assertion failed: `internalSlotsList` must be an Array');
	}

	var O;
	if (hasProto) {
		O = { __proto__: proto };
	} else if ($ObjectCreate) {
		O = $ObjectCreate(proto);
	} else {
		if (proto === null) {
			throw new $SyntaxError('native Object.create support is required to create null objects');
		}
		var T = function T() {};
		T.prototype = proto;
		O = new T();
	}

	if (slots.length > 0) {
		forEach(slots, function (slot) {
			SLOT.set(O, slot, void undefined);
		});
	}

	return O; // step 6
};
'use strict';

var DefinePropertyOrThrow = require('./DefinePropertyOrThrow');
var Get = require('./Get');
var OrdinaryGetOwnProperty = require('./OrdinaryGetOwnProperty');
var ToObject = require('./ToObject');
var ToPropertyDescriptor = require('./ToPropertyDescriptor');

var forEach = require('../helpers/forEach');
var OwnPropertyKeys = require('own-keys');

// https://262.ecma-international.org/6.0/#sec-objectdefineproperties

/** @type {<T extends Record<PropertyKey, unknown> = {}>(O: T, Properties: object) => T} */
module.exports = function ObjectDefineProperties(O, Properties) {
	var props = ToObject(Properties); // step 1
	var keys = OwnPropertyKeys(props); // step 2
	/** @type {[string | symbol, import('../types').Descriptor][]} */
	var descriptors = []; // step 3

	forEach(keys, function (nextKey) { // step 4
		var propDesc = OrdinaryGetOwnProperty(props, nextKey); // ToPropertyDescriptor(getOwnPropertyDescriptor(props, nextKey)); // step 4.a
		if (typeof propDesc !== 'undefined' && propDesc['[[Enumerable]]']) { // step 4.b
			var descObj = Get(props, nextKey); // step 4.b.i
			var desc = ToPropertyDescriptor(descObj); // step 4.b.ii
			descriptors[descriptors.length] = [nextKey, desc]; // step 4.b.iii
		}
	});

	forEach(descriptors, function (pair) { // step 5
		var P = pair[0]; // step 5.a
		var desc = pair[1]; // step 5.b
		DefinePropertyOrThrow(O, P, desc); // step 5.c
	});

	return O; // step 6
};
'use strict';

var GetIntrinsic = require('get-intrinsic');
var $TypeError = require('es-errors/type');

var GetPrototypeFromConstructor = require('./GetPrototypeFromConstructor');
var IsArray = require('./IsArray');
var ObjectCreate = require('./ObjectCreate');

// https://262.ecma-international.org/6.0/#sec-ordinarycreatefromconstructor

module.exports = function OrdinaryCreateFromConstructor(constructor, intrinsicDefaultProto) {
	GetIntrinsic(intrinsicDefaultProto); // throws if not a valid intrinsic
	var proto = GetPrototypeFromConstructor(constructor, intrinsicDefaultProto);
	var slots = arguments.length < 3 ? [] : arguments[2];
	if (!IsArray(slots)) {
		throw new $TypeError('Assertion failed: if provided, `internalSlotsList` must be a List');
	}
	return ObjectCreate(proto, slots);
};
'use strict';

var $gOPD = require('gopd');
var $SyntaxError = require('es-errors/syntax');
var $TypeError = require('es-errors/type');
var isObject = require('es-object-atoms/isObject');

var isPropertyDescriptor = require('../helpers/records/property-descriptor');

var IsAccessorDescriptor = require('./IsAccessorDescriptor');
var IsExtensible = require('./IsExtensible');
var isPropertyKey = require('../helpers/isPropertyKey');
var ToPropertyDescriptor = require('./ToPropertyDescriptor');
var SameValue = require('./SameValue');
var ValidateAndApplyPropertyDescriptor = require('./ValidateAndApplyPropertyDescriptor');

// https://262.ecma-international.org/6.0/#sec-ordinarydefineownproperty

module.exports = function OrdinaryDefineOwnProperty(O, P, Desc) {
	if (!isObject(O)) {
		throw new $TypeError('Assertion failed: O must be an Object');
	}
	if (!isPropertyKey(P)) {
		throw new $TypeError('Assertion failed: P must be a Property Key');
	}
	if (!isPropertyDescriptor(Desc)) {
		throw new $TypeError('Assertion failed: Desc must be a Property Descriptor');
	}
	if (!$gOPD) {
		// ES3/IE 8 fallback
		if (IsAccessorDescriptor(Desc)) {
			throw new $SyntaxError('This environment does not support accessor property descriptors.');
		}
		var creatingNormalDataProperty = !(P in O)
			&& Desc['[[Writable]]']
			&& Desc['[[Enumerable]]']
			&& Desc['[[Configurable]]']
			&& '[[Value]]' in Desc;
		var settingExistingDataProperty = (P in O)
			&& (!('[[Configurable]]' in Desc) || Desc['[[Configurable]]'])
			&& (!('[[Enumerable]]' in Desc) || Desc['[[Enumerable]]'])
			&& (!('[[Writable]]' in Desc) || Desc['[[Writable]]'])
			&& '[[Value]]' in Desc;
		if (creatingNormalDataProperty || settingExistingDataProperty) {
			O[P] = Desc['[[Value]]']; // eslint-disable-line no-param-reassign
			return SameValue(O[P], Desc['[[Value]]']);
		}
		throw new $SyntaxError('This environment does not support defining non-writable, non-enumerable, or non-configurable properties');
	}
	var desc = $gOPD(O, P);
	var current = desc && ToPropertyDescriptor(desc);
	var extensible = IsExtensible(O);
	return ValidateAndApplyPropertyDescriptor(O, P, extensible, Desc, current);
};
'use strict';

var $gOPD = require('gopd');
var $TypeError = require('es-errors/type');
var isObject = require('es-object-atoms/isObject');
var hasOwn = require('hasown');
var callBound = require('call-bound');

var $isEnumerable = callBound('Object.prototype.propertyIsEnumerable');

var IsArray = require('./IsArray');
var isPropertyKey = require('../helpers/isPropertyKey');
var IsRegExp = require('./IsRegExp');
var ToPropertyDescriptor = require('./ToPropertyDescriptor');

// https://262.ecma-international.org/6.0/#sec-ordinarygetownproperty

module.exports = function OrdinaryGetOwnProperty(O, P) {
	if (!isObject(O)) {
		throw new $TypeError('Assertion failed: O must be an Object');
	}
	if (!isPropertyKey(P)) {
		throw new $TypeError('Assertion failed: P must be a Property Key');
	}
	if (!hasOwn(O, P)) {
		return void 0;
	}
	if (!$gOPD) {
		// ES3 / IE 8 fallback
		var arrayLength = IsArray(O) && P === 'length';
		var regexLastIndex = IsRegExp(O) && P === 'lastIndex';
		return {
			'[[Configurable]]': !(arrayLength || regexLastIndex),
			'[[Enumerable]]': $isEnumerable(O, P),
			'[[Value]]': O[P],
			'[[Writable]]': true
		};
	}
	return ToPropertyDescriptor($gOPD(O, P));
};
'use strict';

var $TypeError = require('es-errors/type');
var isObject = require('es-object-atoms/isObject');

var $getProto = require('get-proto');

// https://262.ecma-international.org/7.0/#sec-ordinarygetprototypeof

module.exports = function OrdinaryGetPrototypeOf(O) {
	if (!isObject(O)) {
		throw new $TypeError('Assertion failed: O must be an Object');
	}
	if (!$getProto) {
		throw new $TypeError('This environment does not support fetching prototypes.');
	}
	return $getProto(O);
};
'use strict';

var $TypeError = require('es-errors/type');
var isObject = require('es-object-atoms/isObject');

var Get = require('./Get');
var IsCallable = require('./IsCallable');

// https://262.ecma-international.org/6.0/#sec-ordinaryhasinstance

module.exports = function OrdinaryHasInstance(C, O) {
	if (!IsCallable(C)) {
		return false;
	}
	if (!isObject(O)) {
		return false;
	}
	var P = Get(C, 'prototype');
	if (!isObject(P)) {
		throw new $TypeError('OrdinaryHasInstance called on an object with an invalid prototype property.');
	}
	return O instanceof C;
};
'use strict';

var $TypeError = require('es-errors/type');
var isObject = require('es-object-atoms/isObject');

var isPropertyKey = require('../helpers/isPropertyKey');

// https://262.ecma-international.org/6.0/#sec-ordinaryhasproperty

module.exports = function OrdinaryHasProperty(O, P) {
	if (!isObject(O)) {
		throw new $TypeError('Assertion failed: Type(O) is not Object');
	}
	if (!isPropertyKey(P)) {
		throw new $TypeError('Assertion failed: P must be a Property Key');
	}
	return P in O;
};
'use strict';

var $TypeError = require('es-errors/type');
var $setProto = require('set-proto');
var isObject = require('es-object-atoms/isObject');

var OrdinaryGetPrototypeOf = require('./OrdinaryGetPrototypeOf');

// https://262.ecma-international.org/7.0/#sec-ordinarysetprototypeof

module.exports = function OrdinarySetPrototypeOf(O, V) {
	if (V !== null && !isObject(V)) {
		throw new $TypeError('Assertion failed: V must be Object or Null');
	}
	/*
	var extensible = IsExtensible(O);
	var current = OrdinaryGetPrototypeOf(O);
	if (SameValue(V, current)) {
		return true;
	}
	if (!extensible) {
		return false;
	}
	*/
	try {
		$setProto(O, V);
	} catch (e) {
		return false;
	}
	return OrdinaryGetPrototypeOf(O) === V;
	/*
	var p = V;
	var done = false;
	while (!done) {
		if (p === null) {
			done = true;
		} else if (SameValue(p, O)) {
			return false;
		} else {
			if (wat) {
				done = true;
			} else {
				p = p.[[Prototype]];
			}
		}
	}
	O.[[Prototype]] = V;
	return true;
	*/
};
'use strict';

var $TypeError = require('es-errors/type');
var isObject = require('es-object-atoms/isObject');

var Call = require('./Call');
var Get = require('./Get');
var IsCallable = require('./IsCallable');

var inspect = require('object-inspect');

// https://262.ecma-international.org/8.0/#sec-ordinarytoprimitive

module.exports = function OrdinaryToPrimitive(O, hint) {
	if (!isObject(O)) {
		throw new $TypeError('Assertion failed: Type(O) is not Object');
	}
	if (/* typeof hint !== 'string' || */ hint !== 'string' && hint !== 'number') {
		throw new $TypeError('Assertion failed: `hint` must be "string" or "number"');
	}

	var methodNames = hint === 'string' ? ['toString', 'valueOf'] : ['valueOf', 'toString'];

	for (var i = 0; i < methodNames.length; i += 1) {
		var name = methodNames[i];
		var method = Get(O, name);
		if (IsCallable(method)) {
			var result = Call(method, O);
			if (!isObject(result)) {
				return result;
			}
		}
	}

	throw new $TypeError('No primitive value for ' + inspect(O));
};
'use strict';

var $TypeError = require('es-errors/type');

var callBound = require('call-bound');
var forEach = require('../helpers/forEach');

var $charCodeAt = callBound('String.prototype.charCodeAt');
var $numberToString = callBound('Number.prototype.toString');
var $toLowerCase = callBound('String.prototype.toLowerCase');
var $strSlice = callBound('String.prototype.slice');
var $strSplit = callBound('String.prototype.split');

// https://262.ecma-international.org/6.0/#sec-quotejsonstring

var escapes = {
	'\u0008': 'b',
	'\u000C': 'f',
	'\u000A': 'n',
	'\u000D': 'r',
	'\u0009': 't'
};

module.exports = function QuoteJSONString(value) {
	if (typeof value !== 'string') {
		throw new $TypeError('Assertion failed: `value` must be a String');
	}
	var product = '"';
	if (value) {
		forEach($strSplit(value, ''), function (C) {
			if (C === '"' || C === '\\') {
				product += '\u005C' + C;
			} else if (C === '\u0008' || C === '\u000C' || C === '\u000A' || C === '\u000D' || C === '\u0009') {
				var abbrev = escapes[C];
				product += '\u005C' + abbrev;
			} else {
				var cCharCode = $charCodeAt(C, 0);
				if (cCharCode < 0x20) {
					product += '\u005Cu' + $toLowerCase($strSlice('0000' + $numberToString(cCharCode, 16), -4));
				} else {
					product += C;
				}
			}
		});
	}
	product += '"';
	return product;
};
'use strict';

var callBound = require('call-bound');

var $RangeError = require('es-errors/range');
var $TypeError = require('es-errors/type');

var $charAt = callBound('String.prototype.charAt');
var $reverse = callBound('Array.prototype.reverse');
var $slice = callBound('Array.prototype.slice');

var hasOwnProperty = require('./HasOwnProperty');
var IsArray = require('./IsArray');

var bytesAsFloat32 = require('../helpers/bytesAsFloat32');
var bytesAsFloat64 = require('../helpers/bytesAsFloat64');
var bytesAsInteger = require('../helpers/bytesAsInteger');
var every = require('../helpers/every');
var isByteValue = require('../helpers/isByteValue');

var tableTAO = require('./tables/typed-array-objects');

// https://262.ecma-international.org/8.0/#sec-rawbytestonumber

module.exports = function RawBytesToNumber(type, rawBytes, isLittleEndian) {
	if (typeof type !== 'string' || !hasOwnProperty(tableTAO.size, '$' + type)) {
		throw new $TypeError('Assertion failed: `type` must be a TypedArray element type');
	}
	if (!IsArray(rawBytes) || !every(rawBytes, isByteValue)) {
		throw new $TypeError('Assertion failed: `rawBytes` must be an Array of bytes');
	}
	if (typeof isLittleEndian !== 'boolean') {
		throw new $TypeError('Assertion failed: `isLittleEndian` must be a Boolean');
	}

	var elementSize = tableTAO.size['$' + type]; // step 1

	if (rawBytes.length !== elementSize) {
		// this assertion is not in the spec, but it'd be an editorial error if it were ever violated
		throw new $RangeError('Assertion failed: `rawBytes` must have a length of ' + elementSize + ' for type ' + type);
	}

	// eslint-disable-next-line no-param-reassign
	rawBytes = $slice(rawBytes, 0, elementSize);
	if (!isLittleEndian) {
		$reverse(rawBytes); // step 2
	}

	if (type === 'Float32') { // step 3
		return bytesAsFloat32(rawBytes);
	}

	if (type === 'Float64') { // step 4
		return bytesAsFloat64(rawBytes);
	}

	return bytesAsInteger(rawBytes, elementSize, $charAt(type, 0) === 'U', false);
};
'use strict';

var GetIntrinsic = require('get-intrinsic');

var $RegExp = GetIntrinsic('%RegExp%');

// var RegExpAlloc = require('./RegExpAlloc');
// var RegExpInitialize = require('./RegExpInitialize');
var ToString = require('./ToString');

// https://262.ecma-international.org/6.0/#sec-regexpcreate

module.exports = function RegExpCreate(P, F) {
	// var obj = RegExpAlloc($RegExp);
	// return RegExpInitialize(obj, P, F);

	// covers spec mechanics; bypass regex brand checking
	var pattern = typeof P === 'undefined' ? '' : ToString(P);
	var flags = typeof F === 'undefined' ? '' : ToString(F);
	return new $RegExp(pattern, flags);
};
'use strict';

var $TypeError = require('es-errors/type');
var isObject = require('es-object-atoms/isObject');
var regexExec = require('call-bound')('RegExp.prototype.exec');

var Call = require('./Call');
var Get = require('./Get');
var IsCallable = require('./IsCallable');

// https://262.ecma-international.org/6.0/#sec-regexpexec

module.exports = function RegExpExec(R, S) {
	if (!isObject(R)) {
		throw new $TypeError('Assertion failed: `R` must be an Object');
	}
	if (typeof S !== 'string') {
		throw new $TypeError('Assertion failed: `S` must be a String');
	}
	var exec = Get(R, 'exec');
	if (IsCallable(exec)) {
		var result = Call(exec, R, [S]);
		if (result === null || isObject(result)) {
			return result;
		}
		throw new $TypeError('"exec" method must return `null` or an Object');
	}
	return regexExec(R, S);
};
'use strict';

module.exports = require('es-object-atoms/RequireObjectCoercible');
'use strict';

var $isNaN = require('math-intrinsics/isNaN');

// http://262.ecma-international.org/5.1/#sec-9.12

module.exports = function SameValue(x, y) {
	if (x === y) { // 0 === -0, but they are not identical.
		if (x === 0) { return 1 / x === 1 / y; }
		return true;
	}
	return $isNaN(x) && $isNaN(y);
};
'use strict';

var $TypeError = require('es-errors/type');

var SameValue = require('./SameValue');

// https://262.ecma-international.org/7.0/#sec-samevaluenonnumber

module.exports = function SameValueNonNumber(x, y) {
	if (typeof x === 'number' || typeof x !== typeof y) {
		throw new $TypeError('SameValueNonNumber requires two non-number values of the same type.');
	}
	return SameValue(x, y);
};
'use strict';

var $isNaN = require('math-intrinsics/isNaN');

// https://262.ecma-international.org/6.0/#sec-samevaluezero

module.exports = function SameValueZero(x, y) {
	return (x === y) || ($isNaN(x) && $isNaN(y));
};
'use strict';

var floor = require('./floor');
var modulo = require('./modulo');

var timeConstants = require('../helpers/timeConstants');
var msPerSecond = timeConstants.msPerSecond;
var SecondsPerMinute = timeConstants.SecondsPerMinute;

// https://262.ecma-international.org/5.1/#sec-15.9.1.10

module.exports = function SecFromTime(t) {
	return modulo(floor(t / msPerSecond), SecondsPerMinute);
};
'use strict';

var hasOwn = require('hasown');

var $TypeError = require('es-errors/type');

var getSymbolDescription = require('get-symbol-description');

var DefinePropertyOrThrow = require('./DefinePropertyOrThrow');
var IsExtensible = require('./IsExtensible');

// https://262.ecma-international.org/6.0/#sec-setfunctionname

module.exports = function SetFunctionName(F, name) {
	if (typeof F !== 'function') {
		throw new $TypeError('Assertion failed: `F` must be a function');
	}
	if (!IsExtensible(F) || hasOwn(F, 'name')) {
		throw new $TypeError('Assertion failed: `F` must be extensible, and must not have a `name` own property');
	}
	if (typeof name !== 'symbol' && typeof name !== 'string') {
		throw new $TypeError('Assertion failed: `name` must be a Symbol or a String');
	}
	if (typeof name === 'symbol') {
		var description = getSymbolDescription(name);
		// eslint-disable-next-line no-param-reassign
		name = typeof description === 'undefined' ? '' : '[' + description + ']';
	}
	if (arguments.length > 2) {
		var prefix = arguments[2];
		// eslint-disable-next-line no-param-reassign
		name = prefix + ' ' + name;
	}
	return DefinePropertyOrThrow(F, 'name', {
		'[[Value]]': name,
		'[[Writable]]': false,
		'[[Enumerable]]': false,
		'[[Configurable]]': true
	});
};
'use strict';

var GetIntrinsic = require('get-intrinsic');

var $SyntaxError = require('es-errors/syntax');
var $TypeError = require('es-errors/type');
var isObject = require('es-object-atoms/isObject');
var $gOPD = require('gopd');
var $preventExtensions = GetIntrinsic('%Object.preventExtensions%', true);
var $gOPN = GetIntrinsic('%Object.getOwnPropertyNames%', true);

var forEach = require('../helpers/forEach');

var DefinePropertyOrThrow = require('./DefinePropertyOrThrow');
var IsAccessorDescriptor = require('./IsAccessorDescriptor');
var ToPropertyDescriptor = require('./ToPropertyDescriptor');

// https://262.ecma-international.org/6.0/#sec-setintegritylevel

module.exports = function SetIntegrityLevel(O, level) {
	if (!isObject(O)) {
		throw new $TypeError('Assertion failed: Type(O) is not Object');
	}
	if (level !== 'sealed' && level !== 'frozen') {
		throw new $TypeError('Assertion failed: `level` must be `"sealed"` or `"frozen"`');
	}
	if (!$preventExtensions) {
		throw new $SyntaxError('SetIntegrityLevel requires native `Object.preventExtensions` support');
	}
	var status = $preventExtensions(O);
	if (!status) {
		return false;
	}
	if (!$gOPN) {
		throw new $SyntaxError('SetIntegrityLevel requires native `Object.getOwnPropertyNames` support');
	}
	var theKeys = $gOPN(O);
	if (level === 'sealed') {
		forEach(theKeys, function (k) {
			DefinePropertyOrThrow(O, k, { configurable: false });
		});
	} else if (level === 'frozen') {
		forEach(theKeys, function (k) {
			var currentDesc = $gOPD(O, k);
			if (typeof currentDesc !== 'undefined') {
				var desc;
				if (IsAccessorDescriptor(ToPropertyDescriptor(currentDesc))) {
					desc = { configurable: false };
				} else {
					desc = { configurable: false, writable: false };
				}
				DefinePropertyOrThrow(O, k, desc);
			}
		});
	}
	return true;
};
'use strict';

var $TypeError = require('es-errors/type');
var isObject = require('es-object-atoms/isObject');

var isPropertyKey = require('../helpers/isPropertyKey');
var SameValue = require('./SameValue');

// IE 9 does not throw in strict mode when writability/configurability/extensibility is violated
var noThrowOnStrictViolation = (function () {
	try {
		delete [].length;
		return true;
	} catch (e) {
		return false;
	}
}());

// https://262.ecma-international.org/6.0/#sec-set-o-p-v-throw

module.exports = function Set(O, P, V, Throw) {
	if (!isObject(O)) {
		throw new $TypeError('Assertion failed: `O` must be an Object');
	}
	if (!isPropertyKey(P)) {
		throw new $TypeError('Assertion failed: `P` must be a Property Key');
	}
	if (typeof Throw !== 'boolean') {
		throw new $TypeError('Assertion failed: `Throw` must be a Boolean');
	}
	if (Throw) {
		O[P] = V; // eslint-disable-line no-param-reassign
		if (noThrowOnStrictViolation && !SameValue(O[P], V)) {
			throw new $TypeError('Attempted to assign to readonly property.');
		}
		return true;
	}
	try {
		O[P] = V; // eslint-disable-line no-param-reassign
		return noThrowOnStrictViolation ? SameValue(O[P], V) : true;
	} catch (e) {
		return false;
	}

};
'use strict';

var GetIntrinsic = require('get-intrinsic');

var $SyntaxError = require('es-errors/syntax');
var $TypeError = require('es-errors/type');
var $Uint8Array = GetIntrinsic('%Uint8Array%', true);

var isInteger = require('math-intrinsics/isInteger');

var IsDetachedBuffer = require('./IsDetachedBuffer');
var NumberToRawBytes = require('./NumberToRawBytes');

var isArrayBuffer = require('is-array-buffer');
var isSharedArrayBuffer = require('is-shared-array-buffer');
var hasOwn = require('hasown');

var tableTAO = require('./tables/typed-array-objects');

var defaultEndianness = require('../helpers/defaultEndianness');
var forEach = require('../helpers/forEach');

// https://262.ecma-international.org/8.0/#sec-setvalueinbuffer

/* eslint max-params: 0 */

module.exports = function SetValueInBuffer(arrayBuffer, byteIndex, type, value, isTypedArray, order) {
	var isSAB = isSharedArrayBuffer(arrayBuffer);
	if (!isArrayBuffer(arrayBuffer) && !isSAB) {
		throw new $TypeError('Assertion failed: `arrayBuffer` must be an ArrayBuffer or a SharedArrayBuffer');
	}

	if (!isInteger(byteIndex)) {
		throw new $TypeError('Assertion failed: `byteIndex` must be an integer');
	}

	if (typeof type !== 'string' || !hasOwn(tableTAO.size, '$' + type)) {
		throw new $TypeError('Assertion failed: `type` must be one of ' + tableTAO.choices);
	}

	if (typeof value !== 'number') {
		throw new $TypeError('Assertion failed: `value` must be a number');
	}

	if (typeof isTypedArray !== 'boolean') {
		throw new $TypeError('Assertion failed: `isTypedArray` must be a boolean');
	}
	if (order !== 'SeqCst' && order !== 'Unordered' && order !== 'Init') {
		throw new $TypeError('Assertion failed: `order` must be `"SeqCst"`, `"Unordered"`, or `"Init"`');
	}

	if (arguments.length > 6 && typeof arguments[6] !== 'boolean') {
		throw new $TypeError('Assertion failed: `isLittleEndian` must be a boolean, if present');
	}

	if (IsDetachedBuffer(arrayBuffer)) {
		throw new $TypeError('Assertion failed: ArrayBuffer is detached'); // step 1
	}

	// 2. Assert: There are sufficient bytes in arrayBuffer starting at byteIndex to represent a value of type.

	if (byteIndex < 0) {
		throw new $TypeError('Assertion failed: `byteIndex` must be non-negative'); // step 3
	}

	// 4. Assert: Type(value) is Number.

	// 5. Let block be arrayBuffer.[[ArrayBufferData]].

	var elementSize = tableTAO.size['$' + type]; // step 6

	// 7. If isLittleEndian is not present, set isLittleEndian to to the value of the [[LittleEndian]] field of the surrounding agent's Agent Record.
	var isLittleEndian = arguments.length > 6 ? arguments[6] : defaultEndianness === 'little'; // step 8

	var rawBytes = NumberToRawBytes(type, value, isLittleEndian); // step 8

	if (isSAB) { // step 9
		/*
			Let execution be the [[CandidateExecution]] field of the surrounding agent's Agent Record.
			Let eventList be the [[EventList]] field of the element in execution.[[EventsRecords]] whose [[AgentSignifier]] is AgentSignifier().
			If isTypedArray is true and IsNoTearConfiguration(type, order) is true, let noTear be true; otherwise let noTear be false.
			Append WriteSharedMemory { [[Order]]: order, [[NoTear]]: noTear, [[Block]]: block, [[ByteIndex]]: byteIndex, [[ElementSize]]: elementSize, [[Payload]]: rawBytes } to eventList.
		*/
		throw new $SyntaxError('SharedArrayBuffer is not supported by this implementation');
	} else {
		// 10. Store the individual bytes of rawBytes into block, in order, starting at block[byteIndex].
		var arr = new $Uint8Array(arrayBuffer, byteIndex, elementSize);
		forEach(rawBytes, function (rawByte, i) {
			arr[i] = rawByte;
		});
	}

	// 11. Return NormalCompletion(undefined).
};
'use strict';

var GetIntrinsic = require('get-intrinsic');

var $species = GetIntrinsic('%Symbol.species%', true);
var $TypeError = require('es-errors/type');
var isObject = require('es-object-atoms/isObject');

var IsConstructor = require('./IsConstructor');

// https://262.ecma-international.org/6.0/#sec-speciesconstructor

module.exports = function SpeciesConstructor(O, defaultConstructor) {
	if (!isObject(O)) {
		throw new $TypeError('Assertion failed: Type(O) is not Object');
	}
	var C = O.constructor;
	if (typeof C === 'undefined') {
		return defaultConstructor;
	}
	if (!isObject(C)) {
		throw new $TypeError('O.constructor is not an Object');
	}
	var S = $species ? C[$species] : void 0;
	if (S == null) {
		return defaultConstructor;
	}
	if (IsConstructor(S)) {
		return S;
	}
	throw new $TypeError('no constructor found');
};
'use strict';

var callBound = require('call-bound');

var $TypeError = require('es-errors/type');
var isInteger = require('math-intrinsics/isInteger');

var $charAt = callBound('String.prototype.charAt');

// https://262.ecma-international.org/6.0/#sec-splitmatch

module.exports = function SplitMatch(S, q, R) {
	if (typeof S !== 'string') {
		throw new $TypeError('Assertion failed: `S` must be a String');
	}
	if (!isInteger(q)) {
		throw new $TypeError('Assertion failed: `q` must be an integer');
	}
	if (typeof R !== 'string') {
		throw new $TypeError('Assertion failed: `R` must be a String');
	}
	var r = R.length;
	var s = S.length;
	if (q + r > s) {
		return false;
	}

	for (var i = 0; i < r; i += 1) {
		if ($charAt(S, q + i) !== $charAt(R, i)) {
			return false;
		}
	}

	return q + r;
};
'use strict';

var Type = require('./Type');

// https://262.ecma-international.org/5.1/#sec-11.9.6

module.exports = function StrictEqualityComparison(x, y) {
	if (Type(x) !== Type(y)) {
		return false;
	}
	if (typeof x === 'undefined' || x === null) {
		return true;
	}
	return x === y; // shortcut for steps 4-7
};
'use strict';

var GetIntrinsic = require('get-intrinsic');

var $Object = require('es-object-atoms');
var $StringPrototype = GetIntrinsic('%String.prototype%');
var $SyntaxError = require('es-errors/syntax');
var $TypeError = require('es-errors/type');
var setProto = require('set-proto');

var DefinePropertyOrThrow = require('./DefinePropertyOrThrow');

// https://262.ecma-international.org/6.0/#sec-stringcreate

module.exports = function StringCreate(value, prototype) {
	if (typeof value !== 'string') {
		throw new $TypeError('Assertion failed: `S` must be a String');
	}

	var S = $Object(value);
	if (prototype !== $StringPrototype) {
		if (setProto) {
			setProto(S, prototype);
		} else {
			throw new $SyntaxError('StringCreate: a `proto` argument that is not `String.prototype` is not supported in an environment that does not support setting the [[Prototype]]');
		}
	}

	var length = value.length;
	DefinePropertyOrThrow(S, 'length', {
		'[[Configurable]]': false,
		'[[Enumerable]]': false,
		'[[Value]]': length,
		'[[Writable]]': false
	});

	return S;
};
'use strict';

var $TypeError = require('es-errors/type');
var isObject = require('es-object-atoms/isObject');

var callBound = require('call-bound');
var $charAt = callBound('String.prototype.charAt');
var $stringToString = callBound('String.prototype.toString');

var CanonicalNumericIndexString = require('./CanonicalNumericIndexString');
var IsInteger = require('./IsInteger');

var isPropertyKey = require('../helpers/isPropertyKey');

var isNegativeZero = require('math-intrinsics/isNegativeZero');

// https://262.ecma-international.org/8.0/#sec-stringgetownproperty

module.exports = function StringGetOwnProperty(S, P) {
	var str;
	if (isObject(S)) {
		try {
			str = $stringToString(S);
		} catch (e) { /**/ }
	}
	if (typeof str !== 'string') {
		throw new $TypeError('Assertion failed: `S` must be a boxed string object');
	}
	if (!isPropertyKey(P)) {
		throw new $TypeError('Assertion failed: P is not a Property Key');
	}
	if (typeof P !== 'string') {
		return void undefined;
	}
	var index = CanonicalNumericIndexString(P);
	var len = str.length;
	if (typeof index === 'undefined' || !IsInteger(index) || isNegativeZero(index) || index < 0 || len <= index) {
		return void undefined;
	}
	var resultStr = $charAt(S, index);
	return {
		'[[Configurable]]': false,
		'[[Enumerable]]': true,
		'[[Value]]': resultStr,
		'[[Writable]]': false
	};
};
'use strict';

var $TypeError = require('es-errors/type');

var callBound = require('call-bound');

var $SymbolToString = callBound('Symbol.prototype.toString', true);

// https://262.ecma-international.org/6.0/#sec-symboldescriptivestring

module.exports = function SymbolDescriptiveString(sym) {
	if (typeof sym !== 'symbol') {
		throw new $TypeError('Assertion failed: `sym` must be a Symbol');
	}
	return $SymbolToString(sym);
};
'use strict';

var $gOPD = require('gopd');
var $TypeError = require('es-errors/type');

var every = require('../helpers/every');
var OwnPropertyKeys = require('own-keys');
var isObject = require('es-object-atoms/isObject');

var IsDataDescriptor = require('./IsDataDescriptor');
var IsExtensible = require('./IsExtensible');
var ToPropertyDescriptor = require('./ToPropertyDescriptor');

// https://262.ecma-international.org/6.0/#sec-testintegritylevel

module.exports = function TestIntegrityLevel(O, level) {
	if (!isObject(O)) {
		throw new $TypeError('Assertion failed: Type(O) is not Object');
	}
	if (level !== 'sealed' && level !== 'frozen') {
		throw new $TypeError('Assertion failed: `level` must be `"sealed"` or `"frozen"`');
	}
	var status = IsExtensible(O);
	if (status || !$gOPD) {
		return false;
	}
	var theKeys = OwnPropertyKeys(O);
	return theKeys.length === 0 || every(theKeys, function (k) {
		var currentDesc = $gOPD(O, k);
		if (typeof currentDesc !== 'undefined') {
			if (currentDesc.configurable) {
				return false;
			}
			if (level === 'frozen' && IsDataDescriptor(ToPropertyDescriptor(currentDesc)) && currentDesc.writable) {
				return false;
			}
		}
		return true;
	});
};
'use strict';

var $BooleanValueOf = require('call-bound')('Boolean.prototype.valueOf');

// https://262.ecma-international.org/6.0/#sec-properties-of-the-boolean-prototype-object

module.exports = function thisBooleanValue(value) {
	if (typeof value === 'boolean') {
		return value;
	}

	return $BooleanValueOf(value);
};
'use strict';

var callBound = require('call-bound');

var $NumberValueOf = callBound('Number.prototype.valueOf');

// https://262.ecma-international.org/6.0/#sec-properties-of-the-number-prototype-object

module.exports = function thisNumberValue(value) {
	if (typeof value === 'number') {
		return value;
	}

	return $NumberValueOf(value);
};

'use strict';

var $StringValueOf = require('call-bound')('String.prototype.valueOf');

// https://262.ecma-international.org/6.0/#sec-properties-of-the-string-prototype-object

module.exports = function thisStringValue(value) {
	if (typeof value === 'string') {
		return value;
	}

	return $StringValueOf(value);
};
'use strict';

var timeValue = require('../helpers/timeValue');

// https://262.ecma-international.org/6.0/#sec-properties-of-the-date-prototype-object

module.exports = function thisTimeValue(value) {
	return timeValue(value);
};
'use strict';

var GetIntrinsic = require('get-intrinsic');

var $Date = GetIntrinsic('%Date%');

var $isFinite = require('math-intrinsics/isFinite');
var abs = require('math-intrinsics/abs');

var ToNumber = require('./ToNumber');

// https://262.ecma-international.org/5.1/#sec-15.9.1.14

module.exports = function TimeClip(time) {
	if (!$isFinite(time) || abs(time) > 8.64e15) {
		return NaN;
	}
	return +new $Date(ToNumber(time));
};

'use strict';

var msPerDay = require('../helpers/timeConstants').msPerDay;

var DayFromYear = require('./DayFromYear');

// https://262.ecma-international.org/5.1/#sec-15.9.1.3

module.exports = function TimeFromYear(y) {
	return msPerDay * DayFromYear(y);
};
'use strict';

var modulo = require('./modulo');

var msPerDay = require('../helpers/timeConstants').msPerDay;

// https://262.ecma-international.org/5.1/#sec-15.9.1.2

module.exports = function TimeWithinDay(t) {
	return modulo(t, msPerDay);
};

'use strict';

// http://262.ecma-international.org/5.1/#sec-9.2

module.exports = function ToBoolean(value) { return !!value; };
'use strict';

var GetIntrinsic = require('get-intrinsic');

var $TypeError = require('es-errors/type');
var $Date = GetIntrinsic('%Date%');
var $String = GetIntrinsic('%String%');

var $isNaN = require('math-intrinsics/isNaN');

// https://262.ecma-international.org/6.0/#sec-todatestring

module.exports = function ToDateString(tv) {
	if (typeof tv !== 'number') {
		throw new $TypeError('Assertion failed: `tv` must be a Number');
	}
	if ($isNaN(tv)) {
		return 'Invalid Date';
	}
	return $String(new $Date(tv));
};
'use strict';

var $RangeError = require('es-errors/range');

var ToInteger = require('./ToInteger');
var ToLength = require('./ToLength');
var SameValueZero = require('./SameValueZero');

// https://262.ecma-international.org/8.0/#sec-toindex

module.exports = function ToIndex(value) {
	if (typeof value === 'undefined') {
		return 0;
	}
	var integerIndex = ToInteger(value);
	if (integerIndex < 0) {
		throw new $RangeError('index must be >= 0');
	}
	var index = ToLength(integerIndex);
	if (!SameValueZero(integerIndex, index)) {
		throw new $RangeError('index must be >= 0 and < 2 ** 53 - 1');
	}
	return index;
};
'use strict';

var ToUint16 = require('./ToUint16');

// https://262.ecma-international.org/6.0/#sec-toint16

module.exports = function ToInt16(argument) {
	var int16bit = ToUint16(argument);
	return int16bit >= 0x8000 ? int16bit - 0x10000 : int16bit;
};
'use strict';

var ToNumber = require('./ToNumber');

// http://262.ecma-international.org/5.1/#sec-9.5

module.exports = function ToInt32(x) {
	return ToNumber(x) >> 0;
};
'use strict';

var ToUint8 = require('./ToUint8');

// https://262.ecma-international.org/6.0/#sec-toint8

module.exports = function ToInt8(argument) {
	var int8bit = ToUint8(argument);
	return int8bit >= 0x80 ? int8bit - 0x100 : int8bit;
};
'use strict';

var ES5ToInteger = require('../5/ToInteger');

var ToNumber = require('./ToNumber');

// https://262.ecma-international.org/6.0/#sec-tointeger

module.exports = function ToInteger(value) {
	var number = ToNumber(value);
	return ES5ToInteger(number);
};
'use strict';

var MAX_SAFE_INTEGER = require('math-intrinsics/constants/maxSafeInteger');

var ToInteger = require('./ToInteger');

// https://262.ecma-international.org/6.0/#sec-tolength

module.exports = function ToLength(argument) {
	var len = ToInteger(argument);
	if (len <= 0) { return 0; } // includes converting -0 to +0
	if (len > MAX_SAFE_INTEGER) { return MAX_SAFE_INTEGER; }
	return len;
};
'use strict';

var GetIntrinsic = require('get-intrinsic');

var $TypeError = require('es-errors/type');
var $Number = GetIntrinsic('%Number%');
var $RegExp = GetIntrinsic('%RegExp%');
var $parseInteger = GetIntrinsic('%parseInt%');

var callBound = require('call-bound');
var regexTester = require('safe-regex-test');
var isPrimitive = require('../helpers/isPrimitive');

var $strSlice = callBound('String.prototype.slice');
var isBinary = regexTester(/^0b[01]+$/i);
var isOctal = regexTester(/^0o[0-7]+$/i);
var isInvalidHexLiteral = regexTester(/^[-+]0x[0-9a-f]+$/i);
var nonWS = ['\u0085', '\u200b', '\ufffe'].join('');
var nonWSregex = new $RegExp('[' + nonWS + ']', 'g');
var hasNonWS = regexTester(nonWSregex);

var $trim = require('string.prototype.trim');

var ToPrimitive = require('./ToPrimitive');

// https://262.ecma-international.org/6.0/#sec-tonumber

module.exports = function ToNumber(argument) {
	var value = isPrimitive(argument) ? argument : ToPrimitive(argument, $Number);
	if (typeof value === 'symbol') {
		throw new $TypeError('Cannot convert a Symbol value to a number');
	}
	if (typeof value === 'string') {
		if (isBinary(value)) {
			return ToNumber($parseInteger($strSlice(value, 2), 2));
		} else if (isOctal(value)) {
			return ToNumber($parseInteger($strSlice(value, 2), 8));
		} else if (hasNonWS(value) || isInvalidHexLiteral(value)) {
			return NaN;
		}
		var trimmed = $trim(value);
		if (trimmed !== value) {
			return ToNumber(trimmed);
		}

	}
	return +value;
};
'use strict';

// https://262.ecma-international.org/6.0/#sec-toobject

module.exports = require('es-object-atoms/ToObject');
'use strict';

var toPrimitive = require('es-to-primitive/es2015');

// https://262.ecma-international.org/6.0/#sec-toprimitive

module.exports = function ToPrimitive(input) {
	if (arguments.length > 1) {
		return toPrimitive(input, arguments[1]);
	}
	return toPrimitive(input);
};
'use strict';

var hasOwn = require('hasown');

var $TypeError = require('es-errors/type');
var isObject = require('es-object-atoms/isObject');

var IsCallable = require('./IsCallable');
var ToBoolean = require('./ToBoolean');

// https://262.ecma-international.org/5.1/#sec-8.10.5

module.exports = function ToPropertyDescriptor(Obj) {
	if (!isObject(Obj)) {
		throw new $TypeError('ToPropertyDescriptor requires an object');
	}

	var desc = {};
	if (hasOwn(Obj, 'enumerable')) {
		desc['[[Enumerable]]'] = ToBoolean(Obj.enumerable);
	}
	if (hasOwn(Obj, 'configurable')) {
		desc['[[Configurable]]'] = ToBoolean(Obj.configurable);
	}
	if (hasOwn(Obj, 'value')) {
		desc['[[Value]]'] = Obj.value;
	}
	if (hasOwn(Obj, 'writable')) {
		desc['[[Writable]]'] = ToBoolean(Obj.writable);
	}
	if (hasOwn(Obj, 'get')) {
		var getter = Obj.get;
		if (typeof getter !== 'undefined' && !IsCallable(getter)) {
			throw new $TypeError('getter must be a function');
		}
		desc['[[Get]]'] = getter;
	}
	if (hasOwn(Obj, 'set')) {
		var setter = Obj.set;
		if (typeof setter !== 'undefined' && !IsCallable(setter)) {
			throw new $TypeError('setter must be a function');
		}
		desc['[[Set]]'] = setter;
	}

	if ((hasOwn(desc, '[[Get]]') || hasOwn(desc, '[[Set]]')) && (hasOwn(desc, '[[Value]]') || hasOwn(desc, '[[Writable]]'))) {
		throw new $TypeError('Invalid property descriptor. Cannot both specify accessors and a value or writable attribute');
	}
	return desc;
};
'use strict';

var GetIntrinsic = require('get-intrinsic');

var $String = GetIntrinsic('%String%');

var ToPrimitive = require('./ToPrimitive');
var ToString = require('./ToString');

// https://262.ecma-international.org/6.0/#sec-topropertykey

module.exports = function ToPropertyKey(argument) {
	var key = ToPrimitive(argument, $String);
	return typeof key === 'symbol' ? key : ToString(key);
};
'use strict';

var GetIntrinsic = require('get-intrinsic');

var $String = GetIntrinsic('%String%');
var $TypeError = require('es-errors/type');

// https://262.ecma-international.org/6.0/#sec-tostring

module.exports = function ToString(argument) {
	if (typeof argument === 'symbol') {
		throw new $TypeError('Cannot convert a Symbol value to a string');
	}
	return $String(argument);
};
'use strict';

var modulo = require('./modulo');
var ToNumber = require('./ToNumber');

var abs = require('math-intrinsics/abs');
var floor = require('math-intrinsics/floor');
var $isNaN = require('math-intrinsics/isNaN');
var $isFinite = require('math-intrinsics/isFinite');
var $sign = require('math-intrinsics/sign');

// http://262.ecma-international.org/5.1/#sec-9.7

module.exports = function ToUint16(value) {
	var number = ToNumber(value);
	if ($isNaN(number) || number === 0 || !$isFinite(number)) { return 0; }
	var posInt = $sign(number) * floor(abs(number));
	return modulo(posInt, 0x10000);
};
'use strict';

var ToNumber = require('./ToNumber');

// http://262.ecma-international.org/5.1/#sec-9.6

module.exports = function ToUint32(x) {
	return ToNumber(x) >>> 0;
};
'use strict';

var ToNumber = require('./ToNumber');
var floor = require('./floor');

var $isNaN = require('math-intrinsics/isNaN');

// https://262.ecma-international.org/6.0/#sec-touint8clamp

module.exports = function ToUint8Clamp(argument) {
	var number = ToNumber(argument);
	if ($isNaN(number) || number <= 0) { return 0; }
	if (number >= 0xFF) { return 0xFF; }
	var f = floor(number);
	if (f + 0.5 < number) { return f + 1; }
	if (number < f + 0.5) { return f; }
	if (f % 2 !== 0) { return f + 1; }
	return f;
};
'use strict';

var ToNumber = require('./ToNumber');

var $isNaN = require('math-intrinsics/isNaN');
var $isFinite = require('math-intrinsics/isFinite');
var $sign = require('math-intrinsics/sign');
var abs = require('math-intrinsics/abs');
var floor = require('math-intrinsics/floor');
var modulo = require('math-intrinsics/mod');

// https://262.ecma-international.org/6.0/#sec-touint8

module.exports = function ToUint8(argument) {
	var number = ToNumber(argument);
	if ($isNaN(number) || number === 0 || !$isFinite(number)) { return 0; }
	var posInt = $sign(number) * floor(abs(number));
	return modulo(posInt, 0x100);
};
'use strict';

var $SyntaxError = require('es-errors/syntax');
var $TypeError = require('es-errors/type');

var IsArray = require('./IsArray');
var IsConstructor = require('./IsConstructor');
var ValidateTypedArray = require('./ValidateTypedArray');

var availableTypedArrays = require('available-typed-arrays')();
var typedArrayLength = require('typed-array-length');

// https://262.ecma-international.org/7.0/#typedarray-create

module.exports = function TypedArrayCreate(constructor, argumentList) {
	if (!IsConstructor(constructor)) {
		throw new $TypeError('Assertion failed: `constructor` must be a constructor');
	}
	if (!IsArray(argumentList)) {
		throw new $TypeError('Assertion failed: `argumentList` must be a List');
	}
	if (availableTypedArrays.length === 0) {
		throw new $SyntaxError('Assertion failed: Typed Arrays are not supported in this environment');
	}

	// var newTypedArray = Construct(constructor, argumentList); // step 1
	var newTypedArray;
	if (argumentList.length === 0) {
		newTypedArray = new constructor();
	} else if (argumentList.length === 1) {
		newTypedArray = new constructor(argumentList[0]);
	} else if (argumentList.length === 2) {
		newTypedArray = new constructor(argumentList[0], argumentList[1]);
	} else {
		newTypedArray = new constructor(argumentList[0], argumentList[1], argumentList[2]);
	}

	ValidateTypedArray(newTypedArray); // step 2

	if (argumentList.length === 1 && typeof argumentList[0] === 'number') { // step 3
		if (typedArrayLength(newTypedArray) < argumentList[0]) {
			throw new $TypeError('Assertion failed: `argumentList[0]` must be <= `newTypedArray.length`'); // step 3.a
		}
	}

	return newTypedArray; // step 4
};
'use strict';

var $SyntaxError = require('es-errors/syntax');
var $TypeError = require('es-errors/type');

var whichTypedArray = require('which-typed-array');
var availableTypedArrays = require('available-typed-arrays')();

var IsArray = require('./IsArray');
var SpeciesConstructor = require('./SpeciesConstructor');
var TypedArrayCreate = require('./TypedArrayCreate');

var getConstructor = require('../helpers/typedArrayConstructors');

// https://262.ecma-international.org/7.0/#typedarray-species-create

module.exports = function TypedArraySpeciesCreate(exemplar, argumentList) {
	if (availableTypedArrays.length === 0) {
		throw new $SyntaxError('Assertion failed: Typed Arrays are not supported in this environment');
	}

	var kind = whichTypedArray(exemplar);
	if (!kind) {
		throw new $TypeError('Assertion failed: exemplar must be a TypedArray'); // step 1
	}
	if (!IsArray(argumentList)) {
		throw new $TypeError('Assertion failed: `argumentList` must be a List'); // step 1
	}

	var defaultConstructor = getConstructor(kind); // step 2
	if (typeof defaultConstructor !== 'function') {
		throw new $SyntaxError('Assertion failed: `constructor` of `exemplar` (' + kind + ') must exist. Please report this!');
	}
	var constructor = SpeciesConstructor(exemplar, defaultConstructor); // step 3

	return TypedArrayCreate(constructor, argumentList); // step 4
};
'use strict';

var ES5Type = require('../5/Type');

// https://262.ecma-international.org/6.0/#sec-ecmascript-data-types-and-values

module.exports = function Type(x) {
	if (typeof x === 'symbol') {
		return 'Symbol';
	}
	return ES5Type(x);
};
'use strict';

var GetIntrinsic = require('get-intrinsic');

var $TypeError = require('es-errors/type');
var $fromCharCode = GetIntrinsic('%String.fromCharCode%');

// https://262.ecma-international.org/7.0/#sec-utf16decode

var isLeadingSurrogate = require('../helpers/isLeadingSurrogate');
var isTrailingSurrogate = require('../helpers/isTrailingSurrogate');

// https://262.ecma-international.org/11.0/#sec-utf16decodesurrogatepair

module.exports = function UTF16Decode(lead, trail) {
	if (!isLeadingSurrogate(lead) || !isTrailingSurrogate(trail)) {
		throw new $TypeError('Assertion failed: `lead` must be a leading surrogate char code, and `trail` must be a trailing surrogate char code');
	}
	// var cp = (lead - 0xD800) * 0x400 + (trail - 0xDC00) + 0x10000;
	return $fromCharCode(lead) + $fromCharCode(trail);
};
'use strict';

var GetIntrinsic = require('get-intrinsic');

var $TypeError = require('es-errors/type');
var $fromCharCode = GetIntrinsic('%String.fromCharCode%');

var floor = require('./floor');
var modulo = require('./modulo');

var isCodePoint = require('../helpers/isCodePoint');

// https://262.ecma-international.org/7.0/#sec-utf16encoding

module.exports = function UTF16Encoding(cp) {
	if (!isCodePoint(cp)) {
		throw new $TypeError('Assertion failed: `cp` must be >= 0 and <= 0x10FFFF');
	}
	if (cp <= 65535) {
		return $fromCharCode(cp);
	}
	var cu1 = $fromCharCode(floor((cp - 65536) / 1024) + 0xD800);
	var cu2 = $fromCharCode(modulo(cp - 65536, 1024) + 0xDC00);
	return cu1 + cu2;
};
'use strict';

var $TypeError = require('es-errors/type');
var isObject = require('es-object-atoms/isObject');

var DefineOwnProperty = require('../helpers/DefineOwnProperty');
var isPropertyDescriptor = require('../helpers/records/property-descriptor');
var isSamePropertyDescriptor = require('../helpers/isSamePropertyDescriptor');

var FromPropertyDescriptor = require('./FromPropertyDescriptor');
var IsAccessorDescriptor = require('./IsAccessorDescriptor');
var IsDataDescriptor = require('./IsDataDescriptor');
var IsGenericDescriptor = require('./IsGenericDescriptor');
var isPropertyKey = require('../helpers/isPropertyKey');
var SameValue = require('./SameValue');

// https://262.ecma-international.org/6.0/#sec-validateandapplypropertydescriptor
// https://262.ecma-international.org/8.0/#sec-validateandapplypropertydescriptor

// eslint-disable-next-line max-lines-per-function, max-statements
module.exports = function ValidateAndApplyPropertyDescriptor(O, P, extensible, Desc, current) {
	// this uses the ES2017+ logic, since it fixes a number of bugs in the ES2015 logic.
	if (typeof O !== 'undefined' && !isObject(O)) {
		throw new $TypeError('Assertion failed: O must be undefined or an Object');
	}
	if (typeof extensible !== 'boolean') {
		throw new $TypeError('Assertion failed: extensible must be a Boolean');
	}
	if (!isPropertyDescriptor(Desc)) {
		throw new $TypeError('Assertion failed: Desc must be a Property Descriptor');
	}
	if (typeof current !== 'undefined' && !isPropertyDescriptor(current)) {
		throw new $TypeError('Assertion failed: current must be a Property Descriptor, or undefined');
	}
	if (typeof O !== 'undefined' && !isPropertyKey(P)) {
		throw new $TypeError('Assertion failed: if O is not undefined, P must be a Property Key');
	}
	if (typeof current === 'undefined') {
		if (!extensible) {
			return false;
		}
		if (IsGenericDescriptor(Desc) || IsDataDescriptor(Desc)) {
			if (typeof O !== 'undefined') {
				DefineOwnProperty(
					IsDataDescriptor,
					SameValue,
					FromPropertyDescriptor,
					O,
					P,
					{
						'[[Configurable]]': Desc['[[Configurable]]'],
						'[[Enumerable]]': Desc['[[Enumerable]]'],
						'[[Value]]': Desc['[[Value]]'],
						'[[Writable]]': Desc['[[Writable]]']
					}
				);
			}
		} else {
			if (!IsAccessorDescriptor(Desc)) {
				throw new $TypeError('Assertion failed: Desc is not an accessor descriptor');
			}
			if (typeof O !== 'undefined') {
				return DefineOwnProperty(
					IsDataDescriptor,
					SameValue,
					FromPropertyDescriptor,
					O,
					P,
					Desc
				);
			}
		}
		return true;
	}
	if (IsGenericDescriptor(Desc) && !('[[Configurable]]' in Desc) && !('[[Enumerable]]' in Desc)) {
		return true;
	}
	if (isSamePropertyDescriptor({ SameValue: SameValue }, Desc, current)) {
		return true; // removed by ES2017, but should still be correct
	}
	// "if every field in Desc is absent, return true" can't really match the assertion that it's a Property Descriptor
	if (!current['[[Configurable]]']) {
		if (Desc['[[Configurable]]']) {
			return false;
		}
		if ('[[Enumerable]]' in Desc && !Desc['[[Enumerable]]'] === !!current['[[Enumerable]]']) {
			return false;
		}
	}
	if (IsGenericDescriptor(Desc)) {
		// no further validation is required.
	} else if (IsDataDescriptor(current) !== IsDataDescriptor(Desc)) {
		if (!current['[[Configurable]]']) {
			return false;
		}
		if (IsDataDescriptor(current)) {
			if (typeof O !== 'undefined') {
				DefineOwnProperty(
					IsDataDescriptor,
					SameValue,
					FromPropertyDescriptor,
					O,
					P,
					{
						'[[Configurable]]': current['[[Configurable]]'],
						'[[Enumerable]]': current['[[Enumerable]]'],
						'[[Get]]': undefined
					}
				);
			}
		} else if (typeof O !== 'undefined') {
			DefineOwnProperty(
				IsDataDescriptor,
				SameValue,
				FromPropertyDescriptor,
				O,
				P,
				{
					'[[Configurable]]': current['[[Configurable]]'],
					'[[Enumerable]]': current['[[Enumerable]]'],
					'[[Value]]': undefined
				}
			);
		}
	} else if (IsDataDescriptor(current) && IsDataDescriptor(Desc)) {
		if (!current['[[Configurable]]'] && !current['[[Writable]]']) {
			if ('[[Writable]]' in Desc && Desc['[[Writable]]']) {
				return false;
			}
			if ('[[Value]]' in Desc && !SameValue(Desc['[[Value]]'], current['[[Value]]'])) {
				return false;
			}
			return true;
		}
	} else if (IsAccessorDescriptor(current) && IsAccessorDescriptor(Desc)) {
		if (!current['[[Configurable]]']) {
			if ('[[Set]]' in Desc && !SameValue(Desc['[[Set]]'], current['[[Set]]'])) {
				return false;
			}
			if ('[[Get]]' in Desc && !SameValue(Desc['[[Get]]'], current['[[Get]]'])) {
				return false;
			}
			return true;
		}
	} else {
		throw new $TypeError('Assertion failed: current and Desc are not both data, both accessors, or one accessor and one data.');
	}
	if (typeof O !== 'undefined') {
		return DefineOwnProperty(
			IsDataDescriptor,
			SameValue,
			FromPropertyDescriptor,
			O,
			P,
			Desc
		);
	}
	return true;
};
'use strict';

var $RangeError = require('es-errors/range');
var $TypeError = require('es-errors/type');

var ToIndex = require('./ToIndex');

var isTypedArray = require('is-typed-array');
var typedArrayLength = require('typed-array-length');

// https://262.ecma-international.org/8.0/#sec-validateatomicaccess

module.exports = function ValidateAtomicAccess(typedArray, requestIndex) {
	if (!isTypedArray(typedArray)) {
		throw new $TypeError('Assertion failed: `typedArray` must be a TypedArray'); // step 1
	}

	var accessIndex = ToIndex(requestIndex); // step 2

	var length = typedArrayLength(typedArray); // step 3

	/*
	// this assertion can never be reached
	if (!(accessIndex >= 0)) {
		throw new $TypeError('Assertion failed: accessIndex >= 0'); // step 4
	}
	*/

	if (accessIndex >= length) {
		throw new $RangeError('index out of range'); // step 5
	}

	return accessIndex; // step 6
};
'use strict';

var $TypeError = require('es-errors/type');
var isObject = require('es-object-atoms/isObject');

var IsDetachedBuffer = require('./IsDetachedBuffer');

var isTypedArray = require('is-typed-array');
var typedArrayBuffer = require('typed-array-buffer');

// https://262.ecma-international.org/6.0/#sec-validatetypedarray

module.exports = function ValidateTypedArray(O) {
	if (!isObject(O)) {
		throw new $TypeError('Assertion failed: `O` must be an Object'); // step 1
	}
	if (!isTypedArray(O)) {
		throw new $TypeError('Assertion failed: `O` must be a Typed Array'); // steps 2 - 3
	}

	var buffer = typedArrayBuffer(O); // step 4

	if (IsDetachedBuffer(buffer)) {
		throw new $TypeError('`O` must be backed by a non-detached buffer'); // step 5
	}

	return buffer; // step 6
};
'use strict';

var Day = require('./Day');
var modulo = require('./modulo');

// https://262.ecma-international.org/5.1/#sec-15.9.1.6

module.exports = function WeekDay(t) {
	return modulo(Day(t) + 4, 7);
};
'use strict';

var $TypeError = require('es-errors/type');

var callBound = require('call-bound');
var $indexOf = callBound('String.prototype.indexOf');

var Canonicalize = require('./Canonicalize');

var caseFolding = require('../helpers/caseFolding.json');
var forEach = require('../helpers/forEach');
var OwnPropertyKeys = require('own-keys');

var A = 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789_'; // step 1

// https://262.ecma-international.org/8.0/#sec-runtime-semantics-wordcharacters-abstract-operation

module.exports = function WordCharacters(IgnoreCase, Unicode) {
	if (typeof IgnoreCase !== 'boolean' || typeof Unicode !== 'boolean') {
		throw new $TypeError('Assertion failed: `IgnoreCase` and `Unicode` must be booleans');
	}

	var U = '';
	forEach(OwnPropertyKeys(caseFolding.C), function (c) {
		if (
			$indexOf(A, c) === -1 // c not in A
			&& $indexOf(A, Canonicalize(c, IgnoreCase, Unicode)) > -1 // canonicalized c IS in A
		) {
			U += caseFolding.C[c]; // step 3
		}
	});
	forEach(OwnPropertyKeys(caseFolding.S), function (c) {
		if (
			$indexOf(A, c) === -1 // c not in A
			&& $indexOf(A, Canonicalize(c, IgnoreCase, Unicode)) > -1 // canonicalized c IS in A
		) {
			U += caseFolding.S[c]; // step 3
		}
	});

	if ((!Unicode || !IgnoreCase) && U.length > 0) {
		throw new $TypeError('Assertion failed: `U` must be empty when `IgnoreCase` and `Unicode` are not both true'); // step 4
	}

	return A + U; // step 5, 6
};
'use strict';

var GetIntrinsic = require('get-intrinsic');

var $Date = GetIntrinsic('%Date%');

var callBound = require('call-bound');

var $getUTCFullYear = callBound('Date.prototype.getUTCFullYear');

// https://262.ecma-international.org/5.1/#sec-15.9.1.3

module.exports = function YearFromTime(t) {
	// largest y such that this.TimeFromYear(y) <= t
	return $getUTCFullYear(new $Date(t));
};
'use strict';

var $abs = require('math-intrinsics/abs');

// https://262.ecma-international.org/5.1/#sec-5.2

module.exports = function abs(x) {
	return $abs(x);
};
'use strict';

var ToNumber = require('./ToNumber');
var ToPrimitive = require('./ToPrimitive');

var isSameType = require('../helpers/isSameType');

var isObject = require('es-object-atoms/isObject');

// https://262.ecma-international.org/6.0/#sec-abstract-equality-comparison

module.exports = function AbstractEqualityComparison(x, y) {
	if (isSameType(x, y)) {
		return x === y; // ES6+ specified this shortcut anyways.
	}
	if (x == null && y == null) {
		return true;
	}
	if (typeof x === 'number' && typeof y === 'string') {
		return AbstractEqualityComparison(x, ToNumber(y));
	}
	if (typeof x === 'string' && typeof y === 'number') {
		return AbstractEqualityComparison(ToNumber(x), y);
	}
	if (typeof x === 'boolean') {
		return AbstractEqualityComparison(ToNumber(x), y);
	}
	if (typeof y === 'boolean') {
		return AbstractEqualityComparison(x, ToNumber(y));
	}
	if ((typeof x === 'string' || typeof x === 'number' || typeof x === 'symbol') && isObject(y)) {
		return AbstractEqualityComparison(x, ToPrimitive(y));
	}
	if (isObject(x) && (typeof y === 'string' || typeof y === 'number' || typeof y === 'symbol')) {
		return AbstractEqualityComparison(ToPrimitive(x), y);
	}
	return false;
};
'use strict';

var GetIntrinsic = require('get-intrinsic');

var $Number = GetIntrinsic('%Number%');
var $TypeError = require('es-errors/type');
var $isNaN = require('math-intrinsics/isNaN');
var $isFinite = require('math-intrinsics/isFinite');

var IsStringPrefix = require('./IsStringPrefix');
var ToNumber = require('./ToNumber');
var ToPrimitive = require('./ToPrimitive');

// https://262.ecma-international.org/9.0/#sec-abstract-relational-comparison

module.exports = function AbstractRelationalComparison(x, y, LeftFirst) {
	if (typeof LeftFirst !== 'boolean') {
		throw new $TypeError('Assertion failed: LeftFirst argument must be a Boolean');
	}
	var px;
	var py;
	if (LeftFirst) {
		px = ToPrimitive(x, $Number);
		py = ToPrimitive(y, $Number);
	} else {
		py = ToPrimitive(y, $Number);
		px = ToPrimitive(x, $Number);
	}
	if (typeof px === 'string' && typeof py === 'string') {
		if (IsStringPrefix(py, px)) {
			return false;
		}
		if (IsStringPrefix(px, py)) {
			return true;
		}
		return px < py; // both strings, neither a prefix of the other. shortcut for steps 3 c-f
	}
	var nx = ToNumber(px);
	var ny = ToNumber(py);
	if ($isNaN(nx) || $isNaN(ny)) {
		return undefined;
	}
	if ($isFinite(nx) && $isFinite(ny) && nx === ny) {
		return false;
	}
	if (nx === Infinity) {
		return false;
	}
	if (ny === Infinity) {
		return true;
	}
	if (ny === -Infinity) {
		return false;
	}
	if (nx === -Infinity) {
		return true;
	}
	return nx < ny; // by now, these are both nonzero, finite, and not equal
};
'use strict';

var isInteger = require('math-intrinsics/isInteger');
var MAX_SAFE_INTEGER = require('math-intrinsics/constants/maxSafeInteger');

var isLeadingSurrogate = require('../helpers/isLeadingSurrogate');
var isTrailingSurrogate = require('../helpers/isTrailingSurrogate');

var $TypeError = require('es-errors/type');

var $charCodeAt = require('call-bound')('String.prototype.charCodeAt');

// https://262.ecma-international.org/6.0/#sec-advancestringindex

module.exports = function AdvanceStringIndex(S, index, unicode) {
	if (typeof S !== 'string') {
		throw new $TypeError('Assertion failed: `S` must be a String');
	}
	if (!isInteger(index) || index < 0 || index > MAX_SAFE_INTEGER) {
		throw new $TypeError('Assertion failed: `length` must be an integer >= 0 and <= 2**53');
	}
	if (typeof unicode !== 'boolean') {
		throw new $TypeError('Assertion failed: `unicode` must be a Boolean');
	}
	if (!unicode) {
		return index + 1;
	}
	var length = S.length;
	if ((index + 1) >= length) {
		return index + 1;
	}

	var first = $charCodeAt(S, index);
	if (!isLeadingSurrogate(first)) {
		return index + 1;
	}

	var second = $charCodeAt(S, index + 1);
	if (!isTrailingSurrogate(second)) {
		return index + 1;
	}

	return index + 2;
};
'use strict';

var GetIntrinsic = require('get-intrinsic');

var $ArrayPrototype = GetIntrinsic('%Array.prototype%');
var $RangeError = require('es-errors/range');
var $SyntaxError = require('es-errors/syntax');
var $TypeError = require('es-errors/type');
var isInteger = require('math-intrinsics/isInteger');
var MAX_ARRAY_LENGTH = require('math-intrinsics/constants/maxArrayLength');
var $setProto = require('set-proto');

// https://262.ecma-international.org/6.0/#sec-arraycreate

module.exports = function ArrayCreate(length) {
	if (!isInteger(length) || length < 0) {
		throw new $TypeError('Assertion failed: `length` must be an integer Number >= 0');
	}
	if (length > MAX_ARRAY_LENGTH) {
		throw new $RangeError('length is greater than (2**32 - 1)');
	}
	var proto = arguments.length > 1 ? arguments[1] : $ArrayPrototype;
	var A = []; // steps 5 - 7, and 9
	if (proto !== $ArrayPrototype) { // step 8
		if (!$setProto) {
			throw new $SyntaxError('ArrayCreate: a `proto` argument that is not `Array.prototype` is not supported in an environment that does not support setting the [[Prototype]]');
		}
		$setProto(A, proto);
	}
	if (length !== 0) { // bypasses the need for step 2
		A.length = length;
	}
	/* step 10, the above as a shortcut for the below
	OrdinaryDefineOwnProperty(A, 'length', {
		'[[Configurable]]': false,
		'[[Enumerable]]': false,
		'[[Value]]': length,
		'[[Writable]]': true
	});
	*/
	return A;
};
'use strict';

var $RangeError = require('es-errors/range');
var $TypeError = require('es-errors/type');

var assign = require('object.assign');

var isPropertyDescriptor = require('../helpers/records/property-descriptor');

var IsArray = require('./IsArray');
var IsDataDescriptor = require('./IsDataDescriptor');
var OrdinaryDefineOwnProperty = require('./OrdinaryDefineOwnProperty');
var OrdinaryGetOwnProperty = require('./OrdinaryGetOwnProperty');
var ToNumber = require('./ToNumber');
var ToString = require('./ToString');
var ToUint32 = require('./ToUint32');

// https://262.ecma-international.org/6.0/#sec-arraysetlength

// eslint-disable-next-line max-statements, max-lines-per-function
module.exports = function ArraySetLength(A, Desc) {
	if (!IsArray(A)) {
		throw new $TypeError('Assertion failed: A must be an Array');
	}
	if (!isPropertyDescriptor(Desc)) {
		throw new $TypeError('Assertion failed: Desc must be a Property Descriptor');
	}
	if (!('[[Value]]' in Desc)) {
		return OrdinaryDefineOwnProperty(A, 'length', Desc);
	}
	var newLenDesc = assign({}, Desc);
	var newLen = ToUint32(Desc['[[Value]]']);
	var numberLen = ToNumber(Desc['[[Value]]']);
	if (newLen !== numberLen) {
		throw new $RangeError('Invalid array length');
	}
	newLenDesc['[[Value]]'] = newLen;
	var oldLenDesc = OrdinaryGetOwnProperty(A, 'length');
	if (!IsDataDescriptor(oldLenDesc)) {
		throw new $TypeError('Assertion failed: an array had a non-data descriptor on `length`');
	}
	var oldLen = oldLenDesc['[[Value]]'];
	if (newLen >= oldLen) {
		return OrdinaryDefineOwnProperty(A, 'length', newLenDesc);
	}
	if (!oldLenDesc['[[Writable]]']) {
		return false;
	}
	var newWritable;
	if (!('[[Writable]]' in newLenDesc) || newLenDesc['[[Writable]]']) {
		newWritable = true;
	} else {
		newWritable = false;
		newLenDesc['[[Writable]]'] = true;
	}
	var succeeded = OrdinaryDefineOwnProperty(A, 'length', newLenDesc);
	if (!succeeded) {
		return false;
	}
	while (newLen < oldLen) {
		oldLen -= 1;
		// eslint-disable-next-line no-param-reassign
		var deleteSucceeded = delete A[ToString(oldLen)];
		if (!deleteSucceeded) {
			newLenDesc['[[Value]]'] = oldLen + 1;
			if (!newWritable) {
				newLenDesc['[[Writable]]'] = false;
				OrdinaryDefineOwnProperty(A, 'length', newLenDesc);
				return false;
			}
		}
	}
	if (!newWritable) {
		return OrdinaryDefineOwnProperty(A, 'length', { '[[Writable]]': false });
	}
	return true;
};
'use strict';

var GetIntrinsic = require('get-intrinsic');

var $Array = GetIntrinsic('%Array%');
var $species = GetIntrinsic('%Symbol.species%', true);
var $TypeError = require('es-errors/type');
var isInteger = require('math-intrinsics/isInteger');
var isObject = require('es-object-atoms/isObject');

var Get = require('./Get');
var IsArray = require('./IsArray');
var IsConstructor = require('./IsConstructor');

// https://262.ecma-international.org/6.0/#sec-arrayspeciescreate

module.exports = function ArraySpeciesCreate(originalArray, length) {
	if (!isInteger(length) || length < 0) {
		throw new $TypeError('Assertion failed: length must be an integer >= 0');
	}
	var len = length === 0 ? 0 : length;
	var C;
	var isArray = IsArray(originalArray);
	if (isArray) {
		C = Get(originalArray, 'constructor');
		// TODO: figure out how to make a cross-realm normal Array, a same-realm Array
		// if (IsConstructor(C)) {
		// 	if C is another realm's Array, C = undefined
		// 	Object.getPrototypeOf(Object.getPrototypeOf(Object.getPrototypeOf(Array))) === null ?
		// }
		if ($species && isObject(C)) {
			C = Get(C, $species);
			if (C === null) {
				C = void 0;
			}
		}
	}
	if (typeof C === 'undefined') {
		return $Array(len);
	}
	if (!IsConstructor(C)) {
		throw new $TypeError('C must be a constructor');
	}
	return new C(len); // Construct(C, len);
};

'use strict';

var GetIntrinsic = require('get-intrinsic');

var $SyntaxError = require('es-errors/syntax');
var $TypeError = require('es-errors/type');
var isObject = require('es-object-atoms/isObject');
var $Promise = GetIntrinsic('%Promise%', true);

var Call = require('./Call');
var CompletionRecord = require('./CompletionRecord');
var GetMethod = require('./GetMethod');

var isIteratorRecord = require('../helpers/records/iterator-record-2023');

var callBound = require('call-bound');

var $then = callBound('Promise.prototype.then', true);

// https://262.ecma-international.org/9.0/#sec-asynciteratorclose

module.exports = function AsyncIteratorClose(iteratorRecord, completion) {
	if (!isIteratorRecord(iteratorRecord)) {
		throw new $TypeError('Assertion failed: `iteratorRecord` must be an Iterator Record'); // step 1
	}

	if (!(completion instanceof CompletionRecord)) {
		throw new $TypeError('Assertion failed: completion is not a Completion Record instance'); // step 2
	}

	if (!$then) {
		throw new $SyntaxError('This environment does not support Promises.');
	}

	var iterator = iteratorRecord['[[Iterator]]']; // step 3

	return new $Promise(function (resolve) {
		var ret = GetMethod(iterator, 'return'); // step 4

		if (typeof ret === 'undefined') {
			resolve(completion); // step 5
		} else {
			resolve($then(
				new $Promise(function (resolve2) {
					// process.exit(42);
					resolve2(Call(ret, iterator, [])); // step 6
				}),
				function (innerResult) {
					if (!isObject(innerResult)) {
						throw new $TypeError('`innerResult` must be an Object'); // step 10
					}
					return completion;
				},
				function (e) {
					if (completion.type() === 'throw') {
						completion['?'](); // step 8
					} else {
						throw e; // step 9
					}
				}
			));
		}
	});
};
'use strict';

var GetIntrinsic = require('get-intrinsic');
var callBound = require('call-bound');

var $TypeError = require('es-errors/type');

var IsArray = require('./IsArray');

var $apply = GetIntrinsic('%Reflect.apply%', true) || callBound('Function.prototype.apply');

// https://262.ecma-international.org/6.0/#sec-call

module.exports = function Call(F, V) {
	var argumentsList = arguments.length > 2 ? arguments[2] : [];
	if (!IsArray(argumentsList)) {
		throw new $TypeError('Assertion failed: optional `argumentsList`, if provided, must be a List');
	}
	return $apply(F, V, argumentsList);
};
'use strict';

var $TypeError = require('es-errors/type');

var callBound = require('call-bound');
var hasOwn = require('hasown');

var $charCodeAt = callBound('String.prototype.charCodeAt');
var $toUpperCase = callBound('String.prototype.toUpperCase');

var caseFolding = require('../helpers/caseFolding.json');

// https://262.ecma-international.org/6.0/#sec-runtime-semantics-canonicalize-ch

module.exports = function Canonicalize(ch, IgnoreCase, Unicode) {
	if (typeof ch !== 'string') {
		throw new $TypeError('Assertion failed: `ch` must be a character');
	}

	if (typeof IgnoreCase !== 'boolean' || typeof Unicode !== 'boolean') {
		throw new $TypeError('Assertion failed: `IgnoreCase` and `Unicode` must be Booleans');
	}

	if (!IgnoreCase) {
		return ch; // step 1
	}

	if (Unicode) { // step 2
		if (hasOwn(caseFolding.C, ch)) {
			return caseFolding.C[ch];
		}
		if (hasOwn(caseFolding.S, ch)) {
			return caseFolding.S[ch];
		}
		return ch; // step 2.b
	}

	var u = $toUpperCase(ch); // step 2

	if (u.length !== 1) {
		return ch; // step 3
	}

	var cu = u; // step 4

	if ($charCodeAt(ch, 0) >= 128 && $charCodeAt(cu, 0) < 128) {
		return ch; // step 5
	}

	return cu;
};
'use strict';

var $TypeError = require('es-errors/type');

var SameValue = require('./SameValue');
var ToNumber = require('./ToNumber');
var ToString = require('./ToString');

// https://262.ecma-international.org/6.0/#sec-canonicalnumericindexstring

module.exports = function CanonicalNumericIndexString(argument) {
	if (typeof argument !== 'string') {
		throw new $TypeError('Assertion failed: `argument` must be a String');
	}
	if (argument === '-0') { return -0; }
	var n = ToNumber(argument);
	if (SameValue(ToString(n), argument)) { return n; }
	return void 0;
};
'use strict';

var GetIntrinsic = require('get-intrinsic');
var callBound = require('call-bound');

var $fromCharCode = GetIntrinsic('%String.fromCharCode%');
var $TypeError = require('es-errors/type');
var $charCodeAt = callBound('String.prototype.charCodeAt');

var CharSet = require('../helpers/CharSet').CharSet;

module.exports = function CharacterRange(A, B) {
	var a;
	var b;

	if (A instanceof CharSet || B instanceof CharSet) {
		if (!(A instanceof CharSet) || !(B instanceof CharSet)) {
			throw new $TypeError('Assertion failed: CharSets A and B are not both CharSets');
		}

		A.yield(function (c) {
			if (typeof a !== 'undefined') {
				throw new $TypeError('Assertion failed: CharSet A has more than one character');
			}
			a = c;
		});
		B.yield(function (c) {
			if (typeof b !== 'undefined') {
				throw new $TypeError('Assertion failed: CharSet B has more than one character');
			}
			b = c;
		});
	} else {
		if (A.length !== 1 || B.length !== 1) {
			throw new $TypeError('Assertion failed: CharSets A and B contain exactly one character');
		}
		a = A[0];
		b = B[0];
	}

	var i = $charCodeAt(a, 0);
	var j = $charCodeAt(b, 0);

	if (!(i <= j)) {
		throw new $TypeError('Assertion failed: i is not <= j');
	}

	var arr = [];
	for (var k = i; k <= j; k += 1) {
		arr[arr.length] = $fromCharCode(k);
	}
	return arr;
};
'use strict';

var $TypeError = require('es-errors/type');

var hasOwn = require('hasown');

var IsDataDescriptor = require('./IsDataDescriptor');
var IsGenericDescriptor = require('./IsGenericDescriptor');

var isPropertyDescriptor = require('../helpers/records/property-descriptor');

// https://262.ecma-international.org/6.0/#sec-completepropertydescriptor

module.exports = function CompletePropertyDescriptor(Desc) {
	if (!isPropertyDescriptor(Desc)) {
		throw new $TypeError('Assertion failed: `Desc` must be a Property Descriptor');
	}

	/* eslint no-param-reassign: 0 */

	if (IsGenericDescriptor(Desc) || IsDataDescriptor(Desc)) {
		if (!hasOwn(Desc, '[[Value]]')) {
			Desc['[[Value]]'] = void 0;
		}
		if (!hasOwn(Desc, '[[Writable]]')) {
			Desc['[[Writable]]'] = false;
		}
	} else {
		if (!hasOwn(Desc, '[[Get]]')) {
			Desc['[[Get]]'] = void 0;
		}
		if (!hasOwn(Desc, '[[Set]]')) {
			Desc['[[Set]]'] = void 0;
		}
	}
	if (!hasOwn(Desc, '[[Enumerable]]')) {
		Desc['[[Enumerable]]'] = false;
	}
	if (!hasOwn(Desc, '[[Configurable]]')) {
		Desc['[[Configurable]]'] = false;
	}
	return Desc;
};
'use strict';

var $SyntaxError = require('es-errors/syntax');

var SLOT = require('internal-slot');

// https://262.ecma-international.org/7.0/#sec-completion-record-specification-type

var CompletionRecord = function CompletionRecord(type, value) {
	if (!(this instanceof CompletionRecord)) {
		return new CompletionRecord(type, value);
	}
	if (type !== 'normal' && type !== 'break' && type !== 'continue' && type !== 'return' && type !== 'throw') {
		throw new $SyntaxError('Assertion failed: `type` must be one of "normal", "break", "continue", "return", or "throw"');
	}
	SLOT.set(this, '[[Type]]', type);
	SLOT.set(this, '[[Value]]', value);
	// [[Target]] slot?
};

CompletionRecord.prototype.type = function Type() {
	return SLOT.get(this, '[[Type]]');
};

CompletionRecord.prototype.value = function Value() {
	return SLOT.get(this, '[[Value]]');
};

CompletionRecord.prototype['?'] = function ReturnIfAbrupt() {
	var type = SLOT.get(this, '[[Type]]');
	var value = SLOT.get(this, '[[Value]]');

	if (type === 'throw') {
		throw value;
	}
	return value;
};

CompletionRecord.prototype['!'] = function assert() {
	var type = SLOT.get(this, '[[Type]]');

	if (type !== 'normal') {
		throw new $SyntaxError('Assertion failed: Completion Record is not of type "normal"');
	}
	return SLOT.get(this, '[[Value]]');
};

module.exports = CompletionRecord;
'use strict';

var $TypeError = require('es-errors/type');
var isObject = require('es-object-atoms/isObject');
var callBound = require('call-bound');
var OwnPropertyKeys = require('own-keys');

var every = require('../helpers/every');
var forEach = require('../helpers/forEach');

var $isEnumerable = callBound('Object.prototype.propertyIsEnumerable');

var CreateDataProperty = require('./CreateDataProperty');
var Get = require('./Get');
var IsArray = require('./IsArray');
var IsInteger = require('./IsInteger');
var isPropertyKey = require('../helpers/isPropertyKey');
var SameValue = require('./SameValue');
var ToNumber = require('./ToNumber');
var ToObject = require('./ToObject');

// https://262.ecma-international.org/9.0/#sec-copydataproperties

module.exports = function CopyDataProperties(target, source, excludedItems) {
	if (!isObject(target)) {
		throw new $TypeError('Assertion failed: "target" must be an Object');
	}

	if (!IsArray(excludedItems) || !every(excludedItems, isPropertyKey)) {
		throw new $TypeError('Assertion failed: "excludedItems" must be a List of Property Keys');
	}

	if (typeof source === 'undefined' || source === null) {
		return target;
	}

	var fromObj = ToObject(source);

	var sourceKeys = OwnPropertyKeys(fromObj);
	forEach(sourceKeys, function (nextKey) {
		var excluded = false;

		forEach(excludedItems, function (e) {
			if (SameValue(e, nextKey) === true) {
				excluded = true;
			}
		});

		var enumerable = $isEnumerable(fromObj, nextKey) || (
			// this is to handle string keys being non-enumerable in older engines
			typeof source === 'string'
			&& nextKey >= 0
			&& IsInteger(ToNumber(nextKey))
		);
		if (excluded === false && enumerable) {
			var propValue = Get(fromObj, nextKey);
			CreateDataProperty(target, nextKey, propValue);
		}
	});

	return target;
};
'use strict';

var GetIntrinsic = require('get-intrinsic');

var $SyntaxError = require('es-errors/syntax');
var $TypeError = require('es-errors/type');
var isObject = require('es-object-atoms/isObject');
var $Promise = GetIntrinsic('%Promise%', true);

var Call = require('./Call');
var CreateIterResultObject = require('./CreateIterResultObject');
var Get = require('./Get');
var GetMethod = require('./GetMethod');
var IteratorComplete = require('./IteratorComplete');
var IteratorNext = require('./IteratorNext');
var IteratorValue = require('./IteratorValue');
var ObjectCreate = require('./ObjectCreate');
var PromiseResolve = require('./PromiseResolve');

var isIteratorRecord = require('../helpers/records/iterator-record-2023');

var SLOT = require('internal-slot');

var callBound = require('call-bound');

var $then = callBound('Promise.prototype.then', true);

var AsyncFromSyncIteratorContinuation = function AsyncFromSyncIteratorContinuation(result) {
	if (!isObject(result)) {
		throw new $TypeError('Assertion failed: Type(O) is not Object');
	}

	if (arguments.length > 1) {
		throw new $TypeError('although AsyncFromSyncIteratorContinuation should take a second argument, it is not used in this implementation');
	}

	if (!$Promise) {
		throw new $SyntaxError('This environment does not support Promises.');
	}

	return new $Promise(function (resolve) {
		var done = IteratorComplete(result); // step 2
		var value = IteratorValue(result); // step 4
		var valueWrapper = PromiseResolve($Promise, value); // step 6

		// eslint-disable-next-line no-shadow
		var onFulfilled = function (value) { // steps 8-9
			return CreateIterResultObject(value, done); // step 8.a
		};
		resolve($then(valueWrapper, onFulfilled)); // step 11
	}); // step 12
};

var $AsyncFromSyncIteratorPrototype = GetIntrinsic('%AsyncFromSyncIteratorPrototype%', true) || {
	next: function next(value) {
		if (!$Promise) {
			throw new $SyntaxError('This environment does not support Promises.');
		}

		var O = this; // step 1

		SLOT.assert(O, '[[SyncIteratorRecord]]'); // step 2

		var argsLength = arguments.length;

		return new $Promise(function (resolve) { // step 3
			var syncIteratorRecord = SLOT.get(O, '[[SyncIteratorRecord]]'); // step 4
			var result;
			if (argsLength > 0) {
				result = IteratorNext(syncIteratorRecord['[[Iterator]]'], value); // step 5.a
			} else { // step 6
				result = IteratorNext(syncIteratorRecord['[[Iterator]]']);// step 6.a
			}
			resolve(AsyncFromSyncIteratorContinuation(result)); // step 8
		});
	},
	'return': function () {
		if (!$Promise) {
			throw new $SyntaxError('This environment does not support Promises.');
		}

		var O = this; // step 1

		SLOT.assert(O, '[[SyncIteratorRecord]]'); // step 2

		var valueIsPresent = arguments.length > 0;
		var value = valueIsPresent ? arguments[0] : void undefined;

		return new $Promise(function (resolve, reject) { // step 3
			var syncIterator = SLOT.get(O, '[[SyncIteratorRecord]]')['[[Iterator]]']; // step 4
			var iteratorReturn = GetMethod(syncIterator, 'return'); // step 5

			if (typeof iteratorReturn === 'undefined') { // step 7
				var iterResult = CreateIterResultObject(value, true); // step 7.a
				Call(resolve, undefined, [iterResult]); // step 7.b
				return;
			}
			var result;
			if (valueIsPresent) { // step 8
				result = Call(iteratorReturn, syncIterator, [value]); // step 8.a
			} else { // step 9
				result = Call(iteratorReturn, syncIterator); // step 9.a
			}
			if (!isObject(result)) { // step 11
				Call(reject, undefined, [new $TypeError('Iterator `return` method returned a non-object value.')]); // step 11.a
				return;
			}

			resolve(AsyncFromSyncIteratorContinuation(result)); // step 12
		});
	},
	'throw': function () {
		if (!$Promise) {
			throw new $SyntaxError('This environment does not support Promises.');
		}

		var O = this; // step 1

		SLOT.assert(O, '[[SyncIteratorRecord]]'); // step 2

		var valueIsPresent = arguments.length > 0;
		var value = valueIsPresent ? arguments[0] : void undefined;

		return new $Promise(function (resolve, reject) { // step 3
			var syncIterator = SLOT.get(O, '[[SyncIteratorRecord]]')['[[Iterator]]']; // step 4

			var throwMethod = GetMethod(syncIterator, 'throw'); // step 5

			if (typeof throwMethod === 'undefined') { // step 7
				Call(reject, undefined, [value]); // step 7.a
				return;
			}

			var result;
			if (valueIsPresent) { // step 8
				result = Call(throwMethod, syncIterator, [value]); // step 8.a
			} else { // step 9
				result = Call(throwMethod, syncIterator); // step 9.a
			}
			if (!isObject(result)) { // step 11
				Call(reject, undefined, [new $TypeError('Iterator `throw` method returned a non-object value.')]); // step 11.a
				return;
			}

			resolve(AsyncFromSyncIteratorContinuation(result/* , promiseCapability */)); // step 12
		});
	}
};

// https://262.ecma-international.org/9.0/#sec-createasyncfromsynciterator

module.exports = function CreateAsyncFromSyncIterator(syncIteratorRecord) {
	if (!isIteratorRecord(syncIteratorRecord)) {
		throw new $TypeError('Assertion failed: `syncIteratorRecord` is not an Iterator Record');
	}

	// var asyncIterator = ObjectCreate(%AsyncFromSyncIteratorPrototype%, « [[SyncIteratorRecord]] »); // step 1
	var asyncIterator = ObjectCreate($AsyncFromSyncIteratorPrototype);

	SLOT.set(asyncIterator, '[[SyncIteratorRecord]]', syncIteratorRecord); // step 2

	var nextMethod = Get(asyncIterator, 'next'); // step 3

	return { // steps 3-4
		'[[Iterator]]': asyncIterator,
		'[[NextMethod]]': nextMethod,
		'[[Done]]': false
	};
};
'use strict';

var $TypeError = require('es-errors/type');
var isObject = require('es-object-atoms/isObject');

var isPropertyKey = require('../helpers/isPropertyKey');
var OrdinaryDefineOwnProperty = require('./OrdinaryDefineOwnProperty');

// https://262.ecma-international.org/6.0/#sec-createdataproperty

module.exports = function CreateDataProperty(O, P, V) {
	if (!isObject(O)) {
		throw new $TypeError('Assertion failed: Type(O) is not Object');
	}
	if (!isPropertyKey(P)) {
		throw new $TypeError('Assertion failed: P is not a Property Key');
	}
	var newDesc = {
		'[[Configurable]]': true,
		'[[Enumerable]]': true,
		'[[Value]]': V,
		'[[Writable]]': true
	};
	return OrdinaryDefineOwnProperty(O, P, newDesc);
};
'use strict';

var $TypeError = require('es-errors/type');
var isObject = require('es-object-atoms/isObject');

var CreateDataProperty = require('./CreateDataProperty');

var isPropertyKey = require('../helpers/isPropertyKey');

// // https://262.ecma-international.org/6.0/#sec-createdatapropertyorthrow

module.exports = function CreateDataPropertyOrThrow(O, P, V) {
	if (!isObject(O)) {
		throw new $TypeError('Assertion failed: Type(O) is not Object');
	}
	if (!isPropertyKey(P)) {
		throw new $TypeError('Assertion failed: P is not a Property Key');
	}
	var success = CreateDataProperty(O, P, V);
	if (!success) {
		throw new $TypeError('unable to create data property');
	}
	return success;
};
'use strict';

var $TypeError = require('es-errors/type');

var callBound = require('call-bound');

var $replace = callBound('String.prototype.replace');

var RequireObjectCoercible = require('./RequireObjectCoercible');
var ToString = require('./ToString');

// https://262.ecma-international.org/6.0/#sec-createhtml

module.exports = function CreateHTML(string, tag, attribute, value) {
	if (typeof tag !== 'string' || typeof attribute !== 'string') {
		throw new $TypeError('Assertion failed: `tag` and `attribute` must be strings');
	}
	var str = RequireObjectCoercible(string);
	var S = ToString(str);
	var p1 = '<' + tag;
	if (attribute !== '') {
		var V = ToString(value);
		var escapedV = $replace(V, /\x22/g, '&quot;');
		p1 += '\x20' + attribute + '\x3D\x22' + escapedV + '\x22';
	}
	return p1 + '>' + S + '</' + tag + '>';
};
'use strict';

var $TypeError = require('es-errors/type');

// https://262.ecma-international.org/6.0/#sec-createiterresultobject

module.exports = function CreateIterResultObject(value, done) {
	if (typeof done !== 'boolean') {
		throw new $TypeError('Assertion failed: Type(done) is not Boolean');
	}
	return {
		value: value,
		done: done
	};
};
'use strict';

var callBound = require('call-bound');

var $TypeError = require('es-errors/type');
var isObject = require('es-object-atoms/isObject');
var $indexOf = callBound('Array.prototype.indexOf', true) || callBound('String.prototype.indexOf');

var Get = require('./Get');
var IsArray = require('./IsArray');
var ToLength = require('./ToLength');
var ToString = require('./ToString');
var Type = require('./Type');

var defaultElementTypes = ['Undefined', 'Null', 'Boolean', 'String', 'Symbol', 'Number', 'Object'];

// https://262.ecma-international.org/6.0/#sec-createlistfromarraylike
module.exports = function CreateListFromArrayLike(obj) {
	var elementTypes = arguments.length > 1
		? arguments[1]
		: defaultElementTypes;

	if (!isObject(obj)) {
		throw new $TypeError('Assertion failed: `obj` must be an Object');
	}
	if (!IsArray(elementTypes)) {
		throw new $TypeError('Assertion failed: `elementTypes`, if provided, must be an array');
	}
	var len = ToLength(Get(obj, 'length'));
	var list = [];
	var index = 0;
	while (index < len) {
		var indexName = ToString(index);
		var next = Get(obj, indexName);
		var nextType = Type(next);
		if ($indexOf(elementTypes, nextType) < 0) {
			throw new $TypeError('item type ' + nextType + ' is not a valid elementType');
		}
		list[list.length] = next;
		index += 1;
	}
	return list;
};
'use strict';

var $TypeError = require('es-errors/type');
var isObject = require('es-object-atoms/isObject');

var DefineOwnProperty = require('../helpers/DefineOwnProperty');

var FromPropertyDescriptor = require('./FromPropertyDescriptor');
var IsDataDescriptor = require('./IsDataDescriptor');
var isPropertyKey = require('../helpers/isPropertyKey');
var SameValue = require('./SameValue');

// https://262.ecma-international.org/6.0/#sec-createmethodproperty

module.exports = function CreateMethodProperty(O, P, V) {
	if (!isObject(O)) {
		throw new $TypeError('Assertion failed: Type(O) is not Object');
	}

	if (!isPropertyKey(P)) {
		throw new $TypeError('Assertion failed: P is not a Property Key');
	}

	var newDesc = {
		'[[Configurable]]': true,
		'[[Enumerable]]': false,
		'[[Value]]': V,
		'[[Writable]]': true
	};
	return DefineOwnProperty(
		IsDataDescriptor,
		SameValue,
		FromPropertyDescriptor,
		O,
		P,
		newDesc
	);
};
'use strict';

var $EvalError = require('es-errors/eval');

var DayWithinYear = require('./DayWithinYear');
var InLeapYear = require('./InLeapYear');
var MonthFromTime = require('./MonthFromTime');

// https://262.ecma-international.org/5.1/#sec-15.9.1.5

module.exports = function DateFromTime(t) {
	var m = MonthFromTime(t);
	var d = DayWithinYear(t);
	if (m === 0) {
		return d + 1;
	}
	if (m === 1) {
		return d - 30;
	}
	var leap = InLeapYear(t);
	if (m === 2) {
		return d - 58 - leap;
	}
	if (m === 3) {
		return d - 89 - leap;
	}
	if (m === 4) {
		return d - 119 - leap;
	}
	if (m === 5) {
		return d - 150 - leap;
	}
	if (m === 6) {
		return d - 180 - leap;
	}
	if (m === 7) {
		return d - 211 - leap;
	}
	if (m === 8) {
		return d - 242 - leap;
	}
	if (m === 9) {
		return d - 272 - leap;
	}
	if (m === 10) {
		return d - 303 - leap;
	}
	if (m === 11) {
		return d - 333 - leap;
	}
	throw new $EvalError('Assertion failed: MonthFromTime returned an impossible value: ' + m);
};
'use strict';

var $TypeError = require('es-errors/type');

var weekdays = ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'];
var months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];

var $isNaN = require('math-intrinsics/isNaN');
var padTimeComponent = require('../helpers/padTimeComponent');

var DateFromTime = require('./DateFromTime');
var MonthFromTime = require('./MonthFromTime');
var WeekDay = require('./WeekDay');
var YearFromTime = require('./YearFromTime');

// https://262.ecma-international.org/9.0/#sec-datestring

module.exports = function DateString(tv) {
	if (typeof tv !== 'number' || $isNaN(tv)) {
		throw new $TypeError('Assertion failed: `tv` must be a non-NaN Number');
	}
	var weekday = weekdays[WeekDay(tv)];
	var month = months[MonthFromTime(tv)];
	var day = padTimeComponent(DateFromTime(tv));
	var year = padTimeComponent(YearFromTime(tv), 4);
	return weekday + '\x20' + month + '\x20' + day + '\x20' + year;
};
'use strict';

var floor = require('./floor');

// https://262.ecma-international.org/5.1/#sec-15.9.1.3

module.exports = function DayFromYear(y) {
	return (365 * (y - 1970)) + floor((y - 1969) / 4) - floor((y - 1901) / 100) + floor((y - 1601) / 400);
};

'use strict';

var floor = require('./floor');

var msPerDay = require('../helpers/timeConstants').msPerDay;

// https://262.ecma-international.org/5.1/#sec-15.9.1.2

module.exports = function Day(t) {
	return floor(t / msPerDay);
};
'use strict';

var modulo = require('./modulo');

// https://262.ecma-international.org/5.1/#sec-15.9.1.3

module.exports = function DaysInYear(y) {
	if (modulo(y, 4) !== 0) {
		return 365;
	}
	if (modulo(y, 100) !== 0) {
		return 366;
	}
	if (modulo(y, 400) !== 0) {
		return 365;
	}
	return 366;
};
'use strict';

var Day = require('./Day');
var DayFromYear = require('./DayFromYear');
var YearFromTime = require('./YearFromTime');

// https://262.ecma-international.org/5.1/#sec-15.9.1.4

module.exports = function DayWithinYear(t) {
	return Day(t) - DayFromYear(YearFromTime(t));
};
'use strict';

var $TypeError = require('es-errors/type');
var isObject = require('es-object-atoms/isObject');

var isPropertyDescriptor = require('../helpers/records/property-descriptor');
var DefineOwnProperty = require('../helpers/DefineOwnProperty');

var FromPropertyDescriptor = require('./FromPropertyDescriptor');
var IsDataDescriptor = require('./IsDataDescriptor');
var isPropertyKey = require('../helpers/isPropertyKey');
var SameValue = require('./SameValue');
var ToPropertyDescriptor = require('./ToPropertyDescriptor');

// https://262.ecma-international.org/6.0/#sec-definepropertyorthrow

module.exports = function DefinePropertyOrThrow(O, P, desc) {
	if (!isObject(O)) {
		throw new $TypeError('Assertion failed: Type(O) is not Object');
	}

	if (!isPropertyKey(P)) {
		throw new $TypeError('Assertion failed: P is not a Property Key');
	}

	var Desc = isPropertyDescriptor(desc) ? desc : ToPropertyDescriptor(desc);
	if (!isPropertyDescriptor(Desc)) {
		throw new $TypeError('Assertion failed: Desc is not a valid Property Descriptor');
	}

	return DefineOwnProperty(
		IsDataDescriptor,
		SameValue,
		FromPropertyDescriptor,
		O,
		P,
		Desc
	);
};
'use strict';

var $TypeError = require('es-errors/type');
var isObject = require('es-object-atoms/isObject');

var isPropertyKey = require('../helpers/isPropertyKey');

// https://262.ecma-international.org/6.0/#sec-deletepropertyorthrow

module.exports = function DeletePropertyOrThrow(O, P) {
	if (!isObject(O)) {
		throw new $TypeError('Assertion failed: Type(O) is not Object');
	}

	if (!isPropertyKey(P)) {
		throw new $TypeError('Assertion failed: P is not a Property Key');
	}

	// eslint-disable-next-line no-param-reassign
	var success = delete O[P];
	if (!success) {
		throw new $TypeError('Attempt to delete property failed.');
	}
	return success;
};
'use strict';

var $SyntaxError = require('es-errors/syntax');
var $TypeError = require('es-errors/type');

var IsDetachedBuffer = require('./IsDetachedBuffer');

var isArrayBuffer = require('is-array-buffer');
var isSharedArrayBuffer = require('is-shared-array-buffer');

var MessageChannel;
try {
	// eslint-disable-next-line global-require
	MessageChannel = require('worker_threads').MessageChannel;
} catch (e) { /**/ }

// https://262.ecma-international.org/9.0/#sec-detacharraybuffer

/* globals postMessage */

module.exports = function DetachArrayBuffer(arrayBuffer) {
	if (!isArrayBuffer(arrayBuffer) || isSharedArrayBuffer(arrayBuffer)) {
		throw new $TypeError('Assertion failed: `arrayBuffer` must be an Object with an [[ArrayBufferData]] internal slot, and not a Shared Array Buffer');
	}

	// commented out since there's no way to set or access this key
	// var key = arguments.length > 1 ? arguments[1] : void undefined;

	// if (!SameValue(arrayBuffer[[ArrayBufferDetachKey]], key)) {
	// 	throw new $TypeError('Assertion failed: `key` must be the value of the [[ArrayBufferDetachKey]] internal slot of `arrayBuffer`');
	// }

	if (!IsDetachedBuffer(arrayBuffer)) { // node v21.0.0+ throws when you structuredClone a detached buffer
		if (typeof structuredClone === 'function') {
			structuredClone(arrayBuffer, { transfer: [arrayBuffer] });
		} else if (typeof postMessage === 'function') {
			postMessage('', '/', [arrayBuffer]); // TODO: see if this might trigger listeners
		} else if (MessageChannel) {
			(new MessageChannel()).port1.postMessage(null, [arrayBuffer]);
		} else {
			throw new $SyntaxError('DetachArrayBuffer is not supported in this environment');
		}
	}

	return null;
};
'use strict';

var $TypeError = require('es-errors/type');
var isObject = require('es-object-atoms/isObject');

var objectKeys = require('object-keys');
var safePushApply = require('safe-push-apply');
var callBound = require('call-bound');

var $isEnumerable = callBound('Object.prototype.propertyIsEnumerable');

var forEach = require('../helpers/forEach');

// https://262.ecma-international.org/8.0/#sec-enumerableownproperties

module.exports = function EnumerableOwnPropertyNames(O, kind) {
	if (!isObject(O)) {
		throw new $TypeError('Assertion failed: Type(O) is not Object');
	}

	var keys = objectKeys(O);
	if (kind === 'key') {
		return keys;
	}
	if (kind === 'value' || kind === 'key+value') {
		var results = [];
		forEach(keys, function (key) {
			if ($isEnumerable(O, key)) {
				safePushApply(results, [
					kind === 'value' ? O[key] : [key, O[key]]
				]);
			}
		});
		return results;
	}
	throw new $TypeError('Assertion failed: "kind" is not "key", "value", or "key+value": ' + kind);
};
'use strict';

// var modulo = require('./modulo');
var $floor = require('math-intrinsics/floor');

// http://262.ecma-international.org/5.1/#sec-5.2

module.exports = function floor(x) {
	// return x - modulo(x, 1);
	return $floor(x);
};
'use strict';

var $TypeError = require('es-errors/type');

var isPropertyDescriptor = require('../helpers/records/property-descriptor');
var fromPropertyDescriptor = require('../helpers/fromPropertyDescriptor');

// https://262.ecma-international.org/6.0/#sec-frompropertydescriptor

module.exports = function FromPropertyDescriptor(Desc) {
	if (typeof Desc !== 'undefined' && !isPropertyDescriptor(Desc)) {
		throw new $TypeError('Assertion failed: `Desc` must be a Property Descriptor');
	}

	return fromPropertyDescriptor(Desc);
};
'use strict';

var getGlobal = require('globalthis/polyfill');

// https://262.ecma-international.org/6.0/#sec-getglobalobject

module.exports = function GetGlobalObject() {
	return getGlobal();
};
'use strict';

var $TypeError = require('es-errors/type');

var getIteratorMethod = require('../helpers/getIteratorMethod');
var AdvanceStringIndex = require('./AdvanceStringIndex');
var Call = require('./Call');
var GetMethod = require('./GetMethod');

var isObject = require('es-object-atoms/isObject');

var ES = {
	AdvanceStringIndex: AdvanceStringIndex,
	GetMethod: GetMethod
};

// https://262.ecma-international.org/6.0/#sec-getiterator

module.exports = function GetIterator(obj, method) {
	var actualMethod = method;
	if (arguments.length < 2) {
		actualMethod = getIteratorMethod(ES, obj);
	}
	var iterator = Call(actualMethod, obj);
	if (!isObject(iterator)) {
		throw new $TypeError('iterator must return an object');
	}

	return iterator;
};
'use strict';

var $TypeError = require('es-errors/type');

var inspect = require('object-inspect');

var isPropertyKey = require('../helpers/isPropertyKey');

var isObject = require('es-object-atoms/isObject');

// https://262.ecma-international.org/6.0/#sec-get-o-p

module.exports = function Get(O, P) {
	// 7.3.1.1
	if (!isObject(O)) {
		throw new $TypeError('Assertion failed: Type(O) is not Object');
	}
	// 7.3.1.2
	if (!isPropertyKey(P)) {
		throw new $TypeError('Assertion failed: P is not a Property Key, got ' + inspect(P));
	}
	// 7.3.1.3
	return O[P];
};
'use strict';

var $TypeError = require('es-errors/type');

var GetV = require('./GetV');
var IsCallable = require('./IsCallable');
var isPropertyKey = require('../helpers/isPropertyKey');

var inspect = require('object-inspect');

// https://262.ecma-international.org/6.0/#sec-getmethod

module.exports = function GetMethod(O, P) {
	// 7.3.9.1
	if (!isPropertyKey(P)) {
		throw new $TypeError('Assertion failed: P is not a Property Key');
	}

	// 7.3.9.2
	var func = GetV(O, P);

	// 7.3.9.4
	if (func == null) {
		return void 0;
	}

	// 7.3.9.5
	if (!IsCallable(func)) {
		throw new $TypeError(inspect(P) + ' is not a function: ' + inspect(func));
	}

	// 7.3.9.6
	return func;
};
'use strict';

var GetIntrinsic = require('get-intrinsic');

var hasSymbols = require('has-symbols')();

var $TypeError = require('es-errors/type');
var isObject = require('es-object-atoms/isObject');

var $gOPN = GetIntrinsic('%Object.getOwnPropertyNames%', true);
var $gOPS = hasSymbols && GetIntrinsic('%Object.getOwnPropertySymbols%', true);
var keys = require('object-keys');

// https://262.ecma-international.org/6.0/#sec-getownpropertykeys

module.exports = function GetOwnPropertyKeys(O, Type) {
	if (!isObject(O)) {
		throw new $TypeError('Assertion failed: Type(O) is not Object');
	}
	if (Type === 'Symbol') {
		return $gOPS ? $gOPS(O) : [];
	}
	if (Type === 'String') {
		if (!$gOPN) {
			return keys(O);
		}
		return $gOPN(O);
	}
	throw new $TypeError('Assertion failed: `Type` must be `"String"` or `"Symbol"`');
};
'use strict';

var GetIntrinsic = require('get-intrinsic');

var $Function = GetIntrinsic('%Function%');
var $TypeError = require('es-errors/type');
var $SyntaxError = require('es-errors/syntax');

var Get = require('./Get');
var IsConstructor = require('./IsConstructor');

var isObject = require('es-object-atoms/isObject');

// https://262.ecma-international.org/6.0/#sec-getprototypefromconstructor

module.exports = function GetPrototypeFromConstructor(constructor, intrinsicDefaultProto) {
	var intrinsic = GetIntrinsic(intrinsicDefaultProto); // throws if not a valid intrinsic
	if (!isObject(intrinsic)) {
		throw new $TypeError('intrinsicDefaultProto must be an object');
	}
	if (!IsConstructor(constructor)) {
		throw new $TypeError('Assertion failed: `constructor` must be a constructor');
	}
	var proto = Get(constructor, 'prototype');
	if (!isObject(proto)) {
		if (!(constructor instanceof $Function)) {
			// ignore other realms, for now
			throw new $SyntaxError('cross-realm constructors not currently supported');
		}
		proto = intrinsic;
	}
	return proto;
};
'use strict';

var $TypeError = require('es-errors/type');

var callBound = require('call-bound');
var regexTester = require('safe-regex-test');
var every = require('../helpers/every');

var $charAt = callBound('String.prototype.charAt');
var $strSlice = callBound('String.prototype.slice');
var $indexOf = callBound('String.prototype.indexOf');
var $parseInt = parseInt;

var isDigit = regexTester(/^[0-9]$/);

var inspect = require('object-inspect');
var isInteger = require('math-intrinsics/isInteger');

var Get = require('./Get');
var IsArray = require('./IsArray');
var ToObject = require('./ToObject');
var ToString = require('./ToString');

var isStringOrUndefined = require('../helpers/isStringOrUndefined');

// http://262.ecma-international.org/9.0/#sec-getsubstitution

// eslint-disable-next-line max-statements, max-params, max-lines-per-function
module.exports = function GetSubstitution(matched, str, position, captures, namedCaptures, replacement) {
	if (typeof matched !== 'string') {
		throw new $TypeError('Assertion failed: `matched` must be a String');
	}
	var matchLength = matched.length;

	if (typeof str !== 'string') {
		throw new $TypeError('Assertion failed: `str` must be a String');
	}
	var stringLength = str.length;

	if (!isInteger(position) || position < 0 || position > stringLength) {
		throw new $TypeError('Assertion failed: `position` must be a nonnegative integer, and less than or equal to the length of `string`, got ' + inspect(position));
	}

	if (!IsArray(captures) || !every(captures, isStringOrUndefined)) {
		throw new $TypeError('Assertion failed: `captures` must be a List of Strings or `undefined`, got ' + inspect(captures));
	}

	if (typeof replacement !== 'string') {
		throw new $TypeError('Assertion failed: `replacement` must be a String');
	}

	var tailPos = position + matchLength;
	var m = captures.length;
	if (typeof namedCaptures !== 'undefined') {
		namedCaptures = ToObject(namedCaptures); // eslint-disable-line no-param-reassign
	}

	var result = '';
	for (var i = 0; i < replacement.length; i += 1) {
		// if this is a $, and it's not the end of the replacement
		var current = $charAt(replacement, i);
		var isLast = (i + 1) >= replacement.length;
		var nextIsLast = (i + 2) >= replacement.length;
		if (current === '$' && !isLast) {
			var next = $charAt(replacement, i + 1);
			if (next === '$') {
				result += '$';
				i += 1;
			} else if (next === '&') {
				result += matched;
				i += 1;
			} else if (next === '`') {
				result += position === 0 ? '' : $strSlice(str, 0, position - 1);
				i += 1;
			} else if (next === "'") {
				result += tailPos >= stringLength ? '' : $strSlice(str, tailPos);
				i += 1;
			} else {
				var nextNext = nextIsLast ? null : $charAt(replacement, i + 2);
				if (isDigit(next) && next !== '0' && (nextIsLast || !isDigit(nextNext))) {
					// $1 through $9, and not followed by a digit
					var n = $parseInt(next, 10);
					// if (n > m, impl-defined)
					result += n <= m && typeof captures[n - 1] === 'undefined' ? '' : captures[n - 1];
					i += 1;
				} else if (isDigit(next) && (nextIsLast || isDigit(nextNext))) {
					// $00 through $99
					var nn = next + nextNext;
					var nnI = $parseInt(nn, 10) - 1;
					// if nn === '00' or nn > m, impl-defined
					result += nn <= m && typeof captures[nnI] === 'undefined' ? '' : captures[nnI];
					i += 2;
				} else if (next === '<') {
					if (typeof namedCaptures === 'undefined') {
						result += '$<';
						i += 2;
					} else {
						var endIndex = $indexOf(replacement, '>', i);

						if (endIndex > -1) {
							var groupName = $strSlice(replacement, i + '$<'.length, endIndex);
							var capture = Get(namedCaptures, groupName);

							if (typeof capture !== 'undefined') {
								result += ToString(capture);
							}
							i += ('<' + groupName + '>').length;
						}
					}
				} else {
					result += '$';
				}
			}
		} else {
			// the final $, or else not a $
			result += $charAt(replacement, i);
		}
	}
	return result;
};
'use strict';

var GetIntrinsic = require('get-intrinsic');

var $SyntaxError = require('es-errors/syntax');
var $TypeError = require('es-errors/type');
var isInteger = require('math-intrinsics/isInteger');
var $Uint8Array = GetIntrinsic('%Uint8Array%', true);

var callBound = require('call-bound');

var $slice = callBound('Array.prototype.slice');

var IsDetachedBuffer = require('./IsDetachedBuffer');
var RawBytesToNumber = require('./RawBytesToNumber');

var isArrayBuffer = require('is-array-buffer');
var isSharedArrayBuffer = require('is-shared-array-buffer');
var safeConcat = require('safe-array-concat');

var tableTAO = require('./tables/typed-array-objects');

var defaultEndianness = require('../helpers/defaultEndianness');

// https://262.ecma-international.org/8.0/#sec-getvaluefrombuffer

module.exports = function GetValueFromBuffer(arrayBuffer, byteIndex, type, isTypedArray, order) {
	var isSAB = isSharedArrayBuffer(arrayBuffer);
	if (!isArrayBuffer(arrayBuffer) && !isSAB) {
		throw new $TypeError('Assertion failed: `arrayBuffer` must be an ArrayBuffer or a SharedArrayBuffer');
	}

	if (!isInteger(byteIndex)) {
		throw new $TypeError('Assertion failed: `byteIndex` must be an integer');
	}

	if (typeof type !== 'string') {
		throw new $TypeError('Assertion failed: `type` must be a string');
	}

	if (typeof isTypedArray !== 'boolean') {
		throw new $TypeError('Assertion failed: `isTypedArray` must be a boolean');
	}

	if (typeof order !== 'string') {
		throw new $TypeError('Assertion failed: `order` must be a string');
	}

	if (arguments.length > 5 && typeof arguments[5] !== 'boolean') {
		throw new $TypeError('Assertion failed: `isLittleEndian` must be a boolean, if present');
	}

	if (IsDetachedBuffer(arrayBuffer)) {
		throw new $TypeError('Assertion failed: `arrayBuffer` is detached'); // step 1
	}

	// 2. Assert: There are sufficient bytes in arrayBuffer starting at byteIndex to represent a value of type.

	if (byteIndex < 0) {
		throw new $TypeError('Assertion failed: `byteIndex` must be non-negative'); // step 3
	}

	// 4. Let block be arrayBuffer.[[ArrayBufferData]].

	var elementSize = tableTAO.size['$' + type]; // step 5
	if (!elementSize) {
		throw new $TypeError('Assertion failed: `type` must be one of ' + tableTAO.choices);
	}

	var rawValue;
	if (isSAB) { // step 6
		/*
		a. Let execution be the [[CandidateExecution]] field of the surrounding agent's Agent Record.
		b. Let eventList be the [[EventList]] field of the element in execution.[[EventLists]] whose [[AgentSignifier]] is AgentSignifier().
		c. If isTypedArray is true and type is "Int8", "Uint8", "Int16", "Uint16", "Int32", or "Uint32", let noTear be true; otherwise let noTear be false.
		d. Let rawValue be a List of length elementSize of nondeterministically chosen byte values.
		e. NOTE: In implementations, rawValue is the result of a non-atomic or atomic read instruction on the underlying hardware. The nondeterminism is a semantic prescription of the memory model to describe observable behaviour of hardware with weak consistency.
		f. Let readEvent be ReadSharedMemory{ [[Order]]: order, [[NoTear]]: noTear, [[Block]]: block, [[ByteIndex]]: byteIndex, [[ElementSize]]: elementSize }.
		g. Append readEvent to eventList.
		h. Append Chosen Value Record { [[Event]]: readEvent, [[ChosenValue]]: rawValue } to execution.[[ChosenValues]].
		*/
		throw new $SyntaxError('TODO: support SharedArrayBuffers');
	} else {
		// 7. Let rawValue be a List of elementSize containing, in order, the elementSize sequence of bytes starting with block[byteIndex].
		rawValue = $slice(new $Uint8Array(arrayBuffer, byteIndex), 0, elementSize); // step 6
	}

	// 8. If isLittleEndian is not present, set isLittleEndian to either true or false. The choice is implementation dependent and should be the alternative that is most efficient for the implementation. An implementation must use the same value each time this step is executed and the same value must be used for the corresponding step in the SetValueInBuffer abstract operation.
	var isLittleEndian = arguments.length > 5 ? arguments[5] : defaultEndianness === 'little'; // step 8

	var bytes = isLittleEndian
		? $slice(safeConcat([0, 0, 0, 0, 0, 0, 0, 0], rawValue), -elementSize)
		: $slice(safeConcat(rawValue, [0, 0, 0, 0, 0, 0, 0, 0]), 0, elementSize);

	return RawBytesToNumber(type, bytes, isLittleEndian);
};
'use strict';

var $TypeError = require('es-errors/type');

var inspect = require('object-inspect');

var isPropertyKey = require('../helpers/isPropertyKey');
// var ToObject = require('./ToObject');

// https://262.ecma-international.org/6.0/#sec-getv

module.exports = function GetV(V, P) {
	// 7.3.2.1
	if (!isPropertyKey(P)) {
		throw new $TypeError('Assertion failed: P is not a Property Key, got ' + inspect(P));
	}

	// 7.3.2.2-3
	// var O = ToObject(V);

	// 7.3.2.4
	return V[P];
};
'use strict';

var $TypeError = require('es-errors/type');

var hasOwn = require('hasown');
var isObject = require('es-object-atoms/isObject');

var isPropertyKey = require('../helpers/isPropertyKey');

// https://262.ecma-international.org/6.0/#sec-hasownproperty

module.exports = function HasOwnProperty(O, P) {
	if (!isObject(O)) {
		throw new $TypeError('Assertion failed: `O` must be an Object');
	}
	if (!isPropertyKey(P)) {
		throw new $TypeError('Assertion failed: `P` must be a Property Key');
	}
	return hasOwn(O, P);
};
'use strict';

var $TypeError = require('es-errors/type');
var isObject = require('es-object-atoms/isObject');

var isPropertyKey = require('../helpers/isPropertyKey');

// https://262.ecma-international.org/6.0/#sec-hasproperty

module.exports = function HasProperty(O, P) {
	if (!isObject(O)) {
		throw new $TypeError('Assertion failed: `O` must be an Object');
	}
	if (!isPropertyKey(P)) {
		throw new $TypeError('Assertion failed: `P` must be a Property Key');
	}
	return P in O;
};
'use strict';

var floor = require('./floor');
var modulo = require('./modulo');

var timeConstants = require('../helpers/timeConstants');
var msPerHour = timeConstants.msPerHour;
var HoursPerDay = timeConstants.HoursPerDay;

// https://262.ecma-international.org/5.1/#sec-15.9.1.10

module.exports = function HourFromTime(t) {
	return modulo(floor(t / msPerHour), HoursPerDay);
};
'use strict';

var $EvalError = require('es-errors/eval');

var DaysInYear = require('./DaysInYear');
var YearFromTime = require('./YearFromTime');

// https://262.ecma-international.org/5.1/#sec-15.9.1.3

module.exports = function InLeapYear(t) {
	var days = DaysInYear(YearFromTime(t));
	if (days === 365) {
		return 0;
	}
	if (days === 366) {
		return 1;
	}
	throw new $EvalError('Assertion failed: there are not 365 or 366 days in a year, got: ' + days);
};
'use strict';

var GetIntrinsic = require('get-intrinsic');

var $TypeError = require('es-errors/type');
var isObject = require('es-object-atoms/isObject');

var $hasInstance = GetIntrinsic('%Symbol.hasInstance%', true);

var Call = require('./Call');
var GetMethod = require('./GetMethod');
var IsCallable = require('./IsCallable');
var OrdinaryHasInstance = require('./OrdinaryHasInstance');
var ToBoolean = require('./ToBoolean');

// https://262.ecma-international.org/6.0/#sec-instanceofoperator

module.exports = function InstanceofOperator(O, C) {
	if (!isObject(O)) {
		throw new $TypeError('Assertion failed: Type(O) is not Object');
	}
	var instOfHandler = $hasInstance ? GetMethod(C, $hasInstance) : void 0;
	if (typeof instOfHandler !== 'undefined') {
		return ToBoolean(Call(instOfHandler, C, [O]));
	}
	if (!IsCallable(C)) {
		throw new $TypeError('`C` is not Callable');
	}
	return OrdinaryHasInstance(C, O);
};
'use strict';

var $SyntaxError = require('es-errors/syntax');
var $TypeError = require('es-errors/type');

var GetValueFromBuffer = require('./GetValueFromBuffer');
var IsDetachedBuffer = require('./IsDetachedBuffer');
var IsInteger = require('./IsInteger');

var isNegativeZero = require('math-intrinsics/isNegativeZero');

var typedArrayLength = require('typed-array-length');
var typedArrayBuffer = require('typed-array-buffer');
var typedArrayByteOffset = require('typed-array-byte-offset');
var whichTypedArray = require('which-typed-array');

var tableTAO = require('./tables/typed-array-objects');

// https://262.ecma-international.org/8.0/#sec-integerindexedelementget

module.exports = function IntegerIndexedElementGet(O, index) {
	if (typeof index !== 'number') {
		throw new $TypeError('`index` must be a Number'); // step 1
	}
	var arrayTypeName = whichTypedArray(O); // step 10
	if (!arrayTypeName) {
		throw new $TypeError('`O` must be a TypedArray'); // step 2
	}
	if (arrayTypeName === 'BigInt64Array' || arrayTypeName === 'BigUint64Array') {
		throw new $SyntaxError('BigInt64Array and BigUint64Array do not exist until ES2020');
	}

	var buffer = typedArrayBuffer(O); // step 3

	if (IsDetachedBuffer(buffer)) {
		throw new $TypeError('`O` has a detached buffer'); // step 4
	}

	if (!IsInteger(index) || isNegativeZero(index)) {
		return void undefined; // steps 5 - 6
	}

	var length = typedArrayLength(O); // step 7

	if (index < 0 || index >= length) {
		return void undefined; // step 8
	}

	var offset = typedArrayByteOffset(O); // step 9

	var elementType = tableTAO.name['$' + arrayTypeName]; // step 13

	var elementSize = tableTAO.size['$' + elementType]; // step 11

	var indexedPosition = (index * elementSize) + offset; // step 12

	return GetValueFromBuffer(buffer, indexedPosition, elementType, true, 'Unordered'); // step 14
};
'use strict';

var $SyntaxError = require('es-errors/syntax');
var $TypeError = require('es-errors/type');

var IsDetachedBuffer = require('./IsDetachedBuffer');
var IsInteger = require('./IsInteger');
var SetValueInBuffer = require('./SetValueInBuffer');
var ToNumber = require('./ToNumber');

var isNegativeZero = require('math-intrinsics/isNegativeZero');
var typedArrayBuffer = require('typed-array-buffer');
var typedArrayByteOffset = require('typed-array-byte-offset');
var typedArrayLength = require('typed-array-length');
var whichTypedArray = require('which-typed-array');

var tableTAO = require('./tables/typed-array-objects');

// https://262.ecma-international.org/8.0/#sec-integerindexedelementset

module.exports = function IntegerIndexedElementSet(O, index, value) {
	if (typeof index !== 'number') {
		throw new $TypeError('`index` must be a Number'); // step 1
	}
	var arrayTypeName = whichTypedArray(O); // step 12
	if (!arrayTypeName) {
		throw new $TypeError('`O` must be a TypedArray'); // step 2
	}
	if (arrayTypeName === 'BigInt64Array' || arrayTypeName === 'BigUint64Array') {
		throw new $SyntaxError('BigInt64Array and BigUint64Array do not exist until ES2020'); // step 2
	}

	var numValue = ToNumber(value); // step 3

	var buffer = typedArrayBuffer(O); // step 5

	if (IsDetachedBuffer(buffer)) {
		throw new $TypeError('`O` has a detached buffer'); // step 6
	}

	if (!IsInteger(index) || isNegativeZero(index)) {
		return false; // steps 7 - 8
	}

	var length = typedArrayLength(O); // step 9

	if (index < 0 || index >= length) {
		return false; // step 10
	}

	var offset = typedArrayByteOffset(O); // step 11

	var elementType = tableTAO.name['$' + arrayTypeName]; // step 15

	var elementSize = tableTAO.size['$' + elementType]; // step 13

	var indexedPosition = (index * elementSize) + offset; // step 14

	SetValueInBuffer(buffer, indexedPosition, elementType, numValue, true, 'Unordered'); // step 16

	return true; // step 17
};
'use strict';

var $TypeError = require('es-errors/type');
var isObject = require('es-object-atoms/isObject');

var Call = require('./Call');
var CreateDataProperty = require('./CreateDataProperty');
var EnumerableOwnPropertyNames = require('./EnumerableOwnPropertyNames');
var Get = require('./Get');
var IsArray = require('./IsArray');
var ToLength = require('./ToLength');
var ToString = require('./ToString');

var forEach = require('../helpers/forEach');

// https://262.ecma-international.org/9.0/#sec-internalizejsonproperty

// note: `reviver` was implicitly closed-over until ES2020, where it becomes a third argument

module.exports = function InternalizeJSONProperty(holder, name, reviver) {
	if (!isObject(holder)) {
		throw new $TypeError('Assertion failed: `holder` is not an Object');
	}
	if (typeof name !== 'string') {
		throw new $TypeError('Assertion failed: `name` is not a String');
	}
	if (typeof reviver !== 'function') {
		throw new $TypeError('Assertion failed: `reviver` is not a Function');
	}

	var val = Get(holder, name); // step 1

	if (isObject(val)) { // step 2
		var isArray = IsArray(val); // step 2.a
		if (isArray) { // step 2.b
			var I = 0; // step 2.b.i

			var len = ToLength(Get(val, 'length')); // step 2.b.ii

			while (I < len) { // step 2.b.iii
				var newElement = InternalizeJSONProperty(val, ToString(I), reviver); // step 2.b.iv.1

				if (typeof newElement === 'undefined') { // step 2.b.iii.2
					delete val[ToString(I)]; // step 2.b.iii.2.a
				} else { // step 2.b.iii.3
					CreateDataProperty(val, ToString(I), newElement); // step 2.b.iii.3.a
				}

				I += 1; // step 2.b.iii.4
			}
		} else { // step 2.c
			var keys = EnumerableOwnPropertyNames(val, 'key'); // step 2.c.i

			forEach(keys, function (P) { // step 2.c.ii
				// eslint-disable-next-line no-shadow
				var newElement = InternalizeJSONProperty(val, P, reviver); // step 2.c.ii.1

				if (typeof newElement === 'undefined') { // step 2.c.ii.2
					delete val[P]; // step 2.c.ii.2.a
				} else { // step 2.c.ii.3
					CreateDataProperty(val, P, newElement); // step 2.c.ii.3.a
				}
			});
		}
	}

	return Call(reviver, holder, [name, val]); // step 3
};
'use strict';

var $TypeError = require('es-errors/type');

var Call = require('./Call');
var IsArray = require('./IsArray');
var GetV = require('./GetV');
var isPropertyKey = require('../helpers/isPropertyKey');

// https://262.ecma-international.org/6.0/#sec-invoke

module.exports = function Invoke(O, P) {
	if (!isPropertyKey(P)) {
		throw new $TypeError('Assertion failed: P must be a Property Key');
	}
	var argumentsList = arguments.length > 2 ? arguments[2] : [];
	if (!IsArray(argumentsList)) {
		throw new $TypeError('Assertion failed: optional `argumentsList`, if provided, must be a List');
	}
	var func = GetV(O, P);
	return Call(func, O, argumentsList);
};
'use strict';

var $TypeError = require('es-errors/type');

var hasOwn = require('hasown');

var isPropertyDescriptor = require('../helpers/records/property-descriptor');

// https://262.ecma-international.org/5.1/#sec-8.10.1

module.exports = function IsAccessorDescriptor(Desc) {
	if (typeof Desc === 'undefined') {
		return false;
	}

	if (!isPropertyDescriptor(Desc)) {
		throw new $TypeError('Assertion failed: `Desc` must be a Property Descriptor');
	}

	if (!hasOwn(Desc, '[[Get]]') && !hasOwn(Desc, '[[Set]]')) {
		return false;
	}

	return true;
};
'use strict';

// https://262.ecma-international.org/6.0/#sec-isarray
module.exports = require('../helpers/IsArray');
'use strict';

// http://262.ecma-international.org/5.1/#sec-9.11

module.exports = require('is-callable');
'use strict';

var ValidateAndApplyPropertyDescriptor = require('./ValidateAndApplyPropertyDescriptor');

// https://262.ecma-international.org/6.0/#sec-iscompatiblepropertydescriptor

module.exports = function IsCompatiblePropertyDescriptor(Extensible, Desc, Current) {
	return ValidateAndApplyPropertyDescriptor(undefined, undefined, Extensible, Desc, Current);
};
'use strict';

var GetIntrinsic = require('get-intrinsic');

var $isConcatSpreadable = GetIntrinsic('%Symbol.isConcatSpreadable%', true);

var Get = require('./Get');
var IsArray = require('./IsArray');
var ToBoolean = require('./ToBoolean');

var isObject = require('es-object-atoms/isObject');

// https://262.ecma-international.org/6.0/#sec-isconcatspreadable

module.exports = function IsConcatSpreadable(O) {
	if (!isObject(O)) {
		return false;
	}
	if ($isConcatSpreadable) {
		var spreadable = Get(O, $isConcatSpreadable);
		if (typeof spreadable !== 'undefined') {
			return ToBoolean(spreadable);
		}
	}
	return IsArray(O);
};
'use strict';

var GetIntrinsic = require('../GetIntrinsic.js');

var $construct = GetIntrinsic('%Reflect.construct%', true);

var DefinePropertyOrThrow = require('./DefinePropertyOrThrow');
try {
	DefinePropertyOrThrow({}, '', { '[[Get]]': function () {} });
} catch (e) {
	// Accessor properties aren't supported
	DefinePropertyOrThrow = null;
}

// https://262.ecma-international.org/6.0/#sec-isconstructor

if (DefinePropertyOrThrow && $construct) {
	var isConstructorMarker = {};
	var badArrayLike = {};
	DefinePropertyOrThrow(badArrayLike, 'length', {
		'[[Get]]': function () {
			throw isConstructorMarker;
		},
		'[[Enumerable]]': true
	});

	module.exports = function IsConstructor(argument) {
		try {
			// `Reflect.construct` invokes `IsConstructor(target)` before `Get(args, 'length')`:
			$construct(argument, badArrayLike);
		} catch (err) {
			return err === isConstructorMarker;
		}
	};
} else {
	module.exports = function IsConstructor(argument) {
		// unfortunately there's no way to truly check this without try/catch `new argument` in old environments
		return typeof argument === 'function' && !!argument.prototype;
	};
}
'use strict';

var $TypeError = require('es-errors/type');

var hasOwn = require('hasown');

var isPropertyDescriptor = require('../helpers/records/property-descriptor');

// https://262.ecma-international.org/5.1/#sec-8.10.2

module.exports = function IsDataDescriptor(Desc) {
	if (typeof Desc === 'undefined') {
		return false;
	}

	if (!isPropertyDescriptor(Desc)) {
		throw new $TypeError('Assertion failed: `Desc` must be a Property Descriptor');
	}

	if (!hasOwn(Desc, '[[Value]]') && !hasOwn(Desc, '[[Writable]]')) {
		return false;
	}

	return true;
};
'use strict';

var $TypeError = require('es-errors/type');

var $byteLength = require('array-buffer-byte-length');
var availableTypedArrays = require('available-typed-arrays')();
var callBound = require('call-bound');
var isArrayBuffer = require('is-array-buffer');
var isSharedArrayBuffer = require('is-shared-array-buffer');

var $sabByteLength = callBound('SharedArrayBuffer.prototype.byteLength', true);

// https://262.ecma-international.org/8.0/#sec-isdetachedbuffer

module.exports = function IsDetachedBuffer(arrayBuffer) {
	var isSAB = isSharedArrayBuffer(arrayBuffer);
	if (!isArrayBuffer(arrayBuffer) && !isSAB) {
		throw new $TypeError('Assertion failed: `arrayBuffer` must be an Object with an [[ArrayBufferData]] internal slot');
	}
	if ((isSAB ? $sabByteLength : $byteLength)(arrayBuffer) === 0) {
		try {
			new global[availableTypedArrays[0]](arrayBuffer); // eslint-disable-line no-new
		} catch (error) {
			return !!error && error.name === 'TypeError';
		}
	}
	return false;
};
'use strict';

var GetIntrinsic = require('get-intrinsic');

var $preventExtensions = GetIntrinsic('%Object.preventExtensions%', true);
var $isExtensible = GetIntrinsic('%Object.isExtensible%', true);

var isPrimitive = require('../helpers/isPrimitive');

// https://262.ecma-international.org/6.0/#sec-isextensible-o

module.exports = $preventExtensions
	? function IsExtensible(obj) {
		return !isPrimitive(obj) && $isExtensible(obj);
	}
	: function IsExtensible(obj) {
		return !isPrimitive(obj);
	};
'use strict';

var $TypeError = require('es-errors/type');

var IsAccessorDescriptor = require('./IsAccessorDescriptor');
var IsDataDescriptor = require('./IsDataDescriptor');

var isPropertyDescriptor = require('../helpers/records/property-descriptor');

// https://262.ecma-international.org/6.0/#sec-isgenericdescriptor

module.exports = function IsGenericDescriptor(Desc) {
	if (typeof Desc === 'undefined') {
		return false;
	}

	if (!isPropertyDescriptor(Desc)) {
		throw new $TypeError('Assertion failed: `Desc` must be a Property Descriptor');
	}

	if (!IsAccessorDescriptor(Desc) && !IsDataDescriptor(Desc)) {
		return true;
	}

	return false;
};
'use strict';

var isInteger = require('math-intrinsics/isInteger');

// https://262.ecma-international.org/6.0/#sec-isinteger

module.exports = function IsInteger(argument) {
	return isInteger(argument);
};
'use strict';

var callBound = require('call-bound');

var $PromiseThen = callBound('Promise.prototype.then', true);

var isObject = require('es-object-atoms/isObject');

// https://262.ecma-international.org/6.0/#sec-ispromise

module.exports = function IsPromise(x) {
	if (!isObject(x)) {
		return false;
	}
	if (!$PromiseThen) { // Promises are not supported
		return false;
	}
	try {
		$PromiseThen(x); // throws if not a promise
	} catch (e) {
		return false;
	}
	return true;
};
'use strict';

var isPropertyKey = require('../helpers/isPropertyKey');

// https://262.ecma-international.org/6.0/#sec-ispropertykey

module.exports = function IsPropertyKey(argument) {
	return isPropertyKey(argument);
};
'use strict';

var GetIntrinsic = require('get-intrinsic');

var $match = GetIntrinsic('%Symbol.match%', true);

var hasRegExpMatcher = require('is-regex');
var isObject = require('es-object-atoms/isObject');

var ToBoolean = require('./ToBoolean');

// https://262.ecma-international.org/6.0/#sec-isregexp

module.exports = function IsRegExp(argument) {
	if (!isObject(argument)) {
		return false;
	}
	if ($match) {
		var isRegExp = argument[$match];
		if (typeof isRegExp !== 'undefined') {
			return ToBoolean(isRegExp);
		}
	}
	return hasRegExpMatcher(argument);
};
'use strict';

var $TypeError = require('es-errors/type');
var isObject = require('es-object-atoms/isObject');

var isSharedArrayBuffer = require('is-shared-array-buffer');

// https://262.ecma-international.org/8.0/#sec-issharedarraybuffer

module.exports = function IsSharedArrayBuffer(obj) {
	if (!isObject(obj)) {
		throw new $TypeError('Assertion failed: Type(O) is not Object');
	}

	return isSharedArrayBuffer(obj);
};
'use strict';

var $TypeError = require('es-errors/type');

var isPrefixOf = require('../helpers/isPrefixOf');

// var callBound = require('call-bound');

// var $charAt = callBound('String.prototype.charAt');

// https://262.ecma-international.org/9.0/#sec-isstringprefix

module.exports = function IsStringPrefix(p, q) {
	if (typeof p !== 'string') {
		throw new $TypeError('Assertion failed: "p" must be a String');
	}

	if (typeof q !== 'string') {
		throw new $TypeError('Assertion failed: "q" must be a String');
	}

	return isPrefixOf(p, q);
	/*
	if (p === q || p === '') {
		return true;
	}

	var pLength = p.length;
	var qLength = q.length;
	if (pLength >= qLength) {
		return false;
	}

	// assert: pLength < qLength

	for (var i = 0; i < pLength; i += 1) {
		if ($charAt(p, i) !== $charAt(q, i)) {
			return false;
		}
	}
	return true;
	*/
};
'use strict';

var $TypeError = require('es-errors/type');

var callBound = require('call-bound');

var $indexOf = callBound('String.prototype.indexOf');

var IsArray = require('./IsArray');
var IsInteger = require('./IsInteger');
var WordCharacters = require('./WordCharacters');

var every = require('../helpers/every');

var isChar = function isChar(c) {
	return typeof c === 'string';
};

// https://262.ecma-international.org/8.0/#sec-runtime-semantics-iswordchar-abstract-operation

// note: prior to ES2023, this AO erroneously omitted the latter of its arguments.
module.exports = function IsWordChar(e, InputLength, Input, IgnoreCase, Unicode) {
	if (!IsInteger(e)) {
		throw new $TypeError('Assertion failed: `e` must be an integer');
	}
	if (!IsInteger(InputLength)) {
		throw new $TypeError('Assertion failed: `InputLength` must be an integer');
	}
	if (!IsArray(Input) || !every(Input, isChar)) {
		throw new $TypeError('Assertion failed: `Input` must be a List of characters');
	}
	if (typeof IgnoreCase !== 'boolean' || typeof Unicode !== 'boolean') {
		throw new $TypeError('Assertion failed: `IgnoreCase` and `Unicode` must be booleans');
	}

	if (e === -1 || e === InputLength) {
		return false; // step 1
	}

	var c = Input[e]; // step 2

	var wordChars = WordCharacters(IgnoreCase, Unicode);

	return $indexOf(wordChars, c) > -1; // steps 3-4
};
'use strict';

var GetIterator = require('./GetIterator');
var IteratorStep = require('./IteratorStep');
var IteratorValue = require('./IteratorValue');

// https://262.ecma-international.org/8.0/#sec-iterabletolist

module.exports = function IterableToList(items, method) {
	var iterator = GetIterator(items, method);
	var values = [];
	var next = true;
	while (next) {
		next = IteratorStep(iterator);
		if (next) {
			var nextValue = IteratorValue(next);
			values[values.length] = nextValue;
		}
	}
	return values;
};
'use strict';

var $TypeError = require('es-errors/type');
var isObject = require('es-object-atoms/isObject');

var Call = require('./Call');
var CompletionRecord = require('./CompletionRecord');
var GetMethod = require('./GetMethod');
var IsCallable = require('./IsCallable');

// https://262.ecma-international.org/6.0/#sec-iteratorclose

module.exports = function IteratorClose(iterator, completion) {
	if (!isObject(iterator)) {
		throw new $TypeError('Assertion failed: Type(iterator) is not Object');
	}
	if (!IsCallable(completion) && !(completion instanceof CompletionRecord)) {
		throw new $TypeError('Assertion failed: completion is not a thunk representing a Completion Record, nor a Completion Record instance');
	}
	var completionThunk = completion instanceof CompletionRecord ? function () { return completion['?'](); } : completion;

	var iteratorReturn = GetMethod(iterator, 'return');

	if (typeof iteratorReturn === 'undefined') {
		return completionThunk();
	}

	var completionRecord;
	try {
		var innerResult = Call(iteratorReturn, iterator, []);
	} catch (e) {
		// if we hit here, then "e" is the innerResult completion that needs re-throwing

		// if the completion is of type "throw", this will throw.
		completionThunk();
		completionThunk = null; // ensure it's not called twice.

		// if not, then return the innerResult completion
		throw e;
	}
	completionRecord = completionThunk(); // if innerResult worked, then throw if the completion does
	completionThunk = null; // ensure it's not called twice.

	if (!isObject(innerResult)) {
		throw new $TypeError('iterator .return must return an object');
	}

	return completionRecord;
};
'use strict';

var $TypeError = require('es-errors/type');
var isObject = require('es-object-atoms/isObject');

var Get = require('./Get');
var ToBoolean = require('./ToBoolean');

// https://262.ecma-international.org/6.0/#sec-iteratorcomplete

module.exports = function IteratorComplete(iterResult) {
	if (!isObject(iterResult)) {
		throw new $TypeError('Assertion failed: Type(iterResult) is not Object');
	}
	return ToBoolean(Get(iterResult, 'done'));
};
'use strict';

var $TypeError = require('es-errors/type');
var isObject = require('es-object-atoms/isObject');

var Invoke = require('./Invoke');

// https://262.ecma-international.org/6.0/#sec-iteratornext

module.exports = function IteratorNext(iterator, value) {
	var result = Invoke(iterator, 'next', arguments.length < 2 ? [] : [value]);
	if (!isObject(result)) {
		throw new $TypeError('iterator next must return an object');
	}
	return result;
};
'use strict';

var IteratorComplete = require('./IteratorComplete');
var IteratorNext = require('./IteratorNext');

// https://262.ecma-international.org/6.0/#sec-iteratorstep

module.exports = function IteratorStep(iterator) {
	var result = IteratorNext(iterator);
	var done = IteratorComplete(result);
	return done === true ? false : result;
};

'use strict';

var $TypeError = require('es-errors/type');
var isObject = require('es-object-atoms/isObject');

var Get = require('./Get');

// https://262.ecma-international.org/6.0/#sec-iteratorvalue

module.exports = function IteratorValue(iterResult) {
	if (!isObject(iterResult)) {
		throw new $TypeError('Assertion failed: Type(iterResult) is not Object');
	}
	return Get(iterResult, 'value');
};

'use strict';

var $isFinite = require('math-intrinsics/isFinite');

var msPerDay = require('../helpers/timeConstants').msPerDay;

// https://262.ecma-international.org/5.1/#sec-15.9.1.13

module.exports = function MakeDate(day, time) {
	if (!$isFinite(day) || !$isFinite(time)) {
		return NaN;
	}
	return (day * msPerDay) + time;
};
'use strict';

var GetIntrinsic = require('get-intrinsic');

var $DateUTC = GetIntrinsic('%Date.UTC%');

var $isFinite = require('math-intrinsics/isFinite');

var DateFromTime = require('./DateFromTime');
var Day = require('./Day');
var floor = require('./floor');
var modulo = require('./modulo');
var MonthFromTime = require('./MonthFromTime');
var ToInteger = require('./ToInteger');
var YearFromTime = require('./YearFromTime');

// https://262.ecma-international.org/5.1/#sec-15.9.1.12

module.exports = function MakeDay(year, month, date) {
	if (!$isFinite(year) || !$isFinite(month) || !$isFinite(date)) {
		return NaN;
	}
	var y = ToInteger(year);
	var m = ToInteger(month);
	var dt = ToInteger(date);
	var ym = y + floor(m / 12);
	var mn = modulo(m, 12);
	var t = $DateUTC(ym, mn, 1);
	if (YearFromTime(t) !== ym || MonthFromTime(t) !== mn || DateFromTime(t) !== 1) {
		return NaN;
	}
	return Day(t) + dt - 1;
};
'use strict';

var $isFinite = require('math-intrinsics/isFinite');

var timeConstants = require('../helpers/timeConstants');
var msPerSecond = timeConstants.msPerSecond;
var msPerMinute = timeConstants.msPerMinute;
var msPerHour = timeConstants.msPerHour;

var ToInteger = require('./ToInteger');

// https://262.ecma-international.org/5.1/#sec-15.9.1.11

module.exports = function MakeTime(hour, min, sec, ms) {
	if (!$isFinite(hour) || !$isFinite(min) || !$isFinite(sec) || !$isFinite(ms)) {
		return NaN;
	}
	var h = ToInteger(hour);
	var m = ToInteger(min);
	var s = ToInteger(sec);
	var milli = ToInteger(ms);
	var t = (h * msPerHour) + (m * msPerMinute) + (s * msPerSecond) + milli;
	return t;
};
'use strict';

// https://262.ecma-international.org/6.0/#sec-algorithm-conventions

module.exports = require('math-intrinsics/max');
'use strict';

var floor = require('./floor');
var modulo = require('./modulo');

var timeConstants = require('../helpers/timeConstants');
var msPerMinute = timeConstants.msPerMinute;
var MinutesPerHour = timeConstants.MinutesPerHour;

// https://262.ecma-international.org/5.1/#sec-15.9.1.10

module.exports = function MinFromTime(t) {
	return modulo(floor(t / msPerMinute), MinutesPerHour);
};
'use strict';

// https://262.ecma-international.org/6.0/#sec-algorithm-conventions

module.exports = require('math-intrinsics/min');
'use strict';

var mod = require('../helpers/mod');

// https://262.ecma-international.org/5.1/#sec-5.2

module.exports = function modulo(x, y) {
	return mod(x, y);
};
'use strict';

var $RangeError = require('es-errors/range');

var DayWithinYear = require('./DayWithinYear');
var InLeapYear = require('./InLeapYear');

// https://262.ecma-international.org/5.1/#sec-15.9.1.4

module.exports = function MonthFromTime(t) {
	var day = DayWithinYear(t);
	if (0 <= day && day < 31) {
		return 0;
	}
	var leap = InLeapYear(t);
	if (31 <= day && day < (59 + leap)) {
		return 1;
	}
	if ((59 + leap) <= day && day < (90 + leap)) {
		return 2;
	}
	if ((90 + leap) <= day && day < (120 + leap)) {
		return 3;
	}
	if ((120 + leap) <= day && day < (151 + leap)) {
		return 4;
	}
	if ((151 + leap) <= day && day < (181 + leap)) {
		return 5;
	}
	if ((181 + leap) <= day && day < (212 + leap)) {
		return 6;
	}
	if ((212 + leap) <= day && day < (243 + leap)) {
		return 7;
	}
	if ((243 + leap) <= day && day < (273 + leap)) {
		return 8;
	}
	if ((273 + leap) <= day && day < (304 + leap)) {
		return 9;
	}
	if ((304 + leap) <= day && day < (334 + leap)) {
		return 10;
	}
	if ((334 + leap) <= day && day < (365 + leap)) {
		return 11;
	}

	throw new $RangeError('Assertion failed: `day` is out of range');
};
'use strict';

var modulo = require('./modulo');

var msPerSecond = require('../helpers/timeConstants').msPerSecond;

// https://262.ecma-international.org/5.1/#sec-15.9.1.10

module.exports = function msFromTime(t) {
	return modulo(t, msPerSecond);
};
'use strict';

var $TypeError = require('es-errors/type');

var IsCallable = require('./IsCallable');
var IsConstructor = require('./IsConstructor');

// https://262.ecma-international.org/6.0/#sec-newpromisecapability

module.exports = function NewPromiseCapability(C) {
	if (!IsConstructor(C)) {
		throw new $TypeError('C must be a constructor'); // step 1
	}

	var resolvingFunctions = { '[[Resolve]]': void undefined, '[[Reject]]': void undefined }; // step 3

	var promise = new C(function (resolve, reject) { // steps 4-5
		if (typeof resolvingFunctions['[[Resolve]]'] !== 'undefined' || typeof resolvingFunctions['[[Reject]]'] !== 'undefined') {
			throw new $TypeError('executor has already been called'); // step 4.a, 4.b
		}
		resolvingFunctions['[[Resolve]]'] = resolve; // step 4.c
		resolvingFunctions['[[Reject]]'] = reject; // step 4.d
	}); // step 4-6

	if (!IsCallable(resolvingFunctions['[[Resolve]]']) || !IsCallable(resolvingFunctions['[[Reject]]'])) {
		throw new $TypeError('executor must provide valid resolve and reject functions'); // steps 7-8
	}

	return {
		'[[Promise]]': promise,
		'[[Resolve]]': resolvingFunctions['[[Resolve]]'],
		'[[Reject]]': resolvingFunctions['[[Reject]]']
	}; // step 9
};
'use strict';

var CompletionRecord = require('./CompletionRecord');

// https://262.ecma-international.org/6.0/#sec-normalcompletion

module.exports = function NormalCompletion(value) {
	return new CompletionRecord('normal', value);
};
'use strict';

var $TypeError = require('es-errors/type');

var hasOwnProperty = require('./HasOwnProperty');
var ToInt16 = require('./ToInt16');
var ToInt32 = require('./ToInt32');
var ToInt8 = require('./ToInt8');
var ToUint16 = require('./ToUint16');
var ToUint32 = require('./ToUint32');
var ToUint8 = require('./ToUint8');
var ToUint8Clamp = require('./ToUint8Clamp');

var valueToFloat32Bytes = require('../helpers/valueToFloat32Bytes');
var valueToFloat64Bytes = require('../helpers/valueToFloat64Bytes');
var integerToNBytes = require('../helpers/integerToNBytes');

var tableTAO = require('./tables/typed-array-objects');

// https://262.ecma-international.org/8.0/#table-50

var TypeToAO = {
	__proto__: null,
	$Int8: ToInt8,
	$Uint8: ToUint8,
	$Uint8C: ToUint8Clamp,
	$Int16: ToInt16,
	$Uint16: ToUint16,
	$Int32: ToInt32,
	$Uint32: ToUint32
};

// https://262.ecma-international.org/8.0/#sec-numbertorawbytes

module.exports = function NumberToRawBytes(type, value, isLittleEndian) {
	if (typeof type !== 'string' || !hasOwnProperty(tableTAO.size, '$' + type)) {
		throw new $TypeError('Assertion failed: `type` must be a TypedArray element type');
	}
	if (typeof value !== 'number') {
		throw new $TypeError('Assertion failed: `value` must be a Number');
	}
	if (typeof isLittleEndian !== 'boolean') {
		throw new $TypeError('Assertion failed: `isLittleEndian` must be a Boolean');
	}

	if (type === 'Float32') { // step 1
		return valueToFloat32Bytes(value, isLittleEndian);
	} else if (type === 'Float64') { // step 2
		return valueToFloat64Bytes(value, isLittleEndian);
	} // step 3

	var n = tableTAO.size['$' + type]; // step 3.a

	var convOp = TypeToAO['$' + type]; // step 3.b

	var intValue = convOp(value); // step 3.c

	return integerToNBytes(intValue, n, isLittleEndian); // step 3.d, 3.e, 4
};
'use strict';

var GetIntrinsic = require('get-intrinsic');

var $String = GetIntrinsic('%String%');
var $TypeError = require('es-errors/type');

// https://262.ecma-international.org/9.0/#sec-tostring-applied-to-the-number-type

module.exports = function NumberToString(m) {
	if (typeof m !== 'number') {
		throw new $TypeError('Assertion failed: "m" must be a String');
	}

	return $String(m);
};

'use strict';

var GetIntrinsic = require('get-intrinsic');

var $ObjectCreate = GetIntrinsic('%Object.create%', true);
var $TypeError = require('es-errors/type');
var $SyntaxError = require('es-errors/syntax');
var isObject = require('es-object-atoms/isObject');

var IsArray = require('./IsArray');

var forEach = require('../helpers/forEach');

var SLOT = require('internal-slot');

var hasProto = require('has-proto')();

// https://262.ecma-international.org/6.0/#sec-objectcreate

module.exports = function ObjectCreate(proto, internalSlotsList) {
	if (proto !== null && !isObject(proto)) {
		throw new $TypeError('Assertion failed: `proto` must be null or an object');
	}
	var slots = arguments.length < 2 ? [] : internalSlotsList; // step 1
	if (arguments.length >= 2 && !IsArray(slots)) {
		throw new $TypeError('Assertion failed: `internalSlotsList` must be an Array');
	}

	var O;
	if (hasProto) {
		O = { __proto__: proto };
	} else if ($ObjectCreate) {
		O = $ObjectCreate(proto);
	} else {
		if (proto === null) {
			throw new $SyntaxError('native Object.create support is required to create null objects');
		}
		var T = function T() {};
		T.prototype = proto;
		O = new T();
	}

	if (slots.length > 0) {
		forEach(slots, function (slot) {
			SLOT.set(O, slot, void undefined);
		});
	}

	return O; // step 6
};
'use strict';

var DefinePropertyOrThrow = require('./DefinePropertyOrThrow');
var Get = require('./Get');
var OrdinaryGetOwnProperty = require('./OrdinaryGetOwnProperty');
var ToObject = require('./ToObject');
var ToPropertyDescriptor = require('./ToPropertyDescriptor');

var forEach = require('../helpers/forEach');
var OwnPropertyKeys = require('own-keys');

// https://262.ecma-international.org/6.0/#sec-objectdefineproperties

/** @type {<T extends Record<PropertyKey, unknown> = {}>(O: T, Properties: object) => T} */
module.exports = function ObjectDefineProperties(O, Properties) {
	var props = ToObject(Properties); // step 1
	var keys = OwnPropertyKeys(props); // step 2
	/** @type {[string | symbol, import('../types').Descriptor][]} */
	var descriptors = []; // step 3

	forEach(keys, function (nextKey) { // step 4
		var propDesc = OrdinaryGetOwnProperty(props, nextKey); // ToPropertyDescriptor(getOwnPropertyDescriptor(props, nextKey)); // step 4.a
		if (typeof propDesc !== 'undefined' && propDesc['[[Enumerable]]']) { // step 4.b
			var descObj = Get(props, nextKey); // step 4.b.i
			var desc = ToPropertyDescriptor(descObj); // step 4.b.ii
			descriptors[descriptors.length] = [nextKey, desc]; // step 4.b.iii
		}
	});

	forEach(descriptors, function (pair) { // step 5
		var P = pair[0]; // step 5.a
		var desc = pair[1]; // step 5.b
		DefinePropertyOrThrow(O, P, desc); // step 5.c
	});

	return O; // step 6
};
'use strict';

var GetIntrinsic = require('get-intrinsic');
var $TypeError = require('es-errors/type');

var GetPrototypeFromConstructor = require('./GetPrototypeFromConstructor');
var IsArray = require('./IsArray');
var ObjectCreate = require('./ObjectCreate');

// https://262.ecma-international.org/6.0/#sec-ordinarycreatefromconstructor

module.exports = function OrdinaryCreateFromConstructor(constructor, intrinsicDefaultProto) {
	GetIntrinsic(intrinsicDefaultProto); // throws if not a valid intrinsic
	var proto = GetPrototypeFromConstructor(constructor, intrinsicDefaultProto);
	var slots = arguments.length < 3 ? [] : arguments[2];
	if (!IsArray(slots)) {
		throw new $TypeError('Assertion failed: if provided, `internalSlotsList` must be a List');
	}
	return ObjectCreate(proto, slots);
};
'use strict';

var $gOPD = require('gopd');
var $SyntaxError = require('es-errors/syntax');
var $TypeError = require('es-errors/type');
var isObject = require('es-object-atoms/isObject');

var isPropertyDescriptor = require('../helpers/records/property-descriptor');

var IsAccessorDescriptor = require('./IsAccessorDescriptor');
var IsExtensible = require('./IsExtensible');
var isPropertyKey = require('../helpers/isPropertyKey');
var ToPropertyDescriptor = require('./ToPropertyDescriptor');
var SameValue = require('./SameValue');
var ValidateAndApplyPropertyDescriptor = require('./ValidateAndApplyPropertyDescriptor');

// https://262.ecma-international.org/6.0/#sec-ordinarydefineownproperty

module.exports = function OrdinaryDefineOwnProperty(O, P, Desc) {
	if (!isObject(O)) {
		throw new $TypeError('Assertion failed: O must be an Object');
	}
	if (!isPropertyKey(P)) {
		throw new $TypeError('Assertion failed: P must be a Property Key');
	}
	if (!isPropertyDescriptor(Desc)) {
		throw new $TypeError('Assertion failed: Desc must be a Property Descriptor');
	}
	if (!$gOPD) {
		// ES3/IE 8 fallback
		if (IsAccessorDescriptor(Desc)) {
			throw new $SyntaxError('This environment does not support accessor property descriptors.');
		}
		var creatingNormalDataProperty = !(P in O)
			&& Desc['[[Writable]]']
			&& Desc['[[Enumerable]]']
			&& Desc['[[Configurable]]']
			&& '[[Value]]' in Desc;
		var settingExistingDataProperty = (P in O)
			&& (!('[[Configurable]]' in Desc) || Desc['[[Configurable]]'])
			&& (!('[[Enumerable]]' in Desc) || Desc['[[Enumerable]]'])
			&& (!('[[Writable]]' in Desc) || Desc['[[Writable]]'])
			&& '[[Value]]' in Desc;
		if (creatingNormalDataProperty || settingExistingDataProperty) {
			O[P] = Desc['[[Value]]']; // eslint-disable-line no-param-reassign
			return SameValue(O[P], Desc['[[Value]]']);
		}
		throw new $SyntaxError('This environment does not support defining non-writable, non-enumerable, or non-configurable properties');
	}
	var desc = $gOPD(O, P);
	var current = desc && ToPropertyDescriptor(desc);
	var extensible = IsExtensible(O);
	return ValidateAndApplyPropertyDescriptor(O, P, extensible, Desc, current);
};
'use strict';

var $gOPD = require('gopd');
var $TypeError = require('es-errors/type');
var isObject = require('es-object-atoms/isObject');
var hasOwn = require('hasown');
var callBound = require('call-bound');

var $isEnumerable = callBound('Object.prototype.propertyIsEnumerable');

var IsArray = require('./IsArray');
var isPropertyKey = require('../helpers/isPropertyKey');
var IsRegExp = require('./IsRegExp');
var ToPropertyDescriptor = require('./ToPropertyDescriptor');

// https://262.ecma-international.org/6.0/#sec-ordinarygetownproperty

module.exports = function OrdinaryGetOwnProperty(O, P) {
	if (!isObject(O)) {
		throw new $TypeError('Assertion failed: O must be an Object');
	}
	if (!isPropertyKey(P)) {
		throw new $TypeError('Assertion failed: P must be a Property Key');
	}
	if (!hasOwn(O, P)) {
		return void 0;
	}
	if (!$gOPD) {
		// ES3 / IE 8 fallback
		var arrayLength = IsArray(O) && P === 'length';
		var regexLastIndex = IsRegExp(O) && P === 'lastIndex';
		return {
			'[[Configurable]]': !(arrayLength || regexLastIndex),
			'[[Enumerable]]': $isEnumerable(O, P),
			'[[Value]]': O[P],
			'[[Writable]]': true
		};
	}
	return ToPropertyDescriptor($gOPD(O, P));
};
'use strict';

var $TypeError = require('es-errors/type');
var isObject = require('es-object-atoms/isObject');

var $getProto = require('get-proto');

// https://262.ecma-international.org/7.0/#sec-ordinarygetprototypeof

module.exports = function OrdinaryGetPrototypeOf(O) {
	if (!isObject(O)) {
		throw new $TypeError('Assertion failed: O must be an Object');
	}
	if (!$getProto) {
		throw new $TypeError('This environment does not support fetching prototypes.');
	}
	return $getProto(O);
};
'use strict';

var $TypeError = require('es-errors/type');
var isObject = require('es-object-atoms/isObject');

var Get = require('./Get');
var IsCallable = require('./IsCallable');

// https://262.ecma-international.org/6.0/#sec-ordinaryhasinstance

module.exports = function OrdinaryHasInstance(C, O) {
	if (!IsCallable(C)) {
		return false;
	}
	if (!isObject(O)) {
		return false;
	}
	var P = Get(C, 'prototype');
	if (!isObject(P)) {
		throw new $TypeError('OrdinaryHasInstance called on an object with an invalid prototype property.');
	}
	return O instanceof C;
};
'use strict';

var $TypeError = require('es-errors/type');
var isObject = require('es-object-atoms/isObject');

var isPropertyKey = require('../helpers/isPropertyKey');

// https://262.ecma-international.org/6.0/#sec-ordinaryhasproperty

module.exports = function OrdinaryHasProperty(O, P) {
	if (!isObject(O)) {
		throw new $TypeError('Assertion failed: Type(O) is not Object');
	}
	if (!isPropertyKey(P)) {
		throw new $TypeError('Assertion failed: P must be a Property Key');
	}
	return P in O;
};
'use strict';

var $TypeError = require('es-errors/type');
var $setProto = require('set-proto');
var isObject = require('es-object-atoms/isObject');

var OrdinaryGetPrototypeOf = require('./OrdinaryGetPrototypeOf');

// https://262.ecma-international.org/7.0/#sec-ordinarysetprototypeof

module.exports = function OrdinarySetPrototypeOf(O, V) {
	if (V !== null && !isObject(V)) {
		throw new $TypeError('Assertion failed: V must be Object or Null');
	}
	/*
	var extensible = IsExtensible(O);
	var current = OrdinaryGetPrototypeOf(O);
	if (SameValue(V, current)) {
		return true;
	}
	if (!extensible) {
		return false;
	}
	*/
	try {
		$setProto(O, V);
	} catch (e) {
		return false;
	}
	return OrdinaryGetPrototypeOf(O) === V;
	/*
	var p = V;
	var done = false;
	while (!done) {
		if (p === null) {
			done = true;
		} else if (SameValue(p, O)) {
			return false;
		} else {
			if (wat) {
				done = true;
			} else {
				p = p.[[Prototype]];
			}
		}
	}
	O.[[Prototype]] = V;
	return true;
	*/
};
'use strict';

var $TypeError = require('es-errors/type');
var isObject = require('es-object-atoms/isObject');

var Call = require('./Call');
var Get = require('./Get');
var IsCallable = require('./IsCallable');

var inspect = require('object-inspect');

// https://262.ecma-international.org/8.0/#sec-ordinarytoprimitive

module.exports = function OrdinaryToPrimitive(O, hint) {
	if (!isObject(O)) {
		throw new $TypeError('Assertion failed: Type(O) is not Object');
	}
	if (/* typeof hint !== 'string' || */ hint !== 'string' && hint !== 'number') {
		throw new $TypeError('Assertion failed: `hint` must be "string" or "number"');
	}

	var methodNames = hint === 'string' ? ['toString', 'valueOf'] : ['valueOf', 'toString'];

	for (var i = 0; i < methodNames.length; i += 1) {
		var name = methodNames[i];
		var method = Get(O, name);
		if (IsCallable(method)) {
			var result = Call(method, O);
			if (!isObject(result)) {
				return result;
			}
		}
	}

	throw new $TypeError('No primitive value for ' + inspect(O));
};
'use strict';

var GetIntrinsic = require('get-intrinsic');
var callBind = require('call-bind');
var $SyntaxError = require('es-errors/syntax');

var $resolve = GetIntrinsic('%Promise.resolve%', true);
var $PromiseResolve = $resolve && callBind($resolve);

// https://262.ecma-international.org/9.0/#sec-promise-resolve

module.exports = function PromiseResolve(C, x) {
	if (!$PromiseResolve) {
		throw new $SyntaxError('This environment does not support Promises.');
	}
	return $PromiseResolve(C, x);
};

'use strict';

var $TypeError = require('es-errors/type');

var callBound = require('call-bound');
var forEach = require('../helpers/forEach');

var $charCodeAt = callBound('String.prototype.charCodeAt');
var $strSplit = callBound('String.prototype.split');

var UnicodeEscape = require('./UnicodeEscape');

var hasOwn = require('hasown');

// https://262.ecma-international.org/9.0/#sec-quotejsonstring

var escapes = {
	'\u0008': '\\b',
	'\u0009': '\\t',
	'\u000A': '\\n',
	'\u000C': '\\f',
	'\u000D': '\\r',
	'\u0022': '\\"',
	'\u005c': '\\\\'
};

module.exports = function QuoteJSONString(value) {
	if (typeof value !== 'string') {
		throw new $TypeError('Assertion failed: `value` must be a String');
	}
	var product = '"';
	if (value) {
		forEach($strSplit(value, ''), function (C) {
			if (hasOwn(escapes, C)) {
				product += escapes[C];
			} else if ($charCodeAt(C, 0) < 0x20) {
				product += UnicodeEscape(C);
			} else {
				product += C;
			}
		});
	}
	product += '"';
	return product;
};
'use strict';

var callBound = require('call-bound');

var $RangeError = require('es-errors/range');
var $TypeError = require('es-errors/type');

var $charAt = callBound('String.prototype.charAt');
var $reverse = callBound('Array.prototype.reverse');
var $slice = callBound('Array.prototype.slice');

var hasOwnProperty = require('./HasOwnProperty');
var IsArray = require('./IsArray');

var bytesAsFloat32 = require('../helpers/bytesAsFloat32');
var bytesAsFloat64 = require('../helpers/bytesAsFloat64');
var bytesAsInteger = require('../helpers/bytesAsInteger');
var every = require('../helpers/every');
var isByteValue = require('../helpers/isByteValue');

var tableTAO = require('./tables/typed-array-objects');

// https://262.ecma-international.org/8.0/#sec-rawbytestonumber

module.exports = function RawBytesToNumber(type, rawBytes, isLittleEndian) {
	if (typeof type !== 'string' || !hasOwnProperty(tableTAO.size, '$' + type)) {
		throw new $TypeError('Assertion failed: `type` must be a TypedArray element type');
	}
	if (!IsArray(rawBytes) || !every(rawBytes, isByteValue)) {
		throw new $TypeError('Assertion failed: `rawBytes` must be an Array of bytes');
	}
	if (typeof isLittleEndian !== 'boolean') {
		throw new $TypeError('Assertion failed: `isLittleEndian` must be a Boolean');
	}

	var elementSize = tableTAO.size['$' + type]; // step 1

	if (rawBytes.length !== elementSize) {
		// this assertion is not in the spec, but it'd be an editorial error if it were ever violated
		throw new $RangeError('Assertion failed: `rawBytes` must have a length of ' + elementSize + ' for type ' + type);
	}

	// eslint-disable-next-line no-param-reassign
	rawBytes = $slice(rawBytes, 0, elementSize);
	if (!isLittleEndian) {
		$reverse(rawBytes); // step 2
	}

	if (type === 'Float32') { // step 3
		return bytesAsFloat32(rawBytes);
	}

	if (type === 'Float64') { // step 4
		return bytesAsFloat64(rawBytes);
	}

	return bytesAsInteger(rawBytes, elementSize, $charAt(type, 0) === 'U', false);
};
'use strict';

var GetIntrinsic = require('get-intrinsic');

var $RegExp = GetIntrinsic('%RegExp%');

// var RegExpAlloc = require('./RegExpAlloc');
// var RegExpInitialize = require('./RegExpInitialize');
var ToString = require('./ToString');

// https://262.ecma-international.org/6.0/#sec-regexpcreate

module.exports = function RegExpCreate(P, F) {
	// var obj = RegExpAlloc($RegExp);
	// return RegExpInitialize(obj, P, F);

	// covers spec mechanics; bypass regex brand checking
	var pattern = typeof P === 'undefined' ? '' : ToString(P);
	var flags = typeof F === 'undefined' ? '' : ToString(F);
	return new $RegExp(pattern, flags);
};
'use strict';

var $TypeError = require('es-errors/type');
var isObject = require('es-object-atoms/isObject');
var regexExec = require('call-bound')('RegExp.prototype.exec');

var Call = require('./Call');
var Get = require('./Get');
var IsCallable = require('./IsCallable');

// https://262.ecma-international.org/6.0/#sec-regexpexec

module.exports = function RegExpExec(R, S) {
	if (!isObject(R)) {
		throw new $TypeError('Assertion failed: `R` must be an Object');
	}
	if (typeof S !== 'string') {
		throw new $TypeError('Assertion failed: `S` must be a String');
	}
	var exec = Get(R, 'exec');
	if (IsCallable(exec)) {
		var result = Call(exec, R, [S]);
		if (result === null || isObject(result)) {
			return result;
		}
		throw new $TypeError('"exec" method must return `null` or an Object');
	}
	return regexExec(R, S);
};
'use strict';

module.exports = require('es-object-atoms/RequireObjectCoercible');
'use strict';

var $isNaN = require('math-intrinsics/isNaN');

// http://262.ecma-international.org/5.1/#sec-9.12

module.exports = function SameValue(x, y) {
	if (x === y) { // 0 === -0, but they are not identical.
		if (x === 0) { return 1 / x === 1 / y; }
		return true;
	}
	return $isNaN(x) && $isNaN(y);
};
'use strict';

var $TypeError = require('es-errors/type');

var SameValue = require('./SameValue');

// https://262.ecma-international.org/7.0/#sec-samevaluenonnumber

module.exports = function SameValueNonNumber(x, y) {
	if (typeof x === 'number' || typeof x !== typeof y) {
		throw new $TypeError('SameValueNonNumber requires two non-number values of the same type.');
	}
	return SameValue(x, y);
};
'use strict';

var $isNaN = require('math-intrinsics/isNaN');

// https://262.ecma-international.org/6.0/#sec-samevaluezero

module.exports = function SameValueZero(x, y) {
	return (x === y) || ($isNaN(x) && $isNaN(y));
};
'use strict';

var floor = require('./floor');
var modulo = require('./modulo');

var timeConstants = require('../helpers/timeConstants');
var msPerSecond = timeConstants.msPerSecond;
var SecondsPerMinute = timeConstants.SecondsPerMinute;

// https://262.ecma-international.org/5.1/#sec-15.9.1.10

module.exports = function SecFromTime(t) {
	return modulo(floor(t / msPerSecond), SecondsPerMinute);
};
'use strict';

var $TypeError = require('es-errors/type');
var isInteger = require('math-intrinsics/isInteger');

var DefinePropertyOrThrow = require('./DefinePropertyOrThrow');
var HasOwnProperty = require('./HasOwnProperty');
var IsExtensible = require('./IsExtensible');

// https://262.ecma-international.org/9.0/#sec-setfunctionlength

module.exports = function SetFunctionLength(F, length) {
	if (typeof F !== 'function' || !IsExtensible(F) || HasOwnProperty(F, 'length')) {
		throw new $TypeError('Assertion failed: `F` must be an extensible function and lack an own `length` property');
	}
	if (typeof length !== 'number') {
		throw new $TypeError('Assertion failed: `length` must be a Number');
	}
	if (length < 0 || !isInteger(length)) {
		throw new $TypeError('Assertion failed: `length` must be an integer >= 0');
	}
	return DefinePropertyOrThrow(F, 'length', {
		'[[Configurable]]': true,
		'[[Enumerable]]': false,
		'[[Value]]': length,
		'[[Writable]]': false
	});
};
'use strict';

var hasOwn = require('hasown');

var $TypeError = require('es-errors/type');

var getSymbolDescription = require('get-symbol-description');

var DefinePropertyOrThrow = require('./DefinePropertyOrThrow');
var IsExtensible = require('./IsExtensible');

// https://262.ecma-international.org/6.0/#sec-setfunctionname

module.exports = function SetFunctionName(F, name) {
	if (typeof F !== 'function') {
		throw new $TypeError('Assertion failed: `F` must be a function');
	}
	if (!IsExtensible(F) || hasOwn(F, 'name')) {
		throw new $TypeError('Assertion failed: `F` must be extensible, and must not have a `name` own property');
	}
	if (typeof name !== 'symbol' && typeof name !== 'string') {
		throw new $TypeError('Assertion failed: `name` must be a Symbol or a String');
	}
	if (typeof name === 'symbol') {
		var description = getSymbolDescription(name);
		// eslint-disable-next-line no-param-reassign
		name = typeof description === 'undefined' ? '' : '[' + description + ']';
	}
	if (arguments.length > 2) {
		var prefix = arguments[2];
		// eslint-disable-next-line no-param-reassign
		name = prefix + ' ' + name;
	}
	return DefinePropertyOrThrow(F, 'name', {
		'[[Value]]': name,
		'[[Writable]]': false,
		'[[Enumerable]]': false,
		'[[Configurable]]': true
	});
};
'use strict';

var GetIntrinsic = require('get-intrinsic');

var $SyntaxError = require('es-errors/syntax');
var $TypeError = require('es-errors/type');
var isObject = require('es-object-atoms/isObject');
var $gOPD = require('gopd');
var $preventExtensions = GetIntrinsic('%Object.preventExtensions%', true);
var $gOPN = GetIntrinsic('%Object.getOwnPropertyNames%', true);

var forEach = require('../helpers/forEach');

var DefinePropertyOrThrow = require('./DefinePropertyOrThrow');
var IsAccessorDescriptor = require('./IsAccessorDescriptor');
var ToPropertyDescriptor = require('./ToPropertyDescriptor');

// https://262.ecma-international.org/6.0/#sec-setintegritylevel

module.exports = function SetIntegrityLevel(O, level) {
	if (!isObject(O)) {
		throw new $TypeError('Assertion failed: Type(O) is not Object');
	}
	if (level !== 'sealed' && level !== 'frozen') {
		throw new $TypeError('Assertion failed: `level` must be `"sealed"` or `"frozen"`');
	}
	if (!$preventExtensions) {
		throw new $SyntaxError('SetIntegrityLevel requires native `Object.preventExtensions` support');
	}
	var status = $preventExtensions(O);
	if (!status) {
		return false;
	}
	if (!$gOPN) {
		throw new $SyntaxError('SetIntegrityLevel requires native `Object.getOwnPropertyNames` support');
	}
	var theKeys = $gOPN(O);
	if (level === 'sealed') {
		forEach(theKeys, function (k) {
			DefinePropertyOrThrow(O, k, { configurable: false });
		});
	} else if (level === 'frozen') {
		forEach(theKeys, function (k) {
			var currentDesc = $gOPD(O, k);
			if (typeof currentDesc !== 'undefined') {
				var desc;
				if (IsAccessorDescriptor(ToPropertyDescriptor(currentDesc))) {
					desc = { configurable: false };
				} else {
					desc = { configurable: false, writable: false };
				}
				DefinePropertyOrThrow(O, k, desc);
			}
		});
	}
	return true;
};
'use strict';

var $TypeError = require('es-errors/type');
var isObject = require('es-object-atoms/isObject');

var isPropertyKey = require('../helpers/isPropertyKey');
var SameValue = require('./SameValue');

// IE 9 does not throw in strict mode when writability/configurability/extensibility is violated
var noThrowOnStrictViolation = (function () {
	try {
		delete [].length;
		return true;
	} catch (e) {
		return false;
	}
}());

// https://262.ecma-international.org/6.0/#sec-set-o-p-v-throw

module.exports = function Set(O, P, V, Throw) {
	if (!isObject(O)) {
		throw new $TypeError('Assertion failed: `O` must be an Object');
	}
	if (!isPropertyKey(P)) {
		throw new $TypeError('Assertion failed: `P` must be a Property Key');
	}
	if (typeof Throw !== 'boolean') {
		throw new $TypeError('Assertion failed: `Throw` must be a Boolean');
	}
	if (Throw) {
		O[P] = V; // eslint-disable-line no-param-reassign
		if (noThrowOnStrictViolation && !SameValue(O[P], V)) {
			throw new $TypeError('Attempted to assign to readonly property.');
		}
		return true;
	}
	try {
		O[P] = V; // eslint-disable-line no-param-reassign
		return noThrowOnStrictViolation ? SameValue(O[P], V) : true;
	} catch (e) {
		return false;
	}

};
'use strict';

var GetIntrinsic = require('get-intrinsic');

var $SyntaxError = require('es-errors/syntax');
var $TypeError = require('es-errors/type');
var $Uint8Array = GetIntrinsic('%Uint8Array%', true);

var isInteger = require('math-intrinsics/isInteger');

var IsDetachedBuffer = require('./IsDetachedBuffer');
var NumberToRawBytes = require('./NumberToRawBytes');

var isArrayBuffer = require('is-array-buffer');
var isSharedArrayBuffer = require('is-shared-array-buffer');
var hasOwn = require('hasown');

var tableTAO = require('./tables/typed-array-objects');

var defaultEndianness = require('../helpers/defaultEndianness');
var forEach = require('../helpers/forEach');

// https://262.ecma-international.org/8.0/#sec-setvalueinbuffer

/* eslint max-params: 0 */

module.exports = function SetValueInBuffer(arrayBuffer, byteIndex, type, value, isTypedArray, order) {
	var isSAB = isSharedArrayBuffer(arrayBuffer);
	if (!isArrayBuffer(arrayBuffer) && !isSAB) {
		throw new $TypeError('Assertion failed: `arrayBuffer` must be an ArrayBuffer or a SharedArrayBuffer');
	}

	if (!isInteger(byteIndex)) {
		throw new $TypeError('Assertion failed: `byteIndex` must be an integer');
	}

	if (typeof type !== 'string' || !hasOwn(tableTAO.size, '$' + type)) {
		throw new $TypeError('Assertion failed: `type` must be one of ' + tableTAO.choices);
	}

	if (typeof value !== 'number') {
		throw new $TypeError('Assertion failed: `value` must be a number');
	}

	if (typeof isTypedArray !== 'boolean') {
		throw new $TypeError('Assertion failed: `isTypedArray` must be a boolean');
	}
	if (order !== 'SeqCst' && order !== 'Unordered' && order !== 'Init') {
		throw new $TypeError('Assertion failed: `order` must be `"SeqCst"`, `"Unordered"`, or `"Init"`');
	}

	if (arguments.length > 6 && typeof arguments[6] !== 'boolean') {
		throw new $TypeError('Assertion failed: `isLittleEndian` must be a boolean, if present');
	}

	if (IsDetachedBuffer(arrayBuffer)) {
		throw new $TypeError('Assertion failed: ArrayBuffer is detached'); // step 1
	}

	// 2. Assert: There are sufficient bytes in arrayBuffer starting at byteIndex to represent a value of type.

	if (byteIndex < 0) {
		throw new $TypeError('Assertion failed: `byteIndex` must be non-negative'); // step 3
	}

	// 4. Assert: Type(value) is Number.

	// 5. Let block be arrayBuffer.[[ArrayBufferData]].

	var elementSize = tableTAO.size['$' + type]; // step 6

	// 7. If isLittleEndian is not present, set isLittleEndian to to the value of the [[LittleEndian]] field of the surrounding agent's Agent Record.
	var isLittleEndian = arguments.length > 6 ? arguments[6] : defaultEndianness === 'little'; // step 8

	var rawBytes = NumberToRawBytes(type, value, isLittleEndian); // step 8

	if (isSAB) { // step 9
		/*
			Let execution be the [[CandidateExecution]] field of the surrounding agent's Agent Record.
			Let eventList be the [[EventList]] field of the element in execution.[[EventsRecords]] whose [[AgentSignifier]] is AgentSignifier().
			If isTypedArray is true and IsNoTearConfiguration(type, order) is true, let noTear be true; otherwise let noTear be false.
			Append WriteSharedMemory { [[Order]]: order, [[NoTear]]: noTear, [[Block]]: block, [[ByteIndex]]: byteIndex, [[ElementSize]]: elementSize, [[Payload]]: rawBytes } to eventList.
		*/
		throw new $SyntaxError('SharedArrayBuffer is not supported by this implementation');
	} else {
		// 10. Store the individual bytes of rawBytes into block, in order, starting at block[byteIndex].
		var arr = new $Uint8Array(arrayBuffer, byteIndex, elementSize);
		forEach(rawBytes, function (rawByte, i) {
			arr[i] = rawByte;
		});
	}

	// 11. Return NormalCompletion(undefined).
};
'use strict';

var GetIntrinsic = require('get-intrinsic');

var $species = GetIntrinsic('%Symbol.species%', true);
var $TypeError = require('es-errors/type');
var isObject = require('es-object-atoms/isObject');

var IsConstructor = require('./IsConstructor');

// https://262.ecma-international.org/6.0/#sec-speciesconstructor

module.exports = function SpeciesConstructor(O, defaultConstructor) {
	if (!isObject(O)) {
		throw new $TypeError('Assertion failed: Type(O) is not Object');
	}
	var C = O.constructor;
	if (typeof C === 'undefined') {
		return defaultConstructor;
	}
	if (!isObject(C)) {
		throw new $TypeError('O.constructor is not an Object');
	}
	var S = $species ? C[$species] : void 0;
	if (S == null) {
		return defaultConstructor;
	}
	if (IsConstructor(S)) {
		return S;
	}
	throw new $TypeError('no constructor found');
};
'use strict';

var callBound = require('call-bound');

var $TypeError = require('es-errors/type');
var isInteger = require('math-intrinsics/isInteger');

var $charAt = callBound('String.prototype.charAt');

// https://262.ecma-international.org/6.0/#sec-splitmatch

module.exports = function SplitMatch(S, q, R) {
	if (typeof S !== 'string') {
		throw new $TypeError('Assertion failed: `S` must be a String');
	}
	if (!isInteger(q)) {
		throw new $TypeError('Assertion failed: `q` must be an integer');
	}
	if (typeof R !== 'string') {
		throw new $TypeError('Assertion failed: `R` must be a String');
	}
	var r = R.length;
	var s = S.length;
	if (q + r > s) {
		return false;
	}

	for (var i = 0; i < r; i += 1) {
		if ($charAt(S, q + i) !== $charAt(R, i)) {
			return false;
		}
	}

	return q + r;
};
'use strict';

var Type = require('./Type');

// https://262.ecma-international.org/5.1/#sec-11.9.6

module.exports = function StrictEqualityComparison(x, y) {
	if (Type(x) !== Type(y)) {
		return false;
	}
	if (typeof x === 'undefined' || x === null) {
		return true;
	}
	return x === y; // shortcut for steps 4-7
};
'use strict';

var GetIntrinsic = require('get-intrinsic');

var $Object = require('es-object-atoms');
var $StringPrototype = GetIntrinsic('%String.prototype%');
var $SyntaxError = require('es-errors/syntax');
var $TypeError = require('es-errors/type');
var setProto = require('set-proto');

var DefinePropertyOrThrow = require('./DefinePropertyOrThrow');

// https://262.ecma-international.org/6.0/#sec-stringcreate

module.exports = function StringCreate(value, prototype) {
	if (typeof value !== 'string') {
		throw new $TypeError('Assertion failed: `S` must be a String');
	}

	var S = $Object(value);
	if (prototype !== $StringPrototype) {
		if (setProto) {
			setProto(S, prototype);
		} else {
			throw new $SyntaxError('StringCreate: a `proto` argument that is not `String.prototype` is not supported in an environment that does not support setting the [[Prototype]]');
		}
	}

	var length = value.length;
	DefinePropertyOrThrow(S, 'length', {
		'[[Configurable]]': false,
		'[[Enumerable]]': false,
		'[[Value]]': length,
		'[[Writable]]': false
	});

	return S;
};
'use strict';

var $TypeError = require('es-errors/type');
var isObject = require('es-object-atoms/isObject');

var callBound = require('call-bound');
var $charAt = callBound('String.prototype.charAt');
var $stringToString = callBound('String.prototype.toString');

var CanonicalNumericIndexString = require('./CanonicalNumericIndexString');
var IsInteger = require('./IsInteger');

var isPropertyKey = require('../helpers/isPropertyKey');

var isNegativeZero = require('math-intrinsics/isNegativeZero');

// https://262.ecma-international.org/8.0/#sec-stringgetownproperty

module.exports = function StringGetOwnProperty(S, P) {
	var str;
	if (isObject(S)) {
		try {
			str = $stringToString(S);
		} catch (e) { /**/ }
	}
	if (typeof str !== 'string') {
		throw new $TypeError('Assertion failed: `S` must be a boxed string object');
	}
	if (!isPropertyKey(P)) {
		throw new $TypeError('Assertion failed: P is not a Property Key');
	}
	if (typeof P !== 'string') {
		return void undefined;
	}
	var index = CanonicalNumericIndexString(P);
	var len = str.length;
	if (typeof index === 'undefined' || !IsInteger(index) || isNegativeZero(index) || index < 0 || len <= index) {
		return void undefined;
	}
	var resultStr = $charAt(S, index);
	return {
		'[[Configurable]]': false,
		'[[Enumerable]]': true,
		'[[Value]]': resultStr,
		'[[Writable]]': false
	};
};
'use strict';

var $TypeError = require('es-errors/type');

var callBound = require('call-bound');

var $SymbolToString = callBound('Symbol.prototype.toString', true);

// https://262.ecma-international.org/6.0/#sec-symboldescriptivestring

module.exports = function SymbolDescriptiveString(sym) {
	if (typeof sym !== 'symbol') {
		throw new $TypeError('Assertion failed: `sym` must be a Symbol');
	}
	return $SymbolToString(sym);
};
'use strict';

var $gOPD = require('gopd');
var $TypeError = require('es-errors/type');

var every = require('../helpers/every');
var OwnPropertyKeys = require('own-keys');
var isObject = require('es-object-atoms/isObject');

var IsDataDescriptor = require('./IsDataDescriptor');
var IsExtensible = require('./IsExtensible');
var ToPropertyDescriptor = require('./ToPropertyDescriptor');

// https://262.ecma-international.org/6.0/#sec-testintegritylevel

module.exports = function TestIntegrityLevel(O, level) {
	if (!isObject(O)) {
		throw new $TypeError('Assertion failed: Type(O) is not Object');
	}
	if (level !== 'sealed' && level !== 'frozen') {
		throw new $TypeError('Assertion failed: `level` must be `"sealed"` or `"frozen"`');
	}
	var status = IsExtensible(O);
	if (status || !$gOPD) {
		return false;
	}
	var theKeys = OwnPropertyKeys(O);
	return theKeys.length === 0 || every(theKeys, function (k) {
		var currentDesc = $gOPD(O, k);
		if (typeof currentDesc !== 'undefined') {
			if (currentDesc.configurable) {
				return false;
			}
			if (level === 'frozen' && IsDataDescriptor(ToPropertyDescriptor(currentDesc)) && currentDesc.writable) {
				return false;
			}
		}
		return true;
	});
};
'use strict';

var $BooleanValueOf = require('call-bound')('Boolean.prototype.valueOf');

// https://262.ecma-international.org/6.0/#sec-properties-of-the-boolean-prototype-object

module.exports = function thisBooleanValue(value) {
	if (typeof value === 'boolean') {
		return value;
	}

	return $BooleanValueOf(value);
};
'use strict';

var callBound = require('call-bound');

var $NumberValueOf = callBound('Number.prototype.valueOf');

// https://262.ecma-international.org/6.0/#sec-properties-of-the-number-prototype-object

module.exports = function thisNumberValue(value) {
	if (typeof value === 'number') {
		return value;
	}

	return $NumberValueOf(value);
};

'use strict';

var $StringValueOf = require('call-bound')('String.prototype.valueOf');

// https://262.ecma-international.org/6.0/#sec-properties-of-the-string-prototype-object

module.exports = function thisStringValue(value) {
	if (typeof value === 'string') {
		return value;
	}

	return $StringValueOf(value);
};
'use strict';

var $SyntaxError = require('es-errors/syntax');
var callBound = require('call-bound');

var $SymbolValueOf = callBound('Symbol.prototype.valueOf', true);

// https://262.ecma-international.org/9.0/#sec-thissymbolvalue

module.exports = function thisSymbolValue(value) {
	if (typeof value === 'symbol') {
		return value;
	}

	if (!$SymbolValueOf) {
		throw new $SyntaxError('Symbols are not supported; thisSymbolValue requires that `value` be a Symbol or a Symbol object');
	}

	return $SymbolValueOf(value);
};
'use strict';

var timeValue = require('../helpers/timeValue');

// https://262.ecma-international.org/6.0/#sec-properties-of-the-date-prototype-object

module.exports = function thisTimeValue(value) {
	return timeValue(value);
};
'use strict';

var CompletionRecord = require('./CompletionRecord');

// https://262.ecma-international.org/9.0/#sec-throwcompletion

module.exports = function ThrowCompletion(argument) {
	return new CompletionRecord('throw', argument);
};
'use strict';

var GetIntrinsic = require('get-intrinsic');

var $Date = GetIntrinsic('%Date%');

var $isFinite = require('math-intrinsics/isFinite');
var abs = require('math-intrinsics/abs');

var ToNumber = require('./ToNumber');

// https://262.ecma-international.org/5.1/#sec-15.9.1.14

module.exports = function TimeClip(time) {
	if (!$isFinite(time) || abs(time) > 8.64e15) {
		return NaN;
	}
	return +new $Date(ToNumber(time));
};

'use strict';

var msPerDay = require('../helpers/timeConstants').msPerDay;

var DayFromYear = require('./DayFromYear');

// https://262.ecma-international.org/5.1/#sec-15.9.1.3

module.exports = function TimeFromYear(y) {
	return msPerDay * DayFromYear(y);
};
'use strict';

var $TypeError = require('es-errors/type');

var $isNaN = require('math-intrinsics/isNaN');
var padTimeComponent = require('../helpers/padTimeComponent');

var HourFromTime = require('./HourFromTime');
var MinFromTime = require('./MinFromTime');
var SecFromTime = require('./SecFromTime');

// https://262.ecma-international.org/9.0/#sec-timestring

module.exports = function TimeString(tv) {
	if (typeof tv !== 'number' || $isNaN(tv)) {
		throw new $TypeError('Assertion failed: `tv` must be a non-NaN Number');
	}
	var hour = HourFromTime(tv);
	var minute = MinFromTime(tv);
	var second = SecFromTime(tv);
	return padTimeComponent(hour) + ':' + padTimeComponent(minute) + ':' + padTimeComponent(second) + '\x20GMT';
};
'use strict';

var modulo = require('./modulo');

var msPerDay = require('../helpers/timeConstants').msPerDay;

// https://262.ecma-international.org/5.1/#sec-15.9.1.2

module.exports = function TimeWithinDay(t) {
	return modulo(t, msPerDay);
};

'use strict';

var GetIntrinsic = require('get-intrinsic');

var $Date = GetIntrinsic('%Date%');
var $TypeError = require('es-errors/type');

var isNaN = require('math-intrinsics/isNaN');

var callBound = require('call-bound');

var $indexOf = callBound('String.prototype.indexOf');
var $slice = callBound('String.prototype.slice');
var $toTimeString = callBound('Date.prototype.toTimeString');

// https://262.ecma-international.org/9.0/#sec-timezoneestring

module.exports = function TimeZoneString(tv) {
	if (typeof tv !== 'number' || isNaN(tv)) {
		throw new $TypeError('Assertion failed: `tv` must be a non-NaN Number'); // steps 1 - 2
	}

	// 3. Let offset be LocalTZA(tv, true).
	// 4. If offset ≥ 0, let offsetSign be "+"; otherwise, let offsetSign be "-".
	// 5. Let offsetMin be the String representation of MinFromTime(abs(offset)), formatted as a two-digit decimal number, padded to the left with a zero if necessary.
	// 6. Let offsetHour be the String representation of HourFromTime(abs(offset)), formatted as a two-digit decimal number, padded to the left with a zero if necessary.
	// 7. Let tzName be an implementation-defined string that is either the empty string or the string-concatenation of the code unit 0x0020 (SPACE), the code unit 0x0028 (LEFT PARENTHESIS), an implementation-dependent timezone name, and the code unit 0x0029 (RIGHT PARENTHESIS).
	// 8. Return the string-concatenation of offsetSign, offsetHour, offsetMin, and tzName.

	// hack until LocalTZA, and "implementation-defined string" are available
	var ts = $toTimeString(new $Date(tv));
	return $slice(ts, $indexOf(ts, '(') + 1, $indexOf(ts, ')'));
};
'use strict';

// http://262.ecma-international.org/5.1/#sec-9.2

module.exports = function ToBoolean(value) { return !!value; };
'use strict';

var GetIntrinsic = require('get-intrinsic');

var $TypeError = require('es-errors/type');
var $Date = GetIntrinsic('%Date%');
var $String = GetIntrinsic('%String%');

var $isNaN = require('math-intrinsics/isNaN');

// https://262.ecma-international.org/6.0/#sec-todatestring

module.exports = function ToDateString(tv) {
	if (typeof tv !== 'number') {
		throw new $TypeError('Assertion failed: `tv` must be a Number');
	}
	if ($isNaN(tv)) {
		return 'Invalid Date';
	}
	return $String(new $Date(tv));
};
'use strict';

var $RangeError = require('es-errors/range');

var ToInteger = require('./ToInteger');
var ToLength = require('./ToLength');
var SameValueZero = require('./SameValueZero');

// https://262.ecma-international.org/8.0/#sec-toindex

module.exports = function ToIndex(value) {
	if (typeof value === 'undefined') {
		return 0;
	}
	var integerIndex = ToInteger(value);
	if (integerIndex < 0) {
		throw new $RangeError('index must be >= 0');
	}
	var index = ToLength(integerIndex);
	if (!SameValueZero(integerIndex, index)) {
		throw new $RangeError('index must be >= 0 and < 2 ** 53 - 1');
	}
	return index;
};
'use strict';

var ToUint16 = require('./ToUint16');

// https://262.ecma-international.org/6.0/#sec-toint16

module.exports = function ToInt16(argument) {
	var int16bit = ToUint16(argument);
	return int16bit >= 0x8000 ? int16bit - 0x10000 : int16bit;
};
'use strict';

var ToNumber = require('./ToNumber');

// http://262.ecma-international.org/5.1/#sec-9.5

module.exports = function ToInt32(x) {
	return ToNumber(x) >> 0;
};
'use strict';

var ToUint8 = require('./ToUint8');

// https://262.ecma-international.org/6.0/#sec-toint8

module.exports = function ToInt8(argument) {
	var int8bit = ToUint8(argument);
	return int8bit >= 0x80 ? int8bit - 0x100 : int8bit;
};
'use strict';

var ES5ToInteger = require('../5/ToInteger');

var ToNumber = require('./ToNumber');

// https://262.ecma-international.org/6.0/#sec-tointeger

module.exports = function ToInteger(value) {
	var number = ToNumber(value);
	return ES5ToInteger(number);
};
'use strict';

var MAX_SAFE_INTEGER = require('math-intrinsics/constants/maxSafeInteger');

var ToInteger = require('./ToInteger');

// https://262.ecma-international.org/6.0/#sec-tolength

module.exports = function ToLength(argument) {
	var len = ToInteger(argument);
	if (len <= 0) { return 0; } // includes converting -0 to +0
	if (len > MAX_SAFE_INTEGER) { return MAX_SAFE_INTEGER; }
	return len;
};
'use strict';

var GetIntrinsic = require('get-intrinsic');

var $TypeError = require('es-errors/type');
var $Number = GetIntrinsic('%Number%');
var $RegExp = GetIntrinsic('%RegExp%');
var $parseInteger = GetIntrinsic('%parseInt%');

var callBound = require('call-bound');
var regexTester = require('safe-regex-test');
var isPrimitive = require('../helpers/isPrimitive');

var $strSlice = callBound('String.prototype.slice');
var isBinary = regexTester(/^0b[01]+$/i);
var isOctal = regexTester(/^0o[0-7]+$/i);
var isInvalidHexLiteral = regexTester(/^[-+]0x[0-9a-f]+$/i);
var nonWS = ['\u0085', '\u200b', '\ufffe'].join('');
var nonWSregex = new $RegExp('[' + nonWS + ']', 'g');
var hasNonWS = regexTester(nonWSregex);

var $trim = require('string.prototype.trim');

var ToPrimitive = require('./ToPrimitive');

// https://262.ecma-international.org/6.0/#sec-tonumber

module.exports = function ToNumber(argument) {
	var value = isPrimitive(argument) ? argument : ToPrimitive(argument, $Number);
	if (typeof value === 'symbol') {
		throw new $TypeError('Cannot convert a Symbol value to a number');
	}
	if (typeof value === 'string') {
		if (isBinary(value)) {
			return ToNumber($parseInteger($strSlice(value, 2), 2));
		} else if (isOctal(value)) {
			return ToNumber($parseInteger($strSlice(value, 2), 8));
		} else if (hasNonWS(value) || isInvalidHexLiteral(value)) {
			return NaN;
		}
		var trimmed = $trim(value);
		if (trimmed !== value) {
			return ToNumber(trimmed);
		}

	}
	return +value;
};
'use strict';

// https://262.ecma-international.org/6.0/#sec-toobject

module.exports = require('es-object-atoms/ToObject');
'use strict';

var toPrimitive = require('es-to-primitive/es2015');

// https://262.ecma-international.org/6.0/#sec-toprimitive

module.exports = function ToPrimitive(input) {
	if (arguments.length > 1) {
		return toPrimitive(input, arguments[1]);
	}
	return toPrimitive(input);
};
'use strict';

var hasOwn = require('hasown');

var $TypeError = require('es-errors/type');
var isObject = require('es-object-atoms/isObject');

var IsCallable = require('./IsCallable');
var ToBoolean = require('./ToBoolean');

// https://262.ecma-international.org/5.1/#sec-8.10.5

module.exports = function ToPropertyDescriptor(Obj) {
	if (!isObject(Obj)) {
		throw new $TypeError('ToPropertyDescriptor requires an object');
	}

	var desc = {};
	if (hasOwn(Obj, 'enumerable')) {
		desc['[[Enumerable]]'] = ToBoolean(Obj.enumerable);
	}
	if (hasOwn(Obj, 'configurable')) {
		desc['[[Configurable]]'] = ToBoolean(Obj.configurable);
	}
	if (hasOwn(Obj, 'value')) {
		desc['[[Value]]'] = Obj.value;
	}
	if (hasOwn(Obj, 'writable')) {
		desc['[[Writable]]'] = ToBoolean(Obj.writable);
	}
	if (hasOwn(Obj, 'get')) {
		var getter = Obj.get;
		if (typeof getter !== 'undefined' && !IsCallable(getter)) {
			throw new $TypeError('getter must be a function');
		}
		desc['[[Get]]'] = getter;
	}
	if (hasOwn(Obj, 'set')) {
		var setter = Obj.set;
		if (typeof setter !== 'undefined' && !IsCallable(setter)) {
			throw new $TypeError('setter must be a function');
		}
		desc['[[Set]]'] = setter;
	}

	if ((hasOwn(desc, '[[Get]]') || hasOwn(desc, '[[Set]]')) && (hasOwn(desc, '[[Value]]') || hasOwn(desc, '[[Writable]]'))) {
		throw new $TypeError('Invalid property descriptor. Cannot both specify accessors and a value or writable attribute');
	}
	return desc;
};
'use strict';

var GetIntrinsic = require('get-intrinsic');

var $String = GetIntrinsic('%String%');

var ToPrimitive = require('./ToPrimitive');
var ToString = require('./ToString');

// https://262.ecma-international.org/6.0/#sec-topropertykey

module.exports = function ToPropertyKey(argument) {
	var key = ToPrimitive(argument, $String);
	return typeof key === 'symbol' ? key : ToString(key);
};
'use strict';

var GetIntrinsic = require('get-intrinsic');

var $String = GetIntrinsic('%String%');
var $TypeError = require('es-errors/type');

// https://262.ecma-international.org/6.0/#sec-tostring

module.exports = function ToString(argument) {
	if (typeof argument === 'symbol') {
		throw new $TypeError('Cannot convert a Symbol value to a string');
	}
	return $String(argument);
};
'use strict';

var modulo = require('./modulo');
var ToNumber = require('./ToNumber');

var abs = require('math-intrinsics/abs');
var floor = require('math-intrinsics/floor');
var $isNaN = require('math-intrinsics/isNaN');
var $isFinite = require('math-intrinsics/isFinite');
var $sign = require('math-intrinsics/sign');

// http://262.ecma-international.org/5.1/#sec-9.7

module.exports = function ToUint16(value) {
	var number = ToNumber(value);
	if ($isNaN(number) || number === 0 || !$isFinite(number)) { return 0; }
	var posInt = $sign(number) * floor(abs(number));
	return modulo(posInt, 0x10000);
};
'use strict';

var ToNumber = require('./ToNumber');

// http://262.ecma-international.org/5.1/#sec-9.6

module.exports = function ToUint32(x) {
	return ToNumber(x) >>> 0;
};
'use strict';

var ToNumber = require('./ToNumber');
var floor = require('./floor');

var $isNaN = require('math-intrinsics/isNaN');

// https://262.ecma-international.org/6.0/#sec-touint8clamp

module.exports = function ToUint8Clamp(argument) {
	var number = ToNumber(argument);
	if ($isNaN(number) || number <= 0) { return 0; }
	if (number >= 0xFF) { return 0xFF; }
	var f = floor(number);
	if (f + 0.5 < number) { return f + 1; }
	if (number < f + 0.5) { return f; }
	if (f % 2 !== 0) { return f + 1; }
	return f;
};
'use strict';

var ToNumber = require('./ToNumber');

var $isNaN = require('math-intrinsics/isNaN');
var $isFinite = require('math-intrinsics/isFinite');
var $sign = require('math-intrinsics/sign');
var abs = require('math-intrinsics/abs');
var floor = require('math-intrinsics/floor');
var modulo = require('math-intrinsics/mod');

// https://262.ecma-international.org/6.0/#sec-touint8

module.exports = function ToUint8(argument) {
	var number = ToNumber(argument);
	if ($isNaN(number) || number === 0 || !$isFinite(number)) { return 0; }
	var posInt = $sign(number) * floor(abs(number));
	return modulo(posInt, 0x100);
};
'use strict';

var $SyntaxError = require('es-errors/syntax');
var $TypeError = require('es-errors/type');

var IsArray = require('./IsArray');
var IsConstructor = require('./IsConstructor');
var ValidateTypedArray = require('./ValidateTypedArray');

var availableTypedArrays = require('available-typed-arrays')();
var typedArrayLength = require('typed-array-length');

// https://262.ecma-international.org/7.0/#typedarray-create

module.exports = function TypedArrayCreate(constructor, argumentList) {
	if (!IsConstructor(constructor)) {
		throw new $TypeError('Assertion failed: `constructor` must be a constructor');
	}
	if (!IsArray(argumentList)) {
		throw new $TypeError('Assertion failed: `argumentList` must be a List');
	}
	if (availableTypedArrays.length === 0) {
		throw new $SyntaxError('Assertion failed: Typed Arrays are not supported in this environment');
	}

	// var newTypedArray = Construct(constructor, argumentList); // step 1
	var newTypedArray;
	if (argumentList.length === 0) {
		newTypedArray = new constructor();
	} else if (argumentList.length === 1) {
		newTypedArray = new constructor(argumentList[0]);
	} else if (argumentList.length === 2) {
		newTypedArray = new constructor(argumentList[0], argumentList[1]);
	} else {
		newTypedArray = new constructor(argumentList[0], argumentList[1], argumentList[2]);
	}

	ValidateTypedArray(newTypedArray); // step 2

	if (argumentList.length === 1 && typeof argumentList[0] === 'number') { // step 3
		if (typedArrayLength(newTypedArray) < argumentList[0]) {
			throw new $TypeError('Assertion failed: `argumentList[0]` must be <= `newTypedArray.length`'); // step 3.a
		}
	}

	return newTypedArray; // step 4
};
'use strict';

var $SyntaxError = require('es-errors/syntax');
var $TypeError = require('es-errors/type');

var whichTypedArray = require('which-typed-array');
var availableTypedArrays = require('available-typed-arrays')();

var IsArray = require('./IsArray');
var SpeciesConstructor = require('./SpeciesConstructor');
var TypedArrayCreate = require('./TypedArrayCreate');

var getConstructor = require('../helpers/typedArrayConstructors');

// https://262.ecma-international.org/7.0/#typedarray-species-create

module.exports = function TypedArraySpeciesCreate(exemplar, argumentList) {
	if (availableTypedArrays.length === 0) {
		throw new $SyntaxError('Assertion failed: Typed Arrays are not supported in this environment');
	}

	var kind = whichTypedArray(exemplar);
	if (!kind) {
		throw new $TypeError('Assertion failed: exemplar must be a TypedArray'); // step 1
	}
	if (!IsArray(argumentList)) {
		throw new $TypeError('Assertion failed: `argumentList` must be a List'); // step 1
	}

	var defaultConstructor = getConstructor(kind); // step 2
	if (typeof defaultConstructor !== 'function') {
		throw new $SyntaxError('Assertion failed: `constructor` of `exemplar` (' + kind + ') must exist. Please report this!');
	}
	var constructor = SpeciesConstructor(exemplar, defaultConstructor); // step 3

	return TypedArrayCreate(constructor, argumentList); // step 4
};
'use strict';

var ES5Type = require('../5/Type');

// https://262.ecma-international.org/6.0/#sec-ecmascript-data-types-and-values

module.exports = function Type(x) {
	if (typeof x === 'symbol') {
		return 'Symbol';
	}
	return ES5Type(x);
};
'use strict';

var $TypeError = require('es-errors/type');

var callBound = require('call-bound');

var $charCodeAt = callBound('String.prototype.charCodeAt');
var $numberToString = callBound('Number.prototype.toString');
var $toLowerCase = callBound('String.prototype.toLowerCase');
var $strSlice = callBound('String.prototype.slice');

// https://262.ecma-international.org/9.0/#sec-unicodeescape

module.exports = function UnicodeEscape(C) {
	if (typeof C !== 'string' || C.length !== 1) {
		throw new $TypeError('Assertion failed: `C` must be a single code unit');
	}
	var n = $charCodeAt(C, 0);
	if (n > 0xFFFF) {
		throw new $TypeError('`Assertion failed: numeric value of `C` must be <= 0xFFFF');
	}

	return '\\u' + $strSlice('0000' + $toLowerCase($numberToString(n, 16)), -4);
};
'use strict';

var GetIntrinsic = require('get-intrinsic');

var $TypeError = require('es-errors/type');
var $fromCharCode = GetIntrinsic('%String.fromCharCode%');

// https://262.ecma-international.org/7.0/#sec-utf16decode

var isLeadingSurrogate = require('../helpers/isLeadingSurrogate');
var isTrailingSurrogate = require('../helpers/isTrailingSurrogate');

// https://262.ecma-international.org/11.0/#sec-utf16decodesurrogatepair

module.exports = function UTF16Decode(lead, trail) {
	if (!isLeadingSurrogate(lead) || !isTrailingSurrogate(trail)) {
		throw new $TypeError('Assertion failed: `lead` must be a leading surrogate char code, and `trail` must be a trailing surrogate char code');
	}
	// var cp = (lead - 0xD800) * 0x400 + (trail - 0xDC00) + 0x10000;
	return $fromCharCode(lead) + $fromCharCode(trail);
};
'use strict';

var GetIntrinsic = require('get-intrinsic');

var $TypeError = require('es-errors/type');
var $fromCharCode = GetIntrinsic('%String.fromCharCode%');

var floor = require('./floor');
var modulo = require('./modulo');

var isCodePoint = require('../helpers/isCodePoint');

// https://262.ecma-international.org/7.0/#sec-utf16encoding

module.exports = function UTF16Encoding(cp) {
	if (!isCodePoint(cp)) {
		throw new $TypeError('Assertion failed: `cp` must be >= 0 and <= 0x10FFFF');
	}
	if (cp <= 65535) {
		return $fromCharCode(cp);
	}
	var cu1 = $fromCharCode(floor((cp - 65536) / 1024) + 0xD800);
	var cu2 = $fromCharCode(modulo(cp - 65536, 1024) + 0xDC00);
	return cu1 + cu2;
};
'use strict';

var $TypeError = require('es-errors/type');
var isObject = require('es-object-atoms/isObject');

var DefineOwnProperty = require('../helpers/DefineOwnProperty');
var isPropertyDescriptor = require('../helpers/records/property-descriptor');
var isSamePropertyDescriptor = require('../helpers/isSamePropertyDescriptor');

var FromPropertyDescriptor = require('./FromPropertyDescriptor');
var IsAccessorDescriptor = require('./IsAccessorDescriptor');
var IsDataDescriptor = require('./IsDataDescriptor');
var IsGenericDescriptor = require('./IsGenericDescriptor');
var isPropertyKey = require('../helpers/isPropertyKey');
var SameValue = require('./SameValue');

// https://262.ecma-international.org/6.0/#sec-validateandapplypropertydescriptor
// https://262.ecma-international.org/8.0/#sec-validateandapplypropertydescriptor

// eslint-disable-next-line max-lines-per-function, max-statements
module.exports = function ValidateAndApplyPropertyDescriptor(O, P, extensible, Desc, current) {
	// this uses the ES2017+ logic, since it fixes a number of bugs in the ES2015 logic.
	if (typeof O !== 'undefined' && !isObject(O)) {
		throw new $TypeError('Assertion failed: O must be undefined or an Object');
	}
	if (typeof extensible !== 'boolean') {
		throw new $TypeError('Assertion failed: extensible must be a Boolean');
	}
	if (!isPropertyDescriptor(Desc)) {
		throw new $TypeError('Assertion failed: Desc must be a Property Descriptor');
	}
	if (typeof current !== 'undefined' && !isPropertyDescriptor(current)) {
		throw new $TypeError('Assertion failed: current must be a Property Descriptor, or undefined');
	}
	if (typeof O !== 'undefined' && !isPropertyKey(P)) {
		throw new $TypeError('Assertion failed: if O is not undefined, P must be a Property Key');
	}
	if (typeof current === 'undefined') {
		if (!extensible) {
			return false;
		}
		if (IsGenericDescriptor(Desc) || IsDataDescriptor(Desc)) {
			if (typeof O !== 'undefined') {
				DefineOwnProperty(
					IsDataDescriptor,
					SameValue,
					FromPropertyDescriptor,
					O,
					P,
					{
						'[[Configurable]]': Desc['[[Configurable]]'],
						'[[Enumerable]]': Desc['[[Enumerable]]'],
						'[[Value]]': Desc['[[Value]]'],
						'[[Writable]]': Desc['[[Writable]]']
					}
				);
			}
		} else {
			if (!IsAccessorDescriptor(Desc)) {
				throw new $TypeError('Assertion failed: Desc is not an accessor descriptor');
			}
			if (typeof O !== 'undefined') {
				return DefineOwnProperty(
					IsDataDescriptor,
					SameValue,
					FromPropertyDescriptor,
					O,
					P,
					Desc
				);
			}
		}
		return true;
	}
	if (IsGenericDescriptor(Desc) && !('[[Configurable]]' in Desc) && !('[[Enumerable]]' in Desc)) {
		return true;
	}
	if (isSamePropertyDescriptor({ SameValue: SameValue }, Desc, current)) {
		return true; // removed by ES2017, but should still be correct
	}
	// "if every field in Desc is absent, return true" can't really match the assertion that it's a Property Descriptor
	if (!current['[[Configurable]]']) {
		if (Desc['[[Configurable]]']) {
			return false;
		}
		if ('[[Enumerable]]' in Desc && !Desc['[[Enumerable]]'] === !!current['[[Enumerable]]']) {
			return false;
		}
	}
	if (IsGenericDescriptor(Desc)) {
		// no further validation is required.
	} else if (IsDataDescriptor(current) !== IsDataDescriptor(Desc)) {
		if (!current['[[Configurable]]']) {
			return false;
		}
		if (IsDataDescriptor(current)) {
			if (typeof O !== 'undefined') {
				DefineOwnProperty(
					IsDataDescriptor,
					SameValue,
					FromPropertyDescriptor,
					O,
					P,
					{
						'[[Configurable]]': current['[[Configurable]]'],
						'[[Enumerable]]': current['[[Enumerable]]'],
						'[[Get]]': undefined
					}
				);
			}
		} else if (typeof O !== 'undefined') {
			DefineOwnProperty(
				IsDataDescriptor,
				SameValue,
				FromPropertyDescriptor,
				O,
				P,
				{
					'[[Configurable]]': current['[[Configurable]]'],
					'[[Enumerable]]': current['[[Enumerable]]'],
					'[[Value]]': undefined
				}
			);
		}
	} else if (IsDataDescriptor(current) && IsDataDescriptor(Desc)) {
		if (!current['[[Configurable]]'] && !current['[[Writable]]']) {
			if ('[[Writable]]' in Desc && Desc['[[Writable]]']) {
				return false;
			}
			if ('[[Value]]' in Desc && !SameValue(Desc['[[Value]]'], current['[[Value]]'])) {
				return false;
			}
			return true;
		}
	} else if (IsAccessorDescriptor(current) && IsAccessorDescriptor(Desc)) {
		if (!current['[[Configurable]]']) {
			if ('[[Set]]' in Desc && !SameValue(Desc['[[Set]]'], current['[[Set]]'])) {
				return false;
			}
			if ('[[Get]]' in Desc && !SameValue(Desc['[[Get]]'], current['[[Get]]'])) {
				return false;
			}
			return true;
		}
	} else {
		throw new $TypeError('Assertion failed: current and Desc are not both data, both accessors, or one accessor and one data.');
	}
	if (typeof O !== 'undefined') {
		return DefineOwnProperty(
			IsDataDescriptor,
			SameValue,
			FromPropertyDescriptor,
			O,
			P,
			Desc
		);
	}
	return true;
};
'use strict';

var $RangeError = require('es-errors/range');
var $TypeError = require('es-errors/type');

var ToIndex = require('./ToIndex');

var isTypedArray = require('is-typed-array');
var typedArrayLength = require('typed-array-length');

// https://262.ecma-international.org/8.0/#sec-validateatomicaccess

module.exports = function ValidateAtomicAccess(typedArray, requestIndex) {
	if (!isTypedArray(typedArray)) {
		throw new $TypeError('Assertion failed: `typedArray` must be a TypedArray'); // step 1
	}

	var accessIndex = ToIndex(requestIndex); // step 2

	var length = typedArrayLength(typedArray); // step 3

	/*
	// this assertion can never be reached
	if (!(accessIndex >= 0)) {
		throw new $TypeError('Assertion failed: accessIndex >= 0'); // step 4
	}
	*/

	if (accessIndex >= length) {
		throw new $RangeError('index out of range'); // step 5
	}

	return accessIndex; // step 6
};
'use strict';

var $TypeError = require('es-errors/type');
var isObject = require('es-object-atoms/isObject');

var IsDetachedBuffer = require('./IsDetachedBuffer');

var isTypedArray = require('is-typed-array');
var typedArrayBuffer = require('typed-array-buffer');

// https://262.ecma-international.org/6.0/#sec-validatetypedarray

module.exports = function ValidateTypedArray(O) {
	if (!isObject(O)) {
		throw new $TypeError('Assertion failed: `O` must be an Object'); // step 1
	}
	if (!isTypedArray(O)) {
		throw new $TypeError('Assertion failed: `O` must be a Typed Array'); // steps 2 - 3
	}

	var buffer = typedArrayBuffer(O); // step 4

	if (IsDetachedBuffer(buffer)) {
		throw new $TypeError('`O` must be backed by a non-detached buffer'); // step 5
	}

	return buffer; // step 6
};
'use strict';

var Day = require('./Day');
var modulo = require('./modulo');

// https://262.ecma-international.org/5.1/#sec-15.9.1.6

module.exports = function WeekDay(t) {
	return modulo(Day(t) + 4, 7);
};
'use strict';

var $TypeError = require('es-errors/type');

var callBound = require('call-bound');
var $indexOf = callBound('String.prototype.indexOf');

var Canonicalize = require('./Canonicalize');

var caseFolding = require('../helpers/caseFolding.json');
var forEach = require('../helpers/forEach');
var OwnPropertyKeys = require('own-keys');

var A = 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789_'; // step 1

// https://262.ecma-international.org/8.0/#sec-runtime-semantics-wordcharacters-abstract-operation

module.exports = function WordCharacters(IgnoreCase, Unicode) {
	if (typeof IgnoreCase !== 'boolean' || typeof Unicode !== 'boolean') {
		throw new $TypeError('Assertion failed: `IgnoreCase` and `Unicode` must be booleans');
	}

	var U = '';
	forEach(OwnPropertyKeys(caseFolding.C), function (c) {
		if (
			$indexOf(A, c) === -1 // c not in A
			&& $indexOf(A, Canonicalize(c, IgnoreCase, Unicode)) > -1 // canonicalized c IS in A
		) {
			U += caseFolding.C[c]; // step 3
		}
	});
	forEach(OwnPropertyKeys(caseFolding.S), function (c) {
		if (
			$indexOf(A, c) === -1 // c not in A
			&& $indexOf(A, Canonicalize(c, IgnoreCase, Unicode)) > -1 // canonicalized c IS in A
		) {
			U += caseFolding.S[c]; // step 3
		}
	});

	if ((!Unicode || !IgnoreCase) && U.length > 0) {
		throw new $TypeError('Assertion failed: `U` must be empty when `IgnoreCase` and `Unicode` are not both true'); // step 4
	}

	return A + U; // step 5, 6
};
'use strict';

var GetIntrinsic = require('get-intrinsic');

var $Date = GetIntrinsic('%Date%');

var callBound = require('call-bound');

var $getUTCFullYear = callBound('Date.prototype.getUTCFullYear');

// https://262.ecma-international.org/5.1/#sec-15.9.1.3

module.exports = function YearFromTime(t) {
	// largest y such that this.TimeFromYear(y) <= t
	return $getUTCFullYear(new $Date(t));
};
'use strict';

var $abs = require('math-intrinsics/abs');

// https://262.ecma-international.org/5.1/#sec-5.2

module.exports = function abs(x) {
	return $abs(x);
};
'use strict';

var ToNumber = require('./ToNumber');
var ToPrimitive = require('./ToPrimitive');

var isSameType = require('../helpers/isSameType');

var isObject = require('es-object-atoms/isObject');

// https://262.ecma-international.org/6.0/#sec-abstract-equality-comparison

module.exports = function AbstractEqualityComparison(x, y) {
	if (isSameType(x, y)) {
		return x === y; // ES6+ specified this shortcut anyways.
	}
	if (x == null && y == null) {
		return true;
	}
	if (typeof x === 'number' && typeof y === 'string') {
		return AbstractEqualityComparison(x, ToNumber(y));
	}
	if (typeof x === 'string' && typeof y === 'number') {
		return AbstractEqualityComparison(ToNumber(x), y);
	}
	if (typeof x === 'boolean') {
		return AbstractEqualityComparison(ToNumber(x), y);
	}
	if (typeof y === 'boolean') {
		return AbstractEqualityComparison(x, ToNumber(y));
	}
	if ((typeof x === 'string' || typeof x === 'number' || typeof x === 'symbol') && isObject(y)) {
		return AbstractEqualityComparison(x, ToPrimitive(y));
	}
	if (isObject(x) && (typeof y === 'string' || typeof y === 'number' || typeof y === 'symbol')) {
		return AbstractEqualityComparison(ToPrimitive(x), y);
	}
	return false;
};
'use strict';

var GetIntrinsic = require('get-intrinsic');

var $Number = GetIntrinsic('%Number%');
var $TypeError = require('es-errors/type');
var $isNaN = require('math-intrinsics/isNaN');
var $isFinite = require('math-intrinsics/isFinite');

var IsStringPrefix = require('./IsStringPrefix');
var ToNumber = require('./ToNumber');
var ToPrimitive = require('./ToPrimitive');

// https://262.ecma-international.org/9.0/#sec-abstract-relational-comparison

module.exports = function AbstractRelationalComparison(x, y, LeftFirst) {
	if (typeof LeftFirst !== 'boolean') {
		throw new $TypeError('Assertion failed: LeftFirst argument must be a Boolean');
	}
	var px;
	var py;
	if (LeftFirst) {
		px = ToPrimitive(x, $Number);
		py = ToPrimitive(y, $Number);
	} else {
		py = ToPrimitive(y, $Number);
		px = ToPrimitive(x, $Number);
	}
	if (typeof px === 'string' && typeof py === 'string') {
		if (IsStringPrefix(py, px)) {
			return false;
		}
		if (IsStringPrefix(px, py)) {
			return true;
		}
		return px < py; // both strings, neither a prefix of the other. shortcut for steps 3 c-f
	}
	var nx = ToNumber(px);
	var ny = ToNumber(py);
	if ($isNaN(nx) || $isNaN(ny)) {
		return undefined;
	}
	if ($isFinite(nx) && $isFinite(ny) && nx === ny) {
		return false;
	}
	if (nx === Infinity) {
		return false;
	}
	if (ny === Infinity) {
		return true;
	}
	if (ny === -Infinity) {
		return false;
	}
	if (nx === -Infinity) {
		return true;
	}
	return nx < ny; // by now, these are both nonzero, finite, and not equal
};
'use strict';

var $TypeError = require('es-errors/type');
var isObject = require('es-object-atoms/isObject');
var inspect = require('object-inspect');

var Call = require('./Call');
var Get = require('./Get');
var GetIterator = require('./GetIterator');
var IsCallable = require('./IsCallable');
var IteratorClose = require('./IteratorClose');
var IteratorStep = require('./IteratorStep');
var IteratorValue = require('./IteratorValue');
var ThrowCompletion = require('./ThrowCompletion');

// https://262.ecma-international.org/10.0/#sec-add-entries-from-iterable

module.exports = function AddEntriesFromIterable(target, iterable, adder) {
	if (!IsCallable(adder)) {
		throw new $TypeError('Assertion failed: `adder` is not callable');
	}
	if (iterable == null) {
		throw new $TypeError('Assertion failed: `iterable` is present, and not nullish');
	}
	var iteratorRecord = GetIterator(iterable);
	while (true) { // eslint-disable-line no-constant-condition
		var next = IteratorStep(iteratorRecord);
		if (!next) {
			return target;
		}
		var nextItem = IteratorValue(next);
		if (!isObject(nextItem)) {
			var error = ThrowCompletion(new $TypeError('iterator next must return an Object, got ' + inspect(nextItem)));
			return IteratorClose(iteratorRecord, error);
		}
		try {
			var k = Get(nextItem, '0');
			var v = Get(nextItem, '1');
			Call(adder, target, [k, v]);
		} catch (e) {
			return IteratorClose(iteratorRecord, ThrowCompletion(e));
		}
	}
};
'use strict';

var isInteger = require('math-intrinsics/isInteger');
var MAX_SAFE_INTEGER = require('math-intrinsics/constants/maxSafeInteger');

var isLeadingSurrogate = require('../helpers/isLeadingSurrogate');
var isTrailingSurrogate = require('../helpers/isTrailingSurrogate');

var $TypeError = require('es-errors/type');

var $charCodeAt = require('call-bound')('String.prototype.charCodeAt');

// https://262.ecma-international.org/6.0/#sec-advancestringindex

module.exports = function AdvanceStringIndex(S, index, unicode) {
	if (typeof S !== 'string') {
		throw new $TypeError('Assertion failed: `S` must be a String');
	}
	if (!isInteger(index) || index < 0 || index > MAX_SAFE_INTEGER) {
		throw new $TypeError('Assertion failed: `length` must be an integer >= 0 and <= 2**53');
	}
	if (typeof unicode !== 'boolean') {
		throw new $TypeError('Assertion failed: `unicode` must be a Boolean');
	}
	if (!unicode) {
		return index + 1;
	}
	var length = S.length;
	if ((index + 1) >= length) {
		return index + 1;
	}

	var first = $charCodeAt(S, index);
	if (!isLeadingSurrogate(first)) {
		return index + 1;
	}

	var second = $charCodeAt(S, index + 1);
	if (!isTrailingSurrogate(second)) {
		return index + 1;
	}

	return index + 2;
};
'use strict';

var GetIntrinsic = require('get-intrinsic');

var $ArrayPrototype = GetIntrinsic('%Array.prototype%');
var $RangeError = require('es-errors/range');
var $SyntaxError = require('es-errors/syntax');
var $TypeError = require('es-errors/type');
var isInteger = require('math-intrinsics/isInteger');
var MAX_ARRAY_LENGTH = require('math-intrinsics/constants/maxArrayLength');
var $setProto = require('set-proto');

// https://262.ecma-international.org/6.0/#sec-arraycreate

module.exports = function ArrayCreate(length) {
	if (!isInteger(length) || length < 0) {
		throw new $TypeError('Assertion failed: `length` must be an integer Number >= 0');
	}
	if (length > MAX_ARRAY_LENGTH) {
		throw new $RangeError('length is greater than (2**32 - 1)');
	}
	var proto = arguments.length > 1 ? arguments[1] : $ArrayPrototype;
	var A = []; // steps 5 - 7, and 9
	if (proto !== $ArrayPrototype) { // step 8
		if (!$setProto) {
			throw new $SyntaxError('ArrayCreate: a `proto` argument that is not `Array.prototype` is not supported in an environment that does not support setting the [[Prototype]]');
		}
		$setProto(A, proto);
	}
	if (length !== 0) { // bypasses the need for step 2
		A.length = length;
	}
	/* step 10, the above as a shortcut for the below
	OrdinaryDefineOwnProperty(A, 'length', {
		'[[Configurable]]': false,
		'[[Enumerable]]': false,
		'[[Value]]': length,
		'[[Writable]]': true
	});
	*/
	return A;
};
'use strict';

var $RangeError = require('es-errors/range');
var $TypeError = require('es-errors/type');

var assign = require('object.assign');

var isPropertyDescriptor = require('../helpers/records/property-descriptor');

var IsArray = require('./IsArray');
var IsDataDescriptor = require('./IsDataDescriptor');
var OrdinaryDefineOwnProperty = require('./OrdinaryDefineOwnProperty');
var OrdinaryGetOwnProperty = require('./OrdinaryGetOwnProperty');
var ToNumber = require('./ToNumber');
var ToString = require('./ToString');
var ToUint32 = require('./ToUint32');

// https://262.ecma-international.org/6.0/#sec-arraysetlength

// eslint-disable-next-line max-statements, max-lines-per-function
module.exports = function ArraySetLength(A, Desc) {
	if (!IsArray(A)) {
		throw new $TypeError('Assertion failed: A must be an Array');
	}
	if (!isPropertyDescriptor(Desc)) {
		throw new $TypeError('Assertion failed: Desc must be a Property Descriptor');
	}
	if (!('[[Value]]' in Desc)) {
		return OrdinaryDefineOwnProperty(A, 'length', Desc);
	}
	var newLenDesc = assign({}, Desc);
	var newLen = ToUint32(Desc['[[Value]]']);
	var numberLen = ToNumber(Desc['[[Value]]']);
	if (newLen !== numberLen) {
		throw new $RangeError('Invalid array length');
	}
	newLenDesc['[[Value]]'] = newLen;
	var oldLenDesc = OrdinaryGetOwnProperty(A, 'length');
	if (!IsDataDescriptor(oldLenDesc)) {
		throw new $TypeError('Assertion failed: an array had a non-data descriptor on `length`');
	}
	var oldLen = oldLenDesc['[[Value]]'];
	if (newLen >= oldLen) {
		return OrdinaryDefineOwnProperty(A, 'length', newLenDesc);
	}
	if (!oldLenDesc['[[Writable]]']) {
		return false;
	}
	var newWritable;
	if (!('[[Writable]]' in newLenDesc) || newLenDesc['[[Writable]]']) {
		newWritable = true;
	} else {
		newWritable = false;
		newLenDesc['[[Writable]]'] = true;
	}
	var succeeded = OrdinaryDefineOwnProperty(A, 'length', newLenDesc);
	if (!succeeded) {
		return false;
	}
	while (newLen < oldLen) {
		oldLen -= 1;
		// eslint-disable-next-line no-param-reassign
		var deleteSucceeded = delete A[ToString(oldLen)];
		if (!deleteSucceeded) {
			newLenDesc['[[Value]]'] = oldLen + 1;
			if (!newWritable) {
				newLenDesc['[[Writable]]'] = false;
				OrdinaryDefineOwnProperty(A, 'length', newLenDesc);
				return false;
			}
		}
	}
	if (!newWritable) {
		return OrdinaryDefineOwnProperty(A, 'length', { '[[Writable]]': false });
	}
	return true;
};
'use strict';

var GetIntrinsic = require('get-intrinsic');

var $Array = GetIntrinsic('%Array%');
var $species = GetIntrinsic('%Symbol.species%', true);
var $TypeError = require('es-errors/type');
var isInteger = require('math-intrinsics/isInteger');
var isObject = require('es-object-atoms/isObject');

var Get = require('./Get');
var IsArray = require('./IsArray');
var IsConstructor = require('./IsConstructor');

// https://262.ecma-international.org/6.0/#sec-arrayspeciescreate

module.exports = function ArraySpeciesCreate(originalArray, length) {
	if (!isInteger(length) || length < 0) {
		throw new $TypeError('Assertion failed: length must be an integer >= 0');
	}
	var len = length === 0 ? 0 : length;
	var C;
	var isArray = IsArray(originalArray);
	if (isArray) {
		C = Get(originalArray, 'constructor');
		// TODO: figure out how to make a cross-realm normal Array, a same-realm Array
		// if (IsConstructor(C)) {
		// 	if C is another realm's Array, C = undefined
		// 	Object.getPrototypeOf(Object.getPrototypeOf(Object.getPrototypeOf(Array))) === null ?
		// }
		if ($species && isObject(C)) {
			C = Get(C, $species);
			if (C === null) {
				C = void 0;
			}
		}
	}
	if (typeof C === 'undefined') {
		return $Array(len);
	}
	if (!IsConstructor(C)) {
		throw new $TypeError('C must be a constructor');
	}
	return new C(len); // Construct(C, len);
};

'use strict';

var GetIntrinsic = require('get-intrinsic');

var $SyntaxError = require('es-errors/syntax');
var $TypeError = require('es-errors/type');
var isObject = require('es-object-atoms/isObject');
var $Promise = GetIntrinsic('%Promise%', true);

var callBound = require('call-bound');

var CreateIterResultObject = require('./CreateIterResultObject');
var IteratorComplete = require('./IteratorComplete');
var IteratorValue = require('./IteratorValue');
var PromiseResolve = require('./PromiseResolve');

var $then = callBound('Promise.prototype.then', true);

// https://262.ecma-international.org/10.0/#sec-asyncfromsynciteratorcontinuation

module.exports = function AsyncFromSyncIteratorContinuation(result) {
	if (!isObject(result)) {
		throw new $TypeError('Assertion failed: Type(O) is not Object');
	}

	if (arguments.length > 1) {
		throw new $SyntaxError('although AsyncFromSyncIteratorContinuation should take a second argument, it is not used in this implementation');
	}

	if (!$Promise) {
		throw new $SyntaxError('This environment does not support Promises.');
	}

	return new $Promise(function (resolve) {
		var done = IteratorComplete(result); // step 2
		var value = IteratorValue(result); // step 4
		var valueWrapper = PromiseResolve($Promise, value); // step 6

		// eslint-disable-next-line no-shadow
		var onFulfilled = function (value) { // steps 8-9
			return CreateIterResultObject(value, done); // step 8.a
		};
		resolve($then(valueWrapper, onFulfilled)); // step 11
	}); // step 12
};
'use strict';

var GetIntrinsic = require('get-intrinsic');

var $SyntaxError = require('es-errors/syntax');
var $TypeError = require('es-errors/type');
var isObject = require('es-object-atoms/isObject');
var $Promise = GetIntrinsic('%Promise%', true);

var Call = require('./Call');
var CompletionRecord = require('./CompletionRecord');
var GetMethod = require('./GetMethod');

var isIteratorRecord = require('../helpers/records/iterator-record-2023');

var callBound = require('call-bound');

var $then = callBound('Promise.prototype.then', true);

// https://262.ecma-international.org/9.0/#sec-asynciteratorclose

module.exports = function AsyncIteratorClose(iteratorRecord, completion) {
	if (!isIteratorRecord(iteratorRecord)) {
		throw new $TypeError('Assertion failed: `iteratorRecord` must be an Iterator Record'); // step 1
	}

	if (!(completion instanceof CompletionRecord)) {
		throw new $TypeError('Assertion failed: completion is not a Completion Record instance'); // step 2
	}

	if (!$then) {
		throw new $SyntaxError('This environment does not support Promises.');
	}

	var iterator = iteratorRecord['[[Iterator]]']; // step 3

	return new $Promise(function (resolve) {
		var ret = GetMethod(iterator, 'return'); // step 4

		if (typeof ret === 'undefined') {
			resolve(completion); // step 5
		} else {
			resolve($then(
				new $Promise(function (resolve2) {
					// process.exit(42);
					resolve2(Call(ret, iterator, [])); // step 6
				}),
				function (innerResult) {
					if (!isObject(innerResult)) {
						throw new $TypeError('`innerResult` must be an Object'); // step 10
					}
					return completion;
				},
				function (e) {
					if (completion.type() === 'throw') {
						completion['?'](); // step 8
					} else {
						throw e; // step 9
					}
				}
			));
		}
	});
};
'use strict';

var GetIntrinsic = require('get-intrinsic');
var callBound = require('call-bound');

var $TypeError = require('es-errors/type');

var IsArray = require('./IsArray');

var $apply = GetIntrinsic('%Reflect.apply%', true) || callBound('Function.prototype.apply');

// https://262.ecma-international.org/6.0/#sec-call

module.exports = function Call(F, V) {
	var argumentsList = arguments.length > 2 ? arguments[2] : [];
	if (!IsArray(argumentsList)) {
		throw new $TypeError('Assertion failed: optional `argumentsList`, if provided, must be a List');
	}
	return $apply(F, V, argumentsList);
};
'use strict';

var $TypeError = require('es-errors/type');

var callBound = require('call-bound');
var hasOwn = require('hasown');

var $charCodeAt = callBound('String.prototype.charCodeAt');
var $toUpperCase = callBound('String.prototype.toUpperCase');

var caseFolding = require('../helpers/caseFolding.json');

// https://262.ecma-international.org/6.0/#sec-runtime-semantics-canonicalize-ch

module.exports = function Canonicalize(ch, IgnoreCase, Unicode) {
	if (typeof ch !== 'string') {
		throw new $TypeError('Assertion failed: `ch` must be a character');
	}

	if (typeof IgnoreCase !== 'boolean' || typeof Unicode !== 'boolean') {
		throw new $TypeError('Assertion failed: `IgnoreCase` and `Unicode` must be Booleans');
	}

	if (!IgnoreCase) {
		return ch; // step 1
	}

	if (Unicode) { // step 2
		if (hasOwn(caseFolding.C, ch)) {
			return caseFolding.C[ch];
		}
		if (hasOwn(caseFolding.S, ch)) {
			return caseFolding.S[ch];
		}
		return ch; // step 2.b
	}

	var u = $toUpperCase(ch); // step 2

	if (u.length !== 1) {
		return ch; // step 3
	}

	var cu = u; // step 4

	if ($charCodeAt(ch, 0) >= 128 && $charCodeAt(cu, 0) < 128) {
		return ch; // step 5
	}

	return cu;
};
'use strict';

var $TypeError = require('es-errors/type');

var SameValue = require('./SameValue');
var ToNumber = require('./ToNumber');
var ToString = require('./ToString');

// https://262.ecma-international.org/6.0/#sec-canonicalnumericindexstring

module.exports = function CanonicalNumericIndexString(argument) {
	if (typeof argument !== 'string') {
		throw new $TypeError('Assertion failed: `argument` must be a String');
	}
	if (argument === '-0') { return -0; }
	var n = ToNumber(argument);
	if (SameValue(ToString(n), argument)) { return n; }
	return void 0;
};
'use strict';

var GetIntrinsic = require('get-intrinsic');
var callBound = require('call-bound');

var $fromCharCode = GetIntrinsic('%String.fromCharCode%');
var $TypeError = require('es-errors/type');
var $charCodeAt = callBound('String.prototype.charCodeAt');

var CharSet = require('../helpers/CharSet').CharSet;

module.exports = function CharacterRange(A, B) {
	var a;
	var b;

	if (A instanceof CharSet || B instanceof CharSet) {
		if (!(A instanceof CharSet) || !(B instanceof CharSet)) {
			throw new $TypeError('Assertion failed: CharSets A and B are not both CharSets');
		}

		A.yield(function (c) {
			if (typeof a !== 'undefined') {
				throw new $TypeError('Assertion failed: CharSet A has more than one character');
			}
			a = c;
		});
		B.yield(function (c) {
			if (typeof b !== 'undefined') {
				throw new $TypeError('Assertion failed: CharSet B has more than one character');
			}
			b = c;
		});
	} else {
		if (A.length !== 1 || B.length !== 1) {
			throw new $TypeError('Assertion failed: CharSets A and B contain exactly one character');
		}
		a = A[0];
		b = B[0];
	}

	var i = $charCodeAt(a, 0);
	var j = $charCodeAt(b, 0);

	if (!(i <= j)) {
		throw new $TypeError('Assertion failed: i is not <= j');
	}

	var arr = [];
	for (var k = i; k <= j; k += 1) {
		arr[arr.length] = $fromCharCode(k);
	}
	return arr;
};
'use strict';

var $TypeError = require('es-errors/type');

var hasOwn = require('hasown');

var IsDataDescriptor = require('./IsDataDescriptor');
var IsGenericDescriptor = require('./IsGenericDescriptor');

var isPropertyDescriptor = require('../helpers/records/property-descriptor');

// https://262.ecma-international.org/6.0/#sec-completepropertydescriptor

module.exports = function CompletePropertyDescriptor(Desc) {
	if (!isPropertyDescriptor(Desc)) {
		throw new $TypeError('Assertion failed: `Desc` must be a Property Descriptor');
	}

	/* eslint no-param-reassign: 0 */

	if (IsGenericDescriptor(Desc) || IsDataDescriptor(Desc)) {
		if (!hasOwn(Desc, '[[Value]]')) {
			Desc['[[Value]]'] = void 0;
		}
		if (!hasOwn(Desc, '[[Writable]]')) {
			Desc['[[Writable]]'] = false;
		}
	} else {
		if (!hasOwn(Desc, '[[Get]]')) {
			Desc['[[Get]]'] = void 0;
		}
		if (!hasOwn(Desc, '[[Set]]')) {
			Desc['[[Set]]'] = void 0;
		}
	}
	if (!hasOwn(Desc, '[[Enumerable]]')) {
		Desc['[[Enumerable]]'] = false;
	}
	if (!hasOwn(Desc, '[[Configurable]]')) {
		Desc['[[Configurable]]'] = false;
	}
	return Desc;
};
'use strict';

var $SyntaxError = require('es-errors/syntax');

var SLOT = require('internal-slot');

// https://262.ecma-international.org/7.0/#sec-completion-record-specification-type

var CompletionRecord = function CompletionRecord(type, value) {
	if (!(this instanceof CompletionRecord)) {
		return new CompletionRecord(type, value);
	}
	if (type !== 'normal' && type !== 'break' && type !== 'continue' && type !== 'return' && type !== 'throw') {
		throw new $SyntaxError('Assertion failed: `type` must be one of "normal", "break", "continue", "return", or "throw"');
	}
	SLOT.set(this, '[[Type]]', type);
	SLOT.set(this, '[[Value]]', value);
	// [[Target]] slot?
};

CompletionRecord.prototype.type = function Type() {
	return SLOT.get(this, '[[Type]]');
};

CompletionRecord.prototype.value = function Value() {
	return SLOT.get(this, '[[Value]]');
};

CompletionRecord.prototype['?'] = function ReturnIfAbrupt() {
	var type = SLOT.get(this, '[[Type]]');
	var value = SLOT.get(this, '[[Value]]');

	if (type === 'throw') {
		throw value;
	}
	return value;
};

CompletionRecord.prototype['!'] = function assert() {
	var type = SLOT.get(this, '[[Type]]');

	if (type !== 'normal') {
		throw new $SyntaxError('Assertion failed: Completion Record is not of type "normal"');
	}
	return SLOT.get(this, '[[Value]]');
};

module.exports = CompletionRecord;
'use strict';

var $TypeError = require('es-errors/type');
var isObject = require('es-object-atoms/isObject');
var callBound = require('call-bound');
var OwnPropertyKeys = require('own-keys');

var every = require('../helpers/every');
var forEach = require('../helpers/forEach');

var $isEnumerable = callBound('Object.prototype.propertyIsEnumerable');

var CreateDataProperty = require('./CreateDataProperty');
var Get = require('./Get');
var IsArray = require('./IsArray');
var IsInteger = require('./IsInteger');
var isPropertyKey = require('../helpers/isPropertyKey');
var SameValue = require('./SameValue');
var ToNumber = require('./ToNumber');
var ToObject = require('./ToObject');

// https://262.ecma-international.org/9.0/#sec-copydataproperties

module.exports = function CopyDataProperties(target, source, excludedItems) {
	if (!isObject(target)) {
		throw new $TypeError('Assertion failed: "target" must be an Object');
	}

	if (!IsArray(excludedItems) || !every(excludedItems, isPropertyKey)) {
		throw new $TypeError('Assertion failed: "excludedItems" must be a List of Property Keys');
	}

	if (typeof source === 'undefined' || source === null) {
		return target;
	}

	var fromObj = ToObject(source);

	var sourceKeys = OwnPropertyKeys(fromObj);
	forEach(sourceKeys, function (nextKey) {
		var excluded = false;

		forEach(excludedItems, function (e) {
			if (SameValue(e, nextKey) === true) {
				excluded = true;
			}
		});

		var enumerable = $isEnumerable(fromObj, nextKey) || (
			// this is to handle string keys being non-enumerable in older engines
			typeof source === 'string'
			&& nextKey >= 0
			&& IsInteger(ToNumber(nextKey))
		);
		if (excluded === false && enumerable) {
			var propValue = Get(fromObj, nextKey);
			CreateDataProperty(target, nextKey, propValue);
		}
	});

	return target;
};
'use strict';

var GetIntrinsic = require('get-intrinsic');

var $SyntaxError = require('es-errors/syntax');
var $TypeError = require('es-errors/type');
var isObject = require('es-object-atoms/isObject');
var $Promise = GetIntrinsic('%Promise%', true);

var AsyncFromSyncIteratorContinuation = require('./AsyncFromSyncIteratorContinuation');
var Call = require('./Call');
var CreateIterResultObject = require('./CreateIterResultObject');
var Get = require('./Get');
var GetMethod = require('./GetMethod');
var IteratorNext = require('./IteratorNext');
var ObjectCreate = require('./ObjectCreate');

var isIteratorRecord = require('../helpers/records/iterator-record-2023');

var SLOT = require('internal-slot');

var $AsyncFromSyncIteratorPrototype = GetIntrinsic('%AsyncFromSyncIteratorPrototype%', true) || {
	next: function next(value) {
		if (!$Promise) {
			throw new $SyntaxError('This environment does not support Promises.');
		}

		var O = this; // step 1

		SLOT.assert(O, '[[SyncIteratorRecord]]'); // step 2

		var argsLength = arguments.length;

		return new $Promise(function (resolve) { // step 3
			var syncIteratorRecord = SLOT.get(O, '[[SyncIteratorRecord]]'); // step 4
			var result;
			if (argsLength > 0) {
				result = IteratorNext(syncIteratorRecord['[[Iterator]]'], value); // step 5.a
			} else { // step 6
				result = IteratorNext(syncIteratorRecord['[[Iterator]]']);// step 6.a
			}
			resolve(AsyncFromSyncIteratorContinuation(result)); // step 8
		});
	},
	'return': function () {
		if (!$Promise) {
			throw new $SyntaxError('This environment does not support Promises.');
		}

		var O = this; // step 1

		SLOT.assert(O, '[[SyncIteratorRecord]]'); // step 2

		var valueIsPresent = arguments.length > 0;
		var value = valueIsPresent ? arguments[0] : void undefined;

		return new $Promise(function (resolve, reject) { // step 3
			var syncIterator = SLOT.get(O, '[[SyncIteratorRecord]]')['[[Iterator]]']; // step 4
			var iteratorReturn = GetMethod(syncIterator, 'return'); // step 5

			if (typeof iteratorReturn === 'undefined') { // step 7
				var iterResult = CreateIterResultObject(value, true); // step 7.a
				Call(resolve, undefined, [iterResult]); // step 7.b
				return;
			}
			var result;
			if (valueIsPresent) { // step 8
				result = Call(iteratorReturn, syncIterator, [value]); // step 8.a
			} else { // step 9
				result = Call(iteratorReturn, syncIterator); // step 9.a
			}
			if (!isObject(result)) { // step 11
				Call(reject, undefined, [new $TypeError('Iterator `return` method returned a non-object value.')]); // step 11.a
				return;
			}

			resolve(AsyncFromSyncIteratorContinuation(result)); // step 12
		});
	},
	'throw': function () {
		if (!$Promise) {
			throw new $SyntaxError('This environment does not support Promises.');
		}

		var O = this; // step 1

		SLOT.assert(O, '[[SyncIteratorRecord]]'); // step 2

		var valueIsPresent = arguments.length > 0;
		var value = valueIsPresent ? arguments[0] : void undefined;

		return new $Promise(function (resolve, reject) { // step 3
			var syncIterator = SLOT.get(O, '[[SyncIteratorRecord]]')['[[Iterator]]']; // step 4

			var throwMethod = GetMethod(syncIterator, 'throw'); // step 5

			if (typeof throwMethod === 'undefined') { // step 7
				Call(reject, undefined, [value]); // step 7.a
				return;
			}

			var result;
			if (valueIsPresent) { // step 8
				result = Call(throwMethod, syncIterator, [value]); // step 8.a
			} else { // step 9
				result = Call(throwMethod, syncIterator); // step 9.a
			}
			if (!isObject(result)) { // step 11
				Call(reject, undefined, [new $TypeError('Iterator `throw` method returned a non-object value.')]); // step 11.a
				return;
			}

			resolve(AsyncFromSyncIteratorContinuation(result/* , promiseCapability */)); // step 12
		});
	}
};

// https://262.ecma-international.org/10.0/#sec-createasyncfromsynciterator

module.exports = function CreateAsyncFromSyncIterator(syncIteratorRecord) {
	if (!isIteratorRecord(syncIteratorRecord)) {
		throw new $TypeError('Assertion failed: `syncIteratorRecord` must be an Iterator Record'); // step 1
	}

	// var asyncIterator = ObjectCreate(%AsyncFromSyncIteratorPrototype%, « [[SyncIteratorRecord]] »); // step 1
	var asyncIterator = ObjectCreate($AsyncFromSyncIteratorPrototype);

	SLOT.set(asyncIterator, '[[SyncIteratorRecord]]', syncIteratorRecord); // step 2

	var nextMethod = Get(asyncIterator, 'next'); // step 3

	return { // steps 3-4
		'[[Iterator]]': asyncIterator,
		'[[NextMethod]]': nextMethod,
		'[[Done]]': false
	};
};
'use strict';

var $TypeError = require('es-errors/type');
var isObject = require('es-object-atoms/isObject');

var isPropertyKey = require('../helpers/isPropertyKey');
var OrdinaryDefineOwnProperty = require('./OrdinaryDefineOwnProperty');

// https://262.ecma-international.org/6.0/#sec-createdataproperty

module.exports = function CreateDataProperty(O, P, V) {
	if (!isObject(O)) {
		throw new $TypeError('Assertion failed: Type(O) is not Object');
	}
	if (!isPropertyKey(P)) {
		throw new $TypeError('Assertion failed: P is not a Property Key');
	}
	var newDesc = {
		'[[Configurable]]': true,
		'[[Enumerable]]': true,
		'[[Value]]': V,
		'[[Writable]]': true
	};
	return OrdinaryDefineOwnProperty(O, P, newDesc);
};
'use strict';

var $TypeError = require('es-errors/type');
var isObject = require('es-object-atoms/isObject');

var CreateDataProperty = require('./CreateDataProperty');

var isPropertyKey = require('../helpers/isPropertyKey');

// // https://262.ecma-international.org/6.0/#sec-createdatapropertyorthrow

module.exports = function CreateDataPropertyOrThrow(O, P, V) {
	if (!isObject(O)) {
		throw new $TypeError('Assertion failed: Type(O) is not Object');
	}
	if (!isPropertyKey(P)) {
		throw new $TypeError('Assertion failed: P is not a Property Key');
	}
	var success = CreateDataProperty(O, P, V);
	if (!success) {
		throw new $TypeError('unable to create data property');
	}
	return success;
};
'use strict';

var $TypeError = require('es-errors/type');

var callBound = require('call-bound');

var $replace = callBound('String.prototype.replace');

var RequireObjectCoercible = require('./RequireObjectCoercible');
var ToString = require('./ToString');

// https://262.ecma-international.org/6.0/#sec-createhtml

module.exports = function CreateHTML(string, tag, attribute, value) {
	if (typeof tag !== 'string' || typeof attribute !== 'string') {
		throw new $TypeError('Assertion failed: `tag` and `attribute` must be strings');
	}
	var str = RequireObjectCoercible(string);
	var S = ToString(str);
	var p1 = '<' + tag;
	if (attribute !== '') {
		var V = ToString(value);
		var escapedV = $replace(V, /\x22/g, '&quot;');
		p1 += '\x20' + attribute + '\x3D\x22' + escapedV + '\x22';
	}
	return p1 + '>' + S + '</' + tag + '>';
};
'use strict';

var $TypeError = require('es-errors/type');

// https://262.ecma-international.org/6.0/#sec-createiterresultobject

module.exports = function CreateIterResultObject(value, done) {
	if (typeof done !== 'boolean') {
		throw new $TypeError('Assertion failed: Type(done) is not Boolean');
	}
	return {
		value: value,
		done: done
	};
};
'use strict';

var callBound = require('call-bound');

var $TypeError = require('es-errors/type');
var isObject = require('es-object-atoms/isObject');
var $indexOf = callBound('Array.prototype.indexOf', true) || callBound('String.prototype.indexOf');

var Get = require('./Get');
var IsArray = require('./IsArray');
var ToLength = require('./ToLength');
var ToString = require('./ToString');
var Type = require('./Type');

var defaultElementTypes = ['Undefined', 'Null', 'Boolean', 'String', 'Symbol', 'Number', 'Object'];

// https://262.ecma-international.org/6.0/#sec-createlistfromarraylike
module.exports = function CreateListFromArrayLike(obj) {
	var elementTypes = arguments.length > 1
		? arguments[1]
		: defaultElementTypes;

	if (!isObject(obj)) {
		throw new $TypeError('Assertion failed: `obj` must be an Object');
	}
	if (!IsArray(elementTypes)) {
		throw new $TypeError('Assertion failed: `elementTypes`, if provided, must be an array');
	}
	var len = ToLength(Get(obj, 'length'));
	var list = [];
	var index = 0;
	while (index < len) {
		var indexName = ToString(index);
		var next = Get(obj, indexName);
		var nextType = Type(next);
		if ($indexOf(elementTypes, nextType) < 0) {
			throw new $TypeError('item type ' + nextType + ' is not a valid elementType');
		}
		list[list.length] = next;
		index += 1;
	}
	return list;
};
'use strict';

var $TypeError = require('es-errors/type');
var isObject = require('es-object-atoms/isObject');

var DefineOwnProperty = require('../helpers/DefineOwnProperty');

var FromPropertyDescriptor = require('./FromPropertyDescriptor');
var IsDataDescriptor = require('./IsDataDescriptor');
var isPropertyKey = require('../helpers/isPropertyKey');
var SameValue = require('./SameValue');

// https://262.ecma-international.org/6.0/#sec-createmethodproperty

module.exports = function CreateMethodProperty(O, P, V) {
	if (!isObject(O)) {
		throw new $TypeError('Assertion failed: Type(O) is not Object');
	}

	if (!isPropertyKey(P)) {
		throw new $TypeError('Assertion failed: P is not a Property Key');
	}

	var newDesc = {
		'[[Configurable]]': true,
		'[[Enumerable]]': false,
		'[[Value]]': V,
		'[[Writable]]': true
	};
	return DefineOwnProperty(
		IsDataDescriptor,
		SameValue,
		FromPropertyDescriptor,
		O,
		P,
		newDesc
	);
};
'use strict';

var $EvalError = require('es-errors/eval');

var DayWithinYear = require('./DayWithinYear');
var InLeapYear = require('./InLeapYear');
var MonthFromTime = require('./MonthFromTime');

// https://262.ecma-international.org/5.1/#sec-15.9.1.5

module.exports = function DateFromTime(t) {
	var m = MonthFromTime(t);
	var d = DayWithinYear(t);
	if (m === 0) {
		return d + 1;
	}
	if (m === 1) {
		return d - 30;
	}
	var leap = InLeapYear(t);
	if (m === 2) {
		return d - 58 - leap;
	}
	if (m === 3) {
		return d - 89 - leap;
	}
	if (m === 4) {
		return d - 119 - leap;
	}
	if (m === 5) {
		return d - 150 - leap;
	}
	if (m === 6) {
		return d - 180 - leap;
	}
	if (m === 7) {
		return d - 211 - leap;
	}
	if (m === 8) {
		return d - 242 - leap;
	}
	if (m === 9) {
		return d - 272 - leap;
	}
	if (m === 10) {
		return d - 303 - leap;
	}
	if (m === 11) {
		return d - 333 - leap;
	}
	throw new $EvalError('Assertion failed: MonthFromTime returned an impossible value: ' + m);
};
'use strict';

var $TypeError = require('es-errors/type');

var weekdays = ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'];
var months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];

var $isNaN = require('math-intrinsics/isNaN');
var padTimeComponent = require('../helpers/padTimeComponent');

var DateFromTime = require('./DateFromTime');
var MonthFromTime = require('./MonthFromTime');
var WeekDay = require('./WeekDay');
var YearFromTime = require('./YearFromTime');

// https://262.ecma-international.org/9.0/#sec-datestring

module.exports = function DateString(tv) {
	if (typeof tv !== 'number' || $isNaN(tv)) {
		throw new $TypeError('Assertion failed: `tv` must be a non-NaN Number');
	}
	var weekday = weekdays[WeekDay(tv)];
	var month = months[MonthFromTime(tv)];
	var day = padTimeComponent(DateFromTime(tv));
	var year = padTimeComponent(YearFromTime(tv), 4);
	return weekday + '\x20' + month + '\x20' + day + '\x20' + year;
};
'use strict';

var floor = require('./floor');

// https://262.ecma-international.org/5.1/#sec-15.9.1.3

module.exports = function DayFromYear(y) {
	return (365 * (y - 1970)) + floor((y - 1969) / 4) - floor((y - 1901) / 100) + floor((y - 1601) / 400);
};

'use strict';

var floor = require('./floor');

var msPerDay = require('../helpers/timeConstants').msPerDay;

// https://262.ecma-international.org/5.1/#sec-15.9.1.2

module.exports = function Day(t) {
	return floor(t / msPerDay);
};
'use strict';

var modulo = require('./modulo');

// https://262.ecma-international.org/5.1/#sec-15.9.1.3

module.exports = function DaysInYear(y) {
	if (modulo(y, 4) !== 0) {
		return 365;
	}
	if (modulo(y, 100) !== 0) {
		return 366;
	}
	if (modulo(y, 400) !== 0) {
		return 365;
	}
	return 366;
};
'use strict';

var Day = require('./Day');
var DayFromYear = require('./DayFromYear');
var YearFromTime = require('./YearFromTime');

// https://262.ecma-international.org/5.1/#sec-15.9.1.4

module.exports = function DayWithinYear(t) {
	return Day(t) - DayFromYear(YearFromTime(t));
};
'use strict';

var $TypeError = require('es-errors/type');
var isObject = require('es-object-atoms/isObject');

var isPropertyDescriptor = require('../helpers/records/property-descriptor');
var DefineOwnProperty = require('../helpers/DefineOwnProperty');

var FromPropertyDescriptor = require('./FromPropertyDescriptor');
var IsDataDescriptor = require('./IsDataDescriptor');
var isPropertyKey = require('../helpers/isPropertyKey');
var SameValue = require('./SameValue');
var ToPropertyDescriptor = require('./ToPropertyDescriptor');

// https://262.ecma-international.org/6.0/#sec-definepropertyorthrow

module.exports = function DefinePropertyOrThrow(O, P, desc) {
	if (!isObject(O)) {
		throw new $TypeError('Assertion failed: Type(O) is not Object');
	}

	if (!isPropertyKey(P)) {
		throw new $TypeError('Assertion failed: P is not a Property Key');
	}

	var Desc = isPropertyDescriptor(desc) ? desc : ToPropertyDescriptor(desc);
	if (!isPropertyDescriptor(Desc)) {
		throw new $TypeError('Assertion failed: Desc is not a valid Property Descriptor');
	}

	return DefineOwnProperty(
		IsDataDescriptor,
		SameValue,
		FromPropertyDescriptor,
		O,
		P,
		Desc
	);
};
'use strict';

var $TypeError = require('es-errors/type');
var isObject = require('es-object-atoms/isObject');

var isPropertyKey = require('../helpers/isPropertyKey');

// https://262.ecma-international.org/6.0/#sec-deletepropertyorthrow

module.exports = function DeletePropertyOrThrow(O, P) {
	if (!isObject(O)) {
		throw new $TypeError('Assertion failed: Type(O) is not Object');
	}

	if (!isPropertyKey(P)) {
		throw new $TypeError('Assertion failed: P is not a Property Key');
	}

	// eslint-disable-next-line no-param-reassign
	var success = delete O[P];
	if (!success) {
		throw new $TypeError('Attempt to delete property failed.');
	}
	return success;
};
'use strict';

var $SyntaxError = require('es-errors/syntax');
var $TypeError = require('es-errors/type');

var IsDetachedBuffer = require('./IsDetachedBuffer');

var isArrayBuffer = require('is-array-buffer');
var isSharedArrayBuffer = require('is-shared-array-buffer');

var MessageChannel;
try {
	// eslint-disable-next-line global-require
	MessageChannel = require('worker_threads').MessageChannel;
} catch (e) { /**/ }

// https://262.ecma-international.org/9.0/#sec-detacharraybuffer

/* globals postMessage */

module.exports = function DetachArrayBuffer(arrayBuffer) {
	if (!isArrayBuffer(arrayBuffer) || isSharedArrayBuffer(arrayBuffer)) {
		throw new $TypeError('Assertion failed: `arrayBuffer` must be an Object with an [[ArrayBufferData]] internal slot, and not a Shared Array Buffer');
	}

	// commented out since there's no way to set or access this key
	// var key = arguments.length > 1 ? arguments[1] : void undefined;

	// if (!SameValue(arrayBuffer[[ArrayBufferDetachKey]], key)) {
	// 	throw new $TypeError('Assertion failed: `key` must be the value of the [[ArrayBufferDetachKey]] internal slot of `arrayBuffer`');
	// }

	if (!IsDetachedBuffer(arrayBuffer)) { // node v21.0.0+ throws when you structuredClone a detached buffer
		if (typeof structuredClone === 'function') {
			structuredClone(arrayBuffer, { transfer: [arrayBuffer] });
		} else if (typeof postMessage === 'function') {
			postMessage('', '/', [arrayBuffer]); // TODO: see if this might trigger listeners
		} else if (MessageChannel) {
			(new MessageChannel()).port1.postMessage(null, [arrayBuffer]);
		} else {
			throw new $SyntaxError('DetachArrayBuffer is not supported in this environment');
		}
	}

	return null;
};
'use strict';

var $TypeError = require('es-errors/type');
var isObject = require('es-object-atoms/isObject');

var objectKeys = require('object-keys');
var safePushApply = require('safe-push-apply');
var callBound = require('call-bound');

var $isEnumerable = callBound('Object.prototype.propertyIsEnumerable');

var forEach = require('../helpers/forEach');

// https://262.ecma-international.org/8.0/#sec-enumerableownproperties

module.exports = function EnumerableOwnPropertyNames(O, kind) {
	if (!isObject(O)) {
		throw new $TypeError('Assertion failed: Type(O) is not Object');
	}

	var keys = objectKeys(O);
	if (kind === 'key') {
		return keys;
	}
	if (kind === 'value' || kind === 'key+value') {
		var results = [];
		forEach(keys, function (key) {
			if ($isEnumerable(O, key)) {
				safePushApply(results, [
					kind === 'value' ? O[key] : [key, O[key]]
				]);
			}
		});
		return results;
	}
	throw new $TypeError('Assertion failed: "kind" is not "key", "value", or "key+value": ' + kind);
};
'use strict';

var $TypeError = require('es-errors/type');

var MAX_SAFE_INTEGER = require('math-intrinsics/constants/maxSafeInteger');

var Call = require('./Call');
var CreateDataPropertyOrThrow = require('./CreateDataPropertyOrThrow');
var Get = require('./Get');
var HasProperty = require('./HasProperty');
var IsArray = require('./IsArray');
var ToLength = require('./ToLength');
var ToString = require('./ToString');

// https://262.ecma-international.org/10.0/#sec-flattenintoarray

module.exports = function FlattenIntoArray(target, source, sourceLen, start, depth) {
	var mapperFunction;
	if (arguments.length > 5) {
		mapperFunction = arguments[5];
	}

	var targetIndex = start;
	var sourceIndex = 0;
	while (sourceIndex < sourceLen) {
		var P = ToString(sourceIndex);
		var exists = HasProperty(source, P);
		if (exists === true) {
			var element = Get(source, P);
			if (typeof mapperFunction !== 'undefined') {
				if (arguments.length <= 6) {
					throw new $TypeError('Assertion failed: thisArg is required when mapperFunction is provided');
				}
				element = Call(mapperFunction, arguments[6], [element, sourceIndex, source]);
			}
			var shouldFlatten = false;
			if (depth > 0) {
				shouldFlatten = IsArray(element);
			}
			if (shouldFlatten) {
				var elementLen = ToLength(Get(element, 'length'));
				targetIndex = FlattenIntoArray(target, element, elementLen, targetIndex, depth - 1);
			} else {
				if (targetIndex >= MAX_SAFE_INTEGER) {
					throw new $TypeError('index too large');
				}
				CreateDataPropertyOrThrow(target, ToString(targetIndex), element);
				targetIndex += 1;
			}
		}
		sourceIndex += 1;
	}

	return targetIndex;
};
'use strict';

// var modulo = require('./modulo');
var $floor = require('math-intrinsics/floor');

// http://262.ecma-international.org/5.1/#sec-5.2

module.exports = function floor(x) {
	// return x - modulo(x, 1);
	return $floor(x);
};
'use strict';

var $TypeError = require('es-errors/type');

var isPropertyDescriptor = require('../helpers/records/property-descriptor');
var fromPropertyDescriptor = require('../helpers/fromPropertyDescriptor');

// https://262.ecma-international.org/6.0/#sec-frompropertydescriptor

module.exports = function FromPropertyDescriptor(Desc) {
	if (typeof Desc !== 'undefined' && !isPropertyDescriptor(Desc)) {
		throw new $TypeError('Assertion failed: `Desc` must be a Property Descriptor');
	}

	return fromPropertyDescriptor(Desc);
};
'use strict';

var getGlobal = require('globalthis/polyfill');

// https://262.ecma-international.org/6.0/#sec-getglobalobject

module.exports = function GetGlobalObject() {
	return getGlobal();
};
'use strict';

var $TypeError = require('es-errors/type');

var getIteratorMethod = require('../helpers/getIteratorMethod');
var AdvanceStringIndex = require('./AdvanceStringIndex');
var Call = require('./Call');
var GetMethod = require('./GetMethod');

var isObject = require('es-object-atoms/isObject');

var ES = {
	AdvanceStringIndex: AdvanceStringIndex,
	GetMethod: GetMethod
};

// https://262.ecma-international.org/6.0/#sec-getiterator

module.exports = function GetIterator(obj, method) {
	var actualMethod = method;
	if (arguments.length < 2) {
		actualMethod = getIteratorMethod(ES, obj);
	}
	var iterator = Call(actualMethod, obj);
	if (!isObject(iterator)) {
		throw new $TypeError('iterator must return an object');
	}

	return iterator;
};
'use strict';

var $TypeError = require('es-errors/type');

var inspect = require('object-inspect');

var isPropertyKey = require('../helpers/isPropertyKey');

var isObject = require('es-object-atoms/isObject');

// https://262.ecma-international.org/6.0/#sec-get-o-p

module.exports = function Get(O, P) {
	// 7.3.1.1
	if (!isObject(O)) {
		throw new $TypeError('Assertion failed: Type(O) is not Object');
	}
	// 7.3.1.2
	if (!isPropertyKey(P)) {
		throw new $TypeError('Assertion failed: P is not a Property Key, got ' + inspect(P));
	}
	// 7.3.1.3
	return O[P];
};
'use strict';

var $TypeError = require('es-errors/type');

var GetV = require('./GetV');
var IsCallable = require('./IsCallable');
var isPropertyKey = require('../helpers/isPropertyKey');

var inspect = require('object-inspect');

// https://262.ecma-international.org/6.0/#sec-getmethod

module.exports = function GetMethod(O, P) {
	// 7.3.9.1
	if (!isPropertyKey(P)) {
		throw new $TypeError('Assertion failed: P is not a Property Key');
	}

	// 7.3.9.2
	var func = GetV(O, P);

	// 7.3.9.4
	if (func == null) {
		return void 0;
	}

	// 7.3.9.5
	if (!IsCallable(func)) {
		throw new $TypeError(inspect(P) + ' is not a function: ' + inspect(func));
	}

	// 7.3.9.6
	return func;
};
'use strict';

var GetIntrinsic = require('get-intrinsic');

var hasSymbols = require('has-symbols')();

var $TypeError = require('es-errors/type');
var isObject = require('es-object-atoms/isObject');

var $gOPN = GetIntrinsic('%Object.getOwnPropertyNames%', true);
var $gOPS = hasSymbols && GetIntrinsic('%Object.getOwnPropertySymbols%', true);
var keys = require('object-keys');

// https://262.ecma-international.org/6.0/#sec-getownpropertykeys

module.exports = function GetOwnPropertyKeys(O, Type) {
	if (!isObject(O)) {
		throw new $TypeError('Assertion failed: Type(O) is not Object');
	}
	if (Type === 'Symbol') {
		return $gOPS ? $gOPS(O) : [];
	}
	if (Type === 'String') {
		if (!$gOPN) {
			return keys(O);
		}
		return $gOPN(O);
	}
	throw new $TypeError('Assertion failed: `Type` must be `"String"` or `"Symbol"`');
};
'use strict';

var GetIntrinsic = require('get-intrinsic');

var $Function = GetIntrinsic('%Function%');
var $TypeError = require('es-errors/type');
var $SyntaxError = require('es-errors/syntax');

var Get = require('./Get');
var IsConstructor = require('./IsConstructor');

var isObject = require('es-object-atoms/isObject');

// https://262.ecma-international.org/6.0/#sec-getprototypefromconstructor

module.exports = function GetPrototypeFromConstructor(constructor, intrinsicDefaultProto) {
	var intrinsic = GetIntrinsic(intrinsicDefaultProto); // throws if not a valid intrinsic
	if (!isObject(intrinsic)) {
		throw new $TypeError('intrinsicDefaultProto must be an object');
	}
	if (!IsConstructor(constructor)) {
		throw new $TypeError('Assertion failed: `constructor` must be a constructor');
	}
	var proto = Get(constructor, 'prototype');
	if (!isObject(proto)) {
		if (!(constructor instanceof $Function)) {
			// ignore other realms, for now
			throw new $SyntaxError('cross-realm constructors not currently supported');
		}
		proto = intrinsic;
	}
	return proto;
};
'use strict';

var $TypeError = require('es-errors/type');

var callBound = require('call-bound');
var regexTester = require('safe-regex-test');
var every = require('../helpers/every');

var $charAt = callBound('String.prototype.charAt');
var $strSlice = callBound('String.prototype.slice');
var $indexOf = callBound('String.prototype.indexOf');
var $parseInt = parseInt;

var isDigit = regexTester(/^[0-9]$/);

var inspect = require('object-inspect');
var isInteger = require('math-intrinsics/isInteger');

var Get = require('./Get');
var IsArray = require('./IsArray');
var ToObject = require('./ToObject');
var ToString = require('./ToString');

var isStringOrUndefined = require('../helpers/isStringOrUndefined');

// http://262.ecma-international.org/9.0/#sec-getsubstitution

// eslint-disable-next-line max-statements, max-params, max-lines-per-function
module.exports = function GetSubstitution(matched, str, position, captures, namedCaptures, replacement) {
	if (typeof matched !== 'string') {
		throw new $TypeError('Assertion failed: `matched` must be a String');
	}
	var matchLength = matched.length;

	if (typeof str !== 'string') {
		throw new $TypeError('Assertion failed: `str` must be a String');
	}
	var stringLength = str.length;

	if (!isInteger(position) || position < 0 || position > stringLength) {
		throw new $TypeError('Assertion failed: `position` must be a nonnegative integer, and less than or equal to the length of `string`, got ' + inspect(position));
	}

	if (!IsArray(captures) || !every(captures, isStringOrUndefined)) {
		throw new $TypeError('Assertion failed: `captures` must be a List of Strings or `undefined`, got ' + inspect(captures));
	}

	if (typeof replacement !== 'string') {
		throw new $TypeError('Assertion failed: `replacement` must be a String');
	}

	var tailPos = position + matchLength;
	var m = captures.length;
	if (typeof namedCaptures !== 'undefined') {
		namedCaptures = ToObject(namedCaptures); // eslint-disable-line no-param-reassign
	}

	var result = '';
	for (var i = 0; i < replacement.length; i += 1) {
		// if this is a $, and it's not the end of the replacement
		var current = $charAt(replacement, i);
		var isLast = (i + 1) >= replacement.length;
		var nextIsLast = (i + 2) >= replacement.length;
		if (current === '$' && !isLast) {
			var next = $charAt(replacement, i + 1);
			if (next === '$') {
				result += '$';
				i += 1;
			} else if (next === '&') {
				result += matched;
				i += 1;
			} else if (next === '`') {
				result += position === 0 ? '' : $strSlice(str, 0, position - 1);
				i += 1;
			} else if (next === "'") {
				result += tailPos >= stringLength ? '' : $strSlice(str, tailPos);
				i += 1;
			} else {
				var nextNext = nextIsLast ? null : $charAt(replacement, i + 2);
				if (isDigit(next) && next !== '0' && (nextIsLast || !isDigit(nextNext))) {
					// $1 through $9, and not followed by a digit
					var n = $parseInt(next, 10);
					// if (n > m, impl-defined)
					result += n <= m && typeof captures[n - 1] === 'undefined' ? '' : captures[n - 1];
					i += 1;
				} else if (isDigit(next) && (nextIsLast || isDigit(nextNext))) {
					// $00 through $99
					var nn = next + nextNext;
					var nnI = $parseInt(nn, 10) - 1;
					// if nn === '00' or nn > m, impl-defined
					result += nn <= m && typeof captures[nnI] === 'undefined' ? '' : captures[nnI];
					i += 2;
				} else if (next === '<') {
					if (typeof namedCaptures === 'undefined') {
						result += '$<';
						i += 2;
					} else {
						var endIndex = $indexOf(replacement, '>', i);

						if (endIndex > -1) {
							var groupName = $strSlice(replacement, i + '$<'.length, endIndex);
							var capture = Get(namedCaptures, groupName);

							if (typeof capture !== 'undefined') {
								result += ToString(capture);
							}
							i += ('<' + groupName + '>').length;
						}
					}
				} else {
					result += '$';
				}
			}
		} else {
			// the final $, or else not a $
			result += $charAt(replacement, i);
		}
	}
	return result;
};
'use strict';

var GetIntrinsic = require('get-intrinsic');

var $TypeError = require('es-errors/type');
var $Uint8Array = GetIntrinsic('%Uint8Array%', true);
var isInteger = require('math-intrinsics/isInteger');

var callBound = require('call-bound');

var $slice = callBound('Array.prototype.slice');

var IsDetachedBuffer = require('./IsDetachedBuffer');
var RawBytesToNumber = require('./RawBytesToNumber');

var isArrayBuffer = require('is-array-buffer');
var isSharedArrayBuffer = require('is-shared-array-buffer');
var safeConcat = require('safe-array-concat');

var tableTAO = require('./tables/typed-array-objects');

var defaultEndianness = require('../helpers/defaultEndianness');

// https://262.ecma-international.org/10.0/#sec-getvaluefrombuffer

module.exports = function GetValueFromBuffer(arrayBuffer, byteIndex, type, isTypedArray, order) {
	var isSAB = isSharedArrayBuffer(arrayBuffer);
	if (!isArrayBuffer(arrayBuffer) && !isSAB) {
		throw new $TypeError('Assertion failed: `arrayBuffer` must be an ArrayBuffer or a SharedArrayBuffer');
	}

	if (!isInteger(byteIndex)) {
		throw new $TypeError('Assertion failed: `byteIndex` must be an integer');
	}

	if (typeof type !== 'string') {
		throw new $TypeError('Assertion failed: `type` must be a string');
	}

	if (typeof isTypedArray !== 'boolean') {
		throw new $TypeError('Assertion failed: `isTypedArray` must be a boolean');
	}

	if (typeof order !== 'string') {
		throw new $TypeError('Assertion failed: `order` must be a string');
	}

	if (arguments.length > 5 && typeof arguments[5] !== 'boolean') {
		throw new $TypeError('Assertion failed: `isLittleEndian` must be a boolean, if present');
	}

	if (IsDetachedBuffer(arrayBuffer)) {
		throw new $TypeError('Assertion failed: `arrayBuffer` is detached'); // step 1
	}

	// 2. Assert: There are sufficient bytes in arrayBuffer starting at byteIndex to represent a value of type.

	if (byteIndex < 0) {
		throw new $TypeError('Assertion failed: `byteIndex` must be non-negative'); // step 3
	}

	// 4. Let block be arrayBuffer.[[ArrayBufferData]].

	var elementSize = tableTAO.size['$' + type]; // step 5
	if (!elementSize) {
		throw new $TypeError('Assertion failed: `type` must be one of ' + tableTAO.choices);
	}

	var rawValue;
	if (isSAB) { // step 6
		/*
		a. Let execution be the [[CandidateExecution]] field of the surrounding agent's Agent Record.
		b. Let eventList be the [[EventList]] field of the element in execution.[[EventsRecords]] whose [[AgentSignifier]] is AgentSignifier().
		c. If isTypedArray is true and type is "Int8", "Uint8", "Int16", "Uint16", "Int32", or "Uint32", let noTear be true; otherwise let noTear be false.
		d. Let rawValue be a List of length elementSize of nondeterministically chosen byte values.
		e. NOTE: In implementations, rawValue is the result of a non-atomic or atomic read instruction on the underlying hardware. The nondeterminism is a semantic prescription of the memory model to describe observable behaviour of hardware with weak consistency.
		f. Let readEvent be ReadSharedMemory{ [[Order]]: order, [[NoTear]]: noTear, [[Block]]: block, [[ByteIndex]]: byteIndex, [[ElementSize]]: elementSize }.
		g. Append readEvent to eventList.
		h. Append Chosen Value Record { [[Event]]: readEvent, [[ChosenValue]]: rawValue } to execution.[[ChosenValues]].
		*/
	} else {
		// 7. Let rawValue be a List of elementSize containing, in order, the elementSize sequence of bytes starting with block[byteIndex].
		rawValue = $slice(new $Uint8Array(arrayBuffer, byteIndex), 0, elementSize); // step 6
	}

	// 8. If isLittleEndian is not present, set isLittleEndian to either true or false. The choice is implementation dependent and should be the alternative that is most efficient for the implementation. An implementation must use the same value each time this step is executed and the same value must be used for the corresponding step in the SetValueInBuffer abstract operation.
	var isLittleEndian = arguments.length > 5 ? arguments[5] : defaultEndianness === 'little'; // step 8

	var bytes = isLittleEndian
		? $slice(safeConcat([0, 0, 0, 0, 0, 0, 0, 0], rawValue), -elementSize)
		: $slice(safeConcat(rawValue, [0, 0, 0, 0, 0, 0, 0, 0]), 0, elementSize);

	return RawBytesToNumber(type, bytes, isLittleEndian);
};
'use strict';

var $TypeError = require('es-errors/type');

var inspect = require('object-inspect');

var isPropertyKey = require('../helpers/isPropertyKey');
// var ToObject = require('./ToObject');

// https://262.ecma-international.org/6.0/#sec-getv

module.exports = function GetV(V, P) {
	// 7.3.2.1
	if (!isPropertyKey(P)) {
		throw new $TypeError('Assertion failed: P is not a Property Key, got ' + inspect(P));
	}

	// 7.3.2.2-3
	// var O = ToObject(V);

	// 7.3.2.4
	return V[P];
};
'use strict';

var $TypeError = require('es-errors/type');

var hasOwn = require('hasown');
var isObject = require('es-object-atoms/isObject');

var isPropertyKey = require('../helpers/isPropertyKey');

// https://262.ecma-international.org/6.0/#sec-hasownproperty

module.exports = function HasOwnProperty(O, P) {
	if (!isObject(O)) {
		throw new $TypeError('Assertion failed: `O` must be an Object');
	}
	if (!isPropertyKey(P)) {
		throw new $TypeError('Assertion failed: `P` must be a Property Key');
	}
	return hasOwn(O, P);
};
'use strict';

var $TypeError = require('es-errors/type');
var isObject = require('es-object-atoms/isObject');

var isPropertyKey = require('../helpers/isPropertyKey');

// https://262.ecma-international.org/6.0/#sec-hasproperty

module.exports = function HasProperty(O, P) {
	if (!isObject(O)) {
		throw new $TypeError('Assertion failed: `O` must be an Object');
	}
	if (!isPropertyKey(P)) {
		throw new $TypeError('Assertion failed: `P` must be a Property Key');
	}
	return P in O;
};
'use strict';

var floor = require('./floor');
var modulo = require('./modulo');

var timeConstants = require('../helpers/timeConstants');
var msPerHour = timeConstants.msPerHour;
var HoursPerDay = timeConstants.HoursPerDay;

// https://262.ecma-international.org/5.1/#sec-15.9.1.10

module.exports = function HourFromTime(t) {
	return modulo(floor(t / msPerHour), HoursPerDay);
};
'use strict';

var $EvalError = require('es-errors/eval');

var DaysInYear = require('./DaysInYear');
var YearFromTime = require('./YearFromTime');

// https://262.ecma-international.org/5.1/#sec-15.9.1.3

module.exports = function InLeapYear(t) {
	var days = DaysInYear(YearFromTime(t));
	if (days === 365) {
		return 0;
	}
	if (days === 366) {
		return 1;
	}
	throw new $EvalError('Assertion failed: there are not 365 or 366 days in a year, got: ' + days);
};
'use strict';

var GetIntrinsic = require('get-intrinsic');

var $TypeError = require('es-errors/type');
var isObject = require('es-object-atoms/isObject');

var $hasInstance = GetIntrinsic('%Symbol.hasInstance%', true);

var Call = require('./Call');
var GetMethod = require('./GetMethod');
var IsCallable = require('./IsCallable');
var OrdinaryHasInstance = require('./OrdinaryHasInstance');
var ToBoolean = require('./ToBoolean');

// https://262.ecma-international.org/6.0/#sec-instanceofoperator

module.exports = function InstanceofOperator(O, C) {
	if (!isObject(O)) {
		throw new $TypeError('Assertion failed: Type(O) is not Object');
	}
	var instOfHandler = $hasInstance ? GetMethod(C, $hasInstance) : void 0;
	if (typeof instOfHandler !== 'undefined') {
		return ToBoolean(Call(instOfHandler, C, [O]));
	}
	if (!IsCallable(C)) {
		throw new $TypeError('`C` is not Callable');
	}
	return OrdinaryHasInstance(C, O);
};
'use strict';

var $SyntaxError = require('es-errors/syntax');
var $TypeError = require('es-errors/type');

var GetValueFromBuffer = require('./GetValueFromBuffer');
var IsDetachedBuffer = require('./IsDetachedBuffer');
var IsInteger = require('./IsInteger');

var isNegativeZero = require('math-intrinsics/isNegativeZero');

var typedArrayLength = require('typed-array-length');
var typedArrayBuffer = require('typed-array-buffer');
var typedArrayByteOffset = require('typed-array-byte-offset');
var whichTypedArray = require('which-typed-array');

var tableTAO = require('./tables/typed-array-objects');

// https://262.ecma-international.org/8.0/#sec-integerindexedelementget

module.exports = function IntegerIndexedElementGet(O, index) {
	if (typeof index !== 'number') {
		throw new $TypeError('`index` must be a Number'); // step 1
	}
	var arrayTypeName = whichTypedArray(O); // step 10
	if (!arrayTypeName) {
		throw new $TypeError('`O` must be a TypedArray'); // step 2
	}
	if (arrayTypeName === 'BigInt64Array' || arrayTypeName === 'BigUint64Array') {
		throw new $SyntaxError('BigInt64Array and BigUint64Array do not exist until ES2020');
	}

	var buffer = typedArrayBuffer(O); // step 3

	if (IsDetachedBuffer(buffer)) {
		throw new $TypeError('`O` has a detached buffer'); // step 4
	}

	if (!IsInteger(index) || isNegativeZero(index)) {
		return void undefined; // steps 5 - 6
	}

	var length = typedArrayLength(O); // step 7

	if (index < 0 || index >= length) {
		return void undefined; // step 8
	}

	var offset = typedArrayByteOffset(O); // step 9

	var elementType = tableTAO.name['$' + arrayTypeName]; // step 13

	var elementSize = tableTAO.size['$' + elementType]; // step 11

	var indexedPosition = (index * elementSize) + offset; // step 12

	return GetValueFromBuffer(buffer, indexedPosition, elementType, true, 'Unordered'); // step 14
};
'use strict';

var $SyntaxError = require('es-errors/syntax');
var $TypeError = require('es-errors/type');

var IsDetachedBuffer = require('./IsDetachedBuffer');
var IsInteger = require('./IsInteger');
var SetValueInBuffer = require('./SetValueInBuffer');
var ToNumber = require('./ToNumber');

var isNegativeZero = require('math-intrinsics/isNegativeZero');
var typedArrayBuffer = require('typed-array-buffer');
var typedArrayByteOffset = require('typed-array-byte-offset');
var typedArrayLength = require('typed-array-length');
var whichTypedArray = require('which-typed-array');

var tableTAO = require('./tables/typed-array-objects');

// https://262.ecma-international.org/8.0/#sec-integerindexedelementset

module.exports = function IntegerIndexedElementSet(O, index, value) {
	if (typeof index !== 'number') {
		throw new $TypeError('`index` must be a Number'); // step 1
	}
	var arrayTypeName = whichTypedArray(O); // step 12
	if (!arrayTypeName) {
		throw new $TypeError('`O` must be a TypedArray'); // step 2
	}
	if (arrayTypeName === 'BigInt64Array' || arrayTypeName === 'BigUint64Array') {
		throw new $SyntaxError('BigInt64Array and BigUint64Array do not exist until ES2020'); // step 2
	}

	var numValue = ToNumber(value); // step 3

	var buffer = typedArrayBuffer(O); // step 5

	if (IsDetachedBuffer(buffer)) {
		throw new $TypeError('`O` has a detached buffer'); // step 6
	}

	if (!IsInteger(index) || isNegativeZero(index)) {
		return false; // steps 7 - 8
	}

	var length = typedArrayLength(O); // step 9

	if (index < 0 || index >= length) {
		return false; // step 10
	}

	var offset = typedArrayByteOffset(O); // step 11

	var elementType = tableTAO.name['$' + arrayTypeName]; // step 15

	var elementSize = tableTAO.size['$' + elementType]; // step 13

	var indexedPosition = (index * elementSize) + offset; // step 14

	SetValueInBuffer(buffer, indexedPosition, elementType, numValue, true, 'Unordered'); // step 16

	return true; // step 17
};
'use strict';

var $TypeError = require('es-errors/type');
var isObject = require('es-object-atoms/isObject');

var Call = require('./Call');
var CreateDataProperty = require('./CreateDataProperty');
var EnumerableOwnPropertyNames = require('./EnumerableOwnPropertyNames');
var Get = require('./Get');
var IsArray = require('./IsArray');
var ToLength = require('./ToLength');
var ToString = require('./ToString');

var forEach = require('../helpers/forEach');

// https://262.ecma-international.org/9.0/#sec-internalizejsonproperty

// note: `reviver` was implicitly closed-over until ES2020, where it becomes a third argument

module.exports = function InternalizeJSONProperty(holder, name, reviver) {
	if (!isObject(holder)) {
		throw new $TypeError('Assertion failed: `holder` is not an Object');
	}
	if (typeof name !== 'string') {
		throw new $TypeError('Assertion failed: `name` is not a String');
	}
	if (typeof reviver !== 'function') {
		throw new $TypeError('Assertion failed: `reviver` is not a Function');
	}

	var val = Get(holder, name); // step 1

	if (isObject(val)) { // step 2
		var isArray = IsArray(val); // step 2.a
		if (isArray) { // step 2.b
			var I = 0; // step 2.b.i

			var len = ToLength(Get(val, 'length')); // step 2.b.ii

			while (I < len) { // step 2.b.iii
				var newElement = InternalizeJSONProperty(val, ToString(I), reviver); // step 2.b.iv.1

				if (typeof newElement === 'undefined') { // step 2.b.iii.2
					delete val[ToString(I)]; // step 2.b.iii.2.a
				} else { // step 2.b.iii.3
					CreateDataProperty(val, ToString(I), newElement); // step 2.b.iii.3.a
				}

				I += 1; // step 2.b.iii.4
			}
		} else { // step 2.c
			var keys = EnumerableOwnPropertyNames(val, 'key'); // step 2.c.i

			forEach(keys, function (P) { // step 2.c.ii
				// eslint-disable-next-line no-shadow
				var newElement = InternalizeJSONProperty(val, P, reviver); // step 2.c.ii.1

				if (typeof newElement === 'undefined') { // step 2.c.ii.2
					delete val[P]; // step 2.c.ii.2.a
				} else { // step 2.c.ii.3
					CreateDataProperty(val, P, newElement); // step 2.c.ii.3.a
				}
			});
		}
	}

	return Call(reviver, holder, [name, val]); // step 3
};
'use strict';

var $TypeError = require('es-errors/type');

var Call = require('./Call');
var IsArray = require('./IsArray');
var GetV = require('./GetV');
var isPropertyKey = require('../helpers/isPropertyKey');

// https://262.ecma-international.org/6.0/#sec-invoke

module.exports = function Invoke(O, P) {
	if (!isPropertyKey(P)) {
		throw new $TypeError('Assertion failed: P must be a Property Key');
	}
	var argumentsList = arguments.length > 2 ? arguments[2] : [];
	if (!IsArray(argumentsList)) {
		throw new $TypeError('Assertion failed: optional `argumentsList`, if provided, must be a List');
	}
	var func = GetV(O, P);
	return Call(func, O, argumentsList);
};
'use strict';

var $TypeError = require('es-errors/type');

var hasOwn = require('hasown');

var isPropertyDescriptor = require('../helpers/records/property-descriptor');

// https://262.ecma-international.org/5.1/#sec-8.10.1

module.exports = function IsAccessorDescriptor(Desc) {
	if (typeof Desc === 'undefined') {
		return false;
	}

	if (!isPropertyDescriptor(Desc)) {
		throw new $TypeError('Assertion failed: `Desc` must be a Property Descriptor');
	}

	if (!hasOwn(Desc, '[[Get]]') && !hasOwn(Desc, '[[Set]]')) {
		return false;
	}

	return true;
};
'use strict';

// https://262.ecma-international.org/6.0/#sec-isarray
module.exports = require('../helpers/IsArray');
'use strict';

// http://262.ecma-international.org/5.1/#sec-9.11

module.exports = require('is-callable');
'use strict';

var ValidateAndApplyPropertyDescriptor = require('./ValidateAndApplyPropertyDescriptor');

// https://262.ecma-international.org/6.0/#sec-iscompatiblepropertydescriptor

module.exports = function IsCompatiblePropertyDescriptor(Extensible, Desc, Current) {
	return ValidateAndApplyPropertyDescriptor(undefined, undefined, Extensible, Desc, Current);
};
'use strict';

var GetIntrinsic = require('get-intrinsic');

var $isConcatSpreadable = GetIntrinsic('%Symbol.isConcatSpreadable%', true);

var Get = require('./Get');
var IsArray = require('./IsArray');
var ToBoolean = require('./ToBoolean');

var isObject = require('es-object-atoms/isObject');

// https://262.ecma-international.org/6.0/#sec-isconcatspreadable

module.exports = function IsConcatSpreadable(O) {
	if (!isObject(O)) {
		return false;
	}
	if ($isConcatSpreadable) {
		var spreadable = Get(O, $isConcatSpreadable);
		if (typeof spreadable !== 'undefined') {
			return ToBoolean(spreadable);
		}
	}
	return IsArray(O);
};
'use strict';

var GetIntrinsic = require('../GetIntrinsic.js');

var $construct = GetIntrinsic('%Reflect.construct%', true);

var DefinePropertyOrThrow = require('./DefinePropertyOrThrow');
try {
	DefinePropertyOrThrow({}, '', { '[[Get]]': function () {} });
} catch (e) {
	// Accessor properties aren't supported
	DefinePropertyOrThrow = null;
}

// https://262.ecma-international.org/6.0/#sec-isconstructor

if (DefinePropertyOrThrow && $construct) {
	var isConstructorMarker = {};
	var badArrayLike = {};
	DefinePropertyOrThrow(badArrayLike, 'length', {
		'[[Get]]': function () {
			throw isConstructorMarker;
		},
		'[[Enumerable]]': true
	});

	module.exports = function IsConstructor(argument) {
		try {
			// `Reflect.construct` invokes `IsConstructor(target)` before `Get(args, 'length')`:
			$construct(argument, badArrayLike);
		} catch (err) {
			return err === isConstructorMarker;
		}
	};
} else {
	module.exports = function IsConstructor(argument) {
		// unfortunately there's no way to truly check this without try/catch `new argument` in old environments
		return typeof argument === 'function' && !!argument.prototype;
	};
}
'use strict';

var $TypeError = require('es-errors/type');

var hasOwn = require('hasown');

var isPropertyDescriptor = require('../helpers/records/property-descriptor');

// https://262.ecma-international.org/5.1/#sec-8.10.2

module.exports = function IsDataDescriptor(Desc) {
	if (typeof Desc === 'undefined') {
		return false;
	}

	if (!isPropertyDescriptor(Desc)) {
		throw new $TypeError('Assertion failed: `Desc` must be a Property Descriptor');
	}

	if (!hasOwn(Desc, '[[Value]]') && !hasOwn(Desc, '[[Writable]]')) {
		return false;
	}

	return true;
};
'use strict';

var $TypeError = require('es-errors/type');

var $byteLength = require('array-buffer-byte-length');
var availableTypedArrays = require('available-typed-arrays')();
var callBound = require('call-bound');
var isArrayBuffer = require('is-array-buffer');
var isSharedArrayBuffer = require('is-shared-array-buffer');

var $sabByteLength = callBound('SharedArrayBuffer.prototype.byteLength', true);

// https://262.ecma-international.org/8.0/#sec-isdetachedbuffer

module.exports = function IsDetachedBuffer(arrayBuffer) {
	var isSAB = isSharedArrayBuffer(arrayBuffer);
	if (!isArrayBuffer(arrayBuffer) && !isSAB) {
		throw new $TypeError('Assertion failed: `arrayBuffer` must be an Object with an [[ArrayBufferData]] internal slot');
	}
	if ((isSAB ? $sabByteLength : $byteLength)(arrayBuffer) === 0) {
		try {
			new global[availableTypedArrays[0]](arrayBuffer); // eslint-disable-line no-new
		} catch (error) {
			return !!error && error.name === 'TypeError';
		}
	}
	return false;
};
'use strict';

var GetIntrinsic = require('get-intrinsic');

var $preventExtensions = GetIntrinsic('%Object.preventExtensions%', true);
var $isExtensible = GetIntrinsic('%Object.isExtensible%', true);

var isPrimitive = require('../helpers/isPrimitive');

// https://262.ecma-international.org/6.0/#sec-isextensible-o

module.exports = $preventExtensions
	? function IsExtensible(obj) {
		return !isPrimitive(obj) && $isExtensible(obj);
	}
	: function IsExtensible(obj) {
		return !isPrimitive(obj);
	};
'use strict';

var $TypeError = require('es-errors/type');

var IsAccessorDescriptor = require('./IsAccessorDescriptor');
var IsDataDescriptor = require('./IsDataDescriptor');

var isPropertyDescriptor = require('../helpers/records/property-descriptor');

// https://262.ecma-international.org/6.0/#sec-isgenericdescriptor

module.exports = function IsGenericDescriptor(Desc) {
	if (typeof Desc === 'undefined') {
		return false;
	}

	if (!isPropertyDescriptor(Desc)) {
		throw new $TypeError('Assertion failed: `Desc` must be a Property Descriptor');
	}

	if (!IsAccessorDescriptor(Desc) && !IsDataDescriptor(Desc)) {
		return true;
	}

	return false;
};
'use strict';

var isInteger = require('math-intrinsics/isInteger');

// https://262.ecma-international.org/6.0/#sec-isinteger

module.exports = function IsInteger(argument) {
	return isInteger(argument);
};
'use strict';

var callBound = require('call-bound');

var $PromiseThen = callBound('Promise.prototype.then', true);

var isObject = require('es-object-atoms/isObject');

// https://262.ecma-international.org/6.0/#sec-ispromise

module.exports = function IsPromise(x) {
	if (!isObject(x)) {
		return false;
	}
	if (!$PromiseThen) { // Promises are not supported
		return false;
	}
	try {
		$PromiseThen(x); // throws if not a promise
	} catch (e) {
		return false;
	}
	return true;
};
'use strict';

var isPropertyKey = require('../helpers/isPropertyKey');

// https://262.ecma-international.org/6.0/#sec-ispropertykey

module.exports = function IsPropertyKey(argument) {
	return isPropertyKey(argument);
};
'use strict';

var GetIntrinsic = require('get-intrinsic');

var $match = GetIntrinsic('%Symbol.match%', true);

var hasRegExpMatcher = require('is-regex');
var isObject = require('es-object-atoms/isObject');

var ToBoolean = require('./ToBoolean');

// https://262.ecma-international.org/6.0/#sec-isregexp

module.exports = function IsRegExp(argument) {
	if (!isObject(argument)) {
		return false;
	}
	if ($match) {
		var isRegExp = argument[$match];
		if (typeof isRegExp !== 'undefined') {
			return ToBoolean(isRegExp);
		}
	}
	return hasRegExpMatcher(argument);
};
'use strict';

var $TypeError = require('es-errors/type');
var isObject = require('es-object-atoms/isObject');

var isSharedArrayBuffer = require('is-shared-array-buffer');

// https://262.ecma-international.org/8.0/#sec-issharedarraybuffer

module.exports = function IsSharedArrayBuffer(obj) {
	if (!isObject(obj)) {
		throw new $TypeError('Assertion failed: Type(O) is not Object');
	}

	return isSharedArrayBuffer(obj);
};
'use strict';

var $TypeError = require('es-errors/type');

var isPrefixOf = require('../helpers/isPrefixOf');

// var callBound = require('call-bound');

// var $charAt = callBound('String.prototype.charAt');

// https://262.ecma-international.org/9.0/#sec-isstringprefix

module.exports = function IsStringPrefix(p, q) {
	if (typeof p !== 'string') {
		throw new $TypeError('Assertion failed: "p" must be a String');
	}

	if (typeof q !== 'string') {
		throw new $TypeError('Assertion failed: "q" must be a String');
	}

	return isPrefixOf(p, q);
	/*
	if (p === q || p === '') {
		return true;
	}

	var pLength = p.length;
	var qLength = q.length;
	if (pLength >= qLength) {
		return false;
	}

	// assert: pLength < qLength

	for (var i = 0; i < pLength; i += 1) {
		if ($charAt(p, i) !== $charAt(q, i)) {
			return false;
		}
	}
	return true;
	*/
};
'use strict';

var $TypeError = require('es-errors/type');

var callBound = require('call-bound');

var $indexOf = callBound('String.prototype.indexOf');

var IsArray = require('./IsArray');
var IsInteger = require('./IsInteger');
var WordCharacters = require('./WordCharacters');

var every = require('../helpers/every');

var isChar = function isChar(c) {
	return typeof c === 'string';
};

// https://262.ecma-international.org/8.0/#sec-runtime-semantics-iswordchar-abstract-operation

// note: prior to ES2023, this AO erroneously omitted the latter of its arguments.
module.exports = function IsWordChar(e, InputLength, Input, IgnoreCase, Unicode) {
	if (!IsInteger(e)) {
		throw new $TypeError('Assertion failed: `e` must be an integer');
	}
	if (!IsInteger(InputLength)) {
		throw new $TypeError('Assertion failed: `InputLength` must be an integer');
	}
	if (!IsArray(Input) || !every(Input, isChar)) {
		throw new $TypeError('Assertion failed: `Input` must be a List of characters');
	}
	if (typeof IgnoreCase !== 'boolean' || typeof Unicode !== 'boolean') {
		throw new $TypeError('Assertion failed: `IgnoreCase` and `Unicode` must be booleans');
	}

	if (e === -1 || e === InputLength) {
		return false; // step 1
	}

	var c = Input[e]; // step 2

	var wordChars = WordCharacters(IgnoreCase, Unicode);

	return $indexOf(wordChars, c) > -1; // steps 3-4
};
'use strict';

var GetIterator = require('./GetIterator');
var IteratorStep = require('./IteratorStep');
var IteratorValue = require('./IteratorValue');

// https://262.ecma-international.org/8.0/#sec-iterabletolist

module.exports = function IterableToList(items, method) {
	var iterator = GetIterator(items, method);
	var values = [];
	var next = true;
	while (next) {
		next = IteratorStep(iterator);
		if (next) {
			var nextValue = IteratorValue(next);
			values[values.length] = nextValue;
		}
	}
	return values;
};
'use strict';

var $TypeError = require('es-errors/type');
var isObject = require('es-object-atoms/isObject');

var Call = require('./Call');
var CompletionRecord = require('./CompletionRecord');
var GetMethod = require('./GetMethod');
var IsCallable = require('./IsCallable');

// https://262.ecma-international.org/6.0/#sec-iteratorclose

module.exports = function IteratorClose(iterator, completion) {
	if (!isObject(iterator)) {
		throw new $TypeError('Assertion failed: Type(iterator) is not Object');
	}
	if (!IsCallable(completion) && !(completion instanceof CompletionRecord)) {
		throw new $TypeError('Assertion failed: completion is not a thunk representing a Completion Record, nor a Completion Record instance');
	}
	var completionThunk = completion instanceof CompletionRecord ? function () { return completion['?'](); } : completion;

	var iteratorReturn = GetMethod(iterator, 'return');

	if (typeof iteratorReturn === 'undefined') {
		return completionThunk();
	}

	var completionRecord;
	try {
		var innerResult = Call(iteratorReturn, iterator, []);
	} catch (e) {
		// if we hit here, then "e" is the innerResult completion that needs re-throwing

		// if the completion is of type "throw", this will throw.
		completionThunk();
		completionThunk = null; // ensure it's not called twice.

		// if not, then return the innerResult completion
		throw e;
	}
	completionRecord = completionThunk(); // if innerResult worked, then throw if the completion does
	completionThunk = null; // ensure it's not called twice.

	if (!isObject(innerResult)) {
		throw new $TypeError('iterator .return must return an object');
	}

	return completionRecord;
};
'use strict';

var $TypeError = require('es-errors/type');
var isObject = require('es-object-atoms/isObject');

var Get = require('./Get');
var ToBoolean = require('./ToBoolean');

// https://262.ecma-international.org/6.0/#sec-iteratorcomplete

module.exports = function IteratorComplete(iterResult) {
	if (!isObject(iterResult)) {
		throw new $TypeError('Assertion failed: Type(iterResult) is not Object');
	}
	return ToBoolean(Get(iterResult, 'done'));
};
'use strict';

var $TypeError = require('es-errors/type');
var isObject = require('es-object-atoms/isObject');

var Invoke = require('./Invoke');

// https://262.ecma-international.org/6.0/#sec-iteratornext

module.exports = function IteratorNext(iterator, value) {
	var result = Invoke(iterator, 'next', arguments.length < 2 ? [] : [value]);
	if (!isObject(result)) {
		throw new $TypeError('iterator next must return an object');
	}
	return result;
};
'use strict';

var IteratorComplete = require('./IteratorComplete');
var IteratorNext = require('./IteratorNext');

// https://262.ecma-international.org/6.0/#sec-iteratorstep

module.exports = function IteratorStep(iterator) {
	var result = IteratorNext(iterator);
	var done = IteratorComplete(result);
	return done === true ? false : result;
};

'use strict';

var $TypeError = require('es-errors/type');
var isObject = require('es-object-atoms/isObject');

var Get = require('./Get');

// https://262.ecma-international.org/6.0/#sec-iteratorvalue

module.exports = function IteratorValue(iterResult) {
	if (!isObject(iterResult)) {
		throw new $TypeError('Assertion failed: Type(iterResult) is not Object');
	}
	return Get(iterResult, 'value');
};

'use strict';

var $isFinite = require('math-intrinsics/isFinite');

var msPerDay = require('../helpers/timeConstants').msPerDay;

// https://262.ecma-international.org/5.1/#sec-15.9.1.13

module.exports = function MakeDate(day, time) {
	if (!$isFinite(day) || !$isFinite(time)) {
		return NaN;
	}
	return (day * msPerDay) + time;
};
'use strict';

var GetIntrinsic = require('get-intrinsic');

var $DateUTC = GetIntrinsic('%Date.UTC%');

var $isFinite = require('math-intrinsics/isFinite');

var DateFromTime = require('./DateFromTime');
var Day = require('./Day');
var floor = require('./floor');
var modulo = require('./modulo');
var MonthFromTime = require('./MonthFromTime');
var ToInteger = require('./ToInteger');
var YearFromTime = require('./YearFromTime');

// https://262.ecma-international.org/5.1/#sec-15.9.1.12

module.exports = function MakeDay(year, month, date) {
	if (!$isFinite(year) || !$isFinite(month) || !$isFinite(date)) {
		return NaN;
	}
	var y = ToInteger(year);
	var m = ToInteger(month);
	var dt = ToInteger(date);
	var ym = y + floor(m / 12);
	var mn = modulo(m, 12);
	var t = $DateUTC(ym, mn, 1);
	if (YearFromTime(t) !== ym || MonthFromTime(t) !== mn || DateFromTime(t) !== 1) {
		return NaN;
	}
	return Day(t) + dt - 1;
};
'use strict';

var $isFinite = require('math-intrinsics/isFinite');

var timeConstants = require('../helpers/timeConstants');
var msPerSecond = timeConstants.msPerSecond;
var msPerMinute = timeConstants.msPerMinute;
var msPerHour = timeConstants.msPerHour;

var ToInteger = require('./ToInteger');

// https://262.ecma-international.org/5.1/#sec-15.9.1.11

module.exports = function MakeTime(hour, min, sec, ms) {
	if (!$isFinite(hour) || !$isFinite(min) || !$isFinite(sec) || !$isFinite(ms)) {
		return NaN;
	}
	var h = ToInteger(hour);
	var m = ToInteger(min);
	var s = ToInteger(sec);
	var milli = ToInteger(ms);
	var t = (h * msPerHour) + (m * msPerMinute) + (s * msPerSecond) + milli;
	return t;
};
'use strict';

// https://262.ecma-international.org/6.0/#sec-algorithm-conventions

module.exports = require('math-intrinsics/max');
'use strict';

var floor = require('./floor');
var modulo = require('./modulo');

var timeConstants = require('../helpers/timeConstants');
var msPerMinute = timeConstants.msPerMinute;
var MinutesPerHour = timeConstants.MinutesPerHour;

// https://262.ecma-international.org/5.1/#sec-15.9.1.10

module.exports = function MinFromTime(t) {
	return modulo(floor(t / msPerMinute), MinutesPerHour);
};
'use strict';

// https://262.ecma-international.org/6.0/#sec-algorithm-conventions

module.exports = require('math-intrinsics/min');
'use strict';

var mod = require('../helpers/mod');

// https://262.ecma-international.org/5.1/#sec-5.2

module.exports = function modulo(x, y) {
	return mod(x, y);
};
'use strict';

var $RangeError = require('es-errors/range');

var DayWithinYear = require('./DayWithinYear');
var InLeapYear = require('./InLeapYear');

// https://262.ecma-international.org/5.1/#sec-15.9.1.4

module.exports = function MonthFromTime(t) {
	var day = DayWithinYear(t);
	if (0 <= day && day < 31) {
		return 0;
	}
	var leap = InLeapYear(t);
	if (31 <= day && day < (59 + leap)) {
		return 1;
	}
	if ((59 + leap) <= day && day < (90 + leap)) {
		return 2;
	}
	if ((90 + leap) <= day && day < (120 + leap)) {
		return 3;
	}
	if ((120 + leap) <= day && day < (151 + leap)) {
		return 4;
	}
	if ((151 + leap) <= day && day < (181 + leap)) {
		return 5;
	}
	if ((181 + leap) <= day && day < (212 + leap)) {
		return 6;
	}
	if ((212 + leap) <= day && day < (243 + leap)) {
		return 7;
	}
	if ((243 + leap) <= day && day < (273 + leap)) {
		return 8;
	}
	if ((273 + leap) <= day && day < (304 + leap)) {
		return 9;
	}
	if ((304 + leap) <= day && day < (334 + leap)) {
		return 10;
	}
	if ((334 + leap) <= day && day < (365 + leap)) {
		return 11;
	}

	throw new $RangeError('Assertion failed: `day` is out of range');
};
'use strict';

var modulo = require('./modulo');

var msPerSecond = require('../helpers/timeConstants').msPerSecond;

// https://262.ecma-international.org/5.1/#sec-15.9.1.10

module.exports = function msFromTime(t) {
	return modulo(t, msPerSecond);
};
'use strict';

var $TypeError = require('es-errors/type');

var IsCallable = require('./IsCallable');
var IsConstructor = require('./IsConstructor');

// https://262.ecma-international.org/6.0/#sec-newpromisecapability

module.exports = function NewPromiseCapability(C) {
	if (!IsConstructor(C)) {
		throw new $TypeError('C must be a constructor'); // step 1
	}

	var resolvingFunctions = { '[[Resolve]]': void undefined, '[[Reject]]': void undefined }; // step 3

	var promise = new C(function (resolve, reject) { // steps 4-5
		if (typeof resolvingFunctions['[[Resolve]]'] !== 'undefined' || typeof resolvingFunctions['[[Reject]]'] !== 'undefined') {
			throw new $TypeError('executor has already been called'); // step 4.a, 4.b
		}
		resolvingFunctions['[[Resolve]]'] = resolve; // step 4.c
		resolvingFunctions['[[Reject]]'] = reject; // step 4.d
	}); // step 4-6

	if (!IsCallable(resolvingFunctions['[[Resolve]]']) || !IsCallable(resolvingFunctions['[[Reject]]'])) {
		throw new $TypeError('executor must provide valid resolve and reject functions'); // steps 7-8
	}

	return {
		'[[Promise]]': promise,
		'[[Resolve]]': resolvingFunctions['[[Resolve]]'],
		'[[Reject]]': resolvingFunctions['[[Reject]]']
	}; // step 9
};
'use strict';

var CompletionRecord = require('./CompletionRecord');

// https://262.ecma-international.org/6.0/#sec-normalcompletion

module.exports = function NormalCompletion(value) {
	return new CompletionRecord('normal', value);
};
'use strict';

var $TypeError = require('es-errors/type');

var hasOwnProperty = require('./HasOwnProperty');
var ToInt16 = require('./ToInt16');
var ToInt32 = require('./ToInt32');
var ToInt8 = require('./ToInt8');
var ToUint16 = require('./ToUint16');
var ToUint32 = require('./ToUint32');
var ToUint8 = require('./ToUint8');
var ToUint8Clamp = require('./ToUint8Clamp');

var valueToFloat32Bytes = require('../helpers/valueToFloat32Bytes');
var valueToFloat64Bytes = require('../helpers/valueToFloat64Bytes');
var integerToNBytes = require('../helpers/integerToNBytes');

var tableTAO = require('./tables/typed-array-objects');

// https://262.ecma-international.org/8.0/#table-50

var TypeToAO = {
	__proto__: null,
	$Int8: ToInt8,
	$Uint8: ToUint8,
	$Uint8C: ToUint8Clamp,
	$Int16: ToInt16,
	$Uint16: ToUint16,
	$Int32: ToInt32,
	$Uint32: ToUint32
};

// https://262.ecma-international.org/8.0/#sec-numbertorawbytes

module.exports = function NumberToRawBytes(type, value, isLittleEndian) {
	if (typeof type !== 'string' || !hasOwnProperty(tableTAO.size, '$' + type)) {
		throw new $TypeError('Assertion failed: `type` must be a TypedArray element type');
	}
	if (typeof value !== 'number') {
		throw new $TypeError('Assertion failed: `value` must be a Number');
	}
	if (typeof isLittleEndian !== 'boolean') {
		throw new $TypeError('Assertion failed: `isLittleEndian` must be a Boolean');
	}

	if (type === 'Float32') { // step 1
		return valueToFloat32Bytes(value, isLittleEndian);
	} else if (type === 'Float64') { // step 2
		return valueToFloat64Bytes(value, isLittleEndian);
	} // step 3

	var n = tableTAO.size['$' + type]; // step 3.a

	var convOp = TypeToAO['$' + type]; // step 3.b

	var intValue = convOp(value); // step 3.c

	return integerToNBytes(intValue, n, isLittleEndian); // step 3.d, 3.e, 4
};
'use strict';

var GetIntrinsic = require('get-intrinsic');

var $String = GetIntrinsic('%String%');
var $TypeError = require('es-errors/type');

// https://262.ecma-international.org/9.0/#sec-tostring-applied-to-the-number-type

module.exports = function NumberToString(m) {
	if (typeof m !== 'number') {
		throw new $TypeError('Assertion failed: "m" must be a String');
	}

	return $String(m);
};

'use strict';

var GetIntrinsic = require('get-intrinsic');

var $ObjectCreate = GetIntrinsic('%Object.create%', true);
var $TypeError = require('es-errors/type');
var $SyntaxError = require('es-errors/syntax');
var isObject = require('es-object-atoms/isObject');

var IsArray = require('./IsArray');

var forEach = require('../helpers/forEach');

var SLOT = require('internal-slot');

var hasProto = require('has-proto')();

// https://262.ecma-international.org/6.0/#sec-objectcreate

module.exports = function ObjectCreate(proto, internalSlotsList) {
	if (proto !== null && !isObject(proto)) {
		throw new $TypeError('Assertion failed: `proto` must be null or an object');
	}
	var slots = arguments.length < 2 ? [] : internalSlotsList; // step 1
	if (arguments.length >= 2 && !IsArray(slots)) {
		throw new $TypeError('Assertion failed: `internalSlotsList` must be an Array');
	}

	var O;
	if (hasProto) {
		O = { __proto__: proto };
	} else if ($ObjectCreate) {
		O = $ObjectCreate(proto);
	} else {
		if (proto === null) {
			throw new $SyntaxError('native Object.create support is required to create null objects');
		}
		var T = function T() {};
		T.prototype = proto;
		O = new T();
	}

	if (slots.length > 0) {
		forEach(slots, function (slot) {
			SLOT.set(O, slot, void undefined);
		});
	}

	return O; // step 6
};
'use strict';

var DefinePropertyOrThrow = require('./DefinePropertyOrThrow');
var Get = require('./Get');
var OrdinaryGetOwnProperty = require('./OrdinaryGetOwnProperty');
var ToObject = require('./ToObject');
var ToPropertyDescriptor = require('./ToPropertyDescriptor');

var forEach = require('../helpers/forEach');
var OwnPropertyKeys = require('own-keys');

// https://262.ecma-international.org/6.0/#sec-objectdefineproperties

/** @type {<T extends Record<PropertyKey, unknown> = {}>(O: T, Properties: object) => T} */
module.exports = function ObjectDefineProperties(O, Properties) {
	var props = ToObject(Properties); // step 1
	var keys = OwnPropertyKeys(props); // step 2
	/** @type {[string | symbol, import('../types').Descriptor][]} */
	var descriptors = []; // step 3

	forEach(keys, function (nextKey) { // step 4
		var propDesc = OrdinaryGetOwnProperty(props, nextKey); // ToPropertyDescriptor(getOwnPropertyDescriptor(props, nextKey)); // step 4.a
		if (typeof propDesc !== 'undefined' && propDesc['[[Enumerable]]']) { // step 4.b
			var descObj = Get(props, nextKey); // step 4.b.i
			var desc = ToPropertyDescriptor(descObj); // step 4.b.ii
			descriptors[descriptors.length] = [nextKey, desc]; // step 4.b.iii
		}
	});

	forEach(descriptors, function (pair) { // step 5
		var P = pair[0]; // step 5.a
		var desc = pair[1]; // step 5.b
		DefinePropertyOrThrow(O, P, desc); // step 5.c
	});

	return O; // step 6
};
'use strict';

var GetIntrinsic = require('get-intrinsic');
var $TypeError = require('es-errors/type');

var GetPrototypeFromConstructor = require('./GetPrototypeFromConstructor');
var IsArray = require('./IsArray');
var ObjectCreate = require('./ObjectCreate');

// https://262.ecma-international.org/6.0/#sec-ordinarycreatefromconstructor

module.exports = function OrdinaryCreateFromConstructor(constructor, intrinsicDefaultProto) {
	GetIntrinsic(intrinsicDefaultProto); // throws if not a valid intrinsic
	var proto = GetPrototypeFromConstructor(constructor, intrinsicDefaultProto);
	var slots = arguments.length < 3 ? [] : arguments[2];
	if (!IsArray(slots)) {
		throw new $TypeError('Assertion failed: if provided, `internalSlotsList` must be a List');
	}
	return ObjectCreate(proto, slots);
};
'use strict';

var $gOPD = require('gopd');
var $SyntaxError = require('es-errors/syntax');
var $TypeError = require('es-errors/type');
var isObject = require('es-object-atoms/isObject');

var isPropertyDescriptor = require('../helpers/records/property-descriptor');

var IsAccessorDescriptor = require('./IsAccessorDescriptor');
var IsExtensible = require('./IsExtensible');
var isPropertyKey = require('../helpers/isPropertyKey');
var ToPropertyDescriptor = require('./ToPropertyDescriptor');
var SameValue = require('./SameValue');
var ValidateAndApplyPropertyDescriptor = require('./ValidateAndApplyPropertyDescriptor');

// https://262.ecma-international.org/6.0/#sec-ordinarydefineownproperty

module.exports = function OrdinaryDefineOwnProperty(O, P, Desc) {
	if (!isObject(O)) {
		throw new $TypeError('Assertion failed: O must be an Object');
	}
	if (!isPropertyKey(P)) {
		throw new $TypeError('Assertion failed: P must be a Property Key');
	}
	if (!isPropertyDescriptor(Desc)) {
		throw new $TypeError('Assertion failed: Desc must be a Property Descriptor');
	}
	if (!$gOPD) {
		// ES3/IE 8 fallback
		if (IsAccessorDescriptor(Desc)) {
			throw new $SyntaxError('This environment does not support accessor property descriptors.');
		}
		var creatingNormalDataProperty = !(P in O)
			&& Desc['[[Writable]]']
			&& Desc['[[Enumerable]]']
			&& Desc['[[Configurable]]']
			&& '[[Value]]' in Desc;
		var settingExistingDataProperty = (P in O)
			&& (!('[[Configurable]]' in Desc) || Desc['[[Configurable]]'])
			&& (!('[[Enumerable]]' in Desc) || Desc['[[Enumerable]]'])
			&& (!('[[Writable]]' in Desc) || Desc['[[Writable]]'])
			&& '[[Value]]' in Desc;
		if (creatingNormalDataProperty || settingExistingDataProperty) {
			O[P] = Desc['[[Value]]']; // eslint-disable-line no-param-reassign
			return SameValue(O[P], Desc['[[Value]]']);
		}
		throw new $SyntaxError('This environment does not support defining non-writable, non-enumerable, or non-configurable properties');
	}
	var desc = $gOPD(O, P);
	var current = desc && ToPropertyDescriptor(desc);
	var extensible = IsExtensible(O);
	return ValidateAndApplyPropertyDescriptor(O, P, extensible, Desc, current);
};
'use strict';

var $gOPD = require('gopd');
var $TypeError = require('es-errors/type');
var isObject = require('es-object-atoms/isObject');
var hasOwn = require('hasown');
var callBound = require('call-bound');

var $isEnumerable = callBound('Object.prototype.propertyIsEnumerable');

var IsArray = require('./IsArray');
var isPropertyKey = require('../helpers/isPropertyKey');
var IsRegExp = require('./IsRegExp');
var ToPropertyDescriptor = require('./ToPropertyDescriptor');

// https://262.ecma-international.org/6.0/#sec-ordinarygetownproperty

module.exports = function OrdinaryGetOwnProperty(O, P) {
	if (!isObject(O)) {
		throw new $TypeError('Assertion failed: O must be an Object');
	}
	if (!isPropertyKey(P)) {
		throw new $TypeError('Assertion failed: P must be a Property Key');
	}
	if (!hasOwn(O, P)) {
		return void 0;
	}
	if (!$gOPD) {
		// ES3 / IE 8 fallback
		var arrayLength = IsArray(O) && P === 'length';
		var regexLastIndex = IsRegExp(O) && P === 'lastIndex';
		return {
			'[[Configurable]]': !(arrayLength || regexLastIndex),
			'[[Enumerable]]': $isEnumerable(O, P),
			'[[Value]]': O[P],
			'[[Writable]]': true
		};
	}
	return ToPropertyDescriptor($gOPD(O, P));
};
'use strict';

var $TypeError = require('es-errors/type');
var isObject = require('es-object-atoms/isObject');

var $getProto = require('get-proto');

// https://262.ecma-international.org/7.0/#sec-ordinarygetprototypeof

module.exports = function OrdinaryGetPrototypeOf(O) {
	if (!isObject(O)) {
		throw new $TypeError('Assertion failed: O must be an Object');
	}
	if (!$getProto) {
		throw new $TypeError('This environment does not support fetching prototypes.');
	}
	return $getProto(O);
};
'use strict';

var $TypeError = require('es-errors/type');
var isObject = require('es-object-atoms/isObject');

var Get = require('./Get');
var IsCallable = require('./IsCallable');

// https://262.ecma-international.org/6.0/#sec-ordinaryhasinstance

module.exports = function OrdinaryHasInstance(C, O) {
	if (!IsCallable(C)) {
		return false;
	}
	if (!isObject(O)) {
		return false;
	}
	var P = Get(C, 'prototype');
	if (!isObject(P)) {
		throw new $TypeError('OrdinaryHasInstance called on an object with an invalid prototype property.');
	}
	return O instanceof C;
};
'use strict';

var $TypeError = require('es-errors/type');
var isObject = require('es-object-atoms/isObject');

var isPropertyKey = require('../helpers/isPropertyKey');

// https://262.ecma-international.org/6.0/#sec-ordinaryhasproperty

module.exports = function OrdinaryHasProperty(O, P) {
	if (!isObject(O)) {
		throw new $TypeError('Assertion failed: Type(O) is not Object');
	}
	if (!isPropertyKey(P)) {
		throw new $TypeError('Assertion failed: P must be a Property Key');
	}
	return P in O;
};
'use strict';

var $TypeError = require('es-errors/type');
var $setProto = require('set-proto');
var isObject = require('es-object-atoms/isObject');

var OrdinaryGetPrototypeOf = require('./OrdinaryGetPrototypeOf');

// https://262.ecma-international.org/7.0/#sec-ordinarysetprototypeof

module.exports = function OrdinarySetPrototypeOf(O, V) {
	if (V !== null && !isObject(V)) {
		throw new $TypeError('Assertion failed: V must be Object or Null');
	}
	/*
	var extensible = IsExtensible(O);
	var current = OrdinaryGetPrototypeOf(O);
	if (SameValue(V, current)) {
		return true;
	}
	if (!extensible) {
		return false;
	}
	*/
	try {
		$setProto(O, V);
	} catch (e) {
		return false;
	}
	return OrdinaryGetPrototypeOf(O) === V;
	/*
	var p = V;
	var done = false;
	while (!done) {
		if (p === null) {
			done = true;
		} else if (SameValue(p, O)) {
			return false;
		} else {
			if (wat) {
				done = true;
			} else {
				p = p.[[Prototype]];
			}
		}
	}
	O.[[Prototype]] = V;
	return true;
	*/
};
'use strict';

var $TypeError = require('es-errors/type');
var isObject = require('es-object-atoms/isObject');

var Call = require('./Call');
var Get = require('./Get');
var IsCallable = require('./IsCallable');

var inspect = require('object-inspect');

// https://262.ecma-international.org/8.0/#sec-ordinarytoprimitive

module.exports = function OrdinaryToPrimitive(O, hint) {
	if (!isObject(O)) {
		throw new $TypeError('Assertion failed: Type(O) is not Object');
	}
	if (/* typeof hint !== 'string' || */ hint !== 'string' && hint !== 'number') {
		throw new $TypeError('Assertion failed: `hint` must be "string" or "number"');
	}

	var methodNames = hint === 'string' ? ['toString', 'valueOf'] : ['valueOf', 'toString'];

	for (var i = 0; i < methodNames.length; i += 1) {
		var name = methodNames[i];
		var method = Get(O, name);
		if (IsCallable(method)) {
			var result = Call(method, O);
			if (!isObject(result)) {
				return result;
			}
		}
	}

	throw new $TypeError('No primitive value for ' + inspect(O));
};
'use strict';

var GetIntrinsic = require('get-intrinsic');
var callBind = require('call-bind');
var $SyntaxError = require('es-errors/syntax');

var $resolve = GetIntrinsic('%Promise.resolve%', true);
var $PromiseResolve = $resolve && callBind($resolve);

// https://262.ecma-international.org/9.0/#sec-promise-resolve

module.exports = function PromiseResolve(C, x) {
	if (!$PromiseResolve) {
		throw new $SyntaxError('This environment does not support Promises.');
	}
	return $PromiseResolve(C, x);
};

'use strict';

var $TypeError = require('es-errors/type');

var callBound = require('call-bound');
var forEach = require('../helpers/forEach');
var isLeadingSurrogate = require('../helpers/isLeadingSurrogate');
var isTrailingSurrogate = require('../helpers/isTrailingSurrogate');

var $charCodeAt = callBound('String.prototype.charCodeAt');
var $strSplit = callBound('String.prototype.split');

var UnicodeEscape = require('./UnicodeEscape');
var UTF16Encoding = require('./UTF16Encoding');

var hasOwn = require('hasown');

// https://262.ecma-international.org/10.0/#sec-quotejsonstring

var escapes = {
	'\u0008': '\\b',
	'\u0009': '\\t',
	'\u000A': '\\n',
	'\u000C': '\\f',
	'\u000D': '\\r',
	'\u0022': '\\"',
	'\u005c': '\\\\'
};

module.exports = function QuoteJSONString(value) {
	if (typeof value !== 'string') {
		throw new $TypeError('Assertion failed: `value` must be a String');
	}
	var product = '"';
	if (value) {
		forEach($strSplit(value, ''), function (C) {
			if (hasOwn(escapes, C)) {
				product += escapes[C];
			} else {
				var cCharCode = $charCodeAt(C, 0);
				if (cCharCode < 0x20 || isLeadingSurrogate(cCharCode) || isTrailingSurrogate(cCharCode)) {
					product += UnicodeEscape(C);
				} else {
					product += UTF16Encoding(cCharCode);
				}
			}
		});
	}
	product += '"';
	return product;
};
'use strict';

var callBound = require('call-bound');

var $RangeError = require('es-errors/range');
var $TypeError = require('es-errors/type');

var $charAt = callBound('String.prototype.charAt');
var $reverse = callBound('Array.prototype.reverse');
var $slice = callBound('Array.prototype.slice');

var hasOwnProperty = require('./HasOwnProperty');
var IsArray = require('./IsArray');

var bytesAsFloat32 = require('../helpers/bytesAsFloat32');
var bytesAsFloat64 = require('../helpers/bytesAsFloat64');
var bytesAsInteger = require('../helpers/bytesAsInteger');
var every = require('../helpers/every');
var isByteValue = require('../helpers/isByteValue');

var tableTAO = require('./tables/typed-array-objects');

// https://262.ecma-international.org/8.0/#sec-rawbytestonumber

module.exports = function RawBytesToNumber(type, rawBytes, isLittleEndian) {
	if (typeof type !== 'string' || !hasOwnProperty(tableTAO.size, '$' + type)) {
		throw new $TypeError('Assertion failed: `type` must be a TypedArray element type');
	}
	if (!IsArray(rawBytes) || !every(rawBytes, isByteValue)) {
		throw new $TypeError('Assertion failed: `rawBytes` must be an Array of bytes');
	}
	if (typeof isLittleEndian !== 'boolean') {
		throw new $TypeError('Assertion failed: `isLittleEndian` must be a Boolean');
	}

	var elementSize = tableTAO.size['$' + type]; // step 1

	if (rawBytes.length !== elementSize) {
		// this assertion is not in the spec, but it'd be an editorial error if it were ever violated
		throw new $RangeError('Assertion failed: `rawBytes` must have a length of ' + elementSize + ' for type ' + type);
	}

	// eslint-disable-next-line no-param-reassign
	rawBytes = $slice(rawBytes, 0, elementSize);
	if (!isLittleEndian) {
		$reverse(rawBytes); // step 2
	}

	if (type === 'Float32') { // step 3
		return bytesAsFloat32(rawBytes);
	}

	if (type === 'Float64') { // step 4
		return bytesAsFloat64(rawBytes);
	}

	return bytesAsInteger(rawBytes, elementSize, $charAt(type, 0) === 'U', false);
};
'use strict';

var GetIntrinsic = require('get-intrinsic');

var $RegExp = GetIntrinsic('%RegExp%');

// var RegExpAlloc = require('./RegExpAlloc');
// var RegExpInitialize = require('./RegExpInitialize');
var ToString = require('./ToString');

// https://262.ecma-international.org/6.0/#sec-regexpcreate

module.exports = function RegExpCreate(P, F) {
	// var obj = RegExpAlloc($RegExp);
	// return RegExpInitialize(obj, P, F);

	// covers spec mechanics; bypass regex brand checking
	var pattern = typeof P === 'undefined' ? '' : ToString(P);
	var flags = typeof F === 'undefined' ? '' : ToString(F);
	return new $RegExp(pattern, flags);
};
'use strict';

var $TypeError = require('es-errors/type');
var isObject = require('es-object-atoms/isObject');
var regexExec = require('call-bound')('RegExp.prototype.exec');

var Call = require('./Call');
var Get = require('./Get');
var IsCallable = require('./IsCallable');

// https://262.ecma-international.org/6.0/#sec-regexpexec

module.exports = function RegExpExec(R, S) {
	if (!isObject(R)) {
		throw new $TypeError('Assertion failed: `R` must be an Object');
	}
	if (typeof S !== 'string') {
		throw new $TypeError('Assertion failed: `S` must be a String');
	}
	var exec = Get(R, 'exec');
	if (IsCallable(exec)) {
		var result = Call(exec, R, [S]);
		if (result === null || isObject(result)) {
			return result;
		}
		throw new $TypeError('"exec" method must return `null` or an Object');
	}
	return regexExec(R, S);
};
'use strict';

module.exports = require('es-object-atoms/RequireObjectCoercible');
'use strict';

var $isNaN = require('math-intrinsics/isNaN');

// http://262.ecma-international.org/5.1/#sec-9.12

module.exports = function SameValue(x, y) {
	if (x === y) { // 0 === -0, but they are not identical.
		if (x === 0) { return 1 / x === 1 / y; }
		return true;
	}
	return $isNaN(x) && $isNaN(y);
};
'use strict';

var $TypeError = require('es-errors/type');

var SameValue = require('./SameValue');

// https://262.ecma-international.org/7.0/#sec-samevaluenonnumber

module.exports = function SameValueNonNumber(x, y) {
	if (typeof x === 'number' || typeof x !== typeof y) {
		throw new $TypeError('SameValueNonNumber requires two non-number values of the same type.');
	}
	return SameValue(x, y);
};
'use strict';

var $isNaN = require('math-intrinsics/isNaN');

// https://262.ecma-international.org/6.0/#sec-samevaluezero

module.exports = function SameValueZero(x, y) {
	return (x === y) || ($isNaN(x) && $isNaN(y));
};
'use strict';

var floor = require('./floor');
var modulo = require('./modulo');

var timeConstants = require('../helpers/timeConstants');
var msPerSecond = timeConstants.msPerSecond;
var SecondsPerMinute = timeConstants.SecondsPerMinute;

// https://262.ecma-international.org/5.1/#sec-15.9.1.10

module.exports = function SecFromTime(t) {
	return modulo(floor(t / msPerSecond), SecondsPerMinute);
};
'use strict';

var $TypeError = require('es-errors/type');
var isInteger = require('math-intrinsics/isInteger');

var DefinePropertyOrThrow = require('./DefinePropertyOrThrow');
var HasOwnProperty = require('./HasOwnProperty');
var IsExtensible = require('./IsExtensible');

// https://262.ecma-international.org/9.0/#sec-setfunctionlength

module.exports = function SetFunctionLength(F, length) {
	if (typeof F !== 'function' || !IsExtensible(F) || HasOwnProperty(F, 'length')) {
		throw new $TypeError('Assertion failed: `F` must be an extensible function and lack an own `length` property');
	}
	if (typeof length !== 'number') {
		throw new $TypeError('Assertion failed: `length` must be a Number');
	}
	if (length < 0 || !isInteger(length)) {
		throw new $TypeError('Assertion failed: `length` must be an integer >= 0');
	}
	return DefinePropertyOrThrow(F, 'length', {
		'[[Configurable]]': true,
		'[[Enumerable]]': false,
		'[[Value]]': length,
		'[[Writable]]': false
	});
};
'use strict';

var hasOwn = require('hasown');

var $TypeError = require('es-errors/type');

var getSymbolDescription = require('get-symbol-description');

var DefinePropertyOrThrow = require('./DefinePropertyOrThrow');
var IsExtensible = require('./IsExtensible');

// https://262.ecma-international.org/6.0/#sec-setfunctionname

module.exports = function SetFunctionName(F, name) {
	if (typeof F !== 'function') {
		throw new $TypeError('Assertion failed: `F` must be a function');
	}
	if (!IsExtensible(F) || hasOwn(F, 'name')) {
		throw new $TypeError('Assertion failed: `F` must be extensible, and must not have a `name` own property');
	}
	if (typeof name !== 'symbol' && typeof name !== 'string') {
		throw new $TypeError('Assertion failed: `name` must be a Symbol or a String');
	}
	if (typeof name === 'symbol') {
		var description = getSymbolDescription(name);
		// eslint-disable-next-line no-param-reassign
		name = typeof description === 'undefined' ? '' : '[' + description + ']';
	}
	if (arguments.length > 2) {
		var prefix = arguments[2];
		// eslint-disable-next-line no-param-reassign
		name = prefix + ' ' + name;
	}
	return DefinePropertyOrThrow(F, 'name', {
		'[[Value]]': name,
		'[[Writable]]': false,
		'[[Enumerable]]': false,
		'[[Configurable]]': true
	});
};
'use strict';

var GetIntrinsic = require('get-intrinsic');

var $SyntaxError = require('es-errors/syntax');
var $TypeError = require('es-errors/type');
var isObject = require('es-object-atoms/isObject');
var $gOPD = require('gopd');
var $preventExtensions = GetIntrinsic('%Object.preventExtensions%', true);
var $gOPN = GetIntrinsic('%Object.getOwnPropertyNames%', true);

var forEach = require('../helpers/forEach');

var DefinePropertyOrThrow = require('./DefinePropertyOrThrow');
var IsAccessorDescriptor = require('./IsAccessorDescriptor');
var ToPropertyDescriptor = require('./ToPropertyDescriptor');

// https://262.ecma-international.org/6.0/#sec-setintegritylevel

module.exports = function SetIntegrityLevel(O, level) {
	if (!isObject(O)) {
		throw new $TypeError('Assertion failed: Type(O) is not Object');
	}
	if (level !== 'sealed' && level !== 'frozen') {
		throw new $TypeError('Assertion failed: `level` must be `"sealed"` or `"frozen"`');
	}
	if (!$preventExtensions) {
		throw new $SyntaxError('SetIntegrityLevel requires native `Object.preventExtensions` support');
	}
	var status = $preventExtensions(O);
	if (!status) {
		return false;
	}
	if (!$gOPN) {
		throw new $SyntaxError('SetIntegrityLevel requires native `Object.getOwnPropertyNames` support');
	}
	var theKeys = $gOPN(O);
	if (level === 'sealed') {
		forEach(theKeys, function (k) {
			DefinePropertyOrThrow(O, k, { configurable: false });
		});
	} else if (level === 'frozen') {
		forEach(theKeys, function (k) {
			var currentDesc = $gOPD(O, k);
			if (typeof currentDesc !== 'undefined') {
				var desc;
				if (IsAccessorDescriptor(ToPropertyDescriptor(currentDesc))) {
					desc = { configurable: false };
				} else {
					desc = { configurable: false, writable: false };
				}
				DefinePropertyOrThrow(O, k, desc);
			}
		});
	}
	return true;
};
'use strict';

var $TypeError = require('es-errors/type');
var isObject = require('es-object-atoms/isObject');

var isPropertyKey = require('../helpers/isPropertyKey');
var SameValue = require('./SameValue');

// IE 9 does not throw in strict mode when writability/configurability/extensibility is violated
var noThrowOnStrictViolation = (function () {
	try {
		delete [].length;
		return true;
	} catch (e) {
		return false;
	}
}());

// https://262.ecma-international.org/6.0/#sec-set-o-p-v-throw

module.exports = function Set(O, P, V, Throw) {
	if (!isObject(O)) {
		throw new $TypeError('Assertion failed: `O` must be an Object');
	}
	if (!isPropertyKey(P)) {
		throw new $TypeError('Assertion failed: `P` must be a Property Key');
	}
	if (typeof Throw !== 'boolean') {
		throw new $TypeError('Assertion failed: `Throw` must be a Boolean');
	}
	if (Throw) {
		O[P] = V; // eslint-disable-line no-param-reassign
		if (noThrowOnStrictViolation && !SameValue(O[P], V)) {
			throw new $TypeError('Attempted to assign to readonly property.');
		}
		return true;
	}
	try {
		O[P] = V; // eslint-disable-line no-param-reassign
		return noThrowOnStrictViolation ? SameValue(O[P], V) : true;
	} catch (e) {
		return false;
	}

};
'use strict';

var GetIntrinsic = require('get-intrinsic');

var $SyntaxError = require('es-errors/syntax');
var $TypeError = require('es-errors/type');
var $Uint8Array = GetIntrinsic('%Uint8Array%', true);

var isInteger = require('math-intrinsics/isInteger');

var IsDetachedBuffer = require('./IsDetachedBuffer');
var NumberToRawBytes = require('./NumberToRawBytes');

var isArrayBuffer = require('is-array-buffer');
var isSharedArrayBuffer = require('is-shared-array-buffer');
var hasOwn = require('hasown');

var tableTAO = require('./tables/typed-array-objects');

var defaultEndianness = require('../helpers/defaultEndianness');
var forEach = require('../helpers/forEach');

// https://262.ecma-international.org/8.0/#sec-setvalueinbuffer

/* eslint max-params: 0 */

module.exports = function SetValueInBuffer(arrayBuffer, byteIndex, type, value, isTypedArray, order) {
	var isSAB = isSharedArrayBuffer(arrayBuffer);
	if (!isArrayBuffer(arrayBuffer) && !isSAB) {
		throw new $TypeError('Assertion failed: `arrayBuffer` must be an ArrayBuffer or a SharedArrayBuffer');
	}

	if (!isInteger(byteIndex)) {
		throw new $TypeError('Assertion failed: `byteIndex` must be an integer');
	}

	if (typeof type !== 'string' || !hasOwn(tableTAO.size, '$' + type)) {
		throw new $TypeError('Assertion failed: `type` must be one of ' + tableTAO.choices);
	}

	if (typeof value !== 'number') {
		throw new $TypeError('Assertion failed: `value` must be a number');
	}

	if (typeof isTypedArray !== 'boolean') {
		throw new $TypeError('Assertion failed: `isTypedArray` must be a boolean');
	}
	if (order !== 'SeqCst' && order !== 'Unordered' && order !== 'Init') {
		throw new $TypeError('Assertion failed: `order` must be `"SeqCst"`, `"Unordered"`, or `"Init"`');
	}

	if (arguments.length > 6 && typeof arguments[6] !== 'boolean') {
		throw new $TypeError('Assertion failed: `isLittleEndian` must be a boolean, if present');
	}

	if (IsDetachedBuffer(arrayBuffer)) {
		throw new $TypeError('Assertion failed: ArrayBuffer is detached'); // step 1
	}

	// 2. Assert: There are sufficient bytes in arrayBuffer starting at byteIndex to represent a value of type.

	if (byteIndex < 0) {
		throw new $TypeError('Assertion failed: `byteIndex` must be non-negative'); // step 3
	}

	// 4. Assert: Type(value) is Number.

	// 5. Let block be arrayBuffer.[[ArrayBufferData]].

	var elementSize = tableTAO.size['$' + type]; // step 6

	// 7. If isLittleEndian is not present, set isLittleEndian to to the value of the [[LittleEndian]] field of the surrounding agent's Agent Record.
	var isLittleEndian = arguments.length > 6 ? arguments[6] : defaultEndianness === 'little'; // step 8

	var rawBytes = NumberToRawBytes(type, value, isLittleEndian); // step 8

	if (isSAB) { // step 9
		/*
			Let execution be the [[CandidateExecution]] field of the surrounding agent's Agent Record.
			Let eventList be the [[EventList]] field of the element in execution.[[EventsRecords]] whose [[AgentSignifier]] is AgentSignifier().
			If isTypedArray is true and IsNoTearConfiguration(type, order) is true, let noTear be true; otherwise let noTear be false.
			Append WriteSharedMemory { [[Order]]: order, [[NoTear]]: noTear, [[Block]]: block, [[ByteIndex]]: byteIndex, [[ElementSize]]: elementSize, [[Payload]]: rawBytes } to eventList.
		*/
		throw new $SyntaxError('SharedArrayBuffer is not supported by this implementation');
	} else {
		// 10. Store the individual bytes of rawBytes into block, in order, starting at block[byteIndex].
		var arr = new $Uint8Array(arrayBuffer, byteIndex, elementSize);
		forEach(rawBytes, function (rawByte, i) {
			arr[i] = rawByte;
		});
	}

	// 11. Return NormalCompletion(undefined).
};
'use strict';

var GetIntrinsic = require('get-intrinsic');

var $species = GetIntrinsic('%Symbol.species%', true);
var $TypeError = require('es-errors/type');
var isObject = require('es-object-atoms/isObject');

var IsConstructor = require('./IsConstructor');

// https://262.ecma-international.org/6.0/#sec-speciesconstructor

module.exports = function SpeciesConstructor(O, defaultConstructor) {
	if (!isObject(O)) {
		throw new $TypeError('Assertion failed: Type(O) is not Object');
	}
	var C = O.constructor;
	if (typeof C === 'undefined') {
		return defaultConstructor;
	}
	if (!isObject(C)) {
		throw new $TypeError('O.constructor is not an Object');
	}
	var S = $species ? C[$species] : void 0;
	if (S == null) {
		return defaultConstructor;
	}
	if (IsConstructor(S)) {
		return S;
	}
	throw new $TypeError('no constructor found');
};
'use strict';

var callBound = require('call-bound');

var $TypeError = require('es-errors/type');
var isInteger = require('math-intrinsics/isInteger');

var $charAt = callBound('String.prototype.charAt');

// https://262.ecma-international.org/6.0/#sec-splitmatch

module.exports = function SplitMatch(S, q, R) {
	if (typeof S !== 'string') {
		throw new $TypeError('Assertion failed: `S` must be a String');
	}
	if (!isInteger(q)) {
		throw new $TypeError('Assertion failed: `q` must be an integer');
	}
	if (typeof R !== 'string') {
		throw new $TypeError('Assertion failed: `R` must be a String');
	}
	var r = R.length;
	var s = S.length;
	if (q + r > s) {
		return false;
	}

	for (var i = 0; i < r; i += 1) {
		if ($charAt(S, q + i) !== $charAt(R, i)) {
			return false;
		}
	}

	return q + r;
};
'use strict';

var Type = require('./Type');

// https://262.ecma-international.org/5.1/#sec-11.9.6

module.exports = function StrictEqualityComparison(x, y) {
	if (Type(x) !== Type(y)) {
		return false;
	}
	if (typeof x === 'undefined' || x === null) {
		return true;
	}
	return x === y; // shortcut for steps 4-7
};
'use strict';

var GetIntrinsic = require('get-intrinsic');

var $Object = require('es-object-atoms');
var $StringPrototype = GetIntrinsic('%String.prototype%');
var $SyntaxError = require('es-errors/syntax');
var $TypeError = require('es-errors/type');
var setProto = require('set-proto');

var DefinePropertyOrThrow = require('./DefinePropertyOrThrow');

// https://262.ecma-international.org/6.0/#sec-stringcreate

module.exports = function StringCreate(value, prototype) {
	if (typeof value !== 'string') {
		throw new $TypeError('Assertion failed: `S` must be a String');
	}

	var S = $Object(value);
	if (prototype !== $StringPrototype) {
		if (setProto) {
			setProto(S, prototype);
		} else {
			throw new $SyntaxError('StringCreate: a `proto` argument that is not `String.prototype` is not supported in an environment that does not support setting the [[Prototype]]');
		}
	}

	var length = value.length;
	DefinePropertyOrThrow(S, 'length', {
		'[[Configurable]]': false,
		'[[Enumerable]]': false,
		'[[Value]]': length,
		'[[Writable]]': false
	});

	return S;
};
'use strict';

var $TypeError = require('es-errors/type');
var isObject = require('es-object-atoms/isObject');

var callBound = require('call-bound');
var $charAt = callBound('String.prototype.charAt');
var $stringToString = callBound('String.prototype.toString');

var CanonicalNumericIndexString = require('./CanonicalNumericIndexString');
var IsInteger = require('./IsInteger');

var isPropertyKey = require('../helpers/isPropertyKey');

var isNegativeZero = require('math-intrinsics/isNegativeZero');

// https://262.ecma-international.org/8.0/#sec-stringgetownproperty

module.exports = function StringGetOwnProperty(S, P) {
	var str;
	if (isObject(S)) {
		try {
			str = $stringToString(S);
		} catch (e) { /**/ }
	}
	if (typeof str !== 'string') {
		throw new $TypeError('Assertion failed: `S` must be a boxed string object');
	}
	if (!isPropertyKey(P)) {
		throw new $TypeError('Assertion failed: P is not a Property Key');
	}
	if (typeof P !== 'string') {
		return void undefined;
	}
	var index = CanonicalNumericIndexString(P);
	var len = str.length;
	if (typeof index === 'undefined' || !IsInteger(index) || isNegativeZero(index) || index < 0 || len <= index) {
		return void undefined;
	}
	var resultStr = $charAt(S, index);
	return {
		'[[Configurable]]': false,
		'[[Enumerable]]': true,
		'[[Value]]': resultStr,
		'[[Writable]]': false
	};
};
'use strict';

var $TypeError = require('es-errors/type');

var callBound = require('call-bound');

var $SymbolToString = callBound('Symbol.prototype.toString', true);

// https://262.ecma-international.org/6.0/#sec-symboldescriptivestring

module.exports = function SymbolDescriptiveString(sym) {
	if (typeof sym !== 'symbol') {
		throw new $TypeError('Assertion failed: `sym` must be a Symbol');
	}
	return $SymbolToString(sym);
};
'use strict';

var $gOPD = require('gopd');
var $TypeError = require('es-errors/type');

var every = require('../helpers/every');
var OwnPropertyKeys = require('own-keys');
var isObject = require('es-object-atoms/isObject');

var IsDataDescriptor = require('./IsDataDescriptor');
var IsExtensible = require('./IsExtensible');
var ToPropertyDescriptor = require('./ToPropertyDescriptor');

// https://262.ecma-international.org/6.0/#sec-testintegritylevel

module.exports = function TestIntegrityLevel(O, level) {
	if (!isObject(O)) {
		throw new $TypeError('Assertion failed: Type(O) is not Object');
	}
	if (level !== 'sealed' && level !== 'frozen') {
		throw new $TypeError('Assertion failed: `level` must be `"sealed"` or `"frozen"`');
	}
	var status = IsExtensible(O);
	if (status || !$gOPD) {
		return false;
	}
	var theKeys = OwnPropertyKeys(O);
	return theKeys.length === 0 || every(theKeys, function (k) {
		var currentDesc = $gOPD(O, k);
		if (typeof currentDesc !== 'undefined') {
			if (currentDesc.configurable) {
				return false;
			}
			if (level === 'frozen' && IsDataDescriptor(ToPropertyDescriptor(currentDesc)) && currentDesc.writable) {
				return false;
			}
		}
		return true;
	});
};
'use strict';

var $BooleanValueOf = require('call-bound')('Boolean.prototype.valueOf');

// https://262.ecma-international.org/6.0/#sec-properties-of-the-boolean-prototype-object

module.exports = function thisBooleanValue(value) {
	if (typeof value === 'boolean') {
		return value;
	}

	return $BooleanValueOf(value);
};
'use strict';

var callBound = require('call-bound');

var $NumberValueOf = callBound('Number.prototype.valueOf');

// https://262.ecma-international.org/6.0/#sec-properties-of-the-number-prototype-object

module.exports = function thisNumberValue(value) {
	if (typeof value === 'number') {
		return value;
	}

	return $NumberValueOf(value);
};

'use strict';

var $StringValueOf = require('call-bound')('String.prototype.valueOf');

// https://262.ecma-international.org/6.0/#sec-properties-of-the-string-prototype-object

module.exports = function thisStringValue(value) {
	if (typeof value === 'string') {
		return value;
	}

	return $StringValueOf(value);
};
'use strict';

var $SyntaxError = require('es-errors/syntax');
var callBound = require('call-bound');

var $SymbolValueOf = callBound('Symbol.prototype.valueOf', true);

// https://262.ecma-international.org/9.0/#sec-thissymbolvalue

module.exports = function thisSymbolValue(value) {
	if (typeof value === 'symbol') {
		return value;
	}

	if (!$SymbolValueOf) {
		throw new $SyntaxError('Symbols are not supported; thisSymbolValue requires that `value` be a Symbol or a Symbol object');
	}

	return $SymbolValueOf(value);
};
'use strict';

var timeValue = require('../helpers/timeValue');

// https://262.ecma-international.org/6.0/#sec-properties-of-the-date-prototype-object

module.exports = function thisTimeValue(value) {
	return timeValue(value);
};
'use strict';

var CompletionRecord = require('./CompletionRecord');

// https://262.ecma-international.org/9.0/#sec-throwcompletion

module.exports = function ThrowCompletion(argument) {
	return new CompletionRecord('throw', argument);
};
'use strict';

var GetIntrinsic = require('get-intrinsic');

var $Date = GetIntrinsic('%Date%');

var $isFinite = require('math-intrinsics/isFinite');
var abs = require('math-intrinsics/abs');

var ToNumber = require('./ToNumber');

// https://262.ecma-international.org/5.1/#sec-15.9.1.14

module.exports = function TimeClip(time) {
	if (!$isFinite(time) || abs(time) > 8.64e15) {
		return NaN;
	}
	return +new $Date(ToNumber(time));
};

'use strict';

var msPerDay = require('../helpers/timeConstants').msPerDay;

var DayFromYear = require('./DayFromYear');

// https://262.ecma-international.org/5.1/#sec-15.9.1.3

module.exports = function TimeFromYear(y) {
	return msPerDay * DayFromYear(y);
};
'use strict';

var $TypeError = require('es-errors/type');

var $isNaN = require('math-intrinsics/isNaN');
var padTimeComponent = require('../helpers/padTimeComponent');

var HourFromTime = require('./HourFromTime');
var MinFromTime = require('./MinFromTime');
var SecFromTime = require('./SecFromTime');

// https://262.ecma-international.org/9.0/#sec-timestring

module.exports = function TimeString(tv) {
	if (typeof tv !== 'number' || $isNaN(tv)) {
		throw new $TypeError('Assertion failed: `tv` must be a non-NaN Number');
	}
	var hour = HourFromTime(tv);
	var minute = MinFromTime(tv);
	var second = SecFromTime(tv);
	return padTimeComponent(hour) + ':' + padTimeComponent(minute) + ':' + padTimeComponent(second) + '\x20GMT';
};
'use strict';

var modulo = require('./modulo');

var msPerDay = require('../helpers/timeConstants').msPerDay;

// https://262.ecma-international.org/5.1/#sec-15.9.1.2

module.exports = function TimeWithinDay(t) {
	return modulo(t, msPerDay);
};

'use strict';

var GetIntrinsic = require('get-intrinsic');

var $Date = GetIntrinsic('%Date%');
var $TypeError = require('es-errors/type');

var isNaN = require('math-intrinsics/isNaN');

var callBound = require('call-bound');

var $indexOf = callBound('String.prototype.indexOf');
var $slice = callBound('String.prototype.slice');
var $toTimeString = callBound('Date.prototype.toTimeString');

// https://262.ecma-international.org/9.0/#sec-timezoneestring

module.exports = function TimeZoneString(tv) {
	if (typeof tv !== 'number' || isNaN(tv)) {
		throw new $TypeError('Assertion failed: `tv` must be a non-NaN Number'); // steps 1 - 2
	}

	// 3. Let offset be LocalTZA(tv, true).
	// 4. If offset ≥ 0, let offsetSign be "+"; otherwise, let offsetSign be "-".
	// 5. Let offsetMin be the String representation of MinFromTime(abs(offset)), formatted as a two-digit decimal number, padded to the left with a zero if necessary.
	// 6. Let offsetHour be the String representation of HourFromTime(abs(offset)), formatted as a two-digit decimal number, padded to the left with a zero if necessary.
	// 7. Let tzName be an implementation-defined string that is either the empty string or the string-concatenation of the code unit 0x0020 (SPACE), the code unit 0x0028 (LEFT PARENTHESIS), an implementation-dependent timezone name, and the code unit 0x0029 (RIGHT PARENTHESIS).
	// 8. Return the string-concatenation of offsetSign, offsetHour, offsetMin, and tzName.

	// hack until LocalTZA, and "implementation-defined string" are available
	var ts = $toTimeString(new $Date(tv));
	return $slice(ts, $indexOf(ts, '(') + 1, $indexOf(ts, ')'));
};
'use strict';

// http://262.ecma-international.org/5.1/#sec-9.2

module.exports = function ToBoolean(value) { return !!value; };
'use strict';

var GetIntrinsic = require('get-intrinsic');

var $TypeError = require('es-errors/type');
var $Date = GetIntrinsic('%Date%');
var $String = GetIntrinsic('%String%');

var $isNaN = require('math-intrinsics/isNaN');

// https://262.ecma-international.org/6.0/#sec-todatestring

module.exports = function ToDateString(tv) {
	if (typeof tv !== 'number') {
		throw new $TypeError('Assertion failed: `tv` must be a Number');
	}
	if ($isNaN(tv)) {
		return 'Invalid Date';
	}
	return $String(new $Date(tv));
};
'use strict';

var $RangeError = require('es-errors/range');

var ToInteger = require('./ToInteger');
var ToLength = require('./ToLength');
var SameValueZero = require('./SameValueZero');

// https://262.ecma-international.org/8.0/#sec-toindex

module.exports = function ToIndex(value) {
	if (typeof value === 'undefined') {
		return 0;
	}
	var integerIndex = ToInteger(value);
	if (integerIndex < 0) {
		throw new $RangeError('index must be >= 0');
	}
	var index = ToLength(integerIndex);
	if (!SameValueZero(integerIndex, index)) {
		throw new $RangeError('index must be >= 0 and < 2 ** 53 - 1');
	}
	return index;
};
'use strict';

var ToUint16 = require('./ToUint16');

// https://262.ecma-international.org/6.0/#sec-toint16

module.exports = function ToInt16(argument) {
	var int16bit = ToUint16(argument);
	return int16bit >= 0x8000 ? int16bit - 0x10000 : int16bit;
};
'use strict';

var ToNumber = require('./ToNumber');

// http://262.ecma-international.org/5.1/#sec-9.5

module.exports = function ToInt32(x) {
	return ToNumber(x) >> 0;
};
'use strict';

var ToUint8 = require('./ToUint8');

// https://262.ecma-international.org/6.0/#sec-toint8

module.exports = function ToInt8(argument) {
	var int8bit = ToUint8(argument);
	return int8bit >= 0x80 ? int8bit - 0x100 : int8bit;
};
'use strict';

var ES5ToInteger = require('../5/ToInteger');

var ToNumber = require('./ToNumber');

// https://262.ecma-international.org/6.0/#sec-tointeger

module.exports = function ToInteger(value) {
	var number = ToNumber(value);
	return ES5ToInteger(number);
};
'use strict';

var MAX_SAFE_INTEGER = require('math-intrinsics/constants/maxSafeInteger');

var ToInteger = require('./ToInteger');

// https://262.ecma-international.org/6.0/#sec-tolength

module.exports = function ToLength(argument) {
	var len = ToInteger(argument);
	if (len <= 0) { return 0; } // includes converting -0 to +0
	if (len > MAX_SAFE_INTEGER) { return MAX_SAFE_INTEGER; }
	return len;
};
'use strict';

var GetIntrinsic = require('get-intrinsic');

var $TypeError = require('es-errors/type');
var $Number = GetIntrinsic('%Number%');
var $RegExp = GetIntrinsic('%RegExp%');
var $parseInteger = GetIntrinsic('%parseInt%');

var callBound = require('call-bound');
var regexTester = require('safe-regex-test');
var isPrimitive = require('../helpers/isPrimitive');

var $strSlice = callBound('String.prototype.slice');
var isBinary = regexTester(/^0b[01]+$/i);
var isOctal = regexTester(/^0o[0-7]+$/i);
var isInvalidHexLiteral = regexTester(/^[-+]0x[0-9a-f]+$/i);
var nonWS = ['\u0085', '\u200b', '\ufffe'].join('');
var nonWSregex = new $RegExp('[' + nonWS + ']', 'g');
var hasNonWS = regexTester(nonWSregex);

var $trim = require('string.prototype.trim');

var ToPrimitive = require('./ToPrimitive');

// https://262.ecma-international.org/6.0/#sec-tonumber

module.exports = function ToNumber(argument) {
	var value = isPrimitive(argument) ? argument : ToPrimitive(argument, $Number);
	if (typeof value === 'symbol') {
		throw new $TypeError('Cannot convert a Symbol value to a number');
	}
	if (typeof value === 'string') {
		if (isBinary(value)) {
			return ToNumber($parseInteger($strSlice(value, 2), 2));
		} else if (isOctal(value)) {
			return ToNumber($parseInteger($strSlice(value, 2), 8));
		} else if (hasNonWS(value) || isInvalidHexLiteral(value)) {
			return NaN;
		}
		var trimmed = $trim(value);
		if (trimmed !== value) {
			return ToNumber(trimmed);
		}

	}
	return +value;
};
'use strict';

// https://262.ecma-international.org/6.0/#sec-toobject

module.exports = require('es-object-atoms/ToObject');
'use strict';

var toPrimitive = require('es-to-primitive/es2015');

// https://262.ecma-international.org/6.0/#sec-toprimitive

module.exports = function ToPrimitive(input) {
	if (arguments.length > 1) {
		return toPrimitive(input, arguments[1]);
	}
	return toPrimitive(input);
};
'use strict';

var hasOwn = require('hasown');

var $TypeError = require('es-errors/type');
var isObject = require('es-object-atoms/isObject');

var IsCallable = require('./IsCallable');
var ToBoolean = require('./ToBoolean');

// https://262.ecma-international.org/5.1/#sec-8.10.5

module.exports = function ToPropertyDescriptor(Obj) {
	if (!isObject(Obj)) {
		throw new $TypeError('ToPropertyDescriptor requires an object');
	}

	var desc = {};
	if (hasOwn(Obj, 'enumerable')) {
		desc['[[Enumerable]]'] = ToBoolean(Obj.enumerable);
	}
	if (hasOwn(Obj, 'configurable')) {
		desc['[[Configurable]]'] = ToBoolean(Obj.configurable);
	}
	if (hasOwn(Obj, 'value')) {
		desc['[[Value]]'] = Obj.value;
	}
	if (hasOwn(Obj, 'writable')) {
		desc['[[Writable]]'] = ToBoolean(Obj.writable);
	}
	if (hasOwn(Obj, 'get')) {
		var getter = Obj.get;
		if (typeof getter !== 'undefined' && !IsCallable(getter)) {
			throw new $TypeError('getter must be a function');
		}
		desc['[[Get]]'] = getter;
	}
	if (hasOwn(Obj, 'set')) {
		var setter = Obj.set;
		if (typeof setter !== 'undefined' && !IsCallable(setter)) {
			throw new $TypeError('setter must be a function');
		}
		desc['[[Set]]'] = setter;
	}

	if ((hasOwn(desc, '[[Get]]') || hasOwn(desc, '[[Set]]')) && (hasOwn(desc, '[[Value]]') || hasOwn(desc, '[[Writable]]'))) {
		throw new $TypeError('Invalid property descriptor. Cannot both specify accessors and a value or writable attribute');
	}
	return desc;
};
'use strict';

var GetIntrinsic = require('get-intrinsic');

var $String = GetIntrinsic('%String%');

var ToPrimitive = require('./ToPrimitive');
var ToString = require('./ToString');

// https://262.ecma-international.org/6.0/#sec-topropertykey

module.exports = function ToPropertyKey(argument) {
	var key = ToPrimitive(argument, $String);
	return typeof key === 'symbol' ? key : ToString(key);
};
'use strict';

var GetIntrinsic = require('get-intrinsic');

var $String = GetIntrinsic('%String%');
var $TypeError = require('es-errors/type');

// https://262.ecma-international.org/6.0/#sec-tostring

module.exports = function ToString(argument) {
	if (typeof argument === 'symbol') {
		throw new $TypeError('Cannot convert a Symbol value to a string');
	}
	return $String(argument);
};
'use strict';

var modulo = require('./modulo');
var ToNumber = require('./ToNumber');

var abs = require('math-intrinsics/abs');
var floor = require('math-intrinsics/floor');
var $isNaN = require('math-intrinsics/isNaN');
var $isFinite = require('math-intrinsics/isFinite');
var $sign = require('math-intrinsics/sign');

// http://262.ecma-international.org/5.1/#sec-9.7

module.exports = function ToUint16(value) {
	var number = ToNumber(value);
	if ($isNaN(number) || number === 0 || !$isFinite(number)) { return 0; }
	var posInt = $sign(number) * floor(abs(number));
	return modulo(posInt, 0x10000);
};
'use strict';

var ToNumber = require('./ToNumber');

// http://262.ecma-international.org/5.1/#sec-9.6

module.exports = function ToUint32(x) {
	return ToNumber(x) >>> 0;
};
'use strict';

var ToNumber = require('./ToNumber');
var floor = require('./floor');

var $isNaN = require('math-intrinsics/isNaN');

// https://262.ecma-international.org/6.0/#sec-touint8clamp

module.exports = function ToUint8Clamp(argument) {
	var number = ToNumber(argument);
	if ($isNaN(number) || number <= 0) { return 0; }
	if (number >= 0xFF) { return 0xFF; }
	var f = floor(number);
	if (f + 0.5 < number) { return f + 1; }
	if (number < f + 0.5) { return f; }
	if (f % 2 !== 0) { return f + 1; }
	return f;
};
'use strict';

var ToNumber = require('./ToNumber');

var $isNaN = require('math-intrinsics/isNaN');
var $isFinite = require('math-intrinsics/isFinite');
var $sign = require('math-intrinsics/sign');
var abs = require('math-intrinsics/abs');
var floor = require('math-intrinsics/floor');
var modulo = require('math-intrinsics/mod');

// https://262.ecma-international.org/6.0/#sec-touint8

module.exports = function ToUint8(argument) {
	var number = ToNumber(argument);
	if ($isNaN(number) || number === 0 || !$isFinite(number)) { return 0; }
	var posInt = $sign(number) * floor(abs(number));
	return modulo(posInt, 0x100);
};
'use strict';

var trimStart = require('string.prototype.trimstart');
var trimEnd = require('string.prototype.trimend');

var $TypeError = require('es-errors/type');

var RequireObjectCoercible = require('./RequireObjectCoercible');
var ToString = require('./ToString');

// https://262.ecma-international.org/10.0/#sec-trimstring

module.exports = function TrimString(string, where) {
	var str = RequireObjectCoercible(string);
	var S = ToString(str);
	var T;
	if (where === 'start') {
		T = trimStart(S);
	} else if (where === 'end') {
		T = trimEnd(S);
	} else if (where === 'start+end') {
		T = trimStart(trimEnd(S));
	} else {
		throw new $TypeError('Assertion failed: invalid `where` value; must be "start", "end", or "start+end"');
	}
	return T;
};
'use strict';

var $SyntaxError = require('es-errors/syntax');
var $TypeError = require('es-errors/type');

var IsArray = require('./IsArray');
var IsConstructor = require('./IsConstructor');
var ValidateTypedArray = require('./ValidateTypedArray');

var availableTypedArrays = require('available-typed-arrays')();
var typedArrayLength = require('typed-array-length');

// https://262.ecma-international.org/7.0/#typedarray-create

module.exports = function TypedArrayCreate(constructor, argumentList) {
	if (!IsConstructor(constructor)) {
		throw new $TypeError('Assertion failed: `constructor` must be a constructor');
	}
	if (!IsArray(argumentList)) {
		throw new $TypeError('Assertion failed: `argumentList` must be a List');
	}
	if (availableTypedArrays.length === 0) {
		throw new $SyntaxError('Assertion failed: Typed Arrays are not supported in this environment');
	}

	// var newTypedArray = Construct(constructor, argumentList); // step 1
	var newTypedArray;
	if (argumentList.length === 0) {
		newTypedArray = new constructor();
	} else if (argumentList.length === 1) {
		newTypedArray = new constructor(argumentList[0]);
	} else if (argumentList.length === 2) {
		newTypedArray = new constructor(argumentList[0], argumentList[1]);
	} else {
		newTypedArray = new constructor(argumentList[0], argumentList[1], argumentList[2]);
	}

	ValidateTypedArray(newTypedArray); // step 2

	if (argumentList.length === 1 && typeof argumentList[0] === 'number') { // step 3
		if (typedArrayLength(newTypedArray) < argumentList[0]) {
			throw new $TypeError('Assertion failed: `argumentList[0]` must be <= `newTypedArray.length`'); // step 3.a
		}
	}

	return newTypedArray; // step 4
};
'use strict';

var $SyntaxError = require('es-errors/syntax');
var $TypeError = require('es-errors/type');

var whichTypedArray = require('which-typed-array');
var availableTypedArrays = require('available-typed-arrays')();

var IsArray = require('./IsArray');
var SpeciesConstructor = require('./SpeciesConstructor');
var TypedArrayCreate = require('./TypedArrayCreate');

var getConstructor = require('../helpers/typedArrayConstructors');

// https://262.ecma-international.org/7.0/#typedarray-species-create

module.exports = function TypedArraySpeciesCreate(exemplar, argumentList) {
	if (availableTypedArrays.length === 0) {
		throw new $SyntaxError('Assertion failed: Typed Arrays are not supported in this environment');
	}

	var kind = whichTypedArray(exemplar);
	if (!kind) {
		throw new $TypeError('Assertion failed: exemplar must be a TypedArray'); // step 1
	}
	if (!IsArray(argumentList)) {
		throw new $TypeError('Assertion failed: `argumentList` must be a List'); // step 1
	}

	var defaultConstructor = getConstructor(kind); // step 2
	if (typeof defaultConstructor !== 'function') {
		throw new $SyntaxError('Assertion failed: `constructor` of `exemplar` (' + kind + ') must exist. Please report this!');
	}
	var constructor = SpeciesConstructor(exemplar, defaultConstructor); // step 3

	return TypedArrayCreate(constructor, argumentList); // step 4
};
'use strict';

var ES5Type = require('../5/Type');

// https://262.ecma-international.org/6.0/#sec-ecmascript-data-types-and-values

module.exports = function Type(x) {
	if (typeof x === 'symbol') {
		return 'Symbol';
	}
	return ES5Type(x);
};
'use strict';

var $TypeError = require('es-errors/type');

var callBound = require('call-bound');

var $charCodeAt = callBound('String.prototype.charCodeAt');
var $numberToString = callBound('Number.prototype.toString');
var $toLowerCase = callBound('String.prototype.toLowerCase');
var $strSlice = callBound('String.prototype.slice');

// https://262.ecma-international.org/9.0/#sec-unicodeescape

module.exports = function UnicodeEscape(C) {
	if (typeof C !== 'string' || C.length !== 1) {
		throw new $TypeError('Assertion failed: `C` must be a single code unit');
	}
	var n = $charCodeAt(C, 0);
	if (n > 0xFFFF) {
		throw new $TypeError('`Assertion failed: numeric value of `C` must be <= 0xFFFF');
	}

	return '\\u' + $strSlice('0000' + $toLowerCase($numberToString(n, 16)), -4);
};
'use strict';

var GetIntrinsic = require('get-intrinsic');

var $TypeError = require('es-errors/type');
var $fromCharCode = GetIntrinsic('%String.fromCharCode%');

// https://262.ecma-international.org/7.0/#sec-utf16decode

var isLeadingSurrogate = require('../helpers/isLeadingSurrogate');
var isTrailingSurrogate = require('../helpers/isTrailingSurrogate');

// https://262.ecma-international.org/11.0/#sec-utf16decodesurrogatepair

module.exports = function UTF16Decode(lead, trail) {
	if (!isLeadingSurrogate(lead) || !isTrailingSurrogate(trail)) {
		throw new $TypeError('Assertion failed: `lead` must be a leading surrogate char code, and `trail` must be a trailing surrogate char code');
	}
	// var cp = (lead - 0xD800) * 0x400 + (trail - 0xDC00) + 0x10000;
	return $fromCharCode(lead) + $fromCharCode(trail);
};
'use strict';

var GetIntrinsic = require('get-intrinsic');

var $TypeError = require('es-errors/type');
var $fromCharCode = GetIntrinsic('%String.fromCharCode%');

var floor = require('./floor');
var modulo = require('./modulo');

var isCodePoint = require('../helpers/isCodePoint');

// https://262.ecma-international.org/7.0/#sec-utf16encoding

module.exports = function UTF16Encoding(cp) {
	if (!isCodePoint(cp)) {
		throw new $TypeError('Assertion failed: `cp` must be >= 0 and <= 0x10FFFF');
	}
	if (cp <= 65535) {
		return $fromCharCode(cp);
	}
	var cu1 = $fromCharCode(floor((cp - 65536) / 1024) + 0xD800);
	var cu2 = $fromCharCode(modulo(cp - 65536, 1024) + 0xDC00);
	return cu1 + cu2;
};
'use strict';

var $TypeError = require('es-errors/type');
var isObject = require('es-object-atoms/isObject');

var DefineOwnProperty = require('../helpers/DefineOwnProperty');
var isPropertyDescriptor = require('../helpers/records/property-descriptor');
var isSamePropertyDescriptor = require('../helpers/isSamePropertyDescriptor');

var FromPropertyDescriptor = require('./FromPropertyDescriptor');
var IsAccessorDescriptor = require('./IsAccessorDescriptor');
var IsDataDescriptor = require('./IsDataDescriptor');
var IsGenericDescriptor = require('./IsGenericDescriptor');
var isPropertyKey = require('../helpers/isPropertyKey');
var SameValue = require('./SameValue');

// https://262.ecma-international.org/6.0/#sec-validateandapplypropertydescriptor
// https://262.ecma-international.org/8.0/#sec-validateandapplypropertydescriptor

// eslint-disable-next-line max-lines-per-function, max-statements
module.exports = function ValidateAndApplyPropertyDescriptor(O, P, extensible, Desc, current) {
	// this uses the ES2017+ logic, since it fixes a number of bugs in the ES2015 logic.
	if (typeof O !== 'undefined' && !isObject(O)) {
		throw new $TypeError('Assertion failed: O must be undefined or an Object');
	}
	if (typeof extensible !== 'boolean') {
		throw new $TypeError('Assertion failed: extensible must be a Boolean');
	}
	if (!isPropertyDescriptor(Desc)) {
		throw new $TypeError('Assertion failed: Desc must be a Property Descriptor');
	}
	if (typeof current !== 'undefined' && !isPropertyDescriptor(current)) {
		throw new $TypeError('Assertion failed: current must be a Property Descriptor, or undefined');
	}
	if (typeof O !== 'undefined' && !isPropertyKey(P)) {
		throw new $TypeError('Assertion failed: if O is not undefined, P must be a Property Key');
	}
	if (typeof current === 'undefined') {
		if (!extensible) {
			return false;
		}
		if (IsGenericDescriptor(Desc) || IsDataDescriptor(Desc)) {
			if (typeof O !== 'undefined') {
				DefineOwnProperty(
					IsDataDescriptor,
					SameValue,
					FromPropertyDescriptor,
					O,
					P,
					{
						'[[Configurable]]': Desc['[[Configurable]]'],
						'[[Enumerable]]': Desc['[[Enumerable]]'],
						'[[Value]]': Desc['[[Value]]'],
						'[[Writable]]': Desc['[[Writable]]']
					}
				);
			}
		} else {
			if (!IsAccessorDescriptor(Desc)) {
				throw new $TypeError('Assertion failed: Desc is not an accessor descriptor');
			}
			if (typeof O !== 'undefined') {
				return DefineOwnProperty(
					IsDataDescriptor,
					SameValue,
					FromPropertyDescriptor,
					O,
					P,
					Desc
				);
			}
		}
		return true;
	}
	if (IsGenericDescriptor(Desc) && !('[[Configurable]]' in Desc) && !('[[Enumerable]]' in Desc)) {
		return true;
	}
	if (isSamePropertyDescriptor({ SameValue: SameValue }, Desc, current)) {
		return true; // removed by ES2017, but should still be correct
	}
	// "if every field in Desc is absent, return true" can't really match the assertion that it's a Property Descriptor
	if (!current['[[Configurable]]']) {
		if (Desc['[[Configurable]]']) {
			return false;
		}
		if ('[[Enumerable]]' in Desc && !Desc['[[Enumerable]]'] === !!current['[[Enumerable]]']) {
			return false;
		}
	}
	if (IsGenericDescriptor(Desc)) {
		// no further validation is required.
	} else if (IsDataDescriptor(current) !== IsDataDescriptor(Desc)) {
		if (!current['[[Configurable]]']) {
			return false;
		}
		if (IsDataDescriptor(current)) {
			if (typeof O !== 'undefined') {
				DefineOwnProperty(
					IsDataDescriptor,
					SameValue,
					FromPropertyDescriptor,
					O,
					P,
					{
						'[[Configurable]]': current['[[Configurable]]'],
						'[[Enumerable]]': current['[[Enumerable]]'],
						'[[Get]]': undefined
					}
				);
			}
		} else if (typeof O !== 'undefined') {
			DefineOwnProperty(
				IsDataDescriptor,
				SameValue,
				FromPropertyDescriptor,
				O,
				P,
				{
					'[[Configurable]]': current['[[Configurable]]'],
					'[[Enumerable]]': current['[[Enumerable]]'],
					'[[Value]]': undefined
				}
			);
		}
	} else if (IsDataDescriptor(current) && IsDataDescriptor(Desc)) {
		if (!current['[[Configurable]]'] && !current['[[Writable]]']) {
			if ('[[Writable]]' in Desc && Desc['[[Writable]]']) {
				return false;
			}
			if ('[[Value]]' in Desc && !SameValue(Desc['[[Value]]'], current['[[Value]]'])) {
				return false;
			}
			return true;
		}
	} else if (IsAccessorDescriptor(current) && IsAccessorDescriptor(Desc)) {
		if (!current['[[Configurable]]']) {
			if ('[[Set]]' in Desc && !SameValue(Desc['[[Set]]'], current['[[Set]]'])) {
				return false;
			}
			if ('[[Get]]' in Desc && !SameValue(Desc['[[Get]]'], current['[[Get]]'])) {
				return false;
			}
			return true;
		}
	} else {
		throw new $TypeError('Assertion failed: current and Desc are not both data, both accessors, or one accessor and one data.');
	}
	if (typeof O !== 'undefined') {
		return DefineOwnProperty(
			IsDataDescriptor,
			SameValue,
			FromPropertyDescriptor,
			O,
			P,
			Desc
		);
	}
	return true;
};
'use strict';

var $RangeError = require('es-errors/range');
var $TypeError = require('es-errors/type');

var ToIndex = require('./ToIndex');

var isTypedArray = require('is-typed-array');
var typedArrayLength = require('typed-array-length');

// https://262.ecma-international.org/8.0/#sec-validateatomicaccess

module.exports = function ValidateAtomicAccess(typedArray, requestIndex) {
	if (!isTypedArray(typedArray)) {
		throw new $TypeError('Assertion failed: `typedArray` must be a TypedArray'); // step 1
	}

	var accessIndex = ToIndex(requestIndex); // step 2

	var length = typedArrayLength(typedArray); // step 3

	/*
	// this assertion can never be reached
	if (!(accessIndex >= 0)) {
		throw new $TypeError('Assertion failed: accessIndex >= 0'); // step 4
	}
	*/

	if (accessIndex >= length) {
		throw new $RangeError('index out of range'); // step 5
	}

	return accessIndex; // step 6
};
'use strict';

var $TypeError = require('es-errors/type');
var isObject = require('es-object-atoms/isObject');

var IsDetachedBuffer = require('./IsDetachedBuffer');

var isTypedArray = require('is-typed-array');
var typedArrayBuffer = require('typed-array-buffer');

// https://262.ecma-international.org/6.0/#sec-validatetypedarray

module.exports = function ValidateTypedArray(O) {
	if (!isObject(O)) {
		throw new $TypeError('Assertion failed: `O` must be an Object'); // step 1
	}
	if (!isTypedArray(O)) {
		throw new $TypeError('Assertion failed: `O` must be a Typed Array'); // steps 2 - 3
	}

	var buffer = typedArrayBuffer(O); // step 4

	if (IsDetachedBuffer(buffer)) {
		throw new $TypeError('`O` must be backed by a non-detached buffer'); // step 5
	}

	return buffer; // step 6
};
'use strict';

var Day = require('./Day');
var modulo = require('./modulo');

// https://262.ecma-international.org/5.1/#sec-15.9.1.6

module.exports = function WeekDay(t) {
	return modulo(Day(t) + 4, 7);
};
'use strict';

var $TypeError = require('es-errors/type');

var callBound = require('call-bound');
var $indexOf = callBound('String.prototype.indexOf');

var Canonicalize = require('./Canonicalize');

var caseFolding = require('../helpers/caseFolding.json');
var forEach = require('../helpers/forEach');
var OwnPropertyKeys = require('own-keys');

var A = 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789_'; // step 1

// https://262.ecma-international.org/8.0/#sec-runtime-semantics-wordcharacters-abstract-operation

module.exports = function WordCharacters(IgnoreCase, Unicode) {
	if (typeof IgnoreCase !== 'boolean' || typeof Unicode !== 'boolean') {
		throw new $TypeError('Assertion failed: `IgnoreCase` and `Unicode` must be booleans');
	}

	var U = '';
	forEach(OwnPropertyKeys(caseFolding.C), function (c) {
		if (
			$indexOf(A, c) === -1 // c not in A
			&& $indexOf(A, Canonicalize(c, IgnoreCase, Unicode)) > -1 // canonicalized c IS in A
		) {
			U += caseFolding.C[c]; // step 3
		}
	});
	forEach(OwnPropertyKeys(caseFolding.S), function (c) {
		if (
			$indexOf(A, c) === -1 // c not in A
			&& $indexOf(A, Canonicalize(c, IgnoreCase, Unicode)) > -1 // canonicalized c IS in A
		) {
			U += caseFolding.S[c]; // step 3
		}
	});

	if ((!Unicode || !IgnoreCase) && U.length > 0) {
		throw new $TypeError('Assertion failed: `U` must be empty when `IgnoreCase` and `Unicode` are not both true'); // step 4
	}

	return A + U; // step 5, 6
};
'use strict';

var GetIntrinsic = require('get-intrinsic');

var $Date = GetIntrinsic('%Date%');

var callBound = require('call-bound');

var $getUTCFullYear = callBound('Date.prototype.getUTCFullYear');

// https://262.ecma-international.org/5.1/#sec-15.9.1.3

module.exports = function YearFromTime(t) {
	// largest y such that this.TimeFromYear(y) <= t
	return $getUTCFullYear(new $Date(t));
};
'use strict';

var $abs = require('math-intrinsics/abs');

// https://262.ecma-international.org/11.0/#eqn-abs

module.exports = function abs(x) {
	return typeof x === 'bigint' ? BigInt($abs(Number(x))) : $abs(x);
};
'use strict';

var StrictEqualityComparison = require('./StrictEqualityComparison');
var StringToBigInt = require('./StringToBigInt');
var ToNumber = require('./ToNumber');
var ToPrimitive = require('./ToPrimitive');

var isNaN = require('math-intrinsics/isNaN');
var isObject = require('es-object-atoms/isObject');
var isSameType = require('../helpers/isSameType');

// https://262.ecma-international.org/11.0/#sec-abstract-equality-comparison

module.exports = function AbstractEqualityComparison(x, y) {
	if (isSameType(x, y)) {
		return StrictEqualityComparison(x, y);
	}
	if (x == null && y == null) {
		return true;
	}
	if (typeof x === 'number' && typeof y === 'string') {
		return AbstractEqualityComparison(x, ToNumber(y));
	}
	if (typeof x === 'string' && typeof y === 'number') {
		return AbstractEqualityComparison(ToNumber(x), y);
	}
	if (typeof x === 'bigint' && typeof y === 'string') {
		var n = StringToBigInt(y);
		if (isNaN(n)) {
			return false;
		}
		return AbstractEqualityComparison(x, n);
	}
	if (typeof x === 'string' && typeof y === 'bigint') {
		return AbstractEqualityComparison(y, x);
	}
	if (typeof x === 'boolean') {
		return AbstractEqualityComparison(ToNumber(x), y);
	}
	if (typeof y === 'boolean') {
		return AbstractEqualityComparison(x, ToNumber(y));
	}
	if ((typeof x === 'string' || typeof x === 'number' || typeof x === 'bigint' || typeof x === 'symbol') && isObject(y)) {
		return AbstractEqualityComparison(x, ToPrimitive(y));
	}
	if (isObject(x) && (typeof y === 'string' || typeof y === 'number' || typeof y === 'bigint' || typeof y === 'symbol')) {
		return AbstractEqualityComparison(ToPrimitive(x), y);
	}
	if ((typeof x === 'bigint' && typeof y === 'number') || (typeof x === 'number' && typeof y === 'bigint')) {
		if (isNaN(x) || isNaN(y) || x === Infinity || y === Infinity || x === -Infinity || y === -Infinity) {
			return false;
		}
		return x == y; // eslint-disable-line eqeqeq
	}
	return false;
};
'use strict';

var GetIntrinsic = require('get-intrinsic');

var $Number = GetIntrinsic('%Number%');
var $TypeError = require('es-errors/type');

var $isNaN = require('math-intrinsics/isNaN');

var IsStringPrefix = require('./IsStringPrefix');
var StringToBigInt = require('./StringToBigInt');
var ToNumeric = require('./ToNumeric');
var ToPrimitive = require('./ToPrimitive');

var BigIntLessThan = require('./BigInt/lessThan');
var NumberLessThan = require('./Number/lessThan');

var isSameType = require('../helpers/isSameType');

// https://262.ecma-international.org/11.0/#sec-abstract-relational-comparison

// eslint-disable-next-line max-statements, max-lines-per-function
module.exports = function AbstractRelationalComparison(x, y, LeftFirst) {
	if (typeof LeftFirst !== 'boolean') {
		throw new $TypeError('Assertion failed: LeftFirst argument must be a Boolean');
	}
	var px;
	var py;
	if (LeftFirst) {
		px = ToPrimitive(x, $Number);
		py = ToPrimitive(y, $Number);
	} else {
		py = ToPrimitive(y, $Number);
		px = ToPrimitive(x, $Number);
	}
	if (typeof px === 'string' && typeof py === 'string') {
		if (IsStringPrefix(py, px)) {
			return false;
		}
		if (IsStringPrefix(px, py)) {
			return true;
		}
		return px < py; // both strings, neither a prefix of the other. shortcut for steps 3 c-f
	}

	var nx;
	var ny;
	if (typeof px === 'bigint' && typeof py === 'string') {
		ny = StringToBigInt(py);
		if ($isNaN(ny)) {
			return void undefined;
		}
		return BigIntLessThan(px, ny);
	}
	if (typeof px === 'string' && typeof py === 'bigint') {
		nx = StringToBigInt(px);
		if ($isNaN(nx)) {
			return void undefined;
		}
		return BigIntLessThan(nx, py);
	}

	nx = ToNumeric(px);
	ny = ToNumeric(py);
	if (isSameType(nx, ny)) {
		return typeof nx === 'number' ? NumberLessThan(nx, ny) : BigIntLessThan(nx, ny);
	}

	if ($isNaN(nx) || $isNaN(ny)) {
		return void undefined;
	}
	if (nx === -Infinity || ny === Infinity) {
		return true;
	}
	if (nx === Infinity || ny === -Infinity) {
		return false;
	}

	return nx < ny; // by now, these are both nonzero, finite, and not equal
};
'use strict';

var $TypeError = require('es-errors/type');
var isObject = require('es-object-atoms/isObject');
var inspect = require('object-inspect');

var Call = require('./Call');
var Get = require('./Get');
var GetIterator = require('./GetIterator');
var IsCallable = require('./IsCallable');
var IteratorClose = require('./IteratorClose');
var IteratorStep = require('./IteratorStep');
var IteratorValue = require('./IteratorValue');
var ThrowCompletion = require('./ThrowCompletion');

// https://262.ecma-international.org/10.0/#sec-add-entries-from-iterable

module.exports = function AddEntriesFromIterable(target, iterable, adder) {
	if (!IsCallable(adder)) {
		throw new $TypeError('Assertion failed: `adder` is not callable');
	}
	if (iterable == null) {
		throw new $TypeError('Assertion failed: `iterable` is present, and not nullish');
	}
	var iteratorRecord = GetIterator(iterable);
	while (true) { // eslint-disable-line no-constant-condition
		var next = IteratorStep(iteratorRecord);
		if (!next) {
			return target;
		}
		var nextItem = IteratorValue(next);
		if (!isObject(nextItem)) {
			var error = ThrowCompletion(new $TypeError('iterator next must return an Object, got ' + inspect(nextItem)));
			return IteratorClose(iteratorRecord, error);
		}
		try {
			var k = Get(nextItem, '0');
			var v = Get(nextItem, '1');
			Call(adder, target, [k, v]);
		} catch (e) {
			return IteratorClose(iteratorRecord, ThrowCompletion(e));
		}
	}
};
'use strict';

var CodePointAt = require('./CodePointAt');

var $TypeError = require('es-errors/type');
var isInteger = require('math-intrinsics/isInteger');
var MAX_SAFE_INTEGER = require('math-intrinsics/constants/maxSafeInteger');

// https://262.ecma-international.org/11.0/#sec-advancestringindex

module.exports = function AdvanceStringIndex(S, index, unicode) {
	if (typeof S !== 'string') {
		throw new $TypeError('Assertion failed: `S` must be a String');
	}
	if (!isInteger(index) || index < 0 || index > MAX_SAFE_INTEGER) {
		throw new $TypeError('Assertion failed: `length` must be an integer >= 0 and <= 2**53');
	}
	if (typeof unicode !== 'boolean') {
		throw new $TypeError('Assertion failed: `unicode` must be a Boolean');
	}
	if (!unicode) {
		return index + 1;
	}
	var length = S.length;
	if ((index + 1) >= length) {
		return index + 1;
	}
	var cp = CodePointAt(S, index);
	return index + cp['[[CodeUnitCount]]'];
};
'use strict';

var GetIntrinsic = require('get-intrinsic');

var $ArrayPrototype = GetIntrinsic('%Array.prototype%');
var $RangeError = require('es-errors/range');
var $SyntaxError = require('es-errors/syntax');
var $TypeError = require('es-errors/type');
var isInteger = require('math-intrinsics/isInteger');
var MAX_ARRAY_LENGTH = require('math-intrinsics/constants/maxArrayLength');
var $setProto = require('set-proto');

// https://262.ecma-international.org/6.0/#sec-arraycreate

module.exports = function ArrayCreate(length) {
	if (!isInteger(length) || length < 0) {
		throw new $TypeError('Assertion failed: `length` must be an integer Number >= 0');
	}
	if (length > MAX_ARRAY_LENGTH) {
		throw new $RangeError('length is greater than (2**32 - 1)');
	}
	var proto = arguments.length > 1 ? arguments[1] : $ArrayPrototype;
	var A = []; // steps 5 - 7, and 9
	if (proto !== $ArrayPrototype) { // step 8
		if (!$setProto) {
			throw new $SyntaxError('ArrayCreate: a `proto` argument that is not `Array.prototype` is not supported in an environment that does not support setting the [[Prototype]]');
		}
		$setProto(A, proto);
	}
	if (length !== 0) { // bypasses the need for step 2
		A.length = length;
	}
	/* step 10, the above as a shortcut for the below
	OrdinaryDefineOwnProperty(A, 'length', {
		'[[Configurable]]': false,
		'[[Enumerable]]': false,
		'[[Value]]': length,
		'[[Writable]]': true
	});
	*/
	return A;
};
'use strict';

var $RangeError = require('es-errors/range');
var $TypeError = require('es-errors/type');

var assign = require('object.assign');

var isPropertyDescriptor = require('../helpers/records/property-descriptor');

var IsArray = require('./IsArray');
var IsDataDescriptor = require('./IsDataDescriptor');
var OrdinaryDefineOwnProperty = require('./OrdinaryDefineOwnProperty');
var OrdinaryGetOwnProperty = require('./OrdinaryGetOwnProperty');
var ToNumber = require('./ToNumber');
var ToString = require('./ToString');
var ToUint32 = require('./ToUint32');

// https://262.ecma-international.org/6.0/#sec-arraysetlength

// eslint-disable-next-line max-statements, max-lines-per-function
module.exports = function ArraySetLength(A, Desc) {
	if (!IsArray(A)) {
		throw new $TypeError('Assertion failed: A must be an Array');
	}
	if (!isPropertyDescriptor(Desc)) {
		throw new $TypeError('Assertion failed: Desc must be a Property Descriptor');
	}
	if (!('[[Value]]' in Desc)) {
		return OrdinaryDefineOwnProperty(A, 'length', Desc);
	}
	var newLenDesc = assign({}, Desc);
	var newLen = ToUint32(Desc['[[Value]]']);
	var numberLen = ToNumber(Desc['[[Value]]']);
	if (newLen !== numberLen) {
		throw new $RangeError('Invalid array length');
	}
	newLenDesc['[[Value]]'] = newLen;
	var oldLenDesc = OrdinaryGetOwnProperty(A, 'length');
	if (!IsDataDescriptor(oldLenDesc)) {
		throw new $TypeError('Assertion failed: an array had a non-data descriptor on `length`');
	}
	var oldLen = oldLenDesc['[[Value]]'];
	if (newLen >= oldLen) {
		return OrdinaryDefineOwnProperty(A, 'length', newLenDesc);
	}
	if (!oldLenDesc['[[Writable]]']) {
		return false;
	}
	var newWritable;
	if (!('[[Writable]]' in newLenDesc) || newLenDesc['[[Writable]]']) {
		newWritable = true;
	} else {
		newWritable = false;
		newLenDesc['[[Writable]]'] = true;
	}
	var succeeded = OrdinaryDefineOwnProperty(A, 'length', newLenDesc);
	if (!succeeded) {
		return false;
	}
	while (newLen < oldLen) {
		oldLen -= 1;
		// eslint-disable-next-line no-param-reassign
		var deleteSucceeded = delete A[ToString(oldLen)];
		if (!deleteSucceeded) {
			newLenDesc['[[Value]]'] = oldLen + 1;
			if (!newWritable) {
				newLenDesc['[[Writable]]'] = false;
				OrdinaryDefineOwnProperty(A, 'length', newLenDesc);
				return false;
			}
		}
	}
	if (!newWritable) {
		return OrdinaryDefineOwnProperty(A, 'length', { '[[Writable]]': false });
	}
	return true;
};
'use strict';

var GetIntrinsic = require('get-intrinsic');

var $Array = GetIntrinsic('%Array%');
var $species = GetIntrinsic('%Symbol.species%', true);
var $TypeError = require('es-errors/type');
var isInteger = require('math-intrinsics/isInteger');
var isObject = require('es-object-atoms/isObject');

var Get = require('./Get');
var IsArray = require('./IsArray');
var IsConstructor = require('./IsConstructor');

// https://262.ecma-international.org/6.0/#sec-arrayspeciescreate

module.exports = function ArraySpeciesCreate(originalArray, length) {
	if (!isInteger(length) || length < 0) {
		throw new $TypeError('Assertion failed: length must be an integer >= 0');
	}
	var len = length === 0 ? 0 : length;
	var C;
	var isArray = IsArray(originalArray);
	if (isArray) {
		C = Get(originalArray, 'constructor');
		// TODO: figure out how to make a cross-realm normal Array, a same-realm Array
		// if (IsConstructor(C)) {
		// 	if C is another realm's Array, C = undefined
		// 	Object.getPrototypeOf(Object.getPrototypeOf(Object.getPrototypeOf(Array))) === null ?
		// }
		if ($species && isObject(C)) {
			C = Get(C, $species);
			if (C === null) {
				C = void 0;
			}
		}
	}
	if (typeof C === 'undefined') {
		return $Array(len);
	}
	if (!IsConstructor(C)) {
		throw new $TypeError('C must be a constructor');
	}
	return new C(len); // Construct(C, len);
};

'use strict';

var GetIntrinsic = require('get-intrinsic');

var $SyntaxError = require('es-errors/syntax');
var $TypeError = require('es-errors/type');
var isObject = require('es-object-atoms/isObject');
var $Promise = GetIntrinsic('%Promise%', true);

var callBound = require('call-bound');

var CreateIterResultObject = require('./CreateIterResultObject');
var IteratorComplete = require('./IteratorComplete');
var IteratorValue = require('./IteratorValue');
var PromiseResolve = require('./PromiseResolve');

var $then = callBound('Promise.prototype.then', true);

// https://262.ecma-international.org/10.0/#sec-asyncfromsynciteratorcontinuation

module.exports = function AsyncFromSyncIteratorContinuation(result) {
	if (!isObject(result)) {
		throw new $TypeError('Assertion failed: Type(O) is not Object');
	}

	if (arguments.length > 1) {
		throw new $SyntaxError('although AsyncFromSyncIteratorContinuation should take a second argument, it is not used in this implementation');
	}

	if (!$Promise) {
		throw new $SyntaxError('This environment does not support Promises.');
	}

	return new $Promise(function (resolve) {
		var done = IteratorComplete(result); // step 2
		var value = IteratorValue(result); // step 4
		var valueWrapper = PromiseResolve($Promise, value); // step 6

		// eslint-disable-next-line no-shadow
		var onFulfilled = function (value) { // steps 8-9
			return CreateIterResultObject(value, done); // step 8.a
		};
		resolve($then(valueWrapper, onFulfilled)); // step 11
	}); // step 12
};
'use strict';

var GetIntrinsic = require('get-intrinsic');

var $SyntaxError = require('es-errors/syntax');
var $TypeError = require('es-errors/type');
var isObject = require('es-object-atoms/isObject');
var $Promise = GetIntrinsic('%Promise%', true);

var Call = require('./Call');
var CompletionRecord = require('./CompletionRecord');
var GetMethod = require('./GetMethod');

var isIteratorRecord = require('../helpers/records/iterator-record-2023');

var callBound = require('call-bound');

var $then = callBound('Promise.prototype.then', true);

// https://262.ecma-international.org/9.0/#sec-asynciteratorclose

module.exports = function AsyncIteratorClose(iteratorRecord, completion) {
	if (!isIteratorRecord(iteratorRecord)) {
		throw new $TypeError('Assertion failed: `iteratorRecord` must be an Iterator Record'); // step 1
	}

	if (!(completion instanceof CompletionRecord)) {
		throw new $TypeError('Assertion failed: completion is not a Completion Record instance'); // step 2
	}

	if (!$then) {
		throw new $SyntaxError('This environment does not support Promises.');
	}

	var iterator = iteratorRecord['[[Iterator]]']; // step 3

	return new $Promise(function (resolve) {
		var ret = GetMethod(iterator, 'return'); // step 4

		if (typeof ret === 'undefined') {
			resolve(completion); // step 5
		} else {
			resolve($then(
				new $Promise(function (resolve2) {
					// process.exit(42);
					resolve2(Call(ret, iterator, [])); // step 6
				}),
				function (innerResult) {
					if (!isObject(innerResult)) {
						throw new $TypeError('`innerResult` must be an Object'); // step 10
					}
					return completion;
				},
				function (e) {
					if (completion.type() === 'throw') {
						completion['?'](); // step 8
					} else {
						throw e; // step 9
					}
				}
			));
		}
	});
};
'use strict';

var $TypeError = require('es-errors/type');
// var $BigInt = GetIntrinsic('%BigInt%', true);
// var $pow = require('math-intrinsics/pow');

// var BinaryAnd = require('./BinaryAnd');
// var BinaryOr = require('./BinaryOr');
// var BinaryXor = require('./BinaryXor');
// var modulo = require('./modulo');

// var zero = $BigInt && $BigInt(0);
// var negOne = $BigInt && $BigInt(-1);
// var two = $BigInt && $BigInt(2);

// https://262.ecma-international.org/11.0/#sec-bigintbitwiseop

module.exports = function BigIntBitwiseOp(op, x, y) {
	if (op !== '&' && op !== '|' && op !== '^') {
		throw new $TypeError('Assertion failed: `op` must be `&`, `|`, or `^`');
	}
	if (typeof x !== 'bigint' || typeof y !== 'bigint') {
		throw new $TypeError('`x` and `y` must be BigInts');
	}

	if (op === '&') {
		return x & y;
	}
	if (op === '|') {
		return x | y;
	}
	return x ^ y;
	/*
	var result = zero;
	var shift = 0;
	while (x !== zero && x !== negOne && y !== zero && y !== negOne) {
		var xDigit = modulo(x, two);
		var yDigit = modulo(y, two);
		if (op === '&') {
			result += $pow(2, shift) * BinaryAnd(xDigit, yDigit);
		} else if (op === '|') {
			result += $pow(2, shift) * BinaryOr(xDigit, yDigit);
		} else if (op === '^') {
			result += $pow(2, shift) * BinaryXor(xDigit, yDigit);
		}
		shift += 1;
		x = (x - xDigit) / two;
		y = (y - yDigit) / two;
	}
	var tmp;
	if (op === '&') {
		tmp = BinaryAnd(modulo(x, two), modulo(y, two));
	} else if (op === '|') {
		tmp = BinaryAnd(modulo(x, two), modulo(y, two));
	} else {
		tmp = BinaryXor(modulo(x, two), modulo(y, two));
	}
	if (tmp !== 0) {
		result -= $pow(2, shift);
	}
	return result;
	*/
};
'use strict';

var $TypeError = require('es-errors/type');

// https://262.ecma-international.org/11.0/#sec-binaryand

module.exports = function BinaryAnd(x, y) {
	if ((x !== 0 && x !== 1) || (y !== 0 && y !== 1)) {
		throw new $TypeError('Assertion failed: `x` and `y` must be either 0 or 1');
	}
	return x & y;
};
'use strict';

var $TypeError = require('es-errors/type');

// https://262.ecma-international.org/11.0/#sec-binaryor

module.exports = function BinaryOr(x, y) {
	if ((x !== 0 && x !== 1) || (y !== 0 && y !== 1)) {
		throw new $TypeError('Assertion failed: `x` and `y` must be either 0 or 1');
	}
	return x | y;
};
'use strict';

var $TypeError = require('es-errors/type');

// https://262.ecma-international.org/11.0/#sec-binaryxor

module.exports = function BinaryXor(x, y) {
	if ((x !== 0 && x !== 1) || (y !== 0 && y !== 1)) {
		throw new $TypeError('Assertion failed: `x` and `y` must be either 0 or 1');
	}
	return x ^ y;
};
'use strict';

var GetIntrinsic = require('get-intrinsic');
var callBound = require('call-bound');

var $TypeError = require('es-errors/type');

var IsArray = require('./IsArray');

var $apply = GetIntrinsic('%Reflect.apply%', true) || callBound('Function.prototype.apply');

// https://262.ecma-international.org/6.0/#sec-call

module.exports = function Call(F, V) {
	var argumentsList = arguments.length > 2 ? arguments[2] : [];
	if (!IsArray(argumentsList)) {
		throw new $TypeError('Assertion failed: optional `argumentsList`, if provided, must be a List');
	}
	return $apply(F, V, argumentsList);
};
'use strict';

var $TypeError = require('es-errors/type');

var callBound = require('call-bound');
var hasOwn = require('hasown');

var $charCodeAt = callBound('String.prototype.charCodeAt');
var $toUpperCase = callBound('String.prototype.toUpperCase');

var caseFolding = require('../helpers/caseFolding.json');

// https://262.ecma-international.org/6.0/#sec-runtime-semantics-canonicalize-ch

module.exports = function Canonicalize(ch, IgnoreCase, Unicode) {
	if (typeof ch !== 'string') {
		throw new $TypeError('Assertion failed: `ch` must be a character');
	}

	if (typeof IgnoreCase !== 'boolean' || typeof Unicode !== 'boolean') {
		throw new $TypeError('Assertion failed: `IgnoreCase` and `Unicode` must be Booleans');
	}

	if (!IgnoreCase) {
		return ch; // step 1
	}

	if (Unicode) { // step 2
		if (hasOwn(caseFolding.C, ch)) {
			return caseFolding.C[ch];
		}
		if (hasOwn(caseFolding.S, ch)) {
			return caseFolding.S[ch];
		}
		return ch; // step 2.b
	}

	var u = $toUpperCase(ch); // step 2

	if (u.length !== 1) {
		return ch; // step 3
	}

	var cu = u; // step 4

	if ($charCodeAt(ch, 0) >= 128 && $charCodeAt(cu, 0) < 128) {
		return ch; // step 5
	}

	return cu;
};
'use strict';

var $TypeError = require('es-errors/type');

var SameValue = require('./SameValue');
var ToNumber = require('./ToNumber');
var ToString = require('./ToString');

// https://262.ecma-international.org/6.0/#sec-canonicalnumericindexstring

module.exports = function CanonicalNumericIndexString(argument) {
	if (typeof argument !== 'string') {
		throw new $TypeError('Assertion failed: `argument` must be a String');
	}
	if (argument === '-0') { return -0; }
	var n = ToNumber(argument);
	if (SameValue(ToString(n), argument)) { return n; }
	return void 0;
};
'use strict';

var GetIntrinsic = require('get-intrinsic');
var callBound = require('call-bound');

var $fromCharCode = GetIntrinsic('%String.fromCharCode%');
var $TypeError = require('es-errors/type');
var $charCodeAt = callBound('String.prototype.charCodeAt');

var CharSet = require('../helpers/CharSet').CharSet;

module.exports = function CharacterRange(A, B) {
	var a;
	var b;

	if (A instanceof CharSet || B instanceof CharSet) {
		if (!(A instanceof CharSet) || !(B instanceof CharSet)) {
			throw new $TypeError('Assertion failed: CharSets A and B are not both CharSets');
		}

		A.yield(function (c) {
			if (typeof a !== 'undefined') {
				throw new $TypeError('Assertion failed: CharSet A has more than one character');
			}
			a = c;
		});
		B.yield(function (c) {
			if (typeof b !== 'undefined') {
				throw new $TypeError('Assertion failed: CharSet B has more than one character');
			}
			b = c;
		});
	} else {
		if (A.length !== 1 || B.length !== 1) {
			throw new $TypeError('Assertion failed: CharSets A and B contain exactly one character');
		}
		a = A[0];
		b = B[0];
	}

	var i = $charCodeAt(a, 0);
	var j = $charCodeAt(b, 0);

	if (!(i <= j)) {
		throw new $TypeError('Assertion failed: i is not <= j');
	}

	var arr = [];
	for (var k = i; k <= j; k += 1) {
		arr[arr.length] = $fromCharCode(k);
	}
	return arr;
};
'use strict';

var $TypeError = require('es-errors/type');
var callBound = require('call-bound');
var isLeadingSurrogate = require('../helpers/isLeadingSurrogate');
var isTrailingSurrogate = require('../helpers/isTrailingSurrogate');

var UTF16DecodeSurrogatePair = require('./UTF16DecodeSurrogatePair');

var $charAt = callBound('String.prototype.charAt');
var $charCodeAt = callBound('String.prototype.charCodeAt');

// https://262.ecma-international.org/11.0/#sec-codepointat

module.exports = function CodePointAt(string, position) {
	if (typeof string !== 'string') {
		throw new $TypeError('Assertion failed: `string` must be a String');
	}
	var size = string.length;
	if (position < 0 || position >= size) {
		throw new $TypeError('Assertion failed: `position` must be >= 0, and < the length of `string`');
	}
	var first = $charCodeAt(string, position);
	var cp = $charAt(string, position);
	var firstIsLeading = isLeadingSurrogate(first);
	var firstIsTrailing = isTrailingSurrogate(first);
	if (!firstIsLeading && !firstIsTrailing) {
		return {
			'[[CodePoint]]': cp,
			'[[CodeUnitCount]]': 1,
			'[[IsUnpairedSurrogate]]': false
		};
	}
	if (firstIsTrailing || (position + 1 === size)) {
		return {
			'[[CodePoint]]': cp,
			'[[CodeUnitCount]]': 1,
			'[[IsUnpairedSurrogate]]': true
		};
	}
	var second = $charCodeAt(string, position + 1);
	if (!isTrailingSurrogate(second)) {
		return {
			'[[CodePoint]]': cp,
			'[[CodeUnitCount]]': 1,
			'[[IsUnpairedSurrogate]]': true
		};
	}

	return {
		'[[CodePoint]]': UTF16DecodeSurrogatePair(first, second),
		'[[CodeUnitCount]]': 2,
		'[[IsUnpairedSurrogate]]': false
	};
};
'use strict';

var $TypeError = require('es-errors/type');

var hasOwn = require('hasown');

var IsDataDescriptor = require('./IsDataDescriptor');
var IsGenericDescriptor = require('./IsGenericDescriptor');

var isPropertyDescriptor = require('../helpers/records/property-descriptor');

// https://262.ecma-international.org/6.0/#sec-completepropertydescriptor

module.exports = function CompletePropertyDescriptor(Desc) {
	if (!isPropertyDescriptor(Desc)) {
		throw new $TypeError('Assertion failed: `Desc` must be a Property Descriptor');
	}

	/* eslint no-param-reassign: 0 */

	if (IsGenericDescriptor(Desc) || IsDataDescriptor(Desc)) {
		if (!hasOwn(Desc, '[[Value]]')) {
			Desc['[[Value]]'] = void 0;
		}
		if (!hasOwn(Desc, '[[Writable]]')) {
			Desc['[[Writable]]'] = false;
		}
	} else {
		if (!hasOwn(Desc, '[[Get]]')) {
			Desc['[[Get]]'] = void 0;
		}
		if (!hasOwn(Desc, '[[Set]]')) {
			Desc['[[Set]]'] = void 0;
		}
	}
	if (!hasOwn(Desc, '[[Enumerable]]')) {
		Desc['[[Enumerable]]'] = false;
	}
	if (!hasOwn(Desc, '[[Configurable]]')) {
		Desc['[[Configurable]]'] = false;
	}
	return Desc;
};
'use strict';

var $SyntaxError = require('es-errors/syntax');

var SLOT = require('internal-slot');

// https://262.ecma-international.org/7.0/#sec-completion-record-specification-type

var CompletionRecord = function CompletionRecord(type, value) {
	if (!(this instanceof CompletionRecord)) {
		return new CompletionRecord(type, value);
	}
	if (type !== 'normal' && type !== 'break' && type !== 'continue' && type !== 'return' && type !== 'throw') {
		throw new $SyntaxError('Assertion failed: `type` must be one of "normal", "break", "continue", "return", or "throw"');
	}
	SLOT.set(this, '[[Type]]', type);
	SLOT.set(this, '[[Value]]', value);
	// [[Target]] slot?
};

CompletionRecord.prototype.type = function Type() {
	return SLOT.get(this, '[[Type]]');
};

CompletionRecord.prototype.value = function Value() {
	return SLOT.get(this, '[[Value]]');
};

CompletionRecord.prototype['?'] = function ReturnIfAbrupt() {
	var type = SLOT.get(this, '[[Type]]');
	var value = SLOT.get(this, '[[Value]]');

	if (type === 'throw') {
		throw value;
	}
	return value;
};

CompletionRecord.prototype['!'] = function assert() {
	var type = SLOT.get(this, '[[Type]]');

	if (type !== 'normal') {
		throw new $SyntaxError('Assertion failed: Completion Record is not of type "normal"');
	}
	return SLOT.get(this, '[[Value]]');
};

module.exports = CompletionRecord;
'use strict';

var $TypeError = require('es-errors/type');
var isObject = require('es-object-atoms/isObject');
var callBound = require('call-bound');
var OwnPropertyKeys = require('own-keys');

var every = require('../helpers/every');
var forEach = require('../helpers/forEach');

var $isEnumerable = callBound('Object.prototype.propertyIsEnumerable');

var CreateDataPropertyOrThrow = require('./CreateDataPropertyOrThrow');
var Get = require('./Get');
var IsArray = require('./IsArray');
var IsInteger = require('./IsInteger');
var isPropertyKey = require('../helpers/isPropertyKey');
var SameValue = require('./SameValue');
var ToNumber = require('./ToNumber');
var ToObject = require('./ToObject');

// https://262.ecma-international.org/11.0/#sec-copydataproperties

module.exports = function CopyDataProperties(target, source, excludedItems) {
	if (!isObject(target)) {
		throw new $TypeError('Assertion failed: "target" must be an Object');
	}

	if (!IsArray(excludedItems) || !every(excludedItems, isPropertyKey)) {
		throw new $TypeError('Assertion failed: "excludedItems" must be a List of Property Keys');
	}

	if (typeof source === 'undefined' || source === null) {
		return target;
	}

	var from = ToObject(source);

	var sourceKeys = OwnPropertyKeys(from);
	forEach(sourceKeys, function (nextKey) {
		var excluded = false;

		forEach(excludedItems, function (e) {
			if (SameValue(e, nextKey) === true) {
				excluded = true;
			}
		});

		var enumerable = $isEnumerable(from, nextKey) || (
			// this is to handle string keys being non-enumerable in older engines
			typeof source === 'string'
			&& nextKey >= 0
			&& IsInteger(ToNumber(nextKey))
		);
		if (excluded === false && enumerable) {
			var propValue = Get(from, nextKey);
			CreateDataPropertyOrThrow(target, nextKey, propValue);
		}
	});

	return target;
};
'use strict';

var GetIntrinsic = require('get-intrinsic');

var $SyntaxError = require('es-errors/syntax');
var $TypeError = require('es-errors/type');
var isObject = require('es-object-atoms/isObject');
var $Promise = GetIntrinsic('%Promise%', true);

var AsyncFromSyncIteratorContinuation = require('./AsyncFromSyncIteratorContinuation');
var Call = require('./Call');
var CreateIterResultObject = require('./CreateIterResultObject');
var Get = require('./Get');
var GetMethod = require('./GetMethod');
var IteratorNext = require('./IteratorNext');
var OrdinaryObjectCreate = require('./OrdinaryObjectCreate');

var isIteratorRecord = require('../helpers/records/iterator-record-2023');

var SLOT = require('internal-slot');

var $AsyncFromSyncIteratorPrototype = GetIntrinsic('%AsyncFromSyncIteratorPrototype%', true) || {
	next: function next(value) {
		if (!$Promise) {
			throw new $SyntaxError('This environment does not support Promises.');
		}

		var O = this; // step 1

		SLOT.assert(O, '[[SyncIteratorRecord]]'); // step 2

		var argsLength = arguments.length;

		return new $Promise(function (resolve) { // step 3
			var syncIteratorRecord = SLOT.get(O, '[[SyncIteratorRecord]]'); // step 4
			var result;
			if (argsLength > 0) {
				result = IteratorNext(syncIteratorRecord['[[Iterator]]'], value); // step 5.a
			} else { // step 6
				result = IteratorNext(syncIteratorRecord['[[Iterator]]']);// step 6.a
			}
			resolve(AsyncFromSyncIteratorContinuation(result)); // step 8
		});
	},
	'return': function () {
		if (!$Promise) {
			throw new $SyntaxError('This environment does not support Promises.');
		}

		var O = this; // step 1

		SLOT.assert(O, '[[SyncIteratorRecord]]'); // step 2

		var valueIsPresent = arguments.length > 0;
		var value = valueIsPresent ? arguments[0] : void undefined;

		return new $Promise(function (resolve, reject) { // step 3
			var syncIterator = SLOT.get(O, '[[SyncIteratorRecord]]')['[[Iterator]]']; // step 4
			var iteratorReturn = GetMethod(syncIterator, 'return'); // step 5

			if (typeof iteratorReturn === 'undefined') { // step 7
				var iterResult = CreateIterResultObject(value, true); // step 7.a
				Call(resolve, undefined, [iterResult]); // step 7.b
				return;
			}
			var result;
			if (valueIsPresent) { // step 8
				result = Call(iteratorReturn, syncIterator, [value]); // step 8.a
			} else { // step 9
				result = Call(iteratorReturn, syncIterator); // step 9.a
			}
			if (!isObject(result)) { // step 11
				Call(reject, undefined, [new $TypeError('Iterator `return` method returned a non-object value.')]); // step 11.a
				return;
			}

			resolve(AsyncFromSyncIteratorContinuation(result)); // step 12
		});
	},
	'throw': function () {
		if (!$Promise) {
			throw new $SyntaxError('This environment does not support Promises.');
		}

		var O = this; // step 1

		SLOT.assert(O, '[[SyncIteratorRecord]]'); // step 2

		var valueIsPresent = arguments.length > 0;
		var value = valueIsPresent ? arguments[0] : void undefined;

		return new $Promise(function (resolve, reject) { // step 3
			var syncIterator = SLOT.get(O, '[[SyncIteratorRecord]]')['[[Iterator]]']; // step 4

			var throwMethod = GetMethod(syncIterator, 'throw'); // step 5

			if (typeof throwMethod === 'undefined') { // step 7
				Call(reject, undefined, [value]); // step 7.a
				return;
			}

			var result;
			if (valueIsPresent) { // step 8
				result = Call(throwMethod, syncIterator, [value]); // step 8.a
			} else { // step 9
				result = Call(throwMethod, syncIterator); // step 9.a
			}
			if (!isObject(result)) { // step 11
				Call(reject, undefined, [new $TypeError('Iterator `throw` method returned a non-object value.')]); // step 11.a
				return;
			}

			resolve(AsyncFromSyncIteratorContinuation(result/* , promiseCapability */)); // step 12
		});
	}
};

// https://262.ecma-international.org/11.0/#sec-createasyncfromsynciterator

module.exports = function CreateAsyncFromSyncIterator(syncIteratorRecord) {
	if (!isIteratorRecord(syncIteratorRecord)) {
		throw new $TypeError('Assertion failed: `syncIteratorRecord` must be an Iterator Record');
	}

	// var asyncIterator = OrdinaryObjectCreate(%AsyncFromSyncIteratorPrototype%, « [[SyncIteratorRecord]] »); // step 1
	var asyncIterator = OrdinaryObjectCreate($AsyncFromSyncIteratorPrototype);

	SLOT.set(asyncIterator, '[[SyncIteratorRecord]]', syncIteratorRecord); // step 2

	var nextMethod = Get(asyncIterator, 'next'); // step 3

	return { // steps 3-4
		'[[Iterator]]': asyncIterator,
		'[[NextMethod]]': nextMethod,
		'[[Done]]': false
	};
};
'use strict';

var $TypeError = require('es-errors/type');
var isObject = require('es-object-atoms/isObject');

var isPropertyKey = require('../helpers/isPropertyKey');
var OrdinaryDefineOwnProperty = require('./OrdinaryDefineOwnProperty');

// https://262.ecma-international.org/6.0/#sec-createdataproperty

module.exports = function CreateDataProperty(O, P, V) {
	if (!isObject(O)) {
		throw new $TypeError('Assertion failed: Type(O) is not Object');
	}
	if (!isPropertyKey(P)) {
		throw new $TypeError('Assertion failed: P is not a Property Key');
	}
	var newDesc = {
		'[[Configurable]]': true,
		'[[Enumerable]]': true,
		'[[Value]]': V,
		'[[Writable]]': true
	};
	return OrdinaryDefineOwnProperty(O, P, newDesc);
};
'use strict';

var $TypeError = require('es-errors/type');
var isObject = require('es-object-atoms/isObject');

var CreateDataProperty = require('./CreateDataProperty');

var isPropertyKey = require('../helpers/isPropertyKey');

// // https://262.ecma-international.org/6.0/#sec-createdatapropertyorthrow

module.exports = function CreateDataPropertyOrThrow(O, P, V) {
	if (!isObject(O)) {
		throw new $TypeError('Assertion failed: Type(O) is not Object');
	}
	if (!isPropertyKey(P)) {
		throw new $TypeError('Assertion failed: P is not a Property Key');
	}
	var success = CreateDataProperty(O, P, V);
	if (!success) {
		throw new $TypeError('unable to create data property');
	}
	return success;
};
'use strict';

var $TypeError = require('es-errors/type');

var callBound = require('call-bound');

var $replace = callBound('String.prototype.replace');

var RequireObjectCoercible = require('./RequireObjectCoercible');
var ToString = require('./ToString');

// https://262.ecma-international.org/6.0/#sec-createhtml

module.exports = function CreateHTML(string, tag, attribute, value) {
	if (typeof tag !== 'string' || typeof attribute !== 'string') {
		throw new $TypeError('Assertion failed: `tag` and `attribute` must be strings');
	}
	var str = RequireObjectCoercible(string);
	var S = ToString(str);
	var p1 = '<' + tag;
	if (attribute !== '') {
		var V = ToString(value);
		var escapedV = $replace(V, /\x22/g, '&quot;');
		p1 += '\x20' + attribute + '\x3D\x22' + escapedV + '\x22';
	}
	return p1 + '>' + S + '</' + tag + '>';
};
'use strict';

var $TypeError = require('es-errors/type');

// https://262.ecma-international.org/6.0/#sec-createiterresultobject

module.exports = function CreateIterResultObject(value, done) {
	if (typeof done !== 'boolean') {
		throw new $TypeError('Assertion failed: Type(done) is not Boolean');
	}
	return {
		value: value,
		done: done
	};
};
'use strict';

var callBound = require('call-bound');

var $TypeError = require('es-errors/type');
var isObject = require('es-object-atoms/isObject');
var $indexOf = callBound('Array.prototype.indexOf', true) || callBound('String.prototype.indexOf');

var Get = require('./Get');
var IsArray = require('./IsArray');
var LengthOfArrayLike = require('./LengthOfArrayLike');
var ToString = require('./ToString');
var Type = require('./Type');

var defaultElementTypes = ['Undefined', 'Null', 'Boolean', 'String', 'Symbol', 'Number', 'BigInt', 'Object'];

// https://262.ecma-international.org/11.0/#sec-createlistfromarraylike

/** @type {(obj: object, elementTypes?: typeof defaultElementTypes) => unknown[]} */
module.exports = function CreateListFromArrayLike(obj) {
	var elementTypes = arguments.length > 1
		? arguments[1]
		: defaultElementTypes;

	if (!isObject(obj)) {
		throw new $TypeError('Assertion failed: `obj` must be an Object');
	}
	if (!IsArray(elementTypes)) {
		throw new $TypeError('Assertion failed: `elementTypes`, if provided, must be an array');
	}
	var len = LengthOfArrayLike(obj);
	/** @type {(typeof elementTypes)[]} */
	var list = [];
	var index = 0;
	while (index < len) {
		var indexName = ToString(index);
		var next = Get(obj, indexName);
		var nextType = Type(next);
		if ($indexOf(elementTypes, nextType) < 0) {
			throw new $TypeError('item type ' + nextType + ' is not a valid elementType');
		}
		list[list.length] = next;
		index += 1;
	}
	return list;
};
'use strict';

var $TypeError = require('es-errors/type');
var isObject = require('es-object-atoms/isObject');

var DefineOwnProperty = require('../helpers/DefineOwnProperty');

var FromPropertyDescriptor = require('./FromPropertyDescriptor');
var IsDataDescriptor = require('./IsDataDescriptor');
var isPropertyKey = require('../helpers/isPropertyKey');
var SameValue = require('./SameValue');

// https://262.ecma-international.org/6.0/#sec-createmethodproperty

module.exports = function CreateMethodProperty(O, P, V) {
	if (!isObject(O)) {
		throw new $TypeError('Assertion failed: Type(O) is not Object');
	}

	if (!isPropertyKey(P)) {
		throw new $TypeError('Assertion failed: P is not a Property Key');
	}

	var newDesc = {
		'[[Configurable]]': true,
		'[[Enumerable]]': false,
		'[[Value]]': V,
		'[[Writable]]': true
	};
	return DefineOwnProperty(
		IsDataDescriptor,
		SameValue,
		FromPropertyDescriptor,
		O,
		P,
		newDesc
	);
};
'use strict';

var GetIntrinsic = require('get-intrinsic');
var hasSymbols = require('has-symbols')();

var $TypeError = require('es-errors/type');
var isObject = require('es-object-atoms/isObject');
var IteratorPrototype = GetIntrinsic('%IteratorPrototype%', true);

var AdvanceStringIndex = require('./AdvanceStringIndex');
var CreateIterResultObject = require('./CreateIterResultObject');
var CreateMethodProperty = require('./CreateMethodProperty');
var Get = require('./Get');
var OrdinaryObjectCreate = require('./OrdinaryObjectCreate');
var RegExpExec = require('./RegExpExec');
var Set = require('./Set');
var ToLength = require('./ToLength');
var ToString = require('./ToString');

var SLOT = require('internal-slot');
var setToStringTag = require('es-set-tostringtag');

var RegExpStringIterator = function RegExpStringIterator(R, S, global, fullUnicode) {
	if (typeof S !== 'string') {
		throw new $TypeError('`S` must be a string');
	}
	if (typeof global !== 'boolean') {
		throw new $TypeError('`global` must be a boolean');
	}
	if (typeof fullUnicode !== 'boolean') {
		throw new $TypeError('`fullUnicode` must be a boolean');
	}
	SLOT.set(this, '[[IteratingRegExp]]', R);
	SLOT.set(this, '[[IteratedString]]', S);
	SLOT.set(this, '[[Global]]', global);
	SLOT.set(this, '[[Unicode]]', fullUnicode);
	SLOT.set(this, '[[Done]]', false);
};

if (IteratorPrototype) {
	RegExpStringIterator.prototype = OrdinaryObjectCreate(IteratorPrototype);
}

var RegExpStringIteratorNext = function next() {
	var O = this; // eslint-disable-line no-invalid-this
	if (!isObject(O)) {
		throw new $TypeError('receiver must be an object');
	}
	if (
		!(O instanceof RegExpStringIterator)
		|| !SLOT.has(O, '[[IteratingRegExp]]')
		|| !SLOT.has(O, '[[IteratedString]]')
		|| !SLOT.has(O, '[[Global]]')
		|| !SLOT.has(O, '[[Unicode]]')
		|| !SLOT.has(O, '[[Done]]')
	) {
		throw new $TypeError('"this" value must be a RegExpStringIterator instance');
	}
	if (SLOT.get(O, '[[Done]]')) {
		return CreateIterResultObject(undefined, true);
	}
	var R = SLOT.get(O, '[[IteratingRegExp]]');
	var S = SLOT.get(O, '[[IteratedString]]');
	var global = SLOT.get(O, '[[Global]]');
	var fullUnicode = SLOT.get(O, '[[Unicode]]');
	var match = RegExpExec(R, S);
	if (match === null) {
		SLOT.set(O, '[[Done]]', true);
		return CreateIterResultObject(undefined, true);
	}
	if (global) {
		var matchStr = ToString(Get(match, '0'));
		if (matchStr === '') {
			var thisIndex = ToLength(Get(R, 'lastIndex'));
			var nextIndex = AdvanceStringIndex(S, thisIndex, fullUnicode);
			Set(R, 'lastIndex', nextIndex, true);
		}
		return CreateIterResultObject(match, false);
	}
	SLOT.set(O, '[[Done]]', true);
	return CreateIterResultObject(match, false);
};
CreateMethodProperty(RegExpStringIterator.prototype, 'next', RegExpStringIteratorNext);

if (hasSymbols) {
	setToStringTag(RegExpStringIterator.prototype, 'RegExp String Iterator');

	if (Symbol.iterator && typeof RegExpStringIterator.prototype[Symbol.iterator] !== 'function') {
		var iteratorFn = function SymbolIterator() {
			return this;
		};
		CreateMethodProperty(RegExpStringIterator.prototype, Symbol.iterator, iteratorFn);
	}
}

// https://262.ecma-international.org/11.0/#sec-createregexpstringiterator
module.exports = function CreateRegExpStringIterator(R, S, global, fullUnicode) {
	// assert R.global === global && R.unicode === fullUnicode?
	return new RegExpStringIterator(R, S, global, fullUnicode);
};
'use strict';

var $EvalError = require('es-errors/eval');

var DayWithinYear = require('./DayWithinYear');
var InLeapYear = require('./InLeapYear');
var MonthFromTime = require('./MonthFromTime');

// https://262.ecma-international.org/5.1/#sec-15.9.1.5

module.exports = function DateFromTime(t) {
	var m = MonthFromTime(t);
	var d = DayWithinYear(t);
	if (m === 0) {
		return d + 1;
	}
	if (m === 1) {
		return d - 30;
	}
	var leap = InLeapYear(t);
	if (m === 2) {
		return d - 58 - leap;
	}
	if (m === 3) {
		return d - 89 - leap;
	}
	if (m === 4) {
		return d - 119 - leap;
	}
	if (m === 5) {
		return d - 150 - leap;
	}
	if (m === 6) {
		return d - 180 - leap;
	}
	if (m === 7) {
		return d - 211 - leap;
	}
	if (m === 8) {
		return d - 242 - leap;
	}
	if (m === 9) {
		return d - 272 - leap;
	}
	if (m === 10) {
		return d - 303 - leap;
	}
	if (m === 11) {
		return d - 333 - leap;
	}
	throw new $EvalError('Assertion failed: MonthFromTime returned an impossible value: ' + m);
};
'use strict';

var $TypeError = require('es-errors/type');

var weekdays = ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'];
var months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];

var $isNaN = require('math-intrinsics/isNaN');
var padTimeComponent = require('../helpers/padTimeComponent');

var DateFromTime = require('./DateFromTime');
var MonthFromTime = require('./MonthFromTime');
var WeekDay = require('./WeekDay');
var YearFromTime = require('./YearFromTime');

// https://262.ecma-international.org/9.0/#sec-datestring

module.exports = function DateString(tv) {
	if (typeof tv !== 'number' || $isNaN(tv)) {
		throw new $TypeError('Assertion failed: `tv` must be a non-NaN Number');
	}
	var weekday = weekdays[WeekDay(tv)];
	var month = months[MonthFromTime(tv)];
	var day = padTimeComponent(DateFromTime(tv));
	var year = padTimeComponent(YearFromTime(tv), 4);
	return weekday + '\x20' + month + '\x20' + day + '\x20' + year;
};
'use strict';

var floor = require('./floor');

// https://262.ecma-international.org/5.1/#sec-15.9.1.3

module.exports = function DayFromYear(y) {
	return (365 * (y - 1970)) + floor((y - 1969) / 4) - floor((y - 1901) / 100) + floor((y - 1601) / 400);
};

'use strict';

var floor = require('./floor');

var msPerDay = require('../helpers/timeConstants').msPerDay;

// https://262.ecma-international.org/5.1/#sec-15.9.1.2

module.exports = function Day(t) {
	return floor(t / msPerDay);
};
'use strict';

var modulo = require('./modulo');

// https://262.ecma-international.org/5.1/#sec-15.9.1.3

module.exports = function DaysInYear(y) {
	if (modulo(y, 4) !== 0) {
		return 365;
	}
	if (modulo(y, 100) !== 0) {
		return 366;
	}
	if (modulo(y, 400) !== 0) {
		return 365;
	}
	return 366;
};
'use strict';

var Day = require('./Day');
var DayFromYear = require('./DayFromYear');
var YearFromTime = require('./YearFromTime');

// https://262.ecma-international.org/5.1/#sec-15.9.1.4

module.exports = function DayWithinYear(t) {
	return Day(t) - DayFromYear(YearFromTime(t));
};
'use strict';

var $TypeError = require('es-errors/type');
var isObject = require('es-object-atoms/isObject');

var isPropertyDescriptor = require('../helpers/records/property-descriptor');
var DefineOwnProperty = require('../helpers/DefineOwnProperty');

var FromPropertyDescriptor = require('./FromPropertyDescriptor');
var IsDataDescriptor = require('./IsDataDescriptor');
var isPropertyKey = require('../helpers/isPropertyKey');
var SameValue = require('./SameValue');
var ToPropertyDescriptor = require('./ToPropertyDescriptor');

// https://262.ecma-international.org/6.0/#sec-definepropertyorthrow

module.exports = function DefinePropertyOrThrow(O, P, desc) {
	if (!isObject(O)) {
		throw new $TypeError('Assertion failed: Type(O) is not Object');
	}

	if (!isPropertyKey(P)) {
		throw new $TypeError('Assertion failed: P is not a Property Key');
	}

	var Desc = isPropertyDescriptor(desc) ? desc : ToPropertyDescriptor(desc);
	if (!isPropertyDescriptor(Desc)) {
		throw new $TypeError('Assertion failed: Desc is not a valid Property Descriptor');
	}

	return DefineOwnProperty(
		IsDataDescriptor,
		SameValue,
		FromPropertyDescriptor,
		O,
		P,
		Desc
	);
};
'use strict';

var $TypeError = require('es-errors/type');
var isObject = require('es-object-atoms/isObject');

var isPropertyKey = require('../helpers/isPropertyKey');

// https://262.ecma-international.org/6.0/#sec-deletepropertyorthrow

module.exports = function DeletePropertyOrThrow(O, P) {
	if (!isObject(O)) {
		throw new $TypeError('Assertion failed: Type(O) is not Object');
	}

	if (!isPropertyKey(P)) {
		throw new $TypeError('Assertion failed: P is not a Property Key');
	}

	// eslint-disable-next-line no-param-reassign
	var success = delete O[P];
	if (!success) {
		throw new $TypeError('Attempt to delete property failed.');
	}
	return success;
};
'use strict';

var $SyntaxError = require('es-errors/syntax');
var $TypeError = require('es-errors/type');

var IsDetachedBuffer = require('./IsDetachedBuffer');

var isArrayBuffer = require('is-array-buffer');
var isSharedArrayBuffer = require('is-shared-array-buffer');

var MessageChannel;
try {
	// eslint-disable-next-line global-require
	MessageChannel = require('worker_threads').MessageChannel;
} catch (e) { /**/ }

// https://262.ecma-international.org/9.0/#sec-detacharraybuffer

/* globals postMessage */

module.exports = function DetachArrayBuffer(arrayBuffer) {
	if (!isArrayBuffer(arrayBuffer) || isSharedArrayBuffer(arrayBuffer)) {
		throw new $TypeError('Assertion failed: `arrayBuffer` must be an Object with an [[ArrayBufferData]] internal slot, and not a Shared Array Buffer');
	}

	// commented out since there's no way to set or access this key
	// var key = arguments.length > 1 ? arguments[1] : void undefined;

	// if (!SameValue(arrayBuffer[[ArrayBufferDetachKey]], key)) {
	// 	throw new $TypeError('Assertion failed: `key` must be the value of the [[ArrayBufferDetachKey]] internal slot of `arrayBuffer`');
	// }

	if (!IsDetachedBuffer(arrayBuffer)) { // node v21.0.0+ throws when you structuredClone a detached buffer
		if (typeof structuredClone === 'function') {
			structuredClone(arrayBuffer, { transfer: [arrayBuffer] });
		} else if (typeof postMessage === 'function') {
			postMessage('', '/', [arrayBuffer]); // TODO: see if this might trigger listeners
		} else if (MessageChannel) {
			(new MessageChannel()).port1.postMessage(null, [arrayBuffer]);
		} else {
			throw new $SyntaxError('DetachArrayBuffer is not supported in this environment');
		}
	}

	return null;
};
'use strict';

var $TypeError = require('es-errors/type');
var isObject = require('es-object-atoms/isObject');

var objectKeys = require('object-keys');
var safePushApply = require('safe-push-apply');
var callBound = require('call-bound');

var $isEnumerable = callBound('Object.prototype.propertyIsEnumerable');

var forEach = require('../helpers/forEach');

// https://262.ecma-international.org/8.0/#sec-enumerableownproperties

module.exports = function EnumerableOwnPropertyNames(O, kind) {
	if (!isObject(O)) {
		throw new $TypeError('Assertion failed: Type(O) is not Object');
	}

	var keys = objectKeys(O);
	if (kind === 'key') {
		return keys;
	}
	if (kind === 'value' || kind === 'key+value') {
		var results = [];
		forEach(keys, function (key) {
			if ($isEnumerable(O, key)) {
				safePushApply(results, [
					kind === 'value' ? O[key] : [key, O[key]]
				]);
			}
		});
		return results;
	}
	throw new $TypeError('Assertion failed: "kind" is not "key", "value", or "key+value": ' + kind);
};
'use strict';

var $TypeError = require('es-errors/type');

var MAX_SAFE_INTEGER = require('math-intrinsics/constants/maxSafeInteger');

var Call = require('./Call');
var CreateDataPropertyOrThrow = require('./CreateDataPropertyOrThrow');
var Get = require('./Get');
var HasProperty = require('./HasProperty');
var IsArray = require('./IsArray');
var LengthOfArrayLike = require('./LengthOfArrayLike');
var ToString = require('./ToString');

// https://262.ecma-international.org/11.0/#sec-flattenintoarray

module.exports = function FlattenIntoArray(target, source, sourceLen, start, depth) {
	var mapperFunction;
	if (arguments.length > 5) {
		mapperFunction = arguments[5];
	}

	var targetIndex = start;
	var sourceIndex = 0;
	while (sourceIndex < sourceLen) {
		var P = ToString(sourceIndex);
		var exists = HasProperty(source, P);
		if (exists === true) {
			var element = Get(source, P);
			if (typeof mapperFunction !== 'undefined') {
				if (arguments.length <= 6) {
					throw new $TypeError('Assertion failed: thisArg is required when mapperFunction is provided');
				}
				element = Call(mapperFunction, arguments[6], [element, sourceIndex, source]);
			}
			var shouldFlatten = false;
			if (depth > 0) {
				shouldFlatten = IsArray(element);
			}
			if (shouldFlatten) {
				var elementLen = LengthOfArrayLike(element);
				targetIndex = FlattenIntoArray(target, element, elementLen, targetIndex, depth - 1);
			} else {
				if (targetIndex >= MAX_SAFE_INTEGER) {
					throw new $TypeError('index too large');
				}
				CreateDataPropertyOrThrow(target, ToString(targetIndex), element);
				targetIndex += 1;
			}
		}
		sourceIndex += 1;
	}

	return targetIndex;
};
'use strict';

// var modulo = require('./modulo');
var $floor = require('math-intrinsics/floor');

// http://262.ecma-international.org/11.0/#eqn-floor

module.exports = function floor(x) {
	// return x - modulo(x, 1);
	if (typeof x === 'bigint') {
		return x;
	}
	return $floor(x);
};
'use strict';

var $TypeError = require('es-errors/type');

var isPropertyDescriptor = require('../helpers/records/property-descriptor');
var fromPropertyDescriptor = require('../helpers/fromPropertyDescriptor');

// https://262.ecma-international.org/6.0/#sec-frompropertydescriptor

module.exports = function FromPropertyDescriptor(Desc) {
	if (typeof Desc !== 'undefined' && !isPropertyDescriptor(Desc)) {
		throw new $TypeError('Assertion failed: `Desc` must be a Property Descriptor');
	}

	return fromPropertyDescriptor(Desc);
};
'use strict';

var getGlobal = require('globalthis/polyfill');

// https://262.ecma-international.org/6.0/#sec-getglobalobject

module.exports = function GetGlobalObject() {
	return getGlobal();
};
'use strict';

var GetIntrinsic = require('get-intrinsic');

var $TypeError = require('es-errors/type');
var $SyntaxError = require('es-errors/syntax');
var isObject = require('es-object-atoms/isObject');
var $asyncIterator = GetIntrinsic('%Symbol.asyncIterator%', true);

var inspect = require('object-inspect');
var hasSymbols = require('has-symbols')();

var getIteratorMethod = require('../helpers/getIteratorMethod');
var AdvanceStringIndex = require('./AdvanceStringIndex');
var Call = require('./Call');
var GetMethod = require('./GetMethod');

var ES = {
	AdvanceStringIndex: AdvanceStringIndex,
	GetMethod: GetMethod
};

// https://262.ecma-international.org/9.0/#sec-getiterator

module.exports = function GetIterator(obj, hint, method) {
	var actualHint = hint;
	if (arguments.length < 2) {
		actualHint = 'sync';
	}
	if (actualHint !== 'sync' && actualHint !== 'async') {
		throw new $TypeError("Assertion failed: `hint` must be one of 'sync' or 'async', got " + inspect(hint));
	}

	var actualMethod = method;
	if (arguments.length < 3) {
		if (actualHint === 'async') {
			if (hasSymbols && $asyncIterator) {
				actualMethod = GetMethod(obj, $asyncIterator);
			}
			if (actualMethod === undefined) {
				throw new $SyntaxError("async from sync iterators aren't currently supported");
			}
		} else {
			actualMethod = getIteratorMethod(ES, obj);
		}
	}
	var iterator = Call(actualMethod, obj);
	if (!isObject(iterator)) {
		throw new $TypeError('iterator must return an object');
	}

	return iterator;

	// TODO: This should return an IteratorRecord
	/*
	var nextMethod = GetV(iterator, 'next');
	return {
		'[[Iterator]]': iterator,
		'[[NextMethod]]': nextMethod,
		'[[Done]]': false
	};
	*/
};
'use strict';

var $TypeError = require('es-errors/type');

var inspect = require('object-inspect');

var isPropertyKey = require('../helpers/isPropertyKey');

var isObject = require('es-object-atoms/isObject');

// https://262.ecma-international.org/6.0/#sec-get-o-p

module.exports = function Get(O, P) {
	// 7.3.1.1
	if (!isObject(O)) {
		throw new $TypeError('Assertion failed: Type(O) is not Object');
	}
	// 7.3.1.2
	if (!isPropertyKey(P)) {
		throw new $TypeError('Assertion failed: P is not a Property Key, got ' + inspect(P));
	}
	// 7.3.1.3
	return O[P];
};
'use strict';

var $TypeError = require('es-errors/type');

var GetV = require('./GetV');
var IsCallable = require('./IsCallable');
var isPropertyKey = require('../helpers/isPropertyKey');

var inspect = require('object-inspect');

// https://262.ecma-international.org/6.0/#sec-getmethod

module.exports = function GetMethod(O, P) {
	// 7.3.9.1
	if (!isPropertyKey(P)) {
		throw new $TypeError('Assertion failed: P is not a Property Key');
	}

	// 7.3.9.2
	var func = GetV(O, P);

	// 7.3.9.4
	if (func == null) {
		return void 0;
	}

	// 7.3.9.5
	if (!IsCallable(func)) {
		throw new $TypeError(inspect(P) + ' is not a function: ' + inspect(func));
	}

	// 7.3.9.6
	return func;
};
'use strict';

var GetIntrinsic = require('get-intrinsic');

var hasSymbols = require('has-symbols')();

var $TypeError = require('es-errors/type');
var isObject = require('es-object-atoms/isObject');

var $gOPN = GetIntrinsic('%Object.getOwnPropertyNames%', true);
var $gOPS = hasSymbols && GetIntrinsic('%Object.getOwnPropertySymbols%', true);
var keys = require('object-keys');

// https://262.ecma-international.org/6.0/#sec-getownpropertykeys

module.exports = function GetOwnPropertyKeys(O, Type) {
	if (!isObject(O)) {
		throw new $TypeError('Assertion failed: Type(O) is not Object');
	}
	if (Type === 'Symbol') {
		return $gOPS ? $gOPS(O) : [];
	}
	if (Type === 'String') {
		if (!$gOPN) {
			return keys(O);
		}
		return $gOPN(O);
	}
	throw new $TypeError('Assertion failed: `Type` must be `"String"` or `"Symbol"`');
};
'use strict';

var GetIntrinsic = require('get-intrinsic');

var $Function = GetIntrinsic('%Function%');
var $TypeError = require('es-errors/type');
var $SyntaxError = require('es-errors/syntax');

var Get = require('./Get');
var IsConstructor = require('./IsConstructor');

var isObject = require('es-object-atoms/isObject');

// https://262.ecma-international.org/6.0/#sec-getprototypefromconstructor

module.exports = function GetPrototypeFromConstructor(constructor, intrinsicDefaultProto) {
	var intrinsic = GetIntrinsic(intrinsicDefaultProto); // throws if not a valid intrinsic
	if (!isObject(intrinsic)) {
		throw new $TypeError('intrinsicDefaultProto must be an object');
	}
	if (!IsConstructor(constructor)) {
		throw new $TypeError('Assertion failed: `constructor` must be a constructor');
	}
	var proto = Get(constructor, 'prototype');
	if (!isObject(proto)) {
		if (!(constructor instanceof $Function)) {
			// ignore other realms, for now
			throw new $SyntaxError('cross-realm constructors not currently supported');
		}
		proto = intrinsic;
	}
	return proto;
};
'use strict';

var $TypeError = require('es-errors/type');

var callBound = require('call-bound');
var regexTester = require('safe-regex-test');
var every = require('../helpers/every');

var $charAt = callBound('String.prototype.charAt');
var $strSlice = callBound('String.prototype.slice');
var $indexOf = callBound('String.prototype.indexOf');
var $parseInt = parseInt;

var isDigit = regexTester(/^[0-9]$/);

var inspect = require('object-inspect');
var isInteger = require('math-intrinsics/isInteger');

var Get = require('./Get');
var IsArray = require('./IsArray');
var ToObject = require('./ToObject');
var ToString = require('./ToString');

var isStringOrUndefined = require('../helpers/isStringOrUndefined');

// http://262.ecma-international.org/9.0/#sec-getsubstitution

// eslint-disable-next-line max-statements, max-params, max-lines-per-function
module.exports = function GetSubstitution(matched, str, position, captures, namedCaptures, replacement) {
	if (typeof matched !== 'string') {
		throw new $TypeError('Assertion failed: `matched` must be a String');
	}
	var matchLength = matched.length;

	if (typeof str !== 'string') {
		throw new $TypeError('Assertion failed: `str` must be a String');
	}
	var stringLength = str.length;

	if (!isInteger(position) || position < 0 || position > stringLength) {
		throw new $TypeError('Assertion failed: `position` must be a nonnegative integer, and less than or equal to the length of `string`, got ' + inspect(position));
	}

	if (!IsArray(captures) || !every(captures, isStringOrUndefined)) {
		throw new $TypeError('Assertion failed: `captures` must be a List of Strings or `undefined`, got ' + inspect(captures));
	}

	if (typeof replacement !== 'string') {
		throw new $TypeError('Assertion failed: `replacement` must be a String');
	}

	var tailPos = position + matchLength;
	var m = captures.length;
	if (typeof namedCaptures !== 'undefined') {
		namedCaptures = ToObject(namedCaptures); // eslint-disable-line no-param-reassign
	}

	var result = '';
	for (var i = 0; i < replacement.length; i += 1) {
		// if this is a $, and it's not the end of the replacement
		var current = $charAt(replacement, i);
		var isLast = (i + 1) >= replacement.length;
		var nextIsLast = (i + 2) >= replacement.length;
		if (current === '$' && !isLast) {
			var next = $charAt(replacement, i + 1);
			if (next === '$') {
				result += '$';
				i += 1;
			} else if (next === '&') {
				result += matched;
				i += 1;
			} else if (next === '`') {
				result += position === 0 ? '' : $strSlice(str, 0, position - 1);
				i += 1;
			} else if (next === "'") {
				result += tailPos >= stringLength ? '' : $strSlice(str, tailPos);
				i += 1;
			} else {
				var nextNext = nextIsLast ? null : $charAt(replacement, i + 2);
				if (isDigit(next) && next !== '0' && (nextIsLast || !isDigit(nextNext))) {
					// $1 through $9, and not followed by a digit
					var n = $parseInt(next, 10);
					// if (n > m, impl-defined)
					result += n <= m && typeof captures[n - 1] === 'undefined' ? '' : captures[n - 1];
					i += 1;
				} else if (isDigit(next) && (nextIsLast || isDigit(nextNext))) {
					// $00 through $99
					var nn = next + nextNext;
					var nnI = $parseInt(nn, 10) - 1;
					// if nn === '00' or nn > m, impl-defined
					result += nn <= m && typeof captures[nnI] === 'undefined' ? '' : captures[nnI];
					i += 2;
				} else if (next === '<') {
					if (typeof namedCaptures === 'undefined') {
						result += '$<';
						i += 2;
					} else {
						var endIndex = $indexOf(replacement, '>', i);

						if (endIndex > -1) {
							var groupName = $strSlice(replacement, i + '$<'.length, endIndex);
							var capture = Get(namedCaptures, groupName);

							if (typeof capture !== 'undefined') {
								result += ToString(capture);
							}
							i += ('<' + groupName + '>').length;
						}
					}
				} else {
					result += '$';
				}
			}
		} else {
			// the final $, or else not a $
			result += $charAt(replacement, i);
		}
	}
	return result;
};
'use strict';

var GetIntrinsic = require('get-intrinsic');

var $SyntaxError = require('es-errors/syntax');
var $TypeError = require('es-errors/type');
var $Uint8Array = GetIntrinsic('%Uint8Array%', true);
var isInteger = require('math-intrinsics/isInteger');

var callBound = require('call-bound');

var $slice = callBound('Array.prototype.slice');

var IsDetachedBuffer = require('./IsDetachedBuffer');
var RawBytesToNumeric = require('./RawBytesToNumeric');

var isArrayBuffer = require('is-array-buffer');
var isSharedArrayBuffer = require('is-shared-array-buffer');
var safeConcat = require('safe-array-concat');

var tableTAO = require('./tables/typed-array-objects');

var defaultEndianness = require('../helpers/defaultEndianness');

// https://262.ecma-international.org/11.0/#sec-getvaluefrombuffer

module.exports = function GetValueFromBuffer(arrayBuffer, byteIndex, type, isTypedArray, order) {
	var isSAB = isSharedArrayBuffer(arrayBuffer);
	if (!isArrayBuffer(arrayBuffer) && !isSAB) {
		throw new $TypeError('Assertion failed: `arrayBuffer` must be an ArrayBuffer or a SharedArrayBuffer');
	}

	if (!isInteger(byteIndex)) {
		throw new $TypeError('Assertion failed: `byteIndex` must be an integer');
	}

	if (typeof type !== 'string' || typeof tableTAO.size['$' + type] !== 'number') {
		throw new $TypeError('Assertion failed: `type` must be one of ' + tableTAO.choices);
	}

	if (typeof isTypedArray !== 'boolean') {
		throw new $TypeError('Assertion failed: `isTypedArray` must be a boolean');
	}

	if (order !== 'SeqCst' && order !== 'Unordered') {
		throw new $TypeError('Assertion failed: `order` must be either `SeqCst` or `Unordered`');
	}

	if (arguments.length > 5 && typeof arguments[5] !== 'boolean') {
		throw new $TypeError('Assertion failed: `isLittleEndian` must be a boolean, if present');
	}

	if (IsDetachedBuffer(arrayBuffer)) {
		throw new $TypeError('Assertion failed: `arrayBuffer` is detached'); // step 1
	}

	// 2. Assert: There are sufficient bytes in arrayBuffer starting at byteIndex to represent a value of type.

	if (byteIndex < 0) {
		throw new $TypeError('Assertion failed: `byteIndex` must be non-negative'); // step 3
	}

	// 4. Let block be arrayBuffer.[[ArrayBufferData]].

	var elementSize = tableTAO.size['$' + type]; // step 5
	if (!elementSize) {
		throw new $TypeError('Assertion failed: `type` must be one of ' + tableTAO.choices);
	}

	var rawValue;
	if (isSAB) { // step 6
		/*
		a. Let execution be the [[CandidateExecution]] field of the surrounding agent's Agent Record.
		b. Let eventList be the [[EventList]] field of the element in execution.[[EventLists]] whose [[AgentSignifier]] is AgentSignifier().
		c. If isTypedArray is true and type is "Int8", "Uint8", "Int16", "Uint16", "Int32", or "Uint32", let noTear be true; otherwise let noTear be false.
		d. Let rawValue be a List of length elementSize of nondeterministically chosen byte values.
		e. NOTE: In implementations, rawValue is the result of a non-atomic or atomic read instruction on the underlying hardware. The nondeterminism is a semantic prescription of the memory model to describe observable behaviour of hardware with weak consistency.
		f. Let readEvent be ReadSharedMemory{ [[Order]]: order, [[NoTear]]: noTear, [[Block]]: block, [[ByteIndex]]: byteIndex, [[ElementSize]]: elementSize }.
		g. Append readEvent to eventList.
		h. Append Chosen Value Record { [[Event]]: readEvent, [[ChosenValue]]: rawValue } to execution.[[ChosenValues]].
		*/
		throw new $SyntaxError('SharedArrayBuffer is not supported by this implementation');
	} else {
		// 7. Let rawValue be a List of elementSize containing, in order, the elementSize sequence of bytes starting with block[byteIndex].
		rawValue = $slice(new $Uint8Array(arrayBuffer, byteIndex), 0, elementSize); // step 6
	}

	// 8. If isLittleEndian is not present, set isLittleEndian to either true or false. The choice is implementation dependent and should be the alternative that is most efficient for the implementation. An implementation must use the same value each time this step is executed and the same value must be used for the corresponding step in the SetValueInBuffer abstract operation.
	var isLittleEndian = arguments.length > 5 ? arguments[5] : defaultEndianness === 'little'; // step 8

	var bytes = isLittleEndian
		? $slice(safeConcat([0, 0, 0, 0, 0, 0, 0, 0], rawValue), -elementSize)
		: $slice(safeConcat(rawValue, [0, 0, 0, 0, 0, 0, 0, 0]), 0, elementSize);

	return RawBytesToNumeric(type, bytes, isLittleEndian);
};
'use strict';

var $TypeError = require('es-errors/type');

var inspect = require('object-inspect');

var isPropertyKey = require('../helpers/isPropertyKey');
// var ToObject = require('./ToObject');

// https://262.ecma-international.org/6.0/#sec-getv

module.exports = function GetV(V, P) {
	// 7.3.2.1
	if (!isPropertyKey(P)) {
		throw new $TypeError('Assertion failed: P is not a Property Key, got ' + inspect(P));
	}

	// 7.3.2.2-3
	// var O = ToObject(V);

	// 7.3.2.4
	return V[P];
};
'use strict';

var $TypeError = require('es-errors/type');

var hasOwn = require('hasown');
var isObject = require('es-object-atoms/isObject');

var isPropertyKey = require('../helpers/isPropertyKey');

// https://262.ecma-international.org/6.0/#sec-hasownproperty

module.exports = function HasOwnProperty(O, P) {
	if (!isObject(O)) {
		throw new $TypeError('Assertion failed: `O` must be an Object');
	}
	if (!isPropertyKey(P)) {
		throw new $TypeError('Assertion failed: `P` must be a Property Key');
	}
	return hasOwn(O, P);
};
'use strict';

var $TypeError = require('es-errors/type');
var isObject = require('es-object-atoms/isObject');

var isPropertyKey = require('../helpers/isPropertyKey');

// https://262.ecma-international.org/6.0/#sec-hasproperty

module.exports = function HasProperty(O, P) {
	if (!isObject(O)) {
		throw new $TypeError('Assertion failed: `O` must be an Object');
	}
	if (!isPropertyKey(P)) {
		throw new $TypeError('Assertion failed: `P` must be a Property Key');
	}
	return P in O;
};
'use strict';

var floor = require('./floor');
var modulo = require('./modulo');

var timeConstants = require('../helpers/timeConstants');
var msPerHour = timeConstants.msPerHour;
var HoursPerDay = timeConstants.HoursPerDay;

// https://262.ecma-international.org/5.1/#sec-15.9.1.10

module.exports = function HourFromTime(t) {
	return modulo(floor(t / msPerHour), HoursPerDay);
};
'use strict';

var $EvalError = require('es-errors/eval');

var DaysInYear = require('./DaysInYear');
var YearFromTime = require('./YearFromTime');

// https://262.ecma-international.org/5.1/#sec-15.9.1.3

module.exports = function InLeapYear(t) {
	var days = DaysInYear(YearFromTime(t));
	if (days === 365) {
		return 0;
	}
	if (days === 366) {
		return 1;
	}
	throw new $EvalError('Assertion failed: there are not 365 or 366 days in a year, got: ' + days);
};
'use strict';

var GetIntrinsic = require('get-intrinsic');

var $TypeError = require('es-errors/type');
var isObject = require('es-object-atoms/isObject');

var $hasInstance = GetIntrinsic('%Symbol.hasInstance%', true);

var Call = require('./Call');
var GetMethod = require('./GetMethod');
var IsCallable = require('./IsCallable');
var OrdinaryHasInstance = require('./OrdinaryHasInstance');
var ToBoolean = require('./ToBoolean');

// https://262.ecma-international.org/6.0/#sec-instanceofoperator

module.exports = function InstanceofOperator(O, C) {
	if (!isObject(O)) {
		throw new $TypeError('Assertion failed: Type(O) is not Object');
	}
	var instOfHandler = $hasInstance ? GetMethod(C, $hasInstance) : void 0;
	if (typeof instOfHandler !== 'undefined') {
		return ToBoolean(Call(instOfHandler, C, [O]));
	}
	if (!IsCallable(C)) {
		throw new $TypeError('`C` is not Callable');
	}
	return OrdinaryHasInstance(C, O);
};
'use strict';

var $TypeError = require('es-errors/type');

var GetValueFromBuffer = require('./GetValueFromBuffer');
var IsDetachedBuffer = require('./IsDetachedBuffer');
var IsValidIntegerIndex = require('./IsValidIntegerIndex');

var typedArrayLength = require('typed-array-length');
var typedArrayBuffer = require('typed-array-buffer');
var typedArrayByteOffset = require('typed-array-byte-offset');
var whichTypedArray = require('which-typed-array');

var tableTAO = require('./tables/typed-array-objects');

// https://262.ecma-international.org/11.0/#sec-integerindexedelementget

module.exports = function IntegerIndexedElementGet(O, index) {
	var arrayTypeName = whichTypedArray(O); // step 7
	if (!arrayTypeName) {
		throw new $TypeError('`O` must be a TypedArray'); // step 1
	}

	if (typeof index !== 'number') {
		throw new $TypeError('`index` must be a Number'); // step 2
	}

	var buffer = typedArrayBuffer(O); // step 3

	if (IsDetachedBuffer(buffer)) {
		throw new $TypeError('`O` has a detached buffer'); // step 4
	}

	if (!IsValidIntegerIndex(O, index)) {
		return void undefined; // step 5
	}

	var offset = typedArrayByteOffset(O); // step 6

	var length = typedArrayLength(O); // step 7

	if (index < 0 || index >= length) {
		return void undefined; // step 8
	}

	var elementType = tableTAO.name['$' + arrayTypeName]; // step 10

	var elementSize = tableTAO.size['$' + elementType]; // step 8

	var indexedPosition = (index * elementSize) + offset; // step 9

	return GetValueFromBuffer(buffer, indexedPosition, elementType, true, 'Unordered'); // step 11
};
'use strict';

var $TypeError = require('es-errors/type');

var IsDetachedBuffer = require('./IsDetachedBuffer');
var IsValidIntegerIndex = require('./IsValidIntegerIndex');
var SetValueInBuffer = require('./SetValueInBuffer');
var ToBigInt = require('./ToBigInt');
var ToNumber = require('./ToNumber');

var typedArrayBuffer = require('typed-array-buffer');
var typedArrayByteOffset = require('typed-array-byte-offset');
var typedArrayLength = require('typed-array-length');
var whichTypedArray = require('which-typed-array');

var tableTAO = require('./tables/typed-array-objects');

// https://262.ecma-international.org/11.0/#sec-integerindexedelementset

module.exports = function IntegerIndexedElementSet(O, index, value) {
	var arrayTypeName = whichTypedArray(O); // step 9
	if (!arrayTypeName) {
		throw new $TypeError('`O` must be a TypedArray'); // step 1
	}

	if (typeof index !== 'number') {
		throw new $TypeError('`index` must be a Number'); // step 2
	}

	var contentType = arrayTypeName === 'BigInt64Array' || arrayTypeName === 'BigUint64Array' ? 'BigInt' : 'Number';
	var numValue = contentType === 'BigInt' ? ToBigInt(value) : ToNumber(value); // steps 3 - 4

	var buffer = typedArrayBuffer(O); // step 5

	if (IsDetachedBuffer(buffer)) {
		throw new $TypeError('`O` has a detached buffer'); // step 6
	}

	if (!IsValidIntegerIndex(O, index)) {
		return false; // step 7
	}

	var offset = typedArrayByteOffset(O); // step 8

	var length = typedArrayLength(O); // step 9

	if (index < 0 || index >= length) {
		return false; // step 10
	}

	var elementType = tableTAO.name['$' + arrayTypeName]; // step 12

	var elementSize = tableTAO.size['$' + elementType]; // step 10

	var indexedPosition = (index * elementSize) + offset; // step 11

	SetValueInBuffer(buffer, indexedPosition, elementType, numValue, true, 'Unordered'); // step 13

	return true; // step 14
};
'use strict';

var $TypeError = require('es-errors/type');
var isObject = require('es-object-atoms/isObject');

var Call = require('./Call');
var CreateDataProperty = require('./CreateDataProperty');
var EnumerableOwnPropertyNames = require('./EnumerableOwnPropertyNames');
var Get = require('./Get');
var IsArray = require('./IsArray');
var LengthOfArrayLike = require('./LengthOfArrayLike');
var ToString = require('./ToString');

var forEach = require('../helpers/forEach');

// https://262.ecma-international.org/11.0/#sec-internalizejsonproperty

module.exports = function InternalizeJSONProperty(holder, name, reviver) {
	if (!isObject(holder)) {
		throw new $TypeError('Assertion failed: `holder` is not an Object');
	}
	if (typeof name !== 'string') {
		throw new $TypeError('Assertion failed: `name` is not a String');
	}
	if (typeof reviver !== 'function') {
		throw new $TypeError('Assertion failed: `reviver` is not a Function');
	}

	var val = Get(holder, name); // step 1

	if (isObject(val)) { // step 2
		var isArray = IsArray(val); // step 2.a
		if (isArray) { // step 2.b
			var I = 0; // step 2.b.i

			var len = LengthOfArrayLike(val, 'length'); // step 2.b.ii

			while (I < len) { // step 2.b.iii
				var newElement = InternalizeJSONProperty(val, ToString(I), reviver); // step 2.b.iv.1

				if (typeof newElement === 'undefined') { // step 2.b.iii.2
					delete val[ToString(I)]; // step 2.b.iii.2.a
				} else { // step 2.b.iii.3
					CreateDataProperty(val, ToString(I), newElement); // step 2.b.iii.3.a
				}

				I += 1; // step 2.b.iii.4
			}
		} else { // step 2.c
			var keys = EnumerableOwnPropertyNames(val, 'key'); // step 2.c.i

			forEach(keys, function (P) { // step 2.c.ii
				// eslint-disable-next-line no-shadow
				var newElement = InternalizeJSONProperty(val, P, reviver); // step 2.c.ii.1

				if (typeof newElement === 'undefined') { // step 2.c.ii.2
					delete val[P]; // step 2.c.ii.2.a
				} else { // step 2.c.ii.3
					CreateDataProperty(val, P, newElement); // step 2.c.ii.3.a
				}
			});
		}
	}

	return Call(reviver, holder, [name, val]); // step 3
};
'use strict';

var $TypeError = require('es-errors/type');

var Call = require('./Call');
var IsArray = require('./IsArray');
var GetV = require('./GetV');
var isPropertyKey = require('../helpers/isPropertyKey');

// https://262.ecma-international.org/6.0/#sec-invoke

module.exports = function Invoke(O, P) {
	if (!isPropertyKey(P)) {
		throw new $TypeError('Assertion failed: P must be a Property Key');
	}
	var argumentsList = arguments.length > 2 ? arguments[2] : [];
	if (!IsArray(argumentsList)) {
		throw new $TypeError('Assertion failed: optional `argumentsList`, if provided, must be a List');
	}
	var func = GetV(O, P);
	return Call(func, O, argumentsList);
};
'use strict';

var $TypeError = require('es-errors/type');

var hasOwn = require('hasown');

var isPropertyDescriptor = require('../helpers/records/property-descriptor');

// https://262.ecma-international.org/5.1/#sec-8.10.1

module.exports = function IsAccessorDescriptor(Desc) {
	if (typeof Desc === 'undefined') {
		return false;
	}

	if (!isPropertyDescriptor(Desc)) {
		throw new $TypeError('Assertion failed: `Desc` must be a Property Descriptor');
	}

	if (!hasOwn(Desc, '[[Get]]') && !hasOwn(Desc, '[[Set]]')) {
		return false;
	}

	return true;
};
'use strict';

// https://262.ecma-international.org/6.0/#sec-isarray
module.exports = require('../helpers/IsArray');
'use strict';

// https://262.ecma-international.org/11.0/#sec-isbigintelementtype

module.exports = function IsBigIntElementType(type) {
	return type === 'BigUint64' || type === 'BigInt64';
};
'use strict';

// http://262.ecma-international.org/5.1/#sec-9.11

module.exports = require('is-callable');
'use strict';

var ValidateAndApplyPropertyDescriptor = require('./ValidateAndApplyPropertyDescriptor');

// https://262.ecma-international.org/6.0/#sec-iscompatiblepropertydescriptor

module.exports = function IsCompatiblePropertyDescriptor(Extensible, Desc, Current) {
	return ValidateAndApplyPropertyDescriptor(undefined, undefined, Extensible, Desc, Current);
};
'use strict';

var GetIntrinsic = require('get-intrinsic');

var $isConcatSpreadable = GetIntrinsic('%Symbol.isConcatSpreadable%', true);

var Get = require('./Get');
var IsArray = require('./IsArray');
var ToBoolean = require('./ToBoolean');

var isObject = require('es-object-atoms/isObject');

// https://262.ecma-international.org/6.0/#sec-isconcatspreadable

module.exports = function IsConcatSpreadable(O) {
	if (!isObject(O)) {
		return false;
	}
	if ($isConcatSpreadable) {
		var spreadable = Get(O, $isConcatSpreadable);
		if (typeof spreadable !== 'undefined') {
			return ToBoolean(spreadable);
		}
	}
	return IsArray(O);
};
'use strict';

var GetIntrinsic = require('../GetIntrinsic.js');

var $construct = GetIntrinsic('%Reflect.construct%', true);

var DefinePropertyOrThrow = require('./DefinePropertyOrThrow');
try {
	DefinePropertyOrThrow({}, '', { '[[Get]]': function () {} });
} catch (e) {
	// Accessor properties aren't supported
	DefinePropertyOrThrow = null;
}

// https://262.ecma-international.org/6.0/#sec-isconstructor

if (DefinePropertyOrThrow && $construct) {
	var isConstructorMarker = {};
	var badArrayLike = {};
	DefinePropertyOrThrow(badArrayLike, 'length', {
		'[[Get]]': function () {
			throw isConstructorMarker;
		},
		'[[Enumerable]]': true
	});

	module.exports = function IsConstructor(argument) {
		try {
			// `Reflect.construct` invokes `IsConstructor(target)` before `Get(args, 'length')`:
			$construct(argument, badArrayLike);
		} catch (err) {
			return err === isConstructorMarker;
		}
	};
} else {
	module.exports = function IsConstructor(argument) {
		// unfortunately there's no way to truly check this without try/catch `new argument` in old environments
		return typeof argument === 'function' && !!argument.prototype;
	};
}
'use strict';

var $TypeError = require('es-errors/type');

var hasOwn = require('hasown');

var isPropertyDescriptor = require('../helpers/records/property-descriptor');

// https://262.ecma-international.org/5.1/#sec-8.10.2

module.exports = function IsDataDescriptor(Desc) {
	if (typeof Desc === 'undefined') {
		return false;
	}

	if (!isPropertyDescriptor(Desc)) {
		throw new $TypeError('Assertion failed: `Desc` must be a Property Descriptor');
	}

	if (!hasOwn(Desc, '[[Value]]') && !hasOwn(Desc, '[[Writable]]')) {
		return false;
	}

	return true;
};
'use strict';

var $TypeError = require('es-errors/type');

var $byteLength = require('array-buffer-byte-length');
var availableTypedArrays = require('available-typed-arrays')();
var callBound = require('call-bound');
var isArrayBuffer = require('is-array-buffer');
var isSharedArrayBuffer = require('is-shared-array-buffer');

var $sabByteLength = callBound('SharedArrayBuffer.prototype.byteLength', true);

// https://262.ecma-international.org/8.0/#sec-isdetachedbuffer

module.exports = function IsDetachedBuffer(arrayBuffer) {
	var isSAB = isSharedArrayBuffer(arrayBuffer);
	if (!isArrayBuffer(arrayBuffer) && !isSAB) {
		throw new $TypeError('Assertion failed: `arrayBuffer` must be an Object with an [[ArrayBufferData]] internal slot');
	}
	if ((isSAB ? $sabByteLength : $byteLength)(arrayBuffer) === 0) {
		try {
			new global[availableTypedArrays[0]](arrayBuffer); // eslint-disable-line no-new
		} catch (error) {
			return !!error && error.name === 'TypeError';
		}
	}
	return false;
};
'use strict';

var GetIntrinsic = require('get-intrinsic');

var $preventExtensions = GetIntrinsic('%Object.preventExtensions%', true);
var $isExtensible = GetIntrinsic('%Object.isExtensible%', true);

var isPrimitive = require('../helpers/isPrimitive');

// https://262.ecma-international.org/6.0/#sec-isextensible-o

module.exports = $preventExtensions
	? function IsExtensible(obj) {
		return !isPrimitive(obj) && $isExtensible(obj);
	}
	: function IsExtensible(obj) {
		return !isPrimitive(obj);
	};
'use strict';

var $TypeError = require('es-errors/type');

var IsAccessorDescriptor = require('./IsAccessorDescriptor');
var IsDataDescriptor = require('./IsDataDescriptor');

var isPropertyDescriptor = require('../helpers/records/property-descriptor');

// https://262.ecma-international.org/6.0/#sec-isgenericdescriptor

module.exports = function IsGenericDescriptor(Desc) {
	if (typeof Desc === 'undefined') {
		return false;
	}

	if (!isPropertyDescriptor(Desc)) {
		throw new $TypeError('Assertion failed: `Desc` must be a Property Descriptor');
	}

	if (!IsAccessorDescriptor(Desc) && !IsDataDescriptor(Desc)) {
		return true;
	}

	return false;
};
'use strict';

var isInteger = require('math-intrinsics/isInteger');

// https://262.ecma-international.org/6.0/#sec-isinteger

module.exports = function IsInteger(argument) {
	return isInteger(argument);
};
'use strict';

var IsInteger = require('./IsInteger');

// https://262.ecma-international.org/11.0/#sec-isnonnegativeinteger

module.exports = function IsNonNegativeInteger(argument) {
	return !!IsInteger(argument) && argument >= 0;
};
'use strict';

var IsUnclampedIntegerElementType = require('./IsUnclampedIntegerElementType');
var IsBigIntElementType = require('./IsBigIntElementType');

// https://262.ecma-international.org/11.0/#sec-isnotearconfiguration

module.exports = function IsNoTearConfiguration(type, order) {
	if (IsUnclampedIntegerElementType(type)) {
		return true;
	}
	if (IsBigIntElementType(type) && order !== 'Init' && order !== 'Unordered') {
		return true;
	}
	return false;
};
'use strict';

var callBound = require('call-bound');

var $PromiseThen = callBound('Promise.prototype.then', true);

var isObject = require('es-object-atoms/isObject');

// https://262.ecma-international.org/6.0/#sec-ispromise

module.exports = function IsPromise(x) {
	if (!isObject(x)) {
		return false;
	}
	if (!$PromiseThen) { // Promises are not supported
		return false;
	}
	try {
		$PromiseThen(x); // throws if not a promise
	} catch (e) {
		return false;
	}
	return true;
};
'use strict';

var isPropertyKey = require('../helpers/isPropertyKey');

// https://262.ecma-international.org/6.0/#sec-ispropertykey

module.exports = function IsPropertyKey(argument) {
	return isPropertyKey(argument);
};
'use strict';

var GetIntrinsic = require('get-intrinsic');

var $match = GetIntrinsic('%Symbol.match%', true);

var hasRegExpMatcher = require('is-regex');
var isObject = require('es-object-atoms/isObject');

var ToBoolean = require('./ToBoolean');

// https://262.ecma-international.org/6.0/#sec-isregexp

module.exports = function IsRegExp(argument) {
	if (!isObject(argument)) {
		return false;
	}
	if ($match) {
		var isRegExp = argument[$match];
		if (typeof isRegExp !== 'undefined') {
			return ToBoolean(isRegExp);
		}
	}
	return hasRegExpMatcher(argument);
};
'use strict';

var $TypeError = require('es-errors/type');
var isObject = require('es-object-atoms/isObject');

var isSharedArrayBuffer = require('is-shared-array-buffer');

// https://262.ecma-international.org/8.0/#sec-issharedarraybuffer

module.exports = function IsSharedArrayBuffer(obj) {
	if (!isObject(obj)) {
		throw new $TypeError('Assertion failed: Type(O) is not Object');
	}

	return isSharedArrayBuffer(obj);
};
'use strict';

var $TypeError = require('es-errors/type');

var isPrefixOf = require('../helpers/isPrefixOf');

// var callBound = require('call-bound');

// var $charAt = callBound('String.prototype.charAt');

// https://262.ecma-international.org/9.0/#sec-isstringprefix

module.exports = function IsStringPrefix(p, q) {
	if (typeof p !== 'string') {
		throw new $TypeError('Assertion failed: "p" must be a String');
	}

	if (typeof q !== 'string') {
		throw new $TypeError('Assertion failed: "q" must be a String');
	}

	return isPrefixOf(p, q);
	/*
	if (p === q || p === '') {
		return true;
	}

	var pLength = p.length;
	var qLength = q.length;
	if (pLength >= qLength) {
		return false;
	}

	// assert: pLength < qLength

	for (var i = 0; i < pLength; i += 1) {
		if ($charAt(p, i) !== $charAt(q, i)) {
			return false;
		}
	}
	return true;
	*/
};
'use strict';

// https://262.ecma-international.org/11.0/#sec-isunclampedintegerelementtype

module.exports = function IsUnclampedIntegerElementType(type) {
	return type === 'Int8'
		|| type === 'Uint8'
		|| type === 'Int16'
		|| type === 'Uint16'
		|| type === 'Int32'
		|| type === 'Uint32';
};
'use strict';

// https://262.ecma-international.org/11.0/#sec-isunsignedelementtype

module.exports = function IsUnsignedElementType(type) {
	return type === 'Uint8'
		|| type === 'Uint8C'
		|| type === 'Uint16'
		|| type === 'Uint32'
		|| type === 'BigUint64';
};
'use strict';

var $TypeError = require('es-errors/type');

var IsInteger = require('./IsInteger');

var isNegativeZero = require('math-intrinsics/isNegativeZero');

var isTypedArray = require('is-typed-array');
var typedArrayBuffer = require('typed-array-buffer');

// https://262.ecma-international.org/11.0/#sec-isvalidintegerindex

module.exports = function IsValidIntegerIndex(O, index) {
	if (!isTypedArray) {
		throw new $TypeError('Assertion failed: `O` must be a Typed Array');
	}

	typedArrayBuffer(O); // step 1

	if (typeof index !== 'number') {
		throw new $TypeError('Assertion failed: Type(index) is not Number'); // step 2
	}

	if (!IsInteger(index)) { return false; } // step 3

	if (isNegativeZero(index)) { return false; } // step 4

	if (index < 0 || index >= O.length) { return false; } // step 5

	return true; // step 6
};
'use strict';

var $TypeError = require('es-errors/type');

var callBound = require('call-bound');

var $indexOf = callBound('String.prototype.indexOf');

var IsArray = require('./IsArray');
var IsInteger = require('./IsInteger');
var WordCharacters = require('./WordCharacters');

var every = require('../helpers/every');

var isChar = function isChar(c) {
	return typeof c === 'string';
};

// https://262.ecma-international.org/8.0/#sec-runtime-semantics-iswordchar-abstract-operation

// note: prior to ES2023, this AO erroneously omitted the latter of its arguments.
module.exports = function IsWordChar(e, InputLength, Input, IgnoreCase, Unicode) {
	if (!IsInteger(e)) {
		throw new $TypeError('Assertion failed: `e` must be an integer');
	}
	if (!IsInteger(InputLength)) {
		throw new $TypeError('Assertion failed: `InputLength` must be an integer');
	}
	if (!IsArray(Input) || !every(Input, isChar)) {
		throw new $TypeError('Assertion failed: `Input` must be a List of characters');
	}
	if (typeof IgnoreCase !== 'boolean' || typeof Unicode !== 'boolean') {
		throw new $TypeError('Assertion failed: `IgnoreCase` and `Unicode` must be booleans');
	}

	if (e === -1 || e === InputLength) {
		return false; // step 1
	}

	var c = Input[e]; // step 2

	var wordChars = WordCharacters(IgnoreCase, Unicode);

	return $indexOf(wordChars, c) > -1; // steps 3-4
};
'use strict';

var GetIterator = require('./GetIterator');
var IteratorStep = require('./IteratorStep');
var IteratorValue = require('./IteratorValue');

// https://262.ecma-international.org/9.0/#sec-iterabletolist

module.exports = function IterableToList(items, method) {
	var iterator = GetIterator(items, 'sync', method);
	var values = [];
	var next = true;
	while (next) {
		next = IteratorStep(iterator);
		if (next) {
			var nextValue = IteratorValue(next);
			values[values.length] = nextValue;
		}
	}
	return values;
};
'use strict';

var $TypeError = require('es-errors/type');
var isObject = require('es-object-atoms/isObject');

var Call = require('./Call');
var CompletionRecord = require('./CompletionRecord');
var GetMethod = require('./GetMethod');
var IsCallable = require('./IsCallable');

// https://262.ecma-international.org/6.0/#sec-iteratorclose

module.exports = function IteratorClose(iterator, completion) {
	if (!isObject(iterator)) {
		throw new $TypeError('Assertion failed: Type(iterator) is not Object');
	}
	if (!IsCallable(completion) && !(completion instanceof CompletionRecord)) {
		throw new $TypeError('Assertion failed: completion is not a thunk representing a Completion Record, nor a Completion Record instance');
	}
	var completionThunk = completion instanceof CompletionRecord ? function () { return completion['?'](); } : completion;

	var iteratorReturn = GetMethod(iterator, 'return');

	if (typeof iteratorReturn === 'undefined') {
		return completionThunk();
	}

	var completionRecord;
	try {
		var innerResult = Call(iteratorReturn, iterator, []);
	} catch (e) {
		// if we hit here, then "e" is the innerResult completion that needs re-throwing

		// if the completion is of type "throw", this will throw.
		completionThunk();
		completionThunk = null; // ensure it's not called twice.

		// if not, then return the innerResult completion
		throw e;
	}
	completionRecord = completionThunk(); // if innerResult worked, then throw if the completion does
	completionThunk = null; // ensure it's not called twice.

	if (!isObject(innerResult)) {
		throw new $TypeError('iterator .return must return an object');
	}

	return completionRecord;
};
'use strict';

var $TypeError = require('es-errors/type');
var isObject = require('es-object-atoms/isObject');

var Get = require('./Get');
var ToBoolean = require('./ToBoolean');

// https://262.ecma-international.org/6.0/#sec-iteratorcomplete

module.exports = function IteratorComplete(iterResult) {
	if (!isObject(iterResult)) {
		throw new $TypeError('Assertion failed: Type(iterResult) is not Object');
	}
	return ToBoolean(Get(iterResult, 'done'));
};
'use strict';

var $TypeError = require('es-errors/type');
var isObject = require('es-object-atoms/isObject');

var Invoke = require('./Invoke');

// https://262.ecma-international.org/6.0/#sec-iteratornext

module.exports = function IteratorNext(iterator, value) {
	var result = Invoke(iterator, 'next', arguments.length < 2 ? [] : [value]);
	if (!isObject(result)) {
		throw new $TypeError('iterator next must return an object');
	}
	return result;
};
'use strict';

var IteratorComplete = require('./IteratorComplete');
var IteratorNext = require('./IteratorNext');

// https://262.ecma-international.org/6.0/#sec-iteratorstep

module.exports = function IteratorStep(iterator) {
	var result = IteratorNext(iterator);
	var done = IteratorComplete(result);
	return done === true ? false : result;
};

'use strict';

var $TypeError = require('es-errors/type');
var isObject = require('es-object-atoms/isObject');

var Get = require('./Get');

// https://262.ecma-international.org/6.0/#sec-iteratorvalue

module.exports = function IteratorValue(iterResult) {
	if (!isObject(iterResult)) {
		throw new $TypeError('Assertion failed: Type(iterResult) is not Object');
	}
	return Get(iterResult, 'value');
};

'use strict';

var $TypeError = require('es-errors/type');
var isObject = require('es-object-atoms/isObject');

var Get = require('./Get');
var ToLength = require('./ToLength');

// https://262.ecma-international.org/11.0/#sec-lengthofarraylike

module.exports = function LengthOfArrayLike(obj) {
	if (!isObject(obj)) {
		throw new $TypeError('Assertion failed: `obj` must be an Object');
	}
	return ToLength(Get(obj, 'length'));
};

// TODO: use this all over
'use strict';

var $isFinite = require('math-intrinsics/isFinite');

var msPerDay = require('../helpers/timeConstants').msPerDay;

// https://262.ecma-international.org/5.1/#sec-15.9.1.13

module.exports = function MakeDate(day, time) {
	if (!$isFinite(day) || !$isFinite(time)) {
		return NaN;
	}
	return (day * msPerDay) + time;
};
'use strict';

var GetIntrinsic = require('get-intrinsic');

var $DateUTC = GetIntrinsic('%Date.UTC%');

var $isFinite = require('math-intrinsics/isFinite');

var DateFromTime = require('./DateFromTime');
var Day = require('./Day');
var floor = require('./floor');
var modulo = require('./modulo');
var MonthFromTime = require('./MonthFromTime');
var ToInteger = require('./ToInteger');
var YearFromTime = require('./YearFromTime');

// https://262.ecma-international.org/5.1/#sec-15.9.1.12

module.exports = function MakeDay(year, month, date) {
	if (!$isFinite(year) || !$isFinite(month) || !$isFinite(date)) {
		return NaN;
	}
	var y = ToInteger(year);
	var m = ToInteger(month);
	var dt = ToInteger(date);
	var ym = y + floor(m / 12);
	var mn = modulo(m, 12);
	var t = $DateUTC(ym, mn, 1);
	if (YearFromTime(t) !== ym || MonthFromTime(t) !== mn || DateFromTime(t) !== 1) {
		return NaN;
	}
	return Day(t) + dt - 1;
};
'use strict';

var $isFinite = require('math-intrinsics/isFinite');

var timeConstants = require('../helpers/timeConstants');
var msPerSecond = timeConstants.msPerSecond;
var msPerMinute = timeConstants.msPerMinute;
var msPerHour = timeConstants.msPerHour;

var ToInteger = require('./ToInteger');

// https://262.ecma-international.org/5.1/#sec-15.9.1.11

module.exports = function MakeTime(hour, min, sec, ms) {
	if (!$isFinite(hour) || !$isFinite(min) || !$isFinite(sec) || !$isFinite(ms)) {
		return NaN;
	}
	var h = ToInteger(hour);
	var m = ToInteger(min);
	var s = ToInteger(sec);
	var milli = ToInteger(ms);
	var t = (h * msPerHour) + (m * msPerMinute) + (s * msPerSecond) + milli;
	return t;
};
'use strict';

// https://262.ecma-international.org/6.0/#sec-algorithm-conventions

module.exports = require('math-intrinsics/max');
'use strict';

var floor = require('./floor');
var modulo = require('./modulo');

var timeConstants = require('../helpers/timeConstants');
var msPerMinute = timeConstants.msPerMinute;
var MinutesPerHour = timeConstants.MinutesPerHour;

// https://262.ecma-international.org/5.1/#sec-15.9.1.10

module.exports = function MinFromTime(t) {
	return modulo(floor(t / msPerMinute), MinutesPerHour);
};
'use strict';

// https://262.ecma-international.org/6.0/#sec-algorithm-conventions

module.exports = require('math-intrinsics/min');
'use strict';

var mod = require('../helpers/mod');

// https://262.ecma-international.org/5.1/#sec-5.2

module.exports = function modulo(x, y) {
	return mod(x, y);
};
'use strict';

var $RangeError = require('es-errors/range');

var DayWithinYear = require('./DayWithinYear');
var InLeapYear = require('./InLeapYear');

// https://262.ecma-international.org/5.1/#sec-15.9.1.4

module.exports = function MonthFromTime(t) {
	var day = DayWithinYear(t);
	if (0 <= day && day < 31) {
		return 0;
	}
	var leap = InLeapYear(t);
	if (31 <= day && day < (59 + leap)) {
		return 1;
	}
	if ((59 + leap) <= day && day < (90 + leap)) {
		return 2;
	}
	if ((90 + leap) <= day && day < (120 + leap)) {
		return 3;
	}
	if ((120 + leap) <= day && day < (151 + leap)) {
		return 4;
	}
	if ((151 + leap) <= day && day < (181 + leap)) {
		return 5;
	}
	if ((181 + leap) <= day && day < (212 + leap)) {
		return 6;
	}
	if ((212 + leap) <= day && day < (243 + leap)) {
		return 7;
	}
	if ((243 + leap) <= day && day < (273 + leap)) {
		return 8;
	}
	if ((273 + leap) <= day && day < (304 + leap)) {
		return 9;
	}
	if ((304 + leap) <= day && day < (334 + leap)) {
		return 10;
	}
	if ((334 + leap) <= day && day < (365 + leap)) {
		return 11;
	}

	throw new $RangeError('Assertion failed: `day` is out of range');
};
'use strict';

var modulo = require('./modulo');

var msPerSecond = require('../helpers/timeConstants').msPerSecond;

// https://262.ecma-international.org/5.1/#sec-15.9.1.10

module.exports = function msFromTime(t) {
	return modulo(t, msPerSecond);
};
'use strict';

var $TypeError = require('es-errors/type');

var IsCallable = require('./IsCallable');
var IsConstructor = require('./IsConstructor');

// https://262.ecma-international.org/6.0/#sec-newpromisecapability

module.exports = function NewPromiseCapability(C) {
	if (!IsConstructor(C)) {
		throw new $TypeError('C must be a constructor'); // step 1
	}

	var resolvingFunctions = { '[[Resolve]]': void undefined, '[[Reject]]': void undefined }; // step 3

	var promise = new C(function (resolve, reject) { // steps 4-5
		if (typeof resolvingFunctions['[[Resolve]]'] !== 'undefined' || typeof resolvingFunctions['[[Reject]]'] !== 'undefined') {
			throw new $TypeError('executor has already been called'); // step 4.a, 4.b
		}
		resolvingFunctions['[[Resolve]]'] = resolve; // step 4.c
		resolvingFunctions['[[Reject]]'] = reject; // step 4.d
	}); // step 4-6

	if (!IsCallable(resolvingFunctions['[[Resolve]]']) || !IsCallable(resolvingFunctions['[[Reject]]'])) {
		throw new $TypeError('executor must provide valid resolve and reject functions'); // steps 7-8
	}

	return {
		'[[Promise]]': promise,
		'[[Resolve]]': resolvingFunctions['[[Resolve]]'],
		'[[Reject]]': resolvingFunctions['[[Reject]]']
	}; // step 9
};
'use strict';

var CompletionRecord = require('./CompletionRecord');

// https://262.ecma-international.org/6.0/#sec-normalcompletion

module.exports = function NormalCompletion(value) {
	return new CompletionRecord('normal', value);
};
'use strict';

var $TypeError = require('es-errors/type');

var ToInt32 = require('./ToInt32');
var ToUint32 = require('./ToUint32');

// https://262.ecma-international.org/11.0/#sec-numberbitwiseop

module.exports = function NumberBitwiseOp(op, x, y) {
	if (op !== '&' && op !== '|' && op !== '^') {
		throw new $TypeError('Assertion failed: `op` must be `&`, `|`, or `^`');
	}
	if (typeof x !== 'number' || typeof y !== 'number') {
		throw new $TypeError('Assertion failed: `x` and `y` arguments must be Numbers');
	}
	var lnum = ToInt32(x);
	var rnum = ToUint32(y);
	if (op === '&') {
		return lnum & rnum;
	}
	if (op === '|') {
		return lnum | rnum;
	}
	return lnum ^ rnum;
};
'use strict';

var GetIntrinsic = require('get-intrinsic');

var $BigInt = GetIntrinsic('%BigInt%', true);
var $RangeError = require('es-errors/range');
var $SyntaxError = require('es-errors/syntax');
var $TypeError = require('es-errors/type');
var isInteger = require('math-intrinsics/isInteger');

// https://262.ecma-international.org/11.0/#sec-numbertobigint

module.exports = function NumberToBigInt(number) {
	if (typeof number !== 'number') {
		throw new $TypeError('Assertion failed: `number` must be a String');
	}
	if (!isInteger(number)) {
		throw new $RangeError('The number ' + number + ' cannot be converted to a BigInt because it is not an integer');
	}
	if (!$BigInt) {
		throw new $SyntaxError('BigInts are not supported in this environment');
	}
	return $BigInt(number);
};
'use strict';

var $TypeError = require('es-errors/type');

var hasOwnProperty = require('./HasOwnProperty');
var ToBigInt64 = require('./ToBigInt64');
var ToBigUint64 = require('./ToBigUint64');
var ToInt16 = require('./ToInt16');
var ToInt32 = require('./ToInt32');
var ToInt8 = require('./ToInt8');
var ToUint16 = require('./ToUint16');
var ToUint32 = require('./ToUint32');
var ToUint8 = require('./ToUint8');
var ToUint8Clamp = require('./ToUint8Clamp');

var valueToFloat32Bytes = require('../helpers/valueToFloat32Bytes');
var valueToFloat64Bytes = require('../helpers/valueToFloat64Bytes');
var integerToNBytes = require('../helpers/integerToNBytes');

var tableTAO = require('./tables/typed-array-objects');

// https://262.ecma-international.org/11.0/#table-the-typedarray-constructors
var TypeToAO = {
	__proto__: null,
	$Int8: ToInt8,
	$Uint8: ToUint8,
	$Uint8C: ToUint8Clamp,
	$Int16: ToInt16,
	$Uint16: ToUint16,
	$Int32: ToInt32,
	$Uint32: ToUint32,
	$BigInt64: ToBigInt64,
	$BigUint64: ToBigUint64
};

// https://262.ecma-international.org/11.0/#sec-numerictorawbytes

module.exports = function NumericToRawBytes(type, value, isLittleEndian) {
	if (typeof type !== 'string' || !hasOwnProperty(tableTAO.size, '$' + type)) {
		throw new $TypeError('Assertion failed: `type` must be a TypedArray element type');
	}
	if (typeof value !== 'number' && typeof value !== 'bigint') {
		throw new $TypeError('Assertion failed: `value` must be a Number or a BigInt');
	}
	if (typeof isLittleEndian !== 'boolean') {
		throw new $TypeError('Assertion failed: `isLittleEndian` must be a Boolean');
	}

	if (type === 'Float32') { // step 1
		return valueToFloat32Bytes(value, isLittleEndian);
	} else if (type === 'Float64') { // step 2
		return valueToFloat64Bytes(value, isLittleEndian);
	} // step 3

	var n = tableTAO.size['$' + type]; // step 3.a

	var convOp = TypeToAO['$' + type]; // step 3.b

	var intValue = convOp(value); // step 3.c

	return integerToNBytes(intValue, n, isLittleEndian); // step 3.d, 3.e, 4
};
'use strict';

var DefinePropertyOrThrow = require('./DefinePropertyOrThrow');
var Get = require('./Get');
var OrdinaryGetOwnProperty = require('./OrdinaryGetOwnProperty');
var ToObject = require('./ToObject');
var ToPropertyDescriptor = require('./ToPropertyDescriptor');

var forEach = require('../helpers/forEach');
var OwnPropertyKeys = require('own-keys');

// https://262.ecma-international.org/6.0/#sec-objectdefineproperties

/** @type {<T extends Record<PropertyKey, unknown> = {}>(O: T, Properties: object) => T} */
module.exports = function ObjectDefineProperties(O, Properties) {
	var props = ToObject(Properties); // step 1
	var keys = OwnPropertyKeys(props); // step 2
	/** @type {[string | symbol, import('../types').Descriptor][]} */
	var descriptors = []; // step 3

	forEach(keys, function (nextKey) { // step 4
		var propDesc = OrdinaryGetOwnProperty(props, nextKey); // ToPropertyDescriptor(getOwnPropertyDescriptor(props, nextKey)); // step 4.a
		if (typeof propDesc !== 'undefined' && propDesc['[[Enumerable]]']) { // step 4.b
			var descObj = Get(props, nextKey); // step 4.b.i
			var desc = ToPropertyDescriptor(descObj); // step 4.b.ii
			descriptors[descriptors.length] = [nextKey, desc]; // step 4.b.iii
		}
	});

	forEach(descriptors, function (pair) { // step 5
		var P = pair[0]; // step 5.a
		var desc = pair[1]; // step 5.b
		DefinePropertyOrThrow(O, P, desc); // step 5.c
	});

	return O; // step 6
};
'use strict';

var GetIntrinsic = require('get-intrinsic');
var $TypeError = require('es-errors/type');

var GetPrototypeFromConstructor = require('./GetPrototypeFromConstructor');
var IsArray = require('./IsArray');
var OrdinaryObjectCreate = require('./OrdinaryObjectCreate');

// https://262.ecma-international.org/6.0/#sec-ordinarycreatefromconstructor

module.exports = function OrdinaryCreateFromConstructor(constructor, intrinsicDefaultProto) {
	GetIntrinsic(intrinsicDefaultProto); // throws if not a valid intrinsic
	var proto = GetPrototypeFromConstructor(constructor, intrinsicDefaultProto);
	var slots = arguments.length < 3 ? [] : arguments[2];
	if (!IsArray(slots)) {
		throw new $TypeError('Assertion failed: if provided, `internalSlotsList` must be a List');
	}
	return OrdinaryObjectCreate(proto, slots);
};
'use strict';

var $gOPD = require('gopd');
var $SyntaxError = require('es-errors/syntax');
var $TypeError = require('es-errors/type');
var isObject = require('es-object-atoms/isObject');

var isPropertyDescriptor = require('../helpers/records/property-descriptor');

var IsAccessorDescriptor = require('./IsAccessorDescriptor');
var IsExtensible = require('./IsExtensible');
var isPropertyKey = require('../helpers/isPropertyKey');
var ToPropertyDescriptor = require('./ToPropertyDescriptor');
var SameValue = require('./SameValue');
var ValidateAndApplyPropertyDescriptor = require('./ValidateAndApplyPropertyDescriptor');

// https://262.ecma-international.org/6.0/#sec-ordinarydefineownproperty

module.exports = function OrdinaryDefineOwnProperty(O, P, Desc) {
	if (!isObject(O)) {
		throw new $TypeError('Assertion failed: O must be an Object');
	}
	if (!isPropertyKey(P)) {
		throw new $TypeError('Assertion failed: P must be a Property Key');
	}
	if (!isPropertyDescriptor(Desc)) {
		throw new $TypeError('Assertion failed: Desc must be a Property Descriptor');
	}
	if (!$gOPD) {
		// ES3/IE 8 fallback
		if (IsAccessorDescriptor(Desc)) {
			throw new $SyntaxError('This environment does not support accessor property descriptors.');
		}
		var creatingNormalDataProperty = !(P in O)
			&& Desc['[[Writable]]']
			&& Desc['[[Enumerable]]']
			&& Desc['[[Configurable]]']
			&& '[[Value]]' in Desc;
		var settingExistingDataProperty = (P in O)
			&& (!('[[Configurable]]' in Desc) || Desc['[[Configurable]]'])
			&& (!('[[Enumerable]]' in Desc) || Desc['[[Enumerable]]'])
			&& (!('[[Writable]]' in Desc) || Desc['[[Writable]]'])
			&& '[[Value]]' in Desc;
		if (creatingNormalDataProperty || settingExistingDataProperty) {
			O[P] = Desc['[[Value]]']; // eslint-disable-line no-param-reassign
			return SameValue(O[P], Desc['[[Value]]']);
		}
		throw new $SyntaxError('This environment does not support defining non-writable, non-enumerable, or non-configurable properties');
	}
	var desc = $gOPD(O, P);
	var current = desc && ToPropertyDescriptor(desc);
	var extensible = IsExtensible(O);
	return ValidateAndApplyPropertyDescriptor(O, P, extensible, Desc, current);
};
'use strict';

var $gOPD = require('gopd');
var $TypeError = require('es-errors/type');
var isObject = require('es-object-atoms/isObject');
var hasOwn = require('hasown');
var callBound = require('call-bound');

var $isEnumerable = callBound('Object.prototype.propertyIsEnumerable');

var IsArray = require('./IsArray');
var isPropertyKey = require('../helpers/isPropertyKey');
var IsRegExp = require('./IsRegExp');
var ToPropertyDescriptor = require('./ToPropertyDescriptor');

// https://262.ecma-international.org/6.0/#sec-ordinarygetownproperty

module.exports = function OrdinaryGetOwnProperty(O, P) {
	if (!isObject(O)) {
		throw new $TypeError('Assertion failed: O must be an Object');
	}
	if (!isPropertyKey(P)) {
		throw new $TypeError('Assertion failed: P must be a Property Key');
	}
	if (!hasOwn(O, P)) {
		return void 0;
	}
	if (!$gOPD) {
		// ES3 / IE 8 fallback
		var arrayLength = IsArray(O) && P === 'length';
		var regexLastIndex = IsRegExp(O) && P === 'lastIndex';
		return {
			'[[Configurable]]': !(arrayLength || regexLastIndex),
			'[[Enumerable]]': $isEnumerable(O, P),
			'[[Value]]': O[P],
			'[[Writable]]': true
		};
	}
	return ToPropertyDescriptor($gOPD(O, P));
};
'use strict';

var $TypeError = require('es-errors/type');
var isObject = require('es-object-atoms/isObject');

var $getProto = require('get-proto');

// https://262.ecma-international.org/7.0/#sec-ordinarygetprototypeof

module.exports = function OrdinaryGetPrototypeOf(O) {
	if (!isObject(O)) {
		throw new $TypeError('Assertion failed: O must be an Object');
	}
	if (!$getProto) {
		throw new $TypeError('This environment does not support fetching prototypes.');
	}
	return $getProto(O);
};
'use strict';

var $TypeError = require('es-errors/type');
var isObject = require('es-object-atoms/isObject');

var Get = require('./Get');
var IsCallable = require('./IsCallable');

// https://262.ecma-international.org/6.0/#sec-ordinaryhasinstance

module.exports = function OrdinaryHasInstance(C, O) {
	if (!IsCallable(C)) {
		return false;
	}
	if (!isObject(O)) {
		return false;
	}
	var P = Get(C, 'prototype');
	if (!isObject(P)) {
		throw new $TypeError('OrdinaryHasInstance called on an object with an invalid prototype property.');
	}
	return O instanceof C;
};
'use strict';

var $TypeError = require('es-errors/type');
var isObject = require('es-object-atoms/isObject');

var isPropertyKey = require('../helpers/isPropertyKey');

// https://262.ecma-international.org/6.0/#sec-ordinaryhasproperty

module.exports = function OrdinaryHasProperty(O, P) {
	if (!isObject(O)) {
		throw new $TypeError('Assertion failed: Type(O) is not Object');
	}
	if (!isPropertyKey(P)) {
		throw new $TypeError('Assertion failed: P must be a Property Key');
	}
	return P in O;
};
'use strict';

var GetIntrinsic = require('get-intrinsic');

var $ObjectCreate = GetIntrinsic('%Object.create%', true);
var $TypeError = require('es-errors/type');
var $SyntaxError = require('es-errors/syntax');
var isObject = require('es-object-atoms/isObject');

var IsArray = require('./IsArray');

var forEach = require('../helpers/forEach');

var SLOT = require('internal-slot');

var hasProto = require('has-proto')();

// https://262.ecma-international.org/11.0/#sec-objectcreate

module.exports = function OrdinaryObjectCreate(proto) {
	if (proto !== null && !isObject(proto)) {
		throw new $TypeError('Assertion failed: `proto` must be null or an object');
	}
	var additionalInternalSlotsList = arguments.length < 2 ? [] : arguments[1];
	if (!IsArray(additionalInternalSlotsList)) {
		throw new $TypeError('Assertion failed: `additionalInternalSlotsList` must be an Array');
	}

	// var internalSlotsList = ['[[Prototype]]', '[[Extensible]]']; // step 1
	// internalSlotsList.push(...additionalInternalSlotsList); // step 2
	// var O = MakeBasicObject(internalSlotsList); // step 3
	// setProto(O, proto); // step 4
	// return O; // step 5

	var O;
	if (hasProto) {
		O = { __proto__: proto };
	} else if ($ObjectCreate) {
		O = $ObjectCreate(proto);
	} else {
		if (proto === null) {
			throw new $SyntaxError('native Object.create support is required to create null objects');
		}
		var T = function T() {};
		T.prototype = proto;
		O = new T();
	}

	if (additionalInternalSlotsList.length > 0) {
		forEach(additionalInternalSlotsList, function (slot) {
			SLOT.set(O, slot, void undefined);
		});
	}

	return O;
};
'use strict';

var $TypeError = require('es-errors/type');
var $setProto = require('set-proto');
var isObject = require('es-object-atoms/isObject');

var OrdinaryGetPrototypeOf = require('./OrdinaryGetPrototypeOf');

// https://262.ecma-international.org/7.0/#sec-ordinarysetprototypeof

module.exports = function OrdinarySetPrototypeOf(O, V) {
	if (V !== null && !isObject(V)) {
		throw new $TypeError('Assertion failed: V must be Object or Null');
	}
	/*
	var extensible = IsExtensible(O);
	var current = OrdinaryGetPrototypeOf(O);
	if (SameValue(V, current)) {
		return true;
	}
	if (!extensible) {
		return false;
	}
	*/
	try {
		$setProto(O, V);
	} catch (e) {
		return false;
	}
	return OrdinaryGetPrototypeOf(O) === V;
	/*
	var p = V;
	var done = false;
	while (!done) {
		if (p === null) {
			done = true;
		} else if (SameValue(p, O)) {
			return false;
		} else {
			if (wat) {
				done = true;
			} else {
				p = p.[[Prototype]];
			}
		}
	}
	O.[[Prototype]] = V;
	return true;
	*/
};
'use strict';

var $TypeError = require('es-errors/type');
var isObject = require('es-object-atoms/isObject');

var Call = require('./Call');
var Get = require('./Get');
var IsCallable = require('./IsCallable');

var inspect = require('object-inspect');

// https://262.ecma-international.org/8.0/#sec-ordinarytoprimitive

module.exports = function OrdinaryToPrimitive(O, hint) {
	if (!isObject(O)) {
		throw new $TypeError('Assertion failed: Type(O) is not Object');
	}
	if (/* typeof hint !== 'string' || */ hint !== 'string' && hint !== 'number') {
		throw new $TypeError('Assertion failed: `hint` must be "string" or "number"');
	}

	var methodNames = hint === 'string' ? ['toString', 'valueOf'] : ['valueOf', 'toString'];

	for (var i = 0; i < methodNames.length; i += 1) {
		var name = methodNames[i];
		var method = Get(O, name);
		if (IsCallable(method)) {
			var result = Call(method, O);
			if (!isObject(result)) {
				return result;
			}
		}
	}

	throw new $TypeError('No primitive value for ' + inspect(O));
};
'use strict';

var GetIntrinsic = require('get-intrinsic');
var callBind = require('call-bind');
var $SyntaxError = require('es-errors/syntax');

var $resolve = GetIntrinsic('%Promise.resolve%', true);
var $PromiseResolve = $resolve && callBind($resolve);

// https://262.ecma-international.org/9.0/#sec-promise-resolve

module.exports = function PromiseResolve(C, x) {
	if (!$PromiseResolve) {
		throw new $SyntaxError('This environment does not support Promises.');
	}
	return $PromiseResolve(C, x);
};

'use strict';

var $TypeError = require('es-errors/type');

var callBound = require('call-bound');
var forEach = require('../helpers/forEach');
var isLeadingSurrogate = require('../helpers/isLeadingSurrogate');
var isTrailingSurrogate = require('../helpers/isTrailingSurrogate');

var $charCodeAt = callBound('String.prototype.charCodeAt');
var $strSplit = callBound('String.prototype.split');

var UnicodeEscape = require('./UnicodeEscape');
var UTF16DecodeString = require('./UTF16DecodeString');
var UTF16Encoding = require('./UTF16Encoding');

var hasOwn = require('hasown');

// https://262.ecma-international.org/11.0/#sec-quotejsonstring

var escapes = {
	'\u0008': '\\b',
	'\u0009': '\\t',
	'\u000A': '\\n',
	'\u000C': '\\f',
	'\u000D': '\\r',
	'\u0022': '\\"',
	'\u005c': '\\\\'
};

module.exports = function QuoteJSONString(value) {
	if (typeof value !== 'string') {
		throw new $TypeError('Assertion failed: `value` must be a String');
	}
	var product = '"';
	if (value) {
		forEach($strSplit(UTF16DecodeString(value), ''), function (C) {
			if (hasOwn(escapes, C)) {
				product += escapes[C];
			} else {
				var cCharCode = $charCodeAt(C, 0);
				if (cCharCode < 0x20 || isLeadingSurrogate(cCharCode) || isTrailingSurrogate(cCharCode)) {
					product += UnicodeEscape(C);
				} else {
					product += UTF16Encoding(cCharCode);
				}
			}
		});
	}
	product += '"';
	return product;
};
'use strict';

var GetIntrinsic = require('get-intrinsic');
var callBound = require('call-bound');

var $RangeError = require('es-errors/range');
var $SyntaxError = require('es-errors/syntax');
var $TypeError = require('es-errors/type');
var $BigInt = GetIntrinsic('%BigInt%', true);

var hasOwnProperty = require('./HasOwnProperty');
var IsArray = require('./IsArray');
var IsBigIntElementType = require('./IsBigIntElementType');
var IsUnsignedElementType = require('./IsUnsignedElementType');

var bytesAsFloat32 = require('../helpers/bytesAsFloat32');
var bytesAsFloat64 = require('../helpers/bytesAsFloat64');
var bytesAsInteger = require('../helpers/bytesAsInteger');
var every = require('../helpers/every');
var isByteValue = require('../helpers/isByteValue');

var $reverse = callBound('Array.prototype.reverse');
var $slice = callBound('Array.prototype.slice');

var tableTAO = require('./tables/typed-array-objects');

// https://262.ecma-international.org/11.0/#sec-rawbytestonumeric

module.exports = function RawBytesToNumeric(type, rawBytes, isLittleEndian) {
	if (typeof type !== 'string' || !hasOwnProperty(tableTAO.size, '$' + type)) {
		throw new $TypeError('Assertion failed: `type` must be a TypedArray element type');
	}
	if (!IsArray(rawBytes) || !every(rawBytes, isByteValue)) {
		throw new $TypeError('Assertion failed: `rawBytes` must be an Array of bytes');
	}
	if (typeof isLittleEndian !== 'boolean') {
		throw new $TypeError('Assertion failed: `isLittleEndian` must be a Boolean');
	}

	var elementSize = tableTAO.size['$' + type]; // step 1

	if (rawBytes.length !== elementSize) {
		// this assertion is not in the spec, but it'd be an editorial error if it were ever violated
		throw new $RangeError('Assertion failed: `rawBytes` must have a length of ' + elementSize + ' for type ' + type);
	}

	var isBigInt = IsBigIntElementType(type);
	if (isBigInt && !$BigInt) {
		throw new $SyntaxError('this environment does not support BigInts');
	}

	// eslint-disable-next-line no-param-reassign
	rawBytes = $slice(rawBytes, 0, elementSize);
	if (!isLittleEndian) {
		$reverse(rawBytes); // step 2
	}

	if (type === 'Float32') { // step 3
		return bytesAsFloat32(rawBytes);
	}

	if (type === 'Float64') { // step 4
		return bytesAsFloat64(rawBytes);
	}

	return bytesAsInteger(rawBytes, elementSize, IsUnsignedElementType(type), isBigInt);
};
'use strict';

var GetIntrinsic = require('get-intrinsic');

var $RegExp = GetIntrinsic('%RegExp%');

// var RegExpAlloc = require('./RegExpAlloc');
// var RegExpInitialize = require('./RegExpInitialize');
var ToString = require('./ToString');

// https://262.ecma-international.org/6.0/#sec-regexpcreate

module.exports = function RegExpCreate(P, F) {
	// var obj = RegExpAlloc($RegExp);
	// return RegExpInitialize(obj, P, F);

	// covers spec mechanics; bypass regex brand checking
	var pattern = typeof P === 'undefined' ? '' : ToString(P);
	var flags = typeof F === 'undefined' ? '' : ToString(F);
	return new $RegExp(pattern, flags);
};
'use strict';

var $TypeError = require('es-errors/type');
var isObject = require('es-object-atoms/isObject');
var regexExec = require('call-bound')('RegExp.prototype.exec');

var Call = require('./Call');
var Get = require('./Get');
var IsCallable = require('./IsCallable');

// https://262.ecma-international.org/6.0/#sec-regexpexec

module.exports = function RegExpExec(R, S) {
	if (!isObject(R)) {
		throw new $TypeError('Assertion failed: `R` must be an Object');
	}
	if (typeof S !== 'string') {
		throw new $TypeError('Assertion failed: `S` must be a String');
	}
	var exec = Get(R, 'exec');
	if (IsCallable(exec)) {
		var result = Call(exec, R, [S]);
		if (result === null || isObject(result)) {
			return result;
		}
		throw new $TypeError('"exec" method must return `null` or an Object');
	}
	return regexExec(R, S);
};
'use strict';

module.exports = require('es-object-atoms/RequireObjectCoercible');
'use strict';

var $isNaN = require('math-intrinsics/isNaN');

// http://262.ecma-international.org/5.1/#sec-9.12

module.exports = function SameValue(x, y) {
	if (x === y) { // 0 === -0, but they are not identical.
		if (x === 0) { return 1 / x === 1 / y; }
		return true;
	}
	return $isNaN(x) && $isNaN(y);
};
'use strict';

var $TypeError = require('es-errors/type');

var SameValue = require('./SameValue');
var Type = require('./Type');

// https://262.ecma-international.org/11.0/#sec-samevaluenonnumeric

module.exports = function SameValueNonNumeric(x, y) {
	if (typeof x === 'number' || typeof x === 'bigint') {
		throw new $TypeError('Assertion failed: SameValueNonNumeric does not accept Number or BigInt values');
	}
	if (Type(x) !== Type(y)) {
		throw new $TypeError('SameValueNonNumeric requires two non-numeric values of the same type.');
	}
	return SameValue(x, y);
};
'use strict';

var $isNaN = require('math-intrinsics/isNaN');

// https://262.ecma-international.org/6.0/#sec-samevaluezero

module.exports = function SameValueZero(x, y) {
	return (x === y) || ($isNaN(x) && $isNaN(y));
};
'use strict';

var floor = require('./floor');
var modulo = require('./modulo');

var timeConstants = require('../helpers/timeConstants');
var msPerSecond = timeConstants.msPerSecond;
var SecondsPerMinute = timeConstants.SecondsPerMinute;

// https://262.ecma-international.org/5.1/#sec-15.9.1.10

module.exports = function SecFromTime(t) {
	return modulo(floor(t / msPerSecond), SecondsPerMinute);
};
'use strict';

var $TypeError = require('es-errors/type');

var DefinePropertyOrThrow = require('./DefinePropertyOrThrow');
var HasOwnProperty = require('./HasOwnProperty');
var IsExtensible = require('./IsExtensible');
var IsNonNegativeInteger = require('./IsNonNegativeInteger');

// https://262.ecma-international.org/11.0/#sec-setfunctionlength

module.exports = function SetFunctionLength(F, length) {
	if (typeof F !== 'function' || !IsExtensible(F) || HasOwnProperty(F, 'length')) {
		throw new $TypeError('Assertion failed: `F` must be an extensible function and lack an own `length` property');
	}
	if (typeof length !== 'number') {
		throw new $TypeError('Assertion failed: `length` must be a Number');
	}
	if (!IsNonNegativeInteger(length)) {
		throw new $TypeError('Assertion failed: `length` must be an integer >= 0');
	}
	return DefinePropertyOrThrow(F, 'length', {
		'[[Configurable]]': true,
		'[[Enumerable]]': false,
		'[[Value]]': length,
		'[[Writable]]': false
	});
};
'use strict';

var hasOwn = require('hasown');

var $TypeError = require('es-errors/type');

var getSymbolDescription = require('get-symbol-description');

var DefinePropertyOrThrow = require('./DefinePropertyOrThrow');
var IsExtensible = require('./IsExtensible');

// https://262.ecma-international.org/6.0/#sec-setfunctionname

module.exports = function SetFunctionName(F, name) {
	if (typeof F !== 'function') {
		throw new $TypeError('Assertion failed: `F` must be a function');
	}
	if (!IsExtensible(F) || hasOwn(F, 'name')) {
		throw new $TypeError('Assertion failed: `F` must be extensible, and must not have a `name` own property');
	}
	if (typeof name !== 'symbol' && typeof name !== 'string') {
		throw new $TypeError('Assertion failed: `name` must be a Symbol or a String');
	}
	if (typeof name === 'symbol') {
		var description = getSymbolDescription(name);
		// eslint-disable-next-line no-param-reassign
		name = typeof description === 'undefined' ? '' : '[' + description + ']';
	}
	if (arguments.length > 2) {
		var prefix = arguments[2];
		// eslint-disable-next-line no-param-reassign
		name = prefix + ' ' + name;
	}
	return DefinePropertyOrThrow(F, 'name', {
		'[[Value]]': name,
		'[[Writable]]': false,
		'[[Enumerable]]': false,
		'[[Configurable]]': true
	});
};
'use strict';

var GetIntrinsic = require('get-intrinsic');

var $SyntaxError = require('es-errors/syntax');
var $TypeError = require('es-errors/type');
var isObject = require('es-object-atoms/isObject');
var $gOPD = require('gopd');
var $preventExtensions = GetIntrinsic('%Object.preventExtensions%', true);
var $gOPN = GetIntrinsic('%Object.getOwnPropertyNames%', true);

var forEach = require('../helpers/forEach');

var DefinePropertyOrThrow = require('./DefinePropertyOrThrow');
var IsAccessorDescriptor = require('./IsAccessorDescriptor');
var ToPropertyDescriptor = require('./ToPropertyDescriptor');

// https://262.ecma-international.org/6.0/#sec-setintegritylevel

module.exports = function SetIntegrityLevel(O, level) {
	if (!isObject(O)) {
		throw new $TypeError('Assertion failed: Type(O) is not Object');
	}
	if (level !== 'sealed' && level !== 'frozen') {
		throw new $TypeError('Assertion failed: `level` must be `"sealed"` or `"frozen"`');
	}
	if (!$preventExtensions) {
		throw new $SyntaxError('SetIntegrityLevel requires native `Object.preventExtensions` support');
	}
	var status = $preventExtensions(O);
	if (!status) {
		return false;
	}
	if (!$gOPN) {
		throw new $SyntaxError('SetIntegrityLevel requires native `Object.getOwnPropertyNames` support');
	}
	var theKeys = $gOPN(O);
	if (level === 'sealed') {
		forEach(theKeys, function (k) {
			DefinePropertyOrThrow(O, k, { configurable: false });
		});
	} else if (level === 'frozen') {
		forEach(theKeys, function (k) {
			var currentDesc = $gOPD(O, k);
			if (typeof currentDesc !== 'undefined') {
				var desc;
				if (IsAccessorDescriptor(ToPropertyDescriptor(currentDesc))) {
					desc = { configurable: false };
				} else {
					desc = { configurable: false, writable: false };
				}
				DefinePropertyOrThrow(O, k, desc);
			}
		});
	}
	return true;
};
'use strict';

var $TypeError = require('es-errors/type');
var isObject = require('es-object-atoms/isObject');

var isPropertyKey = require('../helpers/isPropertyKey');
var SameValue = require('./SameValue');

// IE 9 does not throw in strict mode when writability/configurability/extensibility is violated
var noThrowOnStrictViolation = (function () {
	try {
		delete [].length;
		return true;
	} catch (e) {
		return false;
	}
}());

// https://262.ecma-international.org/6.0/#sec-set-o-p-v-throw

module.exports = function Set(O, P, V, Throw) {
	if (!isObject(O)) {
		throw new $TypeError('Assertion failed: `O` must be an Object');
	}
	if (!isPropertyKey(P)) {
		throw new $TypeError('Assertion failed: `P` must be a Property Key');
	}
	if (typeof Throw !== 'boolean') {
		throw new $TypeError('Assertion failed: `Throw` must be a Boolean');
	}
	if (Throw) {
		O[P] = V; // eslint-disable-line no-param-reassign
		if (noThrowOnStrictViolation && !SameValue(O[P], V)) {
			throw new $TypeError('Attempted to assign to readonly property.');
		}
		return true;
	}
	try {
		O[P] = V; // eslint-disable-line no-param-reassign
		return noThrowOnStrictViolation ? SameValue(O[P], V) : true;
	} catch (e) {
		return false;
	}

};
'use strict';

var GetIntrinsic = require('get-intrinsic');

var $SyntaxError = require('es-errors/syntax');
var $TypeError = require('es-errors/type');
var $Uint8Array = GetIntrinsic('%Uint8Array%', true);
var isInteger = require('math-intrinsics/isInteger');

var IsBigIntElementType = require('./IsBigIntElementType');
var IsDetachedBuffer = require('./IsDetachedBuffer');
var NumericToRawBytes = require('./NumericToRawBytes');

var isArrayBuffer = require('is-array-buffer');
var isSharedArrayBuffer = require('is-shared-array-buffer');
var hasOwn = require('hasown');

var tableTAO = require('./tables/typed-array-objects');

var defaultEndianness = require('../helpers/defaultEndianness');
var forEach = require('../helpers/forEach');

// https://262.ecma-international.org/11.0/#sec-setvalueinbuffer

/* eslint max-params: 0 */

module.exports = function SetValueInBuffer(arrayBuffer, byteIndex, type, value, isTypedArray, order) {
	var isSAB = isSharedArrayBuffer(arrayBuffer);
	if (!isArrayBuffer(arrayBuffer) && !isSAB) {
		throw new $TypeError('Assertion failed: `arrayBuffer` must be an ArrayBuffer or a SharedArrayBuffer');
	}

	if (!isInteger(byteIndex)) {
		throw new $TypeError('Assertion failed: `byteIndex` must be an integer');
	}

	if (typeof type !== 'string' || !hasOwn(tableTAO.size, '$' + type)) {
		throw new $TypeError('Assertion failed: `type` must be one of ' + tableTAO.choices);
	}

	if (typeof value !== 'number' && typeof value !== 'bigint') {
		throw new $TypeError('Assertion failed: `value` must be a Number or a BigInt');
	}

	if (typeof isTypedArray !== 'boolean') {
		throw new $TypeError('Assertion failed: `isTypedArray` must be a boolean');
	}
	if (order !== 'SeqCst' && order !== 'Unordered' && order !== 'Init') {
		throw new $TypeError('Assertion failed: `order` must be `"SeqCst"`, `"Unordered"`, or `"Init"`');
	}

	if (arguments.length > 6 && typeof arguments[6] !== 'boolean') {
		throw new $TypeError('Assertion failed: `isLittleEndian` must be a boolean, if present');
	}

	if (IsDetachedBuffer(arrayBuffer)) {
		throw new $TypeError('Assertion failed: ArrayBuffer is detached'); // step 1
	}

	// 2. Assert: There are sufficient bytes in arrayBuffer starting at byteIndex to represent a value of type.

	if (byteIndex < 0) {
		throw new $TypeError('Assertion failed: `byteIndex` must be non-negative'); // step 3
	}

	if (IsBigIntElementType(type) ? typeof value !== 'bigint' : typeof value !== 'number') { // step 4
		throw new $TypeError('Assertion failed: `value` must be a BigInt if type is BigInt64 or BigUint64, otherwise a Number');
	}

	// 5. Let block be arrayBuffer.[[ArrayBufferData]].

	var elementSize = tableTAO.size['$' + type]; // step 6

	// 7. If isLittleEndian is not present, set isLittleEndian to to the value of the [[LittleEndian]] field of the surrounding agent's Agent Record.
	var isLittleEndian = arguments.length > 6 ? arguments[6] : defaultEndianness === 'little'; // step 8

	var rawBytes = NumericToRawBytes(type, value, isLittleEndian); // step 8

	if (isSAB) { // step 9
		/*
			Let execution be the [[CandidateExecution]] field of the surrounding agent's Agent Record.
			Let eventList be the [[EventList]] field of the element in execution.[[EventsRecords]] whose [[AgentSignifier]] is AgentSignifier().
			If isTypedArray is true and IsNoTearConfiguration(type, order) is true, let noTear be true; otherwise let noTear be false.
			Append WriteSharedMemory { [[Order]]: order, [[NoTear]]: noTear, [[Block]]: block, [[ByteIndex]]: byteIndex, [[ElementSize]]: elementSize, [[Payload]]: rawBytes } to eventList.
		*/
		throw new $SyntaxError('SharedArrayBuffer is not supported by this implementation');
	} else {
		// 10. Store the individual bytes of rawBytes into block, in order, starting at block[byteIndex].
		var arr = new $Uint8Array(arrayBuffer, byteIndex, elementSize);
		forEach(rawBytes, function (rawByte, i) {
			arr[i] = rawByte;
		});
	}

	// 11. Return NormalCompletion(undefined).
};
'use strict';

var GetIntrinsic = require('get-intrinsic');

var $species = GetIntrinsic('%Symbol.species%', true);
var $TypeError = require('es-errors/type');
var isObject = require('es-object-atoms/isObject');

var IsConstructor = require('./IsConstructor');

// https://262.ecma-international.org/6.0/#sec-speciesconstructor

module.exports = function SpeciesConstructor(O, defaultConstructor) {
	if (!isObject(O)) {
		throw new $TypeError('Assertion failed: Type(O) is not Object');
	}
	var C = O.constructor;
	if (typeof C === 'undefined') {
		return defaultConstructor;
	}
	if (!isObject(C)) {
		throw new $TypeError('O.constructor is not an Object');
	}
	var S = $species ? C[$species] : void 0;
	if (S == null) {
		return defaultConstructor;
	}
	if (IsConstructor(S)) {
		return S;
	}
	throw new $TypeError('no constructor found');
};
'use strict';

var callBound = require('call-bound');

var $TypeError = require('es-errors/type');
var isInteger = require('math-intrinsics/isInteger');

var $charAt = callBound('String.prototype.charAt');

// https://262.ecma-international.org/6.0/#sec-splitmatch

module.exports = function SplitMatch(S, q, R) {
	if (typeof S !== 'string') {
		throw new $TypeError('Assertion failed: `S` must be a String');
	}
	if (!isInteger(q)) {
		throw new $TypeError('Assertion failed: `q` must be an integer');
	}
	if (typeof R !== 'string') {
		throw new $TypeError('Assertion failed: `R` must be a String');
	}
	var r = R.length;
	var s = S.length;
	if (q + r > s) {
		return false;
	}

	for (var i = 0; i < r; i += 1) {
		if ($charAt(S, q + i) !== $charAt(R, i)) {
			return false;
		}
	}

	return q + r;
};
'use strict';

var Type = require('./Type');

// https://262.ecma-international.org/5.1/#sec-11.9.6

module.exports = function StrictEqualityComparison(x, y) {
	if (Type(x) !== Type(y)) {
		return false;
	}
	if (typeof x === 'undefined' || x === null) {
		return true;
	}
	return x === y; // shortcut for steps 4-7
};
'use strict';

var GetIntrinsic = require('get-intrinsic');

var $Object = require('es-object-atoms');
var $StringPrototype = GetIntrinsic('%String.prototype%');
var $SyntaxError = require('es-errors/syntax');
var $TypeError = require('es-errors/type');
var setProto = require('set-proto');

var DefinePropertyOrThrow = require('./DefinePropertyOrThrow');

// https://262.ecma-international.org/6.0/#sec-stringcreate

module.exports = function StringCreate(value, prototype) {
	if (typeof value !== 'string') {
		throw new $TypeError('Assertion failed: `S` must be a String');
	}

	var S = $Object(value);
	if (prototype !== $StringPrototype) {
		if (setProto) {
			setProto(S, prototype);
		} else {
			throw new $SyntaxError('StringCreate: a `proto` argument that is not `String.prototype` is not supported in an environment that does not support setting the [[Prototype]]');
		}
	}

	var length = value.length;
	DefinePropertyOrThrow(S, 'length', {
		'[[Configurable]]': false,
		'[[Enumerable]]': false,
		'[[Value]]': length,
		'[[Writable]]': false
	});

	return S;
};
'use strict';

var $TypeError = require('es-errors/type');
var isObject = require('es-object-atoms/isObject');

var callBound = require('call-bound');
var $charAt = callBound('String.prototype.charAt');
var $stringToString = callBound('String.prototype.toString');

var CanonicalNumericIndexString = require('./CanonicalNumericIndexString');
var IsInteger = require('./IsInteger');

var isPropertyKey = require('../helpers/isPropertyKey');

var isNegativeZero = require('math-intrinsics/isNegativeZero');

// https://262.ecma-international.org/8.0/#sec-stringgetownproperty

module.exports = function StringGetOwnProperty(S, P) {
	var str;
	if (isObject(S)) {
		try {
			str = $stringToString(S);
		} catch (e) { /**/ }
	}
	if (typeof str !== 'string') {
		throw new $TypeError('Assertion failed: `S` must be a boxed string object');
	}
	if (!isPropertyKey(P)) {
		throw new $TypeError('Assertion failed: P is not a Property Key');
	}
	if (typeof P !== 'string') {
		return void undefined;
	}
	var index = CanonicalNumericIndexString(P);
	var len = str.length;
	if (typeof index === 'undefined' || !IsInteger(index) || isNegativeZero(index) || index < 0 || len <= index) {
		return void undefined;
	}
	var resultStr = $charAt(S, index);
	return {
		'[[Configurable]]': false,
		'[[Enumerable]]': true,
		'[[Value]]': resultStr,
		'[[Writable]]': false
	};
};
'use strict';

var $TypeError = require('es-errors/type');

var callBound = require('call-bound');

var ToLength = require('./ToLength');
var ToString = require('./ToString');

var $strSlice = callBound('String.prototype.slice');

// https://262.ecma-international.org/11.0/#sec-stringpad

module.exports = function StringPad(O, maxLength, fillString, placement) {
	if (placement !== 'start' && placement !== 'end') {
		throw new $TypeError('Assertion failed: `placement` must be "start" or "end"');
	}
	var S = ToString(O);
	var intMaxLength = ToLength(maxLength);
	var stringLength = S.length;
	if (intMaxLength <= stringLength) {
		return S;
	}
	var filler = typeof fillString === 'undefined' ? ' ' : ToString(fillString);
	if (filler === '') {
		return S;
	}
	var fillLen = intMaxLength - stringLength;

	// the String value consisting of repeated concatenations of filler truncated to length fillLen.
	var truncatedStringFiller = '';
	while (truncatedStringFiller.length < fillLen) {
		truncatedStringFiller += filler;
	}
	truncatedStringFiller = $strSlice(truncatedStringFiller, 0, fillLen);

	if (placement === 'start') {
		return truncatedStringFiller + S;
	}
	return S + truncatedStringFiller;
};
'use strict';

var GetIntrinsic = require('get-intrinsic');

var $BigInt = GetIntrinsic('%BigInt%', true);
var $TypeError = require('es-errors/type');
var $SyntaxError = require('es-errors/syntax');

// https://262.ecma-international.org/11.0/#sec-stringtobigint

module.exports = function StringToBigInt(argument) {
	if (typeof argument !== 'string') {
		throw new $TypeError('`argument` must be a string');
	}
	if (!$BigInt) {
		throw new $SyntaxError('BigInts are not supported in this environment');
	}
	try {
		return $BigInt(argument);
	} catch (e) {
		return NaN;
	}
};
'use strict';

var $TypeError = require('es-errors/type');

var callBound = require('call-bound');

var $SymbolToString = callBound('Symbol.prototype.toString', true);

// https://262.ecma-international.org/6.0/#sec-symboldescriptivestring

module.exports = function SymbolDescriptiveString(sym) {
	if (typeof sym !== 'symbol') {
		throw new $TypeError('Assertion failed: `sym` must be a Symbol');
	}
	return $SymbolToString(sym);
};
'use strict';

var $gOPD = require('gopd');
var $TypeError = require('es-errors/type');

var every = require('../helpers/every');
var OwnPropertyKeys = require('own-keys');
var isObject = require('es-object-atoms/isObject');

var IsDataDescriptor = require('./IsDataDescriptor');
var IsExtensible = require('./IsExtensible');
var ToPropertyDescriptor = require('./ToPropertyDescriptor');

// https://262.ecma-international.org/6.0/#sec-testintegritylevel

module.exports = function TestIntegrityLevel(O, level) {
	if (!isObject(O)) {
		throw new $TypeError('Assertion failed: Type(O) is not Object');
	}
	if (level !== 'sealed' && level !== 'frozen') {
		throw new $TypeError('Assertion failed: `level` must be `"sealed"` or `"frozen"`');
	}
	var status = IsExtensible(O);
	if (status || !$gOPD) {
		return false;
	}
	var theKeys = OwnPropertyKeys(O);
	return theKeys.length === 0 || every(theKeys, function (k) {
		var currentDesc = $gOPD(O, k);
		if (typeof currentDesc !== 'undefined') {
			if (currentDesc.configurable) {
				return false;
			}
			if (level === 'frozen' && IsDataDescriptor(ToPropertyDescriptor(currentDesc)) && currentDesc.writable) {
				return false;
			}
		}
		return true;
	});
};
'use strict';

var callBound = require('call-bound');

var $SyntaxError = require('es-errors/syntax');
var $bigIntValueOf = callBound('BigInt.prototype.valueOf', true);

// https://262.ecma-international.org/11.0/#sec-thisbigintvalue

module.exports = function thisBigIntValue(value) {
	if (typeof value === 'bigint') {
		return value;
	}
	if (!$bigIntValueOf) {
		throw new $SyntaxError('BigInt is not supported');
	}
	return $bigIntValueOf(value);
};
'use strict';

var $BooleanValueOf = require('call-bound')('Boolean.prototype.valueOf');

// https://262.ecma-international.org/6.0/#sec-properties-of-the-boolean-prototype-object

module.exports = function thisBooleanValue(value) {
	if (typeof value === 'boolean') {
		return value;
	}

	return $BooleanValueOf(value);
};
'use strict';

var callBound = require('call-bound');

var $NumberValueOf = callBound('Number.prototype.valueOf');

// https://262.ecma-international.org/6.0/#sec-properties-of-the-number-prototype-object

module.exports = function thisNumberValue(value) {
	if (typeof value === 'number') {
		return value;
	}

	return $NumberValueOf(value);
};

'use strict';

var $StringValueOf = require('call-bound')('String.prototype.valueOf');

// https://262.ecma-international.org/6.0/#sec-properties-of-the-string-prototype-object

module.exports = function thisStringValue(value) {
	if (typeof value === 'string') {
		return value;
	}

	return $StringValueOf(value);
};
'use strict';

var $SyntaxError = require('es-errors/syntax');
var callBound = require('call-bound');

var $SymbolValueOf = callBound('Symbol.prototype.valueOf', true);

// https://262.ecma-international.org/9.0/#sec-thissymbolvalue

module.exports = function thisSymbolValue(value) {
	if (typeof value === 'symbol') {
		return value;
	}

	if (!$SymbolValueOf) {
		throw new $SyntaxError('Symbols are not supported; thisSymbolValue requires that `value` be a Symbol or a Symbol object');
	}

	return $SymbolValueOf(value);
};
'use strict';

var timeValue = require('../helpers/timeValue');

// https://262.ecma-international.org/6.0/#sec-properties-of-the-date-prototype-object

module.exports = function thisTimeValue(value) {
	return timeValue(value);
};
'use strict';

var CompletionRecord = require('./CompletionRecord');

// https://262.ecma-international.org/9.0/#sec-throwcompletion

module.exports = function ThrowCompletion(argument) {
	return new CompletionRecord('throw', argument);
};
'use strict';

var GetIntrinsic = require('get-intrinsic');

var $Date = GetIntrinsic('%Date%');

var $isFinite = require('math-intrinsics/isFinite');
var abs = require('math-intrinsics/abs');

var ToNumber = require('./ToNumber');

// https://262.ecma-international.org/5.1/#sec-15.9.1.14

module.exports = function TimeClip(time) {
	if (!$isFinite(time) || abs(time) > 8.64e15) {
		return NaN;
	}
	return +new $Date(ToNumber(time));
};

'use strict';

var msPerDay = require('../helpers/timeConstants').msPerDay;

var DayFromYear = require('./DayFromYear');

// https://262.ecma-international.org/5.1/#sec-15.9.1.3

module.exports = function TimeFromYear(y) {
	return msPerDay * DayFromYear(y);
};
'use strict';

var $TypeError = require('es-errors/type');

var $isNaN = require('math-intrinsics/isNaN');
var padTimeComponent = require('../helpers/padTimeComponent');

var HourFromTime = require('./HourFromTime');
var MinFromTime = require('./MinFromTime');
var SecFromTime = require('./SecFromTime');

// https://262.ecma-international.org/9.0/#sec-timestring

module.exports = function TimeString(tv) {
	if (typeof tv !== 'number' || $isNaN(tv)) {
		throw new $TypeError('Assertion failed: `tv` must be a non-NaN Number');
	}
	var hour = HourFromTime(tv);
	var minute = MinFromTime(tv);
	var second = SecFromTime(tv);
	return padTimeComponent(hour) + ':' + padTimeComponent(minute) + ':' + padTimeComponent(second) + '\x20GMT';
};
'use strict';

var modulo = require('./modulo');

var msPerDay = require('../helpers/timeConstants').msPerDay;

// https://262.ecma-international.org/5.1/#sec-15.9.1.2

module.exports = function TimeWithinDay(t) {
	return modulo(t, msPerDay);
};

'use strict';

var GetIntrinsic = require('get-intrinsic');

var $Date = GetIntrinsic('%Date%');
var $TypeError = require('es-errors/type');

var isNaN = require('math-intrinsics/isNaN');

var callBound = require('call-bound');

var $indexOf = callBound('String.prototype.indexOf');
var $slice = callBound('String.prototype.slice');
var $toTimeString = callBound('Date.prototype.toTimeString');

// https://262.ecma-international.org/9.0/#sec-timezoneestring

module.exports = function TimeZoneString(tv) {
	if (typeof tv !== 'number' || isNaN(tv)) {
		throw new $TypeError('Assertion failed: `tv` must be a non-NaN Number'); // steps 1 - 2
	}

	// 3. Let offset be LocalTZA(tv, true).
	// 4. If offset ≥ 0, let offsetSign be "+"; otherwise, let offsetSign be "-".
	// 5. Let offsetMin be the String representation of MinFromTime(abs(offset)), formatted as a two-digit decimal number, padded to the left with a zero if necessary.
	// 6. Let offsetHour be the String representation of HourFromTime(abs(offset)), formatted as a two-digit decimal number, padded to the left with a zero if necessary.
	// 7. Let tzName be an implementation-defined string that is either the empty string or the string-concatenation of the code unit 0x0020 (SPACE), the code unit 0x0028 (LEFT PARENTHESIS), an implementation-dependent timezone name, and the code unit 0x0029 (RIGHT PARENTHESIS).
	// 8. Return the string-concatenation of offsetSign, offsetHour, offsetMin, and tzName.

	// hack until LocalTZA, and "implementation-defined string" are available
	var ts = $toTimeString(new $Date(tv));
	return $slice(ts, $indexOf(ts, '(') + 1, $indexOf(ts, ')'));
};
'use strict';

var GetIntrinsic = require('get-intrinsic');

var $BigInt = GetIntrinsic('%BigInt%', true);
var $pow = require('math-intrinsics/pow');

var ToBigInt = require('./ToBigInt');
var BigIntRemainder = require('./BigInt/remainder');

var modBigInt = require('../helpers/modBigInt');

// BigInt(2**63), but node v10.4-v10.8 have a bug where you can't `BigInt(x)` anything larger than MAX_SAFE_INTEGER
var twoSixtyThree = $BigInt && (BigInt($pow(2, 32)) * BigInt($pow(2, 31)));

// BigInt(2**64), but node v10.4-v10.8 have a bug where you can't `BigInt(x)` anything larger than MAX_SAFE_INTEGER
var twoSixtyFour = $BigInt && (BigInt($pow(2, 32)) * BigInt($pow(2, 32)));

// https://262.ecma-international.org/11.0/#sec-tobigint64

module.exports = function ToBigInt64(argument) {
	var n = ToBigInt(argument);
	var int64bit = modBigInt(BigIntRemainder, n, twoSixtyFour);
	return int64bit >= twoSixtyThree ? int64bit - twoSixtyFour : int64bit;
};
'use strict';

var GetIntrinsic = require('get-intrinsic');

var $BigInt = GetIntrinsic('%BigInt%', true);
var $Number = GetIntrinsic('%Number%');
var $TypeError = require('es-errors/type');
var $SyntaxError = require('es-errors/syntax');

var StringToBigInt = require('./StringToBigInt');
var ToPrimitive = require('./ToPrimitive');

var isNaN = require('math-intrinsics/isNaN');

// https://262.ecma-international.org/11.0/#sec-tobigint

module.exports = function ToBigInt(argument) {
	if (!$BigInt) {
		throw new $SyntaxError('BigInts are not supported in this environment');
	}

	var prim = ToPrimitive(argument, $Number);

	if (prim == null) {
		throw new $TypeError('Cannot convert null or undefined to a BigInt');
	}

	if (typeof prim === 'boolean') {
		return prim ? $BigInt(1) : $BigInt(0);
	}

	if (typeof prim === 'number') {
		throw new $TypeError('Cannot convert a Number value to a BigInt');
	}

	if (typeof prim === 'string') {
		var n = StringToBigInt(prim);
		if (isNaN(n)) {
			throw new $TypeError('Failed to parse String to BigInt');
		}
		return n;
	}

	if (typeof prim === 'symbol') {
		throw new $TypeError('Cannot convert a Symbol value to a BigInt');
	}

	if (typeof prim !== 'bigint') {
		throw new $SyntaxError('Assertion failed: unknown primitive type');
	}

	return prim;
};
'use strict';

var GetIntrinsic = require('get-intrinsic');

var $BigInt = GetIntrinsic('%BigInt%', true);

var $pow = require('math-intrinsics/pow');

var ToBigInt = require('./ToBigInt');
var BigIntRemainder = require('./BigInt/remainder');

var modBigInt = require('../helpers/modBigInt');

// BigInt(2**64), but node v10.4-v10.8 have a bug where you can't `BigInt(x)` anything larger than MAX_SAFE_INTEGER
var twoSixtyFour = $BigInt && (BigInt($pow(2, 32)) * BigInt($pow(2, 32)));

// https://262.ecma-international.org/11.0/#sec-tobiguint64

module.exports = function ToBigUint64(argument) {
	var n = ToBigInt(argument);
	var int64bit = modBigInt(BigIntRemainder, n, twoSixtyFour);
	return int64bit;
};
'use strict';

// http://262.ecma-international.org/5.1/#sec-9.2

module.exports = function ToBoolean(value) { return !!value; };
'use strict';

var GetIntrinsic = require('get-intrinsic');

var $TypeError = require('es-errors/type');
var $Date = GetIntrinsic('%Date%');
var $String = GetIntrinsic('%String%');

var $isNaN = require('math-intrinsics/isNaN');

// https://262.ecma-international.org/6.0/#sec-todatestring

module.exports = function ToDateString(tv) {
	if (typeof tv !== 'number') {
		throw new $TypeError('Assertion failed: `tv` must be a Number');
	}
	if ($isNaN(tv)) {
		return 'Invalid Date';
	}
	return $String(new $Date(tv));
};
'use strict';

var $RangeError = require('es-errors/range');

var ToInteger = require('./ToInteger');
var ToLength = require('./ToLength');
var SameValue = require('./SameValue');

// https://262.ecma-international.org/12.0/#sec-toindex

module.exports = function ToIndex(value) {
	if (typeof value === 'undefined') {
		return 0;
	}
	var integerIndex = ToInteger(value);
	if (integerIndex < 0) {
		throw new $RangeError('index must be >= 0');
	}
	var index = ToLength(integerIndex);
	if (!SameValue(integerIndex, index)) {
		throw new $RangeError('index must be >= 0 and < 2 ** 53 - 1');
	}
	return index;
};
'use strict';

var ToUint16 = require('./ToUint16');

// https://262.ecma-international.org/6.0/#sec-toint16

module.exports = function ToInt16(argument) {
	var int16bit = ToUint16(argument);
	return int16bit >= 0x8000 ? int16bit - 0x10000 : int16bit;
};
'use strict';

var ToNumber = require('./ToNumber');

// http://262.ecma-international.org/5.1/#sec-9.5

module.exports = function ToInt32(x) {
	return ToNumber(x) >> 0;
};
'use strict';

var ToUint8 = require('./ToUint8');

// https://262.ecma-international.org/6.0/#sec-toint8

module.exports = function ToInt8(argument) {
	var int8bit = ToUint8(argument);
	return int8bit >= 0x80 ? int8bit - 0x100 : int8bit;
};
'use strict';

var ES5ToInteger = require('../5/ToInteger');

var ToNumber = require('./ToNumber');

// https://262.ecma-international.org/11.0/#sec-tointeger

module.exports = function ToInteger(value) {
	var number = ToNumber(value);
	if (number !== 0) {
		number = ES5ToInteger(number);
	}
	return number === 0 ? 0 : number;
};
'use strict';

var MAX_SAFE_INTEGER = require('math-intrinsics/constants/maxSafeInteger');

var ToInteger = require('./ToInteger');

// https://262.ecma-international.org/6.0/#sec-tolength

module.exports = function ToLength(argument) {
	var len = ToInteger(argument);
	if (len <= 0) { return 0; } // includes converting -0 to +0
	if (len > MAX_SAFE_INTEGER) { return MAX_SAFE_INTEGER; }
	return len;
};
'use strict';

var GetIntrinsic = require('get-intrinsic');

var $TypeError = require('es-errors/type');
var $Number = GetIntrinsic('%Number%');
var $RegExp = GetIntrinsic('%RegExp%');
var $parseInteger = GetIntrinsic('%parseInt%');

var callBound = require('call-bound');
var regexTester = require('safe-regex-test');
var isPrimitive = require('../helpers/isPrimitive');

var $strSlice = callBound('String.prototype.slice');
var isBinary = regexTester(/^0b[01]+$/i);
var isOctal = regexTester(/^0o[0-7]+$/i);
var isInvalidHexLiteral = regexTester(/^[-+]0x[0-9a-f]+$/i);
var nonWS = ['\u0085', '\u200b', '\ufffe'].join('');
var nonWSregex = new $RegExp('[' + nonWS + ']', 'g');
var hasNonWS = regexTester(nonWSregex);

var $trim = require('string.prototype.trim');

var ToPrimitive = require('./ToPrimitive');

// https://262.ecma-international.org/6.0/#sec-tonumber

module.exports = function ToNumber(argument) {
	var value = isPrimitive(argument) ? argument : ToPrimitive(argument, $Number);
	if (typeof value === 'symbol') {
		throw new $TypeError('Cannot convert a Symbol value to a number');
	}
	if (typeof value === 'bigint') {
		throw new $TypeError('Conversion from \'BigInt\' to \'number\' is not allowed.');
	}
	if (typeof value === 'string') {
		if (isBinary(value)) {
			return ToNumber($parseInteger($strSlice(value, 2), 2));
		} else if (isOctal(value)) {
			return ToNumber($parseInteger($strSlice(value, 2), 8));
		} else if (hasNonWS(value) || isInvalidHexLiteral(value)) {
			return NaN;
		}
		var trimmed = $trim(value);
		if (trimmed !== value) {
			return ToNumber(trimmed);
		}

	}
	return +value;
};
'use strict';

var GetIntrinsic = require('get-intrinsic');

var $Number = GetIntrinsic('%Number%');

var isPrimitive = require('../helpers/isPrimitive');

var ToPrimitive = require('./ToPrimitive');
var ToNumber = require('./ToNumber');

// https://262.ecma-international.org/11.0/#sec-tonumeric

module.exports = function ToNumeric(argument) {
	var primValue = isPrimitive(argument) ? argument : ToPrimitive(argument, $Number);
	if (typeof primValue === 'bigint') {
		return primValue;
	}
	return ToNumber(primValue);
};
'use strict';

// https://262.ecma-international.org/6.0/#sec-toobject

module.exports = require('es-object-atoms/ToObject');
'use strict';

var toPrimitive = require('es-to-primitive/es2015');

// https://262.ecma-international.org/6.0/#sec-toprimitive

module.exports = function ToPrimitive(input) {
	if (arguments.length > 1) {
		return toPrimitive(input, arguments[1]);
	}
	return toPrimitive(input);
};
'use strict';

var hasOwn = require('hasown');

var $TypeError = require('es-errors/type');
var isObject = require('es-object-atoms/isObject');

var IsCallable = require('./IsCallable');
var ToBoolean = require('./ToBoolean');

// https://262.ecma-international.org/5.1/#sec-8.10.5

module.exports = function ToPropertyDescriptor(Obj) {
	if (!isObject(Obj)) {
		throw new $TypeError('ToPropertyDescriptor requires an object');
	}

	var desc = {};
	if (hasOwn(Obj, 'enumerable')) {
		desc['[[Enumerable]]'] = ToBoolean(Obj.enumerable);
	}
	if (hasOwn(Obj, 'configurable')) {
		desc['[[Configurable]]'] = ToBoolean(Obj.configurable);
	}
	if (hasOwn(Obj, 'value')) {
		desc['[[Value]]'] = Obj.value;
	}
	if (hasOwn(Obj, 'writable')) {
		desc['[[Writable]]'] = ToBoolean(Obj.writable);
	}
	if (hasOwn(Obj, 'get')) {
		var getter = Obj.get;
		if (typeof getter !== 'undefined' && !IsCallable(getter)) {
			throw new $TypeError('getter must be a function');
		}
		desc['[[Get]]'] = getter;
	}
	if (hasOwn(Obj, 'set')) {
		var setter = Obj.set;
		if (typeof setter !== 'undefined' && !IsCallable(setter)) {
			throw new $TypeError('setter must be a function');
		}
		desc['[[Set]]'] = setter;
	}

	if ((hasOwn(desc, '[[Get]]') || hasOwn(desc, '[[Set]]')) && (hasOwn(desc, '[[Value]]') || hasOwn(desc, '[[Writable]]'))) {
		throw new $TypeError('Invalid property descriptor. Cannot both specify accessors and a value or writable attribute');
	}
	return desc;
};
'use strict';

var GetIntrinsic = require('get-intrinsic');

var $String = GetIntrinsic('%String%');

var ToPrimitive = require('./ToPrimitive');
var ToString = require('./ToString');

// https://262.ecma-international.org/6.0/#sec-topropertykey

module.exports = function ToPropertyKey(argument) {
	var key = ToPrimitive(argument, $String);
	return typeof key === 'symbol' ? key : ToString(key);
};
'use strict';

var GetIntrinsic = require('get-intrinsic');

var $String = GetIntrinsic('%String%');
var $TypeError = require('es-errors/type');

// https://262.ecma-international.org/6.0/#sec-tostring

module.exports = function ToString(argument) {
	if (typeof argument === 'symbol') {
		throw new $TypeError('Cannot convert a Symbol value to a string');
	}
	return $String(argument);
};
'use strict';

var modulo = require('./modulo');
var ToNumber = require('./ToNumber');

var abs = require('math-intrinsics/abs');
var floor = require('math-intrinsics/floor');
var $isNaN = require('math-intrinsics/isNaN');
var $isFinite = require('math-intrinsics/isFinite');
var $sign = require('math-intrinsics/sign');

// http://262.ecma-international.org/5.1/#sec-9.7

module.exports = function ToUint16(value) {
	var number = ToNumber(value);
	if ($isNaN(number) || number === 0 || !$isFinite(number)) { return 0; }
	var posInt = $sign(number) * floor(abs(number));
	return modulo(posInt, 0x10000);
};
'use strict';

var ToNumber = require('./ToNumber');

// http://262.ecma-international.org/5.1/#sec-9.6

module.exports = function ToUint32(x) {
	return ToNumber(x) >>> 0;
};
'use strict';

var ToNumber = require('./ToNumber');
var floor = require('./floor');

var $isNaN = require('math-intrinsics/isNaN');

// https://262.ecma-international.org/6.0/#sec-touint8clamp

module.exports = function ToUint8Clamp(argument) {
	var number = ToNumber(argument);
	if ($isNaN(number) || number <= 0) { return 0; }
	if (number >= 0xFF) { return 0xFF; }
	var f = floor(number);
	if (f + 0.5 < number) { return f + 1; }
	if (number < f + 0.5) { return f; }
	if (f % 2 !== 0) { return f + 1; }
	return f;
};
'use strict';

var ToNumber = require('./ToNumber');

var $isNaN = require('math-intrinsics/isNaN');
var $isFinite = require('math-intrinsics/isFinite');
var $sign = require('math-intrinsics/sign');
var abs = require('math-intrinsics/abs');
var floor = require('math-intrinsics/floor');
var modulo = require('math-intrinsics/mod');

// https://262.ecma-international.org/6.0/#sec-touint8

module.exports = function ToUint8(argument) {
	var number = ToNumber(argument);
	if ($isNaN(number) || number === 0 || !$isFinite(number)) { return 0; }
	var posInt = $sign(number) * floor(abs(number));
	return modulo(posInt, 0x100);
};
'use strict';

var trimStart = require('string.prototype.trimstart');
var trimEnd = require('string.prototype.trimend');

var $TypeError = require('es-errors/type');

var RequireObjectCoercible = require('./RequireObjectCoercible');
var ToString = require('./ToString');

// https://262.ecma-international.org/10.0/#sec-trimstring

module.exports = function TrimString(string, where) {
	var str = RequireObjectCoercible(string);
	var S = ToString(str);
	var T;
	if (where === 'start') {
		T = trimStart(S);
	} else if (where === 'end') {
		T = trimEnd(S);
	} else if (where === 'start+end') {
		T = trimStart(trimEnd(S));
	} else {
		throw new $TypeError('Assertion failed: invalid `where` value; must be "start", "end", or "start+end"');
	}
	return T;
};
'use strict';

var $SyntaxError = require('es-errors/syntax');
var $TypeError = require('es-errors/type');

var IsArray = require('./IsArray');
var IsConstructor = require('./IsConstructor');
var ValidateTypedArray = require('./ValidateTypedArray');

var availableTypedArrays = require('available-typed-arrays')();
var typedArrayLength = require('typed-array-length');

// https://262.ecma-international.org/7.0/#typedarray-create

module.exports = function TypedArrayCreate(constructor, argumentList) {
	if (!IsConstructor(constructor)) {
		throw new $TypeError('Assertion failed: `constructor` must be a constructor');
	}
	if (!IsArray(argumentList)) {
		throw new $TypeError('Assertion failed: `argumentList` must be a List');
	}
	if (availableTypedArrays.length === 0) {
		throw new $SyntaxError('Assertion failed: Typed Arrays are not supported in this environment');
	}

	// var newTypedArray = Construct(constructor, argumentList); // step 1
	var newTypedArray;
	if (argumentList.length === 0) {
		newTypedArray = new constructor();
	} else if (argumentList.length === 1) {
		newTypedArray = new constructor(argumentList[0]);
	} else if (argumentList.length === 2) {
		newTypedArray = new constructor(argumentList[0], argumentList[1]);
	} else {
		newTypedArray = new constructor(argumentList[0], argumentList[1], argumentList[2]);
	}

	ValidateTypedArray(newTypedArray); // step 2

	if (argumentList.length === 1 && typeof argumentList[0] === 'number') { // step 3
		if (typedArrayLength(newTypedArray) < argumentList[0]) {
			throw new $TypeError('Assertion failed: `argumentList[0]` must be <= `newTypedArray.length`'); // step 3.a
		}
	}

	return newTypedArray; // step 4
};
'use strict';

var $SyntaxError = require('es-errors/syntax');
var $TypeError = require('es-errors/type');

var whichTypedArray = require('which-typed-array');
var availableTypedArrays = require('available-typed-arrays')();

var IsArray = require('./IsArray');
var SpeciesConstructor = require('./SpeciesConstructor');
var TypedArrayCreate = require('./TypedArrayCreate');

var getConstructor = require('../helpers/typedArrayConstructors');

// https://262.ecma-international.org/7.0/#typedarray-species-create

module.exports = function TypedArraySpeciesCreate(exemplar, argumentList) {
	if (availableTypedArrays.length === 0) {
		throw new $SyntaxError('Assertion failed: Typed Arrays are not supported in this environment');
	}

	var kind = whichTypedArray(exemplar);
	if (!kind) {
		throw new $TypeError('Assertion failed: exemplar must be a TypedArray'); // step 1
	}
	if (!IsArray(argumentList)) {
		throw new $TypeError('Assertion failed: `argumentList` must be a List'); // step 1
	}

	var defaultConstructor = getConstructor(kind); // step 2
	if (typeof defaultConstructor !== 'function') {
		throw new $SyntaxError('Assertion failed: `constructor` of `exemplar` (' + kind + ') must exist. Please report this!');
	}
	var constructor = SpeciesConstructor(exemplar, defaultConstructor); // step 3

	return TypedArrayCreate(constructor, argumentList); // step 4
};
'use strict';

var ES5Type = require('../5/Type');

// https://262.ecma-international.org/11.0/#sec-ecmascript-data-types-and-values

module.exports = function Type(x) {
	if (typeof x === 'symbol') {
		return 'Symbol';
	}
	if (typeof x === 'bigint') {
		return 'BigInt';
	}
	return ES5Type(x);
};
'use strict';

var $TypeError = require('es-errors/type');

var callBound = require('call-bound');

var $charCodeAt = callBound('String.prototype.charCodeAt');
var $numberToString = callBound('Number.prototype.toString');
var $toLowerCase = callBound('String.prototype.toLowerCase');

var StringPad = require('./StringPad');

// https://262.ecma-international.org/11.0/#sec-unicodeescape

module.exports = function UnicodeEscape(C) {
	if (typeof C !== 'string' || C.length !== 1) {
		throw new $TypeError('Assertion failed: `C` must be a single code unit');
	}
	var n = $charCodeAt(C, 0);
	if (n > 0xFFFF) {
		throw new $TypeError('`Assertion failed: numeric value of `C` must be <= 0xFFFF');
	}

	return '\\u' + StringPad($toLowerCase($numberToString(n, 16)), 4, '0', 'start');
};
'use strict';

var $TypeError = require('es-errors/type');

var CodePointAt = require('./CodePointAt');

// https://262.ecma-international.org/11.0/#sec-utf16decodestring

module.exports = function UTF16DecodeString(string) {
	if (typeof string !== 'string') {
		throw new $TypeError('Assertion failed: `string` must be a String');
	}
	var codePoints = [];
	var size = string.length;
	var position = 0;
	while (position < size) {
		var cp = CodePointAt(string, position);
		codePoints[codePoints.length] = cp['[[CodePoint]]'];
		position += cp['[[CodeUnitCount]]'];
	}
	return codePoints;
};
'use strict';

var GetIntrinsic = require('get-intrinsic');

var $TypeError = require('es-errors/type');
var $fromCharCode = GetIntrinsic('%String.fromCharCode%');

var isLeadingSurrogate = require('../helpers/isLeadingSurrogate');
var isTrailingSurrogate = require('../helpers/isTrailingSurrogate');

// https://262.ecma-international.org/11.0/#sec-utf16decodesurrogatepair

module.exports = function UTF16DecodeSurrogatePair(lead, trail) {
	if (!isLeadingSurrogate(lead) || !isTrailingSurrogate(trail)) {
		throw new $TypeError('Assertion failed: `lead` must be a leading surrogate char code, and `trail` must be a trailing surrogate char code');
	}
	// var cp = (lead - 0xD800) * 0x400 + (trail - 0xDC00) + 0x10000;
	return $fromCharCode(lead) + $fromCharCode(trail);
};
'use strict';

var GetIntrinsic = require('get-intrinsic');

var $TypeError = require('es-errors/type');
var $fromCharCode = GetIntrinsic('%String.fromCharCode%');

var floor = require('./floor');
var modulo = require('./modulo');

var isCodePoint = require('../helpers/isCodePoint');

// https://262.ecma-international.org/7.0/#sec-utf16encoding

module.exports = function UTF16Encoding(cp) {
	if (!isCodePoint(cp)) {
		throw new $TypeError('Assertion failed: `cp` must be >= 0 and <= 0x10FFFF');
	}
	if (cp <= 65535) {
		return $fromCharCode(cp);
	}
	var cu1 = $fromCharCode(floor((cp - 65536) / 1024) + 0xD800);
	var cu2 = $fromCharCode(modulo(cp - 65536, 1024) + 0xDC00);
	return cu1 + cu2;
};
'use strict';

var $TypeError = require('es-errors/type');
var isObject = require('es-object-atoms/isObject');

var DefineOwnProperty = require('../helpers/DefineOwnProperty');
var isPropertyDescriptor = require('../helpers/records/property-descriptor');
var isSamePropertyDescriptor = require('../helpers/isSamePropertyDescriptor');

var FromPropertyDescriptor = require('./FromPropertyDescriptor');
var IsAccessorDescriptor = require('./IsAccessorDescriptor');
var IsDataDescriptor = require('./IsDataDescriptor');
var IsGenericDescriptor = require('./IsGenericDescriptor');
var isPropertyKey = require('../helpers/isPropertyKey');
var SameValue = require('./SameValue');

// https://262.ecma-international.org/6.0/#sec-validateandapplypropertydescriptor
// https://262.ecma-international.org/8.0/#sec-validateandapplypropertydescriptor

// eslint-disable-next-line max-lines-per-function, max-statements
module.exports = function ValidateAndApplyPropertyDescriptor(O, P, extensible, Desc, current) {
	// this uses the ES2017+ logic, since it fixes a number of bugs in the ES2015 logic.
	if (typeof O !== 'undefined' && !isObject(O)) {
		throw new $TypeError('Assertion failed: O must be undefined or an Object');
	}
	if (typeof extensible !== 'boolean') {
		throw new $TypeError('Assertion failed: extensible must be a Boolean');
	}
	if (!isPropertyDescriptor(Desc)) {
		throw new $TypeError('Assertion failed: Desc must be a Property Descriptor');
	}
	if (typeof current !== 'undefined' && !isPropertyDescriptor(current)) {
		throw new $TypeError('Assertion failed: current must be a Property Descriptor, or undefined');
	}
	if (typeof O !== 'undefined' && !isPropertyKey(P)) {
		throw new $TypeError('Assertion failed: if O is not undefined, P must be a Property Key');
	}
	if (typeof current === 'undefined') {
		if (!extensible) {
			return false;
		}
		if (IsGenericDescriptor(Desc) || IsDataDescriptor(Desc)) {
			if (typeof O !== 'undefined') {
				DefineOwnProperty(
					IsDataDescriptor,
					SameValue,
					FromPropertyDescriptor,
					O,
					P,
					{
						'[[Configurable]]': Desc['[[Configurable]]'],
						'[[Enumerable]]': Desc['[[Enumerable]]'],
						'[[Value]]': Desc['[[Value]]'],
						'[[Writable]]': Desc['[[Writable]]']
					}
				);
			}
		} else {
			if (!IsAccessorDescriptor(Desc)) {
				throw new $TypeError('Assertion failed: Desc is not an accessor descriptor');
			}
			if (typeof O !== 'undefined') {
				return DefineOwnProperty(
					IsDataDescriptor,
					SameValue,
					FromPropertyDescriptor,
					O,
					P,
					Desc
				);
			}
		}
		return true;
	}
	if (IsGenericDescriptor(Desc) && !('[[Configurable]]' in Desc) && !('[[Enumerable]]' in Desc)) {
		return true;
	}
	if (isSamePropertyDescriptor({ SameValue: SameValue }, Desc, current)) {
		return true; // removed by ES2017, but should still be correct
	}
	// "if every field in Desc is absent, return true" can't really match the assertion that it's a Property Descriptor
	if (!current['[[Configurable]]']) {
		if (Desc['[[Configurable]]']) {
			return false;
		}
		if ('[[Enumerable]]' in Desc && !Desc['[[Enumerable]]'] === !!current['[[Enumerable]]']) {
			return false;
		}
	}
	if (IsGenericDescriptor(Desc)) {
		// no further validation is required.
	} else if (IsDataDescriptor(current) !== IsDataDescriptor(Desc)) {
		if (!current['[[Configurable]]']) {
			return false;
		}
		if (IsDataDescriptor(current)) {
			if (typeof O !== 'undefined') {
				DefineOwnProperty(
					IsDataDescriptor,
					SameValue,
					FromPropertyDescriptor,
					O,
					P,
					{
						'[[Configurable]]': current['[[Configurable]]'],
						'[[Enumerable]]': current['[[Enumerable]]'],
						'[[Get]]': undefined
					}
				);
			}
		} else if (typeof O !== 'undefined') {
			DefineOwnProperty(
				IsDataDescriptor,
				SameValue,
				FromPropertyDescriptor,
				O,
				P,
				{
					'[[Configurable]]': current['[[Configurable]]'],
					'[[Enumerable]]': current['[[Enumerable]]'],
					'[[Value]]': undefined
				}
			);
		}
	} else if (IsDataDescriptor(current) && IsDataDescriptor(Desc)) {
		if (!current['[[Configurable]]'] && !current['[[Writable]]']) {
			if ('[[Writable]]' in Desc && Desc['[[Writable]]']) {
				return false;
			}
			if ('[[Value]]' in Desc && !SameValue(Desc['[[Value]]'], current['[[Value]]'])) {
				return false;
			}
			return true;
		}
	} else if (IsAccessorDescriptor(current) && IsAccessorDescriptor(Desc)) {
		if (!current['[[Configurable]]']) {
			if ('[[Set]]' in Desc && !SameValue(Desc['[[Set]]'], current['[[Set]]'])) {
				return false;
			}
			if ('[[Get]]' in Desc && !SameValue(Desc['[[Get]]'], current['[[Get]]'])) {
				return false;
			}
			return true;
		}
	} else {
		throw new $TypeError('Assertion failed: current and Desc are not both data, both accessors, or one accessor and one data.');
	}
	if (typeof O !== 'undefined') {
		return DefineOwnProperty(
			IsDataDescriptor,
			SameValue,
			FromPropertyDescriptor,
			O,
			P,
			Desc
		);
	}
	return true;
};
'use strict';

var $RangeError = require('es-errors/range');
var $TypeError = require('es-errors/type');

var ToIndex = require('./ToIndex');

var isTypedArray = require('is-typed-array');
var typedArrayLength = require('typed-array-length');

// https://262.ecma-international.org/8.0/#sec-validateatomicaccess

module.exports = function ValidateAtomicAccess(typedArray, requestIndex) {
	if (!isTypedArray(typedArray)) {
		throw new $TypeError('Assertion failed: `typedArray` must be a TypedArray'); // step 1
	}

	var accessIndex = ToIndex(requestIndex); // step 2

	var length = typedArrayLength(typedArray); // step 3

	/*
	// this assertion can never be reached
	if (!(accessIndex >= 0)) {
		throw new $TypeError('Assertion failed: accessIndex >= 0'); // step 4
	}
	*/

	if (accessIndex >= length) {
		throw new $RangeError('index out of range'); // step 5
	}

	return accessIndex; // step 6
};
'use strict';

var $TypeError = require('es-errors/type');
var isObject = require('es-object-atoms/isObject');

var IsDetachedBuffer = require('./IsDetachedBuffer');

var isTypedArray = require('is-typed-array');
var typedArrayBuffer = require('typed-array-buffer');

// https://262.ecma-international.org/6.0/#sec-validatetypedarray

module.exports = function ValidateTypedArray(O) {
	if (!isObject(O)) {
		throw new $TypeError('Assertion failed: `O` must be an Object'); // step 1
	}
	if (!isTypedArray(O)) {
		throw new $TypeError('Assertion failed: `O` must be a Typed Array'); // steps 2 - 3
	}

	var buffer = typedArrayBuffer(O); // step 4

	if (IsDetachedBuffer(buffer)) {
		throw new $TypeError('`O` must be backed by a non-detached buffer'); // step 5
	}

	return buffer; // step 6
};
'use strict';

var Day = require('./Day');
var modulo = require('./modulo');

// https://262.ecma-international.org/5.1/#sec-15.9.1.6

module.exports = function WeekDay(t) {
	return modulo(Day(t) + 4, 7);
};
'use strict';

var $TypeError = require('es-errors/type');

var callBound = require('call-bound');
var $indexOf = callBound('String.prototype.indexOf');

var Canonicalize = require('./Canonicalize');

var caseFolding = require('../helpers/caseFolding.json');
var forEach = require('../helpers/forEach');
var OwnPropertyKeys = require('own-keys');

var A = 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789_'; // step 1

// https://262.ecma-international.org/8.0/#sec-runtime-semantics-wordcharacters-abstract-operation

module.exports = function WordCharacters(IgnoreCase, Unicode) {
	if (typeof IgnoreCase !== 'boolean' || typeof Unicode !== 'boolean') {
		throw new $TypeError('Assertion failed: `IgnoreCase` and `Unicode` must be booleans');
	}

	var U = '';
	forEach(OwnPropertyKeys(caseFolding.C), function (c) {
		if (
			$indexOf(A, c) === -1 // c not in A
			&& $indexOf(A, Canonicalize(c, IgnoreCase, Unicode)) > -1 // canonicalized c IS in A
		) {
			U += caseFolding.C[c]; // step 3
		}
	});
	forEach(OwnPropertyKeys(caseFolding.S), function (c) {
		if (
			$indexOf(A, c) === -1 // c not in A
			&& $indexOf(A, Canonicalize(c, IgnoreCase, Unicode)) > -1 // canonicalized c IS in A
		) {
			U += caseFolding.S[c]; // step 3
		}
	});

	if ((!Unicode || !IgnoreCase) && U.length > 0) {
		throw new $TypeError('Assertion failed: `U` must be empty when `IgnoreCase` and `Unicode` are not both true'); // step 4
	}

	return A + U; // step 5, 6
};
'use strict';

var GetIntrinsic = require('get-intrinsic');

var $Date = GetIntrinsic('%Date%');

var callBound = require('call-bound');

var $getUTCFullYear = callBound('Date.prototype.getUTCFullYear');

// https://262.ecma-international.org/5.1/#sec-15.9.1.3

module.exports = function YearFromTime(t) {
	// largest y such that this.TimeFromYear(y) <= t
	return $getUTCFullYear(new $Date(t));
};
'use strict';

var $abs = require('math-intrinsics/abs');

// https://262.ecma-international.org/11.0/#eqn-abs

module.exports = function abs(x) {
	return typeof x === 'bigint' ? BigInt($abs(Number(x))) : $abs(x);
};
'use strict';

var StrictEqualityComparison = require('./StrictEqualityComparison');
var StringToBigInt = require('./StringToBigInt');
var ToNumber = require('./ToNumber');
var ToPrimitive = require('./ToPrimitive');

var isNaN = require('math-intrinsics/isNaN');
var isObject = require('es-object-atoms/isObject');
var isSameType = require('../helpers/isSameType');

// https://262.ecma-international.org/11.0/#sec-abstract-equality-comparison

module.exports = function AbstractEqualityComparison(x, y) {
	if (isSameType(x, y)) {
		return StrictEqualityComparison(x, y);
	}
	if (x == null && y == null) {
		return true;
	}
	if (typeof x === 'number' && typeof y === 'string') {
		return AbstractEqualityComparison(x, ToNumber(y));
	}
	if (typeof x === 'string' && typeof y === 'number') {
		return AbstractEqualityComparison(ToNumber(x), y);
	}
	if (typeof x === 'bigint' && typeof y === 'string') {
		var n = StringToBigInt(y);
		if (isNaN(n)) {
			return false;
		}
		return AbstractEqualityComparison(x, n);
	}
	if (typeof x === 'string' && typeof y === 'bigint') {
		return AbstractEqualityComparison(y, x);
	}
	if (typeof x === 'boolean') {
		return AbstractEqualityComparison(ToNumber(x), y);
	}
	if (typeof y === 'boolean') {
		return AbstractEqualityComparison(x, ToNumber(y));
	}
	if ((typeof x === 'string' || typeof x === 'number' || typeof x === 'bigint' || typeof x === 'symbol') && isObject(y)) {
		return AbstractEqualityComparison(x, ToPrimitive(y));
	}
	if (isObject(x) && (typeof y === 'string' || typeof y === 'number' || typeof y === 'bigint' || typeof y === 'symbol')) {
		return AbstractEqualityComparison(ToPrimitive(x), y);
	}
	if ((typeof x === 'bigint' && typeof y === 'number') || (typeof x === 'number' && typeof y === 'bigint')) {
		if (isNaN(x) || isNaN(y) || x === Infinity || y === Infinity || x === -Infinity || y === -Infinity) {
			return false;
		}
		return x == y; // eslint-disable-line eqeqeq
	}
	return false;
};
'use strict';

var GetIntrinsic = require('get-intrinsic');

var $Number = GetIntrinsic('%Number%');
var $TypeError = require('es-errors/type');

var $isNaN = require('math-intrinsics/isNaN');

var IsStringPrefix = require('./IsStringPrefix');
var StringToBigInt = require('./StringToBigInt');
var ToNumeric = require('./ToNumeric');
var ToPrimitive = require('./ToPrimitive');

var BigIntLessThan = require('./BigInt/lessThan');
var NumberLessThan = require('./Number/lessThan');

var isSameType = require('../helpers/isSameType');

// https://262.ecma-international.org/11.0/#sec-abstract-relational-comparison

// eslint-disable-next-line max-statements, max-lines-per-function
module.exports = function AbstractRelationalComparison(x, y, LeftFirst) {
	if (typeof LeftFirst !== 'boolean') {
		throw new $TypeError('Assertion failed: LeftFirst argument must be a Boolean');
	}
	var px;
	var py;
	if (LeftFirst) {
		px = ToPrimitive(x, $Number);
		py = ToPrimitive(y, $Number);
	} else {
		py = ToPrimitive(y, $Number);
		px = ToPrimitive(x, $Number);
	}
	if (typeof px === 'string' && typeof py === 'string') {
		if (IsStringPrefix(py, px)) {
			return false;
		}
		if (IsStringPrefix(px, py)) {
			return true;
		}
		return px < py; // both strings, neither a prefix of the other. shortcut for steps 3 c-f
	}

	var nx;
	var ny;
	if (typeof px === 'bigint' && typeof py === 'string') {
		ny = StringToBigInt(py);
		if ($isNaN(ny)) {
			return void undefined;
		}
		return BigIntLessThan(px, ny);
	}
	if (typeof px === 'string' && typeof py === 'bigint') {
		nx = StringToBigInt(px);
		if ($isNaN(nx)) {
			return void undefined;
		}
		return BigIntLessThan(nx, py);
	}

	nx = ToNumeric(px);
	ny = ToNumeric(py);
	if (isSameType(nx, ny)) {
		return typeof nx === 'number' ? NumberLessThan(nx, ny) : BigIntLessThan(nx, ny);
	}

	if ($isNaN(nx) || $isNaN(ny)) {
		return void undefined;
	}
	if (nx === -Infinity || ny === Infinity) {
		return true;
	}
	if (nx === Infinity || ny === -Infinity) {
		return false;
	}

	return nx < ny; // by now, these are both nonzero, finite, and not equal
};
'use strict';

var $TypeError = require('es-errors/type');
var isObject = require('es-object-atoms/isObject');
var inspect = require('object-inspect');

var Call = require('./Call');
var Get = require('./Get');
var GetIterator = require('./GetIterator');
var IsCallable = require('./IsCallable');
var IteratorClose = require('./IteratorClose');
var IteratorStep = require('./IteratorStep');
var IteratorValue = require('./IteratorValue');
var ThrowCompletion = require('./ThrowCompletion');

// https://262.ecma-international.org/10.0/#sec-add-entries-from-iterable

module.exports = function AddEntriesFromIterable(target, iterable, adder) {
	if (!IsCallable(adder)) {
		throw new $TypeError('Assertion failed: `adder` is not callable');
	}
	if (iterable == null) {
		throw new $TypeError('Assertion failed: `iterable` is present, and not nullish');
	}
	var iteratorRecord = GetIterator(iterable);
	while (true) { // eslint-disable-line no-constant-condition
		var next = IteratorStep(iteratorRecord);
		if (!next) {
			return target;
		}
		var nextItem = IteratorValue(next);
		if (!isObject(nextItem)) {
			var error = ThrowCompletion(new $TypeError('iterator next must return an Object, got ' + inspect(nextItem)));
			return IteratorClose(iteratorRecord, error);
		}
		try {
			var k = Get(nextItem, '0');
			var v = Get(nextItem, '1');
			Call(adder, target, [k, v]);
		} catch (e) {
			return IteratorClose(iteratorRecord, ThrowCompletion(e));
		}
	}
};
'use strict';

var SLOT = require('internal-slot');

var $TypeError = require('es-errors/type');
var isObject = require('es-object-atoms/isObject');

var ClearKeptObjects = require('./ClearKeptObjects');

// https://262.ecma-international.org/12.0/#sec-addtokeptobjects

module.exports = function AddToKeptObjects(object) {
	if (!isObject(object)) {
		throw new $TypeError('Assertion failed: `object` must be an Object');
	}
	var arr = SLOT.get(ClearKeptObjects, '[[es-abstract internal: KeptAlive]]');
	arr[arr.length] = object;
};
'use strict';

var CodePointAt = require('./CodePointAt');

var $TypeError = require('es-errors/type');
var isInteger = require('math-intrinsics/isInteger');
var MAX_SAFE_INTEGER = require('math-intrinsics/constants/maxSafeInteger');

// https://262.ecma-international.org/12.0/#sec-advancestringindex

module.exports = function AdvanceStringIndex(S, index, unicode) {
	if (typeof S !== 'string') {
		throw new $TypeError('Assertion failed: `S` must be a String');
	}
	if (!isInteger(index) || index < 0 || index > MAX_SAFE_INTEGER) {
		throw new $TypeError('Assertion failed: `length` must be an integer >= 0 and <= 2**53');
	}
	if (typeof unicode !== 'boolean') {
		throw new $TypeError('Assertion failed: `unicode` must be a Boolean');
	}
	if (!unicode) {
		return index + 1;
	}
	var length = S.length;
	if ((index + 1) >= length) {
		return index + 1;
	}
	var cp = CodePointAt(S, index);
	return index + cp['[[CodeUnitCount]]'];
};
'use strict';

var $TypeError = require('es-errors/type');

var HasOwnProperty = require('./HasOwnProperty');
var ToNumeric = require('./ToNumeric');
var ToPrimitive = require('./ToPrimitive');
var ToString = require('./ToString');
var Type = require('./Type');

var NumberAdd = require('./Number/add');
var NumberBitwiseAND = require('./Number/bitwiseAND');
var NumberBitwiseOR = require('./Number/bitwiseOR');
var NumberBitwiseXOR = require('./Number/bitwiseXOR');
var NumberDivide = require('./Number/divide');
var NumberExponentiate = require('./Number/exponentiate');
var NumberLeftShift = require('./Number/leftShift');
var NumberMultiply = require('./Number/multiply');
var NumberRemainder = require('./Number/remainder');
var NumberSignedRightShift = require('./Number/signedRightShift');
var NumberSubtract = require('./Number/subtract');
var NumberUnsignedRightShift = require('./Number/unsignedRightShift');
var BigIntAdd = require('./BigInt/add');
var BigIntBitwiseAND = require('./BigInt/bitwiseAND');
var BigIntBitwiseOR = require('./BigInt/bitwiseOR');
var BigIntBitwiseXOR = require('./BigInt/bitwiseXOR');
var BigIntDivide = require('./BigInt/divide');
var BigIntExponentiate = require('./BigInt/exponentiate');
var BigIntLeftShift = require('./BigInt/leftShift');
var BigIntMultiply = require('./BigInt/multiply');
var BigIntRemainder = require('./BigInt/remainder');
var BigIntSignedRightShift = require('./BigInt/signedRightShift');
var BigIntSubtract = require('./BigInt/subtract');
var BigIntUnsignedRightShift = require('./BigInt/unsignedRightShift');

// https://262.ecma-international.org/12.0/#sec-applystringornumericbinaryoperator

// https://262.ecma-international.org/12.0/#step-applystringornumericbinaryoperator-operations-table
var table = {
	'**': [NumberExponentiate, BigIntExponentiate],
	'*': [NumberMultiply, BigIntMultiply],
	'/': [NumberDivide, BigIntDivide],
	'%': [NumberRemainder, BigIntRemainder],
	'+': [NumberAdd, BigIntAdd],
	'-': [NumberSubtract, BigIntSubtract],
	'<<': [NumberLeftShift, BigIntLeftShift],
	'>>': [NumberSignedRightShift, BigIntSignedRightShift],
	'>>>': [NumberUnsignedRightShift, BigIntUnsignedRightShift],
	'&': [NumberBitwiseAND, BigIntBitwiseAND],
	'^': [NumberBitwiseXOR, BigIntBitwiseXOR],
	'|': [NumberBitwiseOR, BigIntBitwiseOR]
};

module.exports = function ApplyStringOrNumericBinaryOperator(lval, opText, rval) {
	if (typeof opText !== 'string' || !HasOwnProperty(table, opText)) {
		throw new $TypeError('Assertion failed: `opText` must be a valid operation string');
	}
	if (opText === '+') {
		var lprim = ToPrimitive(lval);
		var rprim = ToPrimitive(rval);
		if (typeof lprim === 'string' || typeof rprim === 'string') {
			var lstr = ToString(lprim);
			var rstr = ToString(rprim);
			return lstr + rstr;
		}
		/* eslint no-param-reassign: 1 */
		lval = lprim;
		rval = rprim;
	}
	var lnum = ToNumeric(lval);
	var rnum = ToNumeric(rval);
	if (Type(lnum) !== Type(rnum)) {
		throw new $TypeError('types of ' + lnum + ' and ' + rnum + ' differ');
	}
	var Operation = table[opText][typeof lnum === 'bigint' ? 1 : 0];
	return Operation(lnum, rnum);
};
'use strict';

var GetIntrinsic = require('get-intrinsic');

var $ArrayPrototype = GetIntrinsic('%Array.prototype%');
var $RangeError = require('es-errors/range');
var $SyntaxError = require('es-errors/syntax');
var $TypeError = require('es-errors/type');
var isInteger = require('math-intrinsics/isInteger');
var MAX_ARRAY_LENGTH = require('math-intrinsics/constants/maxArrayLength');
var $setProto = require('set-proto');

// https://262.ecma-international.org/12.0/#sec-arraycreate

module.exports = function ArrayCreate(length) {
	if (!isInteger(length) || length < 0) {
		throw new $TypeError('Assertion failed: `length` must be an integer Number >= 0');
	}
	if (length > MAX_ARRAY_LENGTH) {
		throw new $RangeError('length is greater than (2**32 - 1)');
	}
	var proto = arguments.length > 1 ? arguments[1] : $ArrayPrototype;
	var A = []; // steps 3, 5
	if (proto !== $ArrayPrototype) { // step 4
		if (!$setProto) {
			throw new $SyntaxError('ArrayCreate: a `proto` argument that is not `Array.prototype` is not supported in an environment that does not support setting the [[Prototype]]');
		}
		$setProto(A, proto);
	}
	if (length !== 0) { // bypasses the need for step 6
		A.length = length;
	}
	/* step 6, the above as a shortcut for the below
	OrdinaryDefineOwnProperty(A, 'length', {
		'[[Configurable]]': false,
		'[[Enumerable]]': false,
		'[[Value]]': length,
		'[[Writable]]': true
	});
	*/
	return A;
};
'use strict';

var $RangeError = require('es-errors/range');
var $TypeError = require('es-errors/type');

var assign = require('object.assign');

var isPropertyDescriptor = require('../helpers/records/property-descriptor');

var IsArray = require('./IsArray');
var IsDataDescriptor = require('./IsDataDescriptor');
var OrdinaryDefineOwnProperty = require('./OrdinaryDefineOwnProperty');
var OrdinaryGetOwnProperty = require('./OrdinaryGetOwnProperty');
var ToNumber = require('./ToNumber');
var ToString = require('./ToString');
var ToUint32 = require('./ToUint32');

// https://262.ecma-international.org/6.0/#sec-arraysetlength

// eslint-disable-next-line max-statements, max-lines-per-function
module.exports = function ArraySetLength(A, Desc) {
	if (!IsArray(A)) {
		throw new $TypeError('Assertion failed: A must be an Array');
	}
	if (!isPropertyDescriptor(Desc)) {
		throw new $TypeError('Assertion failed: Desc must be a Property Descriptor');
	}
	if (!('[[Value]]' in Desc)) {
		return OrdinaryDefineOwnProperty(A, 'length', Desc);
	}
	var newLenDesc = assign({}, Desc);
	var newLen = ToUint32(Desc['[[Value]]']);
	var numberLen = ToNumber(Desc['[[Value]]']);
	if (newLen !== numberLen) {
		throw new $RangeError('Invalid array length');
	}
	newLenDesc['[[Value]]'] = newLen;
	var oldLenDesc = OrdinaryGetOwnProperty(A, 'length');
	if (!IsDataDescriptor(oldLenDesc)) {
		throw new $TypeError('Assertion failed: an array had a non-data descriptor on `length`');
	}
	var oldLen = oldLenDesc['[[Value]]'];
	if (newLen >= oldLen) {
		return OrdinaryDefineOwnProperty(A, 'length', newLenDesc);
	}
	if (!oldLenDesc['[[Writable]]']) {
		return false;
	}
	var newWritable;
	if (!('[[Writable]]' in newLenDesc) || newLenDesc['[[Writable]]']) {
		newWritable = true;
	} else {
		newWritable = false;
		newLenDesc['[[Writable]]'] = true;
	}
	var succeeded = OrdinaryDefineOwnProperty(A, 'length', newLenDesc);
	if (!succeeded) {
		return false;
	}
	while (newLen < oldLen) {
		oldLen -= 1;
		// eslint-disable-next-line no-param-reassign
		var deleteSucceeded = delete A[ToString(oldLen)];
		if (!deleteSucceeded) {
			newLenDesc['[[Value]]'] = oldLen + 1;
			if (!newWritable) {
				newLenDesc['[[Writable]]'] = false;
				OrdinaryDefineOwnProperty(A, 'length', newLenDesc);
				return false;
			}
		}
	}
	if (!newWritable) {
		return OrdinaryDefineOwnProperty(A, 'length', { '[[Writable]]': false });
	}
	return true;
};
'use strict';

var GetIntrinsic = require('get-intrinsic');

var $species = GetIntrinsic('%Symbol.species%', true);
var $TypeError = require('es-errors/type');
var isInteger = require('math-intrinsics/isInteger');
var isObject = require('es-object-atoms/isObject');

var ArrayCreate = require('./ArrayCreate');
var Get = require('./Get');
var IsArray = require('./IsArray');
var IsConstructor = require('./IsConstructor');

// https://262.ecma-international.org/12.0/#sec-arrayspeciescreate

module.exports = function ArraySpeciesCreate(originalArray, length) {
	if (!isInteger(length) || length < 0) {
		throw new $TypeError('Assertion failed: length must be an integer >= 0');
	}

	var isArray = IsArray(originalArray);
	if (!isArray) {
		return ArrayCreate(length);
	}

	var C = Get(originalArray, 'constructor');
	// TODO: figure out how to make a cross-realm normal Array, a same-realm Array
	// if (IsConstructor(C)) {
	// 	if C is another realm's Array, C = undefined
	// 	Object.getPrototypeOf(Object.getPrototypeOf(Object.getPrototypeOf(Array))) === null ?
	// }
	if ($species && isObject(C)) {
		C = Get(C, $species);
		if (C === null) {
			C = void 0;
		}
	}

	if (typeof C === 'undefined') {
		return ArrayCreate(length);
	}
	if (!IsConstructor(C)) {
		throw new $TypeError('C must be a constructor');
	}
	return new C(length); // Construct(C, length);
};

'use strict';

var GetIntrinsic = require('get-intrinsic');

var $SyntaxError = require('es-errors/syntax');
var $TypeError = require('es-errors/type');
var isObject = require('es-object-atoms/isObject');
var $Promise = GetIntrinsic('%Promise%', true);

var callBound = require('call-bound');

var CreateIterResultObject = require('./CreateIterResultObject');
var IteratorComplete = require('./IteratorComplete');
var IteratorValue = require('./IteratorValue');
var PromiseResolve = require('./PromiseResolve');

var $then = callBound('Promise.prototype.then', true);

// https://262.ecma-international.org/10.0/#sec-asyncfromsynciteratorcontinuation

module.exports = function AsyncFromSyncIteratorContinuation(result) {
	if (!isObject(result)) {
		throw new $TypeError('Assertion failed: Type(O) is not Object');
	}

	if (arguments.length > 1) {
		throw new $SyntaxError('although AsyncFromSyncIteratorContinuation should take a second argument, it is not used in this implementation');
	}

	if (!$Promise) {
		throw new $SyntaxError('This environment does not support Promises.');
	}

	return new $Promise(function (resolve) {
		var done = IteratorComplete(result); // step 2
		var value = IteratorValue(result); // step 4
		var valueWrapper = PromiseResolve($Promise, value); // step 6

		// eslint-disable-next-line no-shadow
		var onFulfilled = function (value) { // steps 8-9
			return CreateIterResultObject(value, done); // step 8.a
		};
		resolve($then(valueWrapper, onFulfilled)); // step 11
	}); // step 12
};
'use strict';

var GetIntrinsic = require('get-intrinsic');

var $SyntaxError = require('es-errors/syntax');
var $TypeError = require('es-errors/type');
var isObject = require('es-object-atoms/isObject');
var $Promise = GetIntrinsic('%Promise%', true);

var Call = require('./Call');
var CompletionRecord = require('./CompletionRecord');
var GetMethod = require('./GetMethod');

var isIteratorRecord = require('../helpers/records/iterator-record-2023');

var callBound = require('call-bound');

var $then = callBound('Promise.prototype.then', true);

// https://262.ecma-international.org/12.0/#sec-asynciteratorclose

module.exports = function AsyncIteratorClose(iteratorRecord, completion) {
	if (!isIteratorRecord(iteratorRecord)) {
		throw new $TypeError('Assertion failed: `iteratorRecord` must be an Iterator Record'); // step 1
	}

	if (!(completion instanceof CompletionRecord)) {
		throw new $TypeError('Assertion failed: completion is not a Completion Record instance'); // step 2
	}

	if (!$then) {
		throw new $SyntaxError('This environment does not support Promises.');
	}

	var iterator = iteratorRecord['[[Iterator]]']; // step 3

	return $then(
		$then(
			$then(
				new $Promise(function (resolve) {
					resolve(GetMethod(iterator, 'return')); // step 4
					// resolve(Call(ret, iterator, [])); // step 6
				}),
				function (returnV) { // step 5.a
					if (typeof returnV === 'undefined') {
						return completion; // step 5.b
					}
					return Call(returnV, iterator); // step 5.c, 5.d.
				}
			),
			null,
			function (e) {
				if (completion.type() === 'throw') {
					completion['?'](); // step 6
				} else {
					throw e; // step 7
				}
			}
		),
		function (innerResult) { // step 8
			if (completion.type() === 'throw') {
				completion['?'](); // step 6
			}
			if (!isObject(innerResult)) {
				throw new $TypeError('`innerResult` must be an Object'); // step 10
			}
			return completion;
		}
	);
};
'use strict';

var $TypeError = require('es-errors/type');
// var $BigInt = GetIntrinsic('%BigInt%', true);
// var $pow = require('math-intrinsics/pow');

// var BinaryAnd = require('./BinaryAnd');
// var BinaryOr = require('./BinaryOr');
// var BinaryXor = require('./BinaryXor');
// var modulo = require('./modulo');

// var zero = $BigInt && $BigInt(0);
// var negOne = $BigInt && $BigInt(-1);
// var two = $BigInt && $BigInt(2);

// https://262.ecma-international.org/11.0/#sec-bigintbitwiseop

module.exports = function BigIntBitwiseOp(op, x, y) {
	if (op !== '&' && op !== '|' && op !== '^') {
		throw new $TypeError('Assertion failed: `op` must be `&`, `|`, or `^`');
	}
	if (typeof x !== 'bigint' || typeof y !== 'bigint') {
		throw new $TypeError('`x` and `y` must be BigInts');
	}

	if (op === '&') {
		return x & y;
	}
	if (op === '|') {
		return x | y;
	}
	return x ^ y;
	/*
	var result = zero;
	var shift = 0;
	while (x !== zero && x !== negOne && y !== zero && y !== negOne) {
		var xDigit = modulo(x, two);
		var yDigit = modulo(y, two);
		if (op === '&') {
			result += $pow(2, shift) * BinaryAnd(xDigit, yDigit);
		} else if (op === '|') {
			result += $pow(2, shift) * BinaryOr(xDigit, yDigit);
		} else if (op === '^') {
			result += $pow(2, shift) * BinaryXor(xDigit, yDigit);
		}
		shift += 1;
		x = (x - xDigit) / two;
		y = (y - yDigit) / two;
	}
	var tmp;
	if (op === '&') {
		tmp = BinaryAnd(modulo(x, two), modulo(y, two));
	} else if (op === '|') {
		tmp = BinaryAnd(modulo(x, two), modulo(y, two));
	} else {
		tmp = BinaryXor(modulo(x, two), modulo(y, two));
	}
	if (tmp !== 0) {
		result -= $pow(2, shift);
	}
	return result;
	*/
};
'use strict';

var $TypeError = require('es-errors/type');

// https://262.ecma-international.org/11.0/#sec-binaryand

module.exports = function BinaryAnd(x, y) {
	if ((x !== 0 && x !== 1) || (y !== 0 && y !== 1)) {
		throw new $TypeError('Assertion failed: `x` and `y` must be either 0 or 1');
	}
	return x & y;
};
'use strict';

var $TypeError = require('es-errors/type');

// https://262.ecma-international.org/11.0/#sec-binaryor

module.exports = function BinaryOr(x, y) {
	if ((x !== 0 && x !== 1) || (y !== 0 && y !== 1)) {
		throw new $TypeError('Assertion failed: `x` and `y` must be either 0 or 1');
	}
	return x | y;
};
'use strict';

var $TypeError = require('es-errors/type');

// https://262.ecma-international.org/11.0/#sec-binaryxor

module.exports = function BinaryXor(x, y) {
	if ((x !== 0 && x !== 1) || (y !== 0 && y !== 1)) {
		throw new $TypeError('Assertion failed: `x` and `y` must be either 0 or 1');
	}
	return x ^ y;
};
'use strict';

var $TypeError = require('es-errors/type');

var IsArray = require('./IsArray');

var isByteValue = require('../helpers/isByteValue');

// https://262.ecma-international.org/12.0/#sec-bytelistbitwiseop

module.exports = function ByteListBitwiseOp(op, xBytes, yBytes) {
	if (op !== '&' && op !== '^' && op !== '|') {
		throw new $TypeError('Assertion failed: `op` must be `&`, `^`, or `|`');
	}
	if (!IsArray(xBytes) || !IsArray(yBytes) || xBytes.length !== yBytes.length) {
		throw new $TypeError('Assertion failed: `xBytes` and `yBytes` must be same-length sequences of byte values (an integer 0-255, inclusive)');
	}

	var result = [];

	for (var i = 0; i < xBytes.length; i += 1) {
		var xByte = xBytes[i];
		var yByte = yBytes[i];
		if (!isByteValue(xByte) || !isByteValue(yByte)) {
			throw new $TypeError('Assertion failed: `xBytes` and `yBytes` must be same-length sequences of byte values (an integer 0-255, inclusive)');
		}
		var resultByte;
		if (op === '&') {
			resultByte = xByte & yByte;
		} else if (op === '^') {
			resultByte = xByte ^ yByte;
		} else {
			resultByte = xByte | yByte;
		}
		result[result.length] = resultByte;
	}

	return result;
};
'use strict';

var $TypeError = require('es-errors/type');

var IsArray = require('./IsArray');

var isByteValue = require('../helpers/isByteValue');

// https://262.ecma-international.org/12.0/#sec-bytelistequal

module.exports = function ByteListEqual(xBytes, yBytes) {
	if (!IsArray(xBytes) || !IsArray(yBytes)) {
		throw new $TypeError('Assertion failed: `xBytes` and `yBytes` must be sequences of byte values (an integer 0-255, inclusive)');
	}

	if (xBytes.length !== yBytes.length) {
		return false;
	}

	for (var i = 0; i < xBytes.length; i += 1) {
		var xByte = xBytes[i];
		var yByte = yBytes[i];
		if (!isByteValue(xByte) || !isByteValue(yByte)) {
			throw new $TypeError('Assertion failed: `xBytes` and `yBytes` must be sequences of byte values (an integer 0-255, inclusive)');
		}
		if (xByte !== yByte) {
			return false;
		}
	}
	return true;
};
'use strict';

var GetIntrinsic = require('get-intrinsic');
var callBound = require('call-bound');

var $TypeError = require('es-errors/type');

var IsArray = require('./IsArray');

var $apply = GetIntrinsic('%Reflect.apply%', true) || callBound('Function.prototype.apply');

// https://262.ecma-international.org/6.0/#sec-call

module.exports = function Call(F, V) {
	var argumentsList = arguments.length > 2 ? arguments[2] : [];
	if (!IsArray(argumentsList)) {
		throw new $TypeError('Assertion failed: optional `argumentsList`, if provided, must be a List');
	}
	return $apply(F, V, argumentsList);
};
'use strict';

var $TypeError = require('es-errors/type');

var callBound = require('call-bound');
var hasOwn = require('hasown');

var $charCodeAt = callBound('String.prototype.charCodeAt');
var $toUpperCase = callBound('String.prototype.toUpperCase');

var caseFolding = require('../helpers/caseFolding.json');

// https://262.ecma-international.org/6.0/#sec-runtime-semantics-canonicalize-ch

module.exports = function Canonicalize(ch, IgnoreCase, Unicode) {
	if (typeof ch !== 'string') {
		throw new $TypeError('Assertion failed: `ch` must be a character');
	}

	if (typeof IgnoreCase !== 'boolean' || typeof Unicode !== 'boolean') {
		throw new $TypeError('Assertion failed: `IgnoreCase` and `Unicode` must be Booleans');
	}

	if (!IgnoreCase) {
		return ch; // step 1
	}

	if (Unicode) { // step 2
		if (hasOwn(caseFolding.C, ch)) {
			return caseFolding.C[ch];
		}
		if (hasOwn(caseFolding.S, ch)) {
			return caseFolding.S[ch];
		}
		return ch; // step 2.b
	}

	var u = $toUpperCase(ch); // step 2

	if (u.length !== 1) {
		return ch; // step 3
	}

	var cu = u; // step 4

	if ($charCodeAt(ch, 0) >= 128 && $charCodeAt(cu, 0) < 128) {
		return ch; // step 5
	}

	return cu;
};
'use strict';

var $TypeError = require('es-errors/type');

var SameValue = require('./SameValue');
var ToNumber = require('./ToNumber');
var ToString = require('./ToString');

// https://262.ecma-international.org/6.0/#sec-canonicalnumericindexstring

module.exports = function CanonicalNumericIndexString(argument) {
	if (typeof argument !== 'string') {
		throw new $TypeError('Assertion failed: `argument` must be a String');
	}
	if (argument === '-0') { return -0; }
	var n = ToNumber(argument);
	if (SameValue(ToString(n), argument)) { return n; }
	return void 0;
};
'use strict';

var GetIntrinsic = require('get-intrinsic');
var callBound = require('call-bound');

var $fromCharCode = GetIntrinsic('%String.fromCharCode%');
var $TypeError = require('es-errors/type');
var $charCodeAt = callBound('String.prototype.charCodeAt');

var CharSet = require('../helpers/CharSet').CharSet;

module.exports = function CharacterRange(A, B) {
	var a;
	var b;

	if (A instanceof CharSet || B instanceof CharSet) {
		if (!(A instanceof CharSet) || !(B instanceof CharSet)) {
			throw new $TypeError('Assertion failed: CharSets A and B are not both CharSets');
		}

		A.yield(function (c) {
			if (typeof a !== 'undefined') {
				throw new $TypeError('Assertion failed: CharSet A has more than one character');
			}
			a = c;
		});
		B.yield(function (c) {
			if (typeof b !== 'undefined') {
				throw new $TypeError('Assertion failed: CharSet B has more than one character');
			}
			b = c;
		});
	} else {
		if (A.length !== 1 || B.length !== 1) {
			throw new $TypeError('Assertion failed: CharSets A and B contain exactly one character');
		}
		a = A[0];
		b = B[0];
	}

	var i = $charCodeAt(a, 0);
	var j = $charCodeAt(b, 0);

	if (!(i <= j)) {
		throw new $TypeError('Assertion failed: i is not <= j');
	}

	var arr = [];
	for (var k = i; k <= j; k += 1) {
		arr[arr.length] = $fromCharCode(k);
	}
	return arr;
};
'use strict';

var $TypeError = require('es-errors/type');
var max = require('math-intrinsics/max');
var min = require('math-intrinsics/min');

// https://262.ecma-international.org/12.0/#clamping

module.exports = function clamp(x, lower, upper) {
	if (typeof x !== 'number' || typeof lower !== 'number' || typeof upper !== 'number' || !(lower <= upper)) {
		throw new $TypeError('Assertion failed: all three arguments must be MVs, and `lower` must be `<= upper`');
	}
	return min(max(lower, x), upper);
};
'use strict';

var SLOT = require('internal-slot');
var keptObjects = [];

// https://262.ecma-international.org/12.0/#sec-clear-kept-objects

module.exports = function ClearKeptObjects() {
	keptObjects.length = 0;
};

SLOT.set(module.exports, '[[es-abstract internal: KeptAlive]]', keptObjects);
'use strict';

var $TypeError = require('es-errors/type');

var GetPrototypeFromConstructor = require('./GetPrototypeFromConstructor');
var IsConstructor = require('./IsConstructor');
var IsDetachedBuffer = require('./IsDetachedBuffer');
var OrdinarySetPrototypeOf = require('./OrdinarySetPrototypeOf');

var isInteger = require('math-intrinsics/isInteger');
var isArrayBuffer = require('is-array-buffer');
var arrayBufferSlice = require('arraybuffer.prototype.slice');

// https://262.ecma-international.org/12.0/#sec-clonearraybuffer

module.exports = function CloneArrayBuffer(srcBuffer, srcByteOffset, srcLength, cloneConstructor) {
	if (!isArrayBuffer(srcBuffer)) {
		throw new $TypeError('Assertion failed: `srcBuffer` must be an ArrayBuffer instance');
	}
	if (!isInteger(srcByteOffset) || srcByteOffset < 0) {
		throw new $TypeError('Assertion failed: `srcByteOffset` must be a non-negative integer');
	}
	if (!isInteger(srcLength) || srcLength < 0) {
		throw new $TypeError('Assertion failed: `srcLength` must be a non-negative integer');
	}
	if (!IsConstructor(cloneConstructor)) {
		throw new $TypeError('Assertion failed: `cloneConstructor` must be a constructor');
	}

	// 3. Let targetBuffer be ? AllocateArrayBuffer(cloneConstructor, srcLength).
	var proto = GetPrototypeFromConstructor(cloneConstructor, '%ArrayBufferPrototype%'); // step 3, kinda

	if (IsDetachedBuffer(srcBuffer)) {
		throw new $TypeError('`srcBuffer` must not be a detached ArrayBuffer'); // step 4
	}

	/*
    5. Let srcBlock be srcBuffer.[[ArrayBufferData]].
    6. Let targetBlock be targetBuffer.[[ArrayBufferData]].
    7. Perform CopyDataBlockBytes(targetBlock, 0, srcBlock, srcByteOffset, srcLength).
    */
	var targetBuffer = arrayBufferSlice(srcBuffer, srcByteOffset, srcByteOffset + srcLength); // steps 5-7
	OrdinarySetPrototypeOf(targetBuffer, proto); // step 3

	return targetBuffer; // step 8
};
'use strict';

var $TypeError = require('es-errors/type');
var callBound = require('call-bound');
var isLeadingSurrogate = require('../helpers/isLeadingSurrogate');
var isTrailingSurrogate = require('../helpers/isTrailingSurrogate');

var UTF16SurrogatePairToCodePoint = require('./UTF16SurrogatePairToCodePoint');

var $charAt = callBound('String.prototype.charAt');
var $charCodeAt = callBound('String.prototype.charCodeAt');

// https://262.ecma-international.org/12.0/#sec-codepointat

module.exports = function CodePointAt(string, position) {
	if (typeof string !== 'string') {
		throw new $TypeError('Assertion failed: `string` must be a String');
	}
	var size = string.length;
	if (position < 0 || position >= size) {
		throw new $TypeError('Assertion failed: `position` must be >= 0, and < the length of `string`');
	}
	var first = $charCodeAt(string, position);
	var cp = $charAt(string, position);
	var firstIsLeading = isLeadingSurrogate(first);
	var firstIsTrailing = isTrailingSurrogate(first);
	if (!firstIsLeading && !firstIsTrailing) {
		return {
			'[[CodePoint]]': cp,
			'[[CodeUnitCount]]': 1,
			'[[IsUnpairedSurrogate]]': false
		};
	}
	if (firstIsTrailing || (position + 1 === size)) {
		return {
			'[[CodePoint]]': cp,
			'[[CodeUnitCount]]': 1,
			'[[IsUnpairedSurrogate]]': true
		};
	}
	var second = $charCodeAt(string, position + 1);
	if (!isTrailingSurrogate(second)) {
		return {
			'[[CodePoint]]': cp,
			'[[CodeUnitCount]]': 1,
			'[[IsUnpairedSurrogate]]': true
		};
	}

	return {
		'[[CodePoint]]': UTF16SurrogatePairToCodePoint(first, second),
		'[[CodeUnitCount]]': 2,
		'[[IsUnpairedSurrogate]]': false
	};
};
'use strict';

var $TypeError = require('es-errors/type');

var UTF16EncodeCodePoint = require('./UTF16EncodeCodePoint');
var IsArray = require('./IsArray');

var forEach = require('../helpers/forEach');
var isCodePoint = require('../helpers/isCodePoint');

// https://262.ecma-international.org/12.0/#sec-codepointstostring

module.exports = function CodePointsToString(text) {
	if (!IsArray(text)) {
		throw new $TypeError('Assertion failed: `text` must be a sequence of Unicode Code Points');
	}
	var result = '';
	forEach(text, function (cp) {
		if (!isCodePoint(cp)) {
			throw new $TypeError('Assertion failed: `text` must be a sequence of Unicode Code Points');
		}
		result += UTF16EncodeCodePoint(cp);
	});
	return result;
};
'use strict';

var $TypeError = require('es-errors/type');

var hasOwn = require('hasown');

var IsDataDescriptor = require('./IsDataDescriptor');
var IsGenericDescriptor = require('./IsGenericDescriptor');

var isPropertyDescriptor = require('../helpers/records/property-descriptor');

// https://262.ecma-international.org/6.0/#sec-completepropertydescriptor

module.exports = function CompletePropertyDescriptor(Desc) {
	if (!isPropertyDescriptor(Desc)) {
		throw new $TypeError('Assertion failed: `Desc` must be a Property Descriptor');
	}

	/* eslint no-param-reassign: 0 */

	if (IsGenericDescriptor(Desc) || IsDataDescriptor(Desc)) {
		if (!hasOwn(Desc, '[[Value]]')) {
			Desc['[[Value]]'] = void 0;
		}
		if (!hasOwn(Desc, '[[Writable]]')) {
			Desc['[[Writable]]'] = false;
		}
	} else {
		if (!hasOwn(Desc, '[[Get]]')) {
			Desc['[[Get]]'] = void 0;
		}
		if (!hasOwn(Desc, '[[Set]]')) {
			Desc['[[Set]]'] = void 0;
		}
	}
	if (!hasOwn(Desc, '[[Enumerable]]')) {
		Desc['[[Enumerable]]'] = false;
	}
	if (!hasOwn(Desc, '[[Configurable]]')) {
		Desc['[[Configurable]]'] = false;
	}
	return Desc;
};
'use strict';

var $SyntaxError = require('es-errors/syntax');

var SLOT = require('internal-slot');

// https://262.ecma-international.org/7.0/#sec-completion-record-specification-type

var CompletionRecord = function CompletionRecord(type, value) {
	if (!(this instanceof CompletionRecord)) {
		return new CompletionRecord(type, value);
	}
	if (type !== 'normal' && type !== 'break' && type !== 'continue' && type !== 'return' && type !== 'throw') {
		throw new $SyntaxError('Assertion failed: `type` must be one of "normal", "break", "continue", "return", or "throw"');
	}
	SLOT.set(this, '[[Type]]', type);
	SLOT.set(this, '[[Value]]', value);
	// [[Target]] slot?
};

CompletionRecord.prototype.type = function Type() {
	return SLOT.get(this, '[[Type]]');
};

CompletionRecord.prototype.value = function Value() {
	return SLOT.get(this, '[[Value]]');
};

CompletionRecord.prototype['?'] = function ReturnIfAbrupt() {
	var type = SLOT.get(this, '[[Type]]');
	var value = SLOT.get(this, '[[Value]]');

	if (type === 'throw') {
		throw value;
	}
	return value;
};

CompletionRecord.prototype['!'] = function assert() {
	var type = SLOT.get(this, '[[Type]]');

	if (type !== 'normal') {
		throw new $SyntaxError('Assertion failed: Completion Record is not of type "normal"');
	}
	return SLOT.get(this, '[[Value]]');
};

module.exports = CompletionRecord;
'use strict';

var $TypeError = require('es-errors/type');
var isObject = require('es-object-atoms/isObject');
var callBound = require('call-bound');
var OwnPropertyKeys = require('own-keys');

var forEach = require('../helpers/forEach');
var every = require('../helpers/every');
var some = require('../helpers/some');

var $isEnumerable = callBound('Object.prototype.propertyIsEnumerable');

var CreateDataPropertyOrThrow = require('./CreateDataPropertyOrThrow');
var Get = require('./Get');
var IsArray = require('./IsArray');
var isPropertyKey = require('../helpers/isPropertyKey');
var SameValue = require('./SameValue');
var ToNumber = require('./ToNumber');
var ToObject = require('./ToObject');

var isInteger = require('math-intrinsics/isInteger');

// https://262.ecma-international.org/12.0/#sec-copydataproperties

module.exports = function CopyDataProperties(target, source, excludedItems) {
	if (!isObject(target)) {
		throw new $TypeError('Assertion failed: "target" must be an Object');
	}

	if (!IsArray(excludedItems) || !every(excludedItems, isPropertyKey)) {
		throw new $TypeError('Assertion failed: "excludedItems" must be a List of Property Keys');
	}

	if (typeof source === 'undefined' || source === null) {
		return target;
	}

	var from = ToObject(source);

	var keys = OwnPropertyKeys(from);
	forEach(keys, function (nextKey) {
		var excluded = some(excludedItems, function (e) {
			return SameValue(e, nextKey) === true;
		});
		/*
		var excluded = false;

		forEach(excludedItems, function (e) {
			if (SameValue(e, nextKey) === true) {
				excluded = true;
			}
		});
		*/

		var enumerable = $isEnumerable(from, nextKey) || (
		// this is to handle string keys being non-enumerable in older engines
			typeof source === 'string'
			&& nextKey >= 0
			&& isInteger(ToNumber(nextKey))
		);
		if (excluded === false && enumerable) {
			var propValue = Get(from, nextKey);
			CreateDataPropertyOrThrow(target, nextKey, propValue);
		}
	});

	return target;
};
'use strict';

var GetIntrinsic = require('get-intrinsic');

var $SyntaxError = require('es-errors/syntax');
var $TypeError = require('es-errors/type');
var isObject = require('es-object-atoms/isObject');
var $Promise = GetIntrinsic('%Promise%', true);

var AsyncFromSyncIteratorContinuation = require('./AsyncFromSyncIteratorContinuation');
var Call = require('./Call');
var CreateIterResultObject = require('./CreateIterResultObject');
var Get = require('./Get');
var GetMethod = require('./GetMethod');
var IteratorNext = require('./IteratorNext');
var OrdinaryObjectCreate = require('./OrdinaryObjectCreate');

var isIteratorRecord = require('../helpers/records/iterator-record-2023');

var SLOT = require('internal-slot');

var $AsyncFromSyncIteratorPrototype = GetIntrinsic('%AsyncFromSyncIteratorPrototype%', true) || {
	next: function next(value) {
		if (!$Promise) {
			throw new $SyntaxError('This environment does not support Promises.');
		}

		var O = this; // step 1

		SLOT.assert(O, '[[SyncIteratorRecord]]'); // step 2

		var argsLength = arguments.length;

		return new $Promise(function (resolve) { // step 3
			var syncIteratorRecord = SLOT.get(O, '[[SyncIteratorRecord]]'); // step 4
			var result;
			if (argsLength > 0) {
				result = IteratorNext(syncIteratorRecord['[[Iterator]]'], value); // step 5.a
			} else { // step 6
				result = IteratorNext(syncIteratorRecord['[[Iterator]]']);// step 6.a
			}
			resolve(AsyncFromSyncIteratorContinuation(result)); // step 8
		});
	},
	'return': function () {
		if (!$Promise) {
			throw new $SyntaxError('This environment does not support Promises.');
		}

		var O = this; // step 1

		SLOT.assert(O, '[[SyncIteratorRecord]]'); // step 2

		var valueIsPresent = arguments.length > 0;
		var value = valueIsPresent ? arguments[0] : void undefined;

		return new $Promise(function (resolve, reject) { // step 3
			var syncIterator = SLOT.get(O, '[[SyncIteratorRecord]]')['[[Iterator]]']; // step 4
			var iteratorReturn = GetMethod(syncIterator, 'return'); // step 5

			if (typeof iteratorReturn === 'undefined') { // step 7
				var iterResult = CreateIterResultObject(value, true); // step 7.a
				Call(resolve, undefined, [iterResult]); // step 7.b
				return;
			}
			var result;
			if (valueIsPresent) { // step 8
				result = Call(iteratorReturn, syncIterator, [value]); // step 8.a
			} else { // step 9
				result = Call(iteratorReturn, syncIterator); // step 9.a
			}
			if (!isObject(result)) { // step 11
				Call(reject, undefined, [new $TypeError('Iterator `return` method returned a non-object value.')]); // step 11.a
				return;
			}

			resolve(AsyncFromSyncIteratorContinuation(result)); // step 12
		});
	},
	'throw': function () {
		if (!$Promise) {
			throw new $SyntaxError('This environment does not support Promises.');
		}

		var O = this; // step 1

		SLOT.assert(O, '[[SyncIteratorRecord]]'); // step 2

		var valueIsPresent = arguments.length > 0;
		var value = valueIsPresent ? arguments[0] : void undefined;

		return new $Promise(function (resolve, reject) { // step 3
			var syncIterator = SLOT.get(O, '[[SyncIteratorRecord]]')['[[Iterator]]']; // step 4

			var throwMethod = GetMethod(syncIterator, 'throw'); // step 5

			if (typeof throwMethod === 'undefined') { // step 7
				Call(reject, undefined, [value]); // step 7.a
				return;
			}

			var result;
			if (valueIsPresent) { // step 8
				result = Call(throwMethod, syncIterator, [value]); // step 8.a
			} else { // step 9
				result = Call(throwMethod, syncIterator); // step 9.a
			}
			if (!isObject(result)) { // step 11
				Call(reject, undefined, [new $TypeError('Iterator `throw` method returned a non-object value.')]); // step 11.a
				return;
			}

			resolve(AsyncFromSyncIteratorContinuation(result/* , promiseCapability */)); // step 12
		});
	}
};

// https://262.ecma-international.org/11.0/#sec-createasyncfromsynciterator

module.exports = function CreateAsyncFromSyncIterator(syncIteratorRecord) {
	if (!isIteratorRecord(syncIteratorRecord)) {
		throw new $TypeError('Assertion failed: `syncIteratorRecord` must be an Iterator Record');
	}

	// var asyncIterator = OrdinaryObjectCreate(%AsyncFromSyncIteratorPrototype%, « [[SyncIteratorRecord]] »); // step 1
	var asyncIterator = OrdinaryObjectCreate($AsyncFromSyncIteratorPrototype);

	SLOT.set(asyncIterator, '[[SyncIteratorRecord]]', syncIteratorRecord); // step 2

	var nextMethod = Get(asyncIterator, 'next'); // step 3

	return { // steps 3-4
		'[[Iterator]]': asyncIterator,
		'[[NextMethod]]': nextMethod,
		'[[Done]]': false
	};
};
'use strict';

var $TypeError = require('es-errors/type');
var isObject = require('es-object-atoms/isObject');

var isPropertyKey = require('../helpers/isPropertyKey');
var OrdinaryDefineOwnProperty = require('./OrdinaryDefineOwnProperty');

// https://262.ecma-international.org/6.0/#sec-createdataproperty

module.exports = function CreateDataProperty(O, P, V) {
	if (!isObject(O)) {
		throw new $TypeError('Assertion failed: Type(O) is not Object');
	}
	if (!isPropertyKey(P)) {
		throw new $TypeError('Assertion failed: P is not a Property Key');
	}
	var newDesc = {
		'[[Configurable]]': true,
		'[[Enumerable]]': true,
		'[[Value]]': V,
		'[[Writable]]': true
	};
	return OrdinaryDefineOwnProperty(O, P, newDesc);
};
'use strict';

var $TypeError = require('es-errors/type');
var isObject = require('es-object-atoms/isObject');

var CreateDataProperty = require('./CreateDataProperty');

var isPropertyKey = require('../helpers/isPropertyKey');

// // https://262.ecma-international.org/6.0/#sec-createdatapropertyorthrow

module.exports = function CreateDataPropertyOrThrow(O, P, V) {
	if (!isObject(O)) {
		throw new $TypeError('Assertion failed: Type(O) is not Object');
	}
	if (!isPropertyKey(P)) {
		throw new $TypeError('Assertion failed: P is not a Property Key');
	}
	var success = CreateDataProperty(O, P, V);
	if (!success) {
		throw new $TypeError('unable to create data property');
	}
	return success;
};
'use strict';

var $TypeError = require('es-errors/type');

var callBound = require('call-bound');

var $replace = callBound('String.prototype.replace');

var RequireObjectCoercible = require('./RequireObjectCoercible');
var ToString = require('./ToString');

// https://262.ecma-international.org/6.0/#sec-createhtml

module.exports = function CreateHTML(string, tag, attribute, value) {
	if (typeof tag !== 'string' || typeof attribute !== 'string') {
		throw new $TypeError('Assertion failed: `tag` and `attribute` must be strings');
	}
	var str = RequireObjectCoercible(string);
	var S = ToString(str);
	var p1 = '<' + tag;
	if (attribute !== '') {
		var V = ToString(value);
		var escapedV = $replace(V, /\x22/g, '&quot;');
		p1 += '\x20' + attribute + '\x3D\x22' + escapedV + '\x22';
	}
	return p1 + '>' + S + '</' + tag + '>';
};
'use strict';

var $TypeError = require('es-errors/type');

// https://262.ecma-international.org/6.0/#sec-createiterresultobject

module.exports = function CreateIterResultObject(value, done) {
	if (typeof done !== 'boolean') {
		throw new $TypeError('Assertion failed: Type(done) is not Boolean');
	}
	return {
		value: value,
		done: done
	};
};
'use strict';

var callBound = require('call-bound');

var $TypeError = require('es-errors/type');
var isObject = require('es-object-atoms/isObject');
var $indexOf = callBound('Array.prototype.indexOf', true) || callBound('String.prototype.indexOf');

var Get = require('./Get');
var IsArray = require('./IsArray');
var LengthOfArrayLike = require('./LengthOfArrayLike');
var ToString = require('./ToString');
var Type = require('./Type');

var defaultElementTypes = ['Undefined', 'Null', 'Boolean', 'String', 'Symbol', 'Number', 'BigInt', 'Object'];

// https://262.ecma-international.org/11.0/#sec-createlistfromarraylike

module.exports = function CreateListFromArrayLike(obj) {
	var elementTypes = arguments.length > 1
		? arguments[1]
		: defaultElementTypes;

	if (!isObject(obj)) {
		throw new $TypeError('Assertion failed: `obj` must be an Object');
	}
	if (!IsArray(elementTypes)) {
		throw new $TypeError('Assertion failed: `elementTypes`, if provided, must be an array');
	}
	var len = LengthOfArrayLike(obj);
	var list = [];
	var index = 0;
	while (index < len) {
		var indexName = ToString(index);
		var next = Get(obj, indexName);
		var nextType = Type(next);
		if ($indexOf(elementTypes, nextType) < 0) {
			throw new $TypeError('item type ' + nextType + ' is not a valid elementType');
		}
		list[list.length] = next;
		index += 1;
	}
	return list;
};
'use strict';

var $TypeError = require('es-errors/type');
var isObject = require('es-object-atoms/isObject');

var DefineOwnProperty = require('../helpers/DefineOwnProperty');

var FromPropertyDescriptor = require('./FromPropertyDescriptor');
var IsDataDescriptor = require('./IsDataDescriptor');
var isPropertyKey = require('../helpers/isPropertyKey');
var SameValue = require('./SameValue');

// https://262.ecma-international.org/6.0/#sec-createmethodproperty

module.exports = function CreateMethodProperty(O, P, V) {
	if (!isObject(O)) {
		throw new $TypeError('Assertion failed: Type(O) is not Object');
	}

	if (!isPropertyKey(P)) {
		throw new $TypeError('Assertion failed: P is not a Property Key');
	}

	var newDesc = {
		'[[Configurable]]': true,
		'[[Enumerable]]': false,
		'[[Value]]': V,
		'[[Writable]]': true
	};
	return DefineOwnProperty(
		IsDataDescriptor,
		SameValue,
		FromPropertyDescriptor,
		O,
		P,
		newDesc
	);
};
'use strict';

var GetIntrinsic = require('get-intrinsic');
var hasSymbols = require('has-symbols')();

var $TypeError = require('es-errors/type');
var isObject = require('es-object-atoms/isObject');
var IteratorPrototype = GetIntrinsic('%IteratorPrototype%', true);

var AdvanceStringIndex = require('./AdvanceStringIndex');
var CreateIterResultObject = require('./CreateIterResultObject');
var CreateMethodProperty = require('./CreateMethodProperty');
var Get = require('./Get');
var OrdinaryObjectCreate = require('./OrdinaryObjectCreate');
var RegExpExec = require('./RegExpExec');
var Set = require('./Set');
var ToLength = require('./ToLength');
var ToString = require('./ToString');

var SLOT = require('internal-slot');
var setToStringTag = require('es-set-tostringtag');

var RegExpStringIterator = function RegExpStringIterator(R, S, global, fullUnicode) {
	if (typeof S !== 'string') {
		throw new $TypeError('`S` must be a string');
	}
	if (typeof global !== 'boolean') {
		throw new $TypeError('`global` must be a boolean');
	}
	if (typeof fullUnicode !== 'boolean') {
		throw new $TypeError('`fullUnicode` must be a boolean');
	}
	SLOT.set(this, '[[IteratingRegExp]]', R);
	SLOT.set(this, '[[IteratedString]]', S);
	SLOT.set(this, '[[Global]]', global);
	SLOT.set(this, '[[Unicode]]', fullUnicode);
	SLOT.set(this, '[[Done]]', false);
};

if (IteratorPrototype) {
	RegExpStringIterator.prototype = OrdinaryObjectCreate(IteratorPrototype);
}

var RegExpStringIteratorNext = function next() {
	var O = this; // eslint-disable-line no-invalid-this
	if (!isObject(O)) {
		throw new $TypeError('receiver must be an object');
	}
	if (
		!(O instanceof RegExpStringIterator)
		|| !SLOT.has(O, '[[IteratingRegExp]]')
		|| !SLOT.has(O, '[[IteratedString]]')
		|| !SLOT.has(O, '[[Global]]')
		|| !SLOT.has(O, '[[Unicode]]')
		|| !SLOT.has(O, '[[Done]]')
	) {
		throw new $TypeError('"this" value must be a RegExpStringIterator instance');
	}
	if (SLOT.get(O, '[[Done]]')) {
		return CreateIterResultObject(undefined, true);
	}
	var R = SLOT.get(O, '[[IteratingRegExp]]');
	var S = SLOT.get(O, '[[IteratedString]]');
	var global = SLOT.get(O, '[[Global]]');
	var fullUnicode = SLOT.get(O, '[[Unicode]]');
	var match = RegExpExec(R, S);
	if (match === null) {
		SLOT.set(O, '[[Done]]', true);
		return CreateIterResultObject(undefined, true);
	}
	if (global) {
		var matchStr = ToString(Get(match, '0'));
		if (matchStr === '') {
			var thisIndex = ToLength(Get(R, 'lastIndex'));
			var nextIndex = AdvanceStringIndex(S, thisIndex, fullUnicode);
			Set(R, 'lastIndex', nextIndex, true);
		}
		return CreateIterResultObject(match, false);
	}
	SLOT.set(O, '[[Done]]', true);
	return CreateIterResultObject(match, false);
};
CreateMethodProperty(RegExpStringIterator.prototype, 'next', RegExpStringIteratorNext);

if (hasSymbols) {
	setToStringTag(RegExpStringIterator.prototype, 'RegExp String Iterator');

	if (Symbol.iterator && typeof RegExpStringIterator.prototype[Symbol.iterator] !== 'function') {
		var iteratorFn = function SymbolIterator() {
			return this;
		};
		CreateMethodProperty(RegExpStringIterator.prototype, Symbol.iterator, iteratorFn);
	}
}

// https://262.ecma-international.org/11.0/#sec-createregexpstringiterator
module.exports = function CreateRegExpStringIterator(R, S, global, fullUnicode) {
	// assert R.global === global && R.unicode === fullUnicode?
	return new RegExpStringIterator(R, S, global, fullUnicode);
};
'use strict';

var $EvalError = require('es-errors/eval');

var DayWithinYear = require('./DayWithinYear');
var InLeapYear = require('./InLeapYear');
var MonthFromTime = require('./MonthFromTime');

// https://262.ecma-international.org/5.1/#sec-15.9.1.5

module.exports = function DateFromTime(t) {
	var m = MonthFromTime(t);
	var d = DayWithinYear(t);
	if (m === 0) {
		return d + 1;
	}
	if (m === 1) {
		return d - 30;
	}
	var leap = InLeapYear(t);
	if (m === 2) {
		return d - 58 - leap;
	}
	if (m === 3) {
		return d - 89 - leap;
	}
	if (m === 4) {
		return d - 119 - leap;
	}
	if (m === 5) {
		return d - 150 - leap;
	}
	if (m === 6) {
		return d - 180 - leap;
	}
	if (m === 7) {
		return d - 211 - leap;
	}
	if (m === 8) {
		return d - 242 - leap;
	}
	if (m === 9) {
		return d - 272 - leap;
	}
	if (m === 10) {
		return d - 303 - leap;
	}
	if (m === 11) {
		return d - 333 - leap;
	}
	throw new $EvalError('Assertion failed: MonthFromTime returned an impossible value: ' + m);
};
'use strict';

var $TypeError = require('es-errors/type');

var weekdays = ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'];
var months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];

var $isNaN = require('math-intrinsics/isNaN');
var padTimeComponent = require('../helpers/padTimeComponent');

var DateFromTime = require('./DateFromTime');
var MonthFromTime = require('./MonthFromTime');
var WeekDay = require('./WeekDay');
var YearFromTime = require('./YearFromTime');

// https://262.ecma-international.org/9.0/#sec-datestring

module.exports = function DateString(tv) {
	if (typeof tv !== 'number' || $isNaN(tv)) {
		throw new $TypeError('Assertion failed: `tv` must be a non-NaN Number');
	}
	var weekday = weekdays[WeekDay(tv)];
	var month = months[MonthFromTime(tv)];
	var day = padTimeComponent(DateFromTime(tv));
	var year = padTimeComponent(YearFromTime(tv), 4);
	return weekday + '\x20' + month + '\x20' + day + '\x20' + year;
};
'use strict';

var floor = require('./floor');

// https://262.ecma-international.org/5.1/#sec-15.9.1.3

module.exports = function DayFromYear(y) {
	return (365 * (y - 1970)) + floor((y - 1969) / 4) - floor((y - 1901) / 100) + floor((y - 1601) / 400);
};

'use strict';

var floor = require('./floor');

var msPerDay = require('../helpers/timeConstants').msPerDay;

// https://262.ecma-international.org/5.1/#sec-15.9.1.2

module.exports = function Day(t) {
	return floor(t / msPerDay);
};
'use strict';

var modulo = require('./modulo');

// https://262.ecma-international.org/5.1/#sec-15.9.1.3

module.exports = function DaysInYear(y) {
	if (modulo(y, 4) !== 0) {
		return 365;
	}
	if (modulo(y, 100) !== 0) {
		return 366;
	}
	if (modulo(y, 400) !== 0) {
		return 365;
	}
	return 366;
};
'use strict';

var Day = require('./Day');
var DayFromYear = require('./DayFromYear');
var YearFromTime = require('./YearFromTime');

// https://262.ecma-international.org/5.1/#sec-15.9.1.4

module.exports = function DayWithinYear(t) {
	return Day(t) - DayFromYear(YearFromTime(t));
};
'use strict';

var $TypeError = require('es-errors/type');
var isObject = require('es-object-atoms/isObject');

var isPropertyDescriptor = require('../helpers/records/property-descriptor');
var DefineOwnProperty = require('../helpers/DefineOwnProperty');

var FromPropertyDescriptor = require('./FromPropertyDescriptor');
var IsDataDescriptor = require('./IsDataDescriptor');
var isPropertyKey = require('../helpers/isPropertyKey');
var SameValue = require('./SameValue');
var ToPropertyDescriptor = require('./ToPropertyDescriptor');

// https://262.ecma-international.org/6.0/#sec-definepropertyorthrow

module.exports = function DefinePropertyOrThrow(O, P, desc) {
	if (!isObject(O)) {
		throw new $TypeError('Assertion failed: Type(O) is not Object');
	}

	if (!isPropertyKey(P)) {
		throw new $TypeError('Assertion failed: P is not a Property Key');
	}

	var Desc = isPropertyDescriptor(desc) ? desc : ToPropertyDescriptor(desc);
	if (!isPropertyDescriptor(Desc)) {
		throw new $TypeError('Assertion failed: Desc is not a valid Property Descriptor');
	}

	return DefineOwnProperty(
		IsDataDescriptor,
		SameValue,
		FromPropertyDescriptor,
		O,
		P,
		Desc
	);
};
'use strict';

var $TypeError = require('es-errors/type');
var isObject = require('es-object-atoms/isObject');

var isPropertyKey = require('../helpers/isPropertyKey');

// https://262.ecma-international.org/6.0/#sec-deletepropertyorthrow

module.exports = function DeletePropertyOrThrow(O, P) {
	if (!isObject(O)) {
		throw new $TypeError('Assertion failed: Type(O) is not Object');
	}

	if (!isPropertyKey(P)) {
		throw new $TypeError('Assertion failed: P is not a Property Key');
	}

	// eslint-disable-next-line no-param-reassign
	var success = delete O[P];
	if (!success) {
		throw new $TypeError('Attempt to delete property failed.');
	}
	return success;
};
'use strict';

var $SyntaxError = require('es-errors/syntax');
var $TypeError = require('es-errors/type');

var IsDetachedBuffer = require('./IsDetachedBuffer');

var isArrayBuffer = require('is-array-buffer');
var isSharedArrayBuffer = require('is-shared-array-buffer');

var MessageChannel;
try {
	// eslint-disable-next-line global-require
	MessageChannel = require('worker_threads').MessageChannel;
} catch (e) { /**/ }

// https://262.ecma-international.org/9.0/#sec-detacharraybuffer

/* globals postMessage */

module.exports = function DetachArrayBuffer(arrayBuffer) {
	if (!isArrayBuffer(arrayBuffer) || isSharedArrayBuffer(arrayBuffer)) {
		throw new $TypeError('Assertion failed: `arrayBuffer` must be an Object with an [[ArrayBufferData]] internal slot, and not a Shared Array Buffer');
	}

	// commented out since there's no way to set or access this key
	// var key = arguments.length > 1 ? arguments[1] : void undefined;

	// if (!SameValue(arrayBuffer[[ArrayBufferDetachKey]], key)) {
	// 	throw new $TypeError('Assertion failed: `key` must be the value of the [[ArrayBufferDetachKey]] internal slot of `arrayBuffer`');
	// }

	if (!IsDetachedBuffer(arrayBuffer)) { // node v21.0.0+ throws when you structuredClone a detached buffer
		if (typeof structuredClone === 'function') {
			structuredClone(arrayBuffer, { transfer: [arrayBuffer] });
		} else if (typeof postMessage === 'function') {
			postMessage('', '/', [arrayBuffer]); // TODO: see if this might trigger listeners
		} else if (MessageChannel) {
			(new MessageChannel()).port1.postMessage(null, [arrayBuffer]);
		} else {
			throw new $SyntaxError('DetachArrayBuffer is not supported in this environment');
		}
	}

	return null;
};
'use strict';

var $TypeError = require('es-errors/type');
var isObject = require('es-object-atoms/isObject');

var objectKeys = require('object-keys');
var safePushApply = require('safe-push-apply');
var callBound = require('call-bound');

var $isEnumerable = callBound('Object.prototype.propertyIsEnumerable');

var forEach = require('../helpers/forEach');

// https://262.ecma-international.org/8.0/#sec-enumerableownproperties

module.exports = function EnumerableOwnPropertyNames(O, kind) {
	if (!isObject(O)) {
		throw new $TypeError('Assertion failed: Type(O) is not Object');
	}

	var keys = objectKeys(O);
	if (kind === 'key') {
		return keys;
	}
	if (kind === 'value' || kind === 'key+value') {
		var results = [];
		forEach(keys, function (key) {
			if ($isEnumerable(O, key)) {
				safePushApply(results, [
					kind === 'value' ? O[key] : [key, O[key]]
				]);
			}
		});
		return results;
	}
	throw new $TypeError('Assertion failed: "kind" is not "key", "value", or "key+value": ' + kind);
};
'use strict';

var $TypeError = require('es-errors/type');

var MAX_SAFE_INTEGER = require('math-intrinsics/constants/maxSafeInteger');

var Call = require('./Call');
var CreateDataPropertyOrThrow = require('./CreateDataPropertyOrThrow');
var Get = require('./Get');
var HasProperty = require('./HasProperty');
var IsArray = require('./IsArray');
var LengthOfArrayLike = require('./LengthOfArrayLike');
var ToString = require('./ToString');

// https://262.ecma-international.org/11.0/#sec-flattenintoarray

module.exports = function FlattenIntoArray(target, source, sourceLen, start, depth) {
	var mapperFunction;
	if (arguments.length > 5) {
		mapperFunction = arguments[5];
	}

	var targetIndex = start;
	var sourceIndex = 0;
	while (sourceIndex < sourceLen) {
		var P = ToString(sourceIndex);
		var exists = HasProperty(source, P);
		if (exists === true) {
			var element = Get(source, P);
			if (typeof mapperFunction !== 'undefined') {
				if (arguments.length <= 6) {
					throw new $TypeError('Assertion failed: thisArg is required when mapperFunction is provided');
				}
				element = Call(mapperFunction, arguments[6], [element, sourceIndex, source]);
			}
			var shouldFlatten = false;
			if (depth > 0) {
				shouldFlatten = IsArray(element);
			}
			if (shouldFlatten) {
				var elementLen = LengthOfArrayLike(element);
				targetIndex = FlattenIntoArray(target, element, elementLen, targetIndex, depth - 1);
			} else {
				if (targetIndex >= MAX_SAFE_INTEGER) {
					throw new $TypeError('index too large');
				}
				CreateDataPropertyOrThrow(target, ToString(targetIndex), element);
				targetIndex += 1;
			}
		}
		sourceIndex += 1;
	}

	return targetIndex;
};
'use strict';

// var modulo = require('./modulo');
var $floor = require('math-intrinsics/floor');

// http://262.ecma-international.org/11.0/#eqn-floor

module.exports = function floor(x) {
	// return x - modulo(x, 1);
	if (typeof x === 'bigint') {
		return x;
	}
	return $floor(x);
};
'use strict';

var $TypeError = require('es-errors/type');

var isPropertyDescriptor = require('../helpers/records/property-descriptor');
var fromPropertyDescriptor = require('../helpers/fromPropertyDescriptor');

// https://262.ecma-international.org/6.0/#sec-frompropertydescriptor

module.exports = function FromPropertyDescriptor(Desc) {
	if (typeof Desc !== 'undefined' && !isPropertyDescriptor(Desc)) {
		throw new $TypeError('Assertion failed: `Desc` must be a Property Descriptor');
	}

	return fromPropertyDescriptor(Desc);
};
'use strict';

var getGlobal = require('globalthis/polyfill');

// https://262.ecma-international.org/6.0/#sec-getglobalobject

module.exports = function GetGlobalObject() {
	return getGlobal();
};
'use strict';

var GetIntrinsic = require('get-intrinsic');

var $TypeError = require('es-errors/type');
var $SyntaxError = require('es-errors/syntax');
var isObject = require('es-object-atoms/isObject');
var $asyncIterator = GetIntrinsic('%Symbol.asyncIterator%', true);

var inspect = require('object-inspect');
var hasSymbols = require('has-symbols')();

var getIteratorMethod = require('../helpers/getIteratorMethod');
var AdvanceStringIndex = require('./AdvanceStringIndex');
var Call = require('./Call');
var GetMethod = require('./GetMethod');

var ES = {
	AdvanceStringIndex: AdvanceStringIndex,
	GetMethod: GetMethod
};

// https://262.ecma-international.org/9.0/#sec-getiterator

module.exports = function GetIterator(obj, hint, method) {
	var actualHint = hint;
	if (arguments.length < 2) {
		actualHint = 'sync';
	}
	if (actualHint !== 'sync' && actualHint !== 'async') {
		throw new $TypeError("Assertion failed: `hint` must be one of 'sync' or 'async', got " + inspect(hint));
	}

	var actualMethod = method;
	if (arguments.length < 3) {
		if (actualHint === 'async') {
			if (hasSymbols && $asyncIterator) {
				actualMethod = GetMethod(obj, $asyncIterator);
			}
			if (actualMethod === undefined) {
				throw new $SyntaxError("async from sync iterators aren't currently supported");
			}
		} else {
			actualMethod = getIteratorMethod(ES, obj);
		}
	}
	var iterator = Call(actualMethod, obj);
	if (!isObject(iterator)) {
		throw new $TypeError('iterator must return an object');
	}

	return iterator;

	// TODO: This should return an IteratorRecord
	/*
	var nextMethod = GetV(iterator, 'next');
	return {
		'[[Iterator]]': iterator,
		'[[NextMethod]]': nextMethod,
		'[[Done]]': false
	};
	*/
};
'use strict';

var $TypeError = require('es-errors/type');

var inspect = require('object-inspect');

var isPropertyKey = require('../helpers/isPropertyKey');

var isObject = require('es-object-atoms/isObject');

// https://262.ecma-international.org/6.0/#sec-get-o-p

module.exports = function Get(O, P) {
	// 7.3.1.1
	if (!isObject(O)) {
		throw new $TypeError('Assertion failed: Type(O) is not Object');
	}
	// 7.3.1.2
	if (!isPropertyKey(P)) {
		throw new $TypeError('Assertion failed: P is not a Property Key, got ' + inspect(P));
	}
	// 7.3.1.3
	return O[P];
};
'use strict';

var $TypeError = require('es-errors/type');

var GetV = require('./GetV');
var IsCallable = require('./IsCallable');
var isPropertyKey = require('../helpers/isPropertyKey');

var inspect = require('object-inspect');

// https://262.ecma-international.org/6.0/#sec-getmethod

module.exports = function GetMethod(O, P) {
	// 7.3.9.1
	if (!isPropertyKey(P)) {
		throw new $TypeError('Assertion failed: P is not a Property Key');
	}

	// 7.3.9.2
	var func = GetV(O, P);

	// 7.3.9.4
	if (func == null) {
		return void 0;
	}

	// 7.3.9.5
	if (!IsCallable(func)) {
		throw new $TypeError(inspect(P) + ' is not a function: ' + inspect(func));
	}

	// 7.3.9.6
	return func;
};
'use strict';

var GetIntrinsic = require('get-intrinsic');

var hasSymbols = require('has-symbols')();

var $TypeError = require('es-errors/type');
var isObject = require('es-object-atoms/isObject');

var $gOPN = GetIntrinsic('%Object.getOwnPropertyNames%', true);
var $gOPS = hasSymbols && GetIntrinsic('%Object.getOwnPropertySymbols%', true);
var keys = require('object-keys');

// https://262.ecma-international.org/6.0/#sec-getownpropertykeys

module.exports = function GetOwnPropertyKeys(O, Type) {
	if (!isObject(O)) {
		throw new $TypeError('Assertion failed: Type(O) is not Object');
	}
	if (Type === 'Symbol') {
		return $gOPS ? $gOPS(O) : [];
	}
	if (Type === 'String') {
		if (!$gOPN) {
			return keys(O);
		}
		return $gOPN(O);
	}
	throw new $TypeError('Assertion failed: `Type` must be `"String"` or `"Symbol"`');
};
'use strict';

var $TypeError = require('es-errors/type');

var Get = require('./Get');
var IsCallable = require('./IsCallable');
var IsConstructor = require('./IsConstructor');

// https://262.ecma-international.org/12.0/#sec-getpromiseresolve

module.exports = function GetPromiseResolve(promiseConstructor) {
	if (!IsConstructor(promiseConstructor)) {
		throw new $TypeError('Assertion failed: `promiseConstructor` must be a constructor');
	}
	var promiseResolve = Get(promiseConstructor, 'resolve');
	if (IsCallable(promiseResolve) === false) {
		throw new $TypeError('`resolve` method is not callable');
	}
	return promiseResolve;
};
'use strict';

var GetIntrinsic = require('get-intrinsic');

var $Function = GetIntrinsic('%Function%');
var $TypeError = require('es-errors/type');
var $SyntaxError = require('es-errors/syntax');

var Get = require('./Get');
var IsConstructor = require('./IsConstructor');

var isObject = require('es-object-atoms/isObject');

// https://262.ecma-international.org/6.0/#sec-getprototypefromconstructor

module.exports = function GetPrototypeFromConstructor(constructor, intrinsicDefaultProto) {
	var intrinsic = GetIntrinsic(intrinsicDefaultProto); // throws if not a valid intrinsic
	if (!isObject(intrinsic)) {
		throw new $TypeError('intrinsicDefaultProto must be an object');
	}
	if (!IsConstructor(constructor)) {
		throw new $TypeError('Assertion failed: `constructor` must be a constructor');
	}
	var proto = Get(constructor, 'prototype');
	if (!isObject(proto)) {
		if (!(constructor instanceof $Function)) {
			// ignore other realms, for now
			throw new $SyntaxError('cross-realm constructors not currently supported');
		}
		proto = intrinsic;
	}
	return proto;
};
'use strict';

var $TypeError = require('es-errors/type');

var callBound = require('call-bound');
var regexTester = require('safe-regex-test');
var isInteger = require('math-intrinsics/isInteger');

var $charAt = callBound('String.prototype.charAt');
var $strSlice = callBound('String.prototype.slice');
var $indexOf = callBound('String.prototype.indexOf');
var $parseInt = parseInt;

var isDigit = regexTester(/^[0-9]$/);

var inspect = require('object-inspect');

var Get = require('./Get');
var IsArray = require('./IsArray');
var ToObject = require('./ToObject');
var ToString = require('./ToString');

var every = require('../helpers/every');
var isStringOrUndefined = require('../helpers/isStringOrUndefined');

// http://www.ecma-international.org/ecma-262/12.0/#sec-getsubstitution

// eslint-disable-next-line max-statements, max-params, max-lines-per-function
module.exports = function GetSubstitution(matched, str, position, captures, namedCaptures, replacement) {
	if (typeof matched !== 'string') {
		throw new $TypeError('Assertion failed: `matched` must be a String');
	}
	var matchLength = matched.length;

	if (typeof str !== 'string') {
		throw new $TypeError('Assertion failed: `str` must be a String');
	}
	var stringLength = str.length;

	if (!isInteger(position) || position < 0 || position > stringLength) {
		throw new $TypeError('Assertion failed: `position` must be a nonnegative integer, and less than or equal to the length of `string`, got ' + inspect(position));
	}

	if (!IsArray(captures) || !every(captures, isStringOrUndefined)) {
		throw new $TypeError('Assertion failed: `captures` must be a possibly-empty List of Strings or `undefined`, got ' + inspect(captures));
	}

	if (typeof replacement !== 'string') {
		throw new $TypeError('Assertion failed: `replacement` must be a String');
	}

	var tailPos = position + matchLength;
	var m = captures.length;
	if (typeof namedCaptures !== 'undefined') {
		namedCaptures = ToObject(namedCaptures); // eslint-disable-line no-param-reassign
	}

	var result = '';
	for (var i = 0; i < replacement.length; i += 1) {
		// if this is a $, and it's not the end of the replacement
		var current = $charAt(replacement, i);
		var isLast = (i + 1) >= replacement.length;
		var nextIsLast = (i + 2) >= replacement.length;
		if (current === '$' && !isLast) {
			var next = $charAt(replacement, i + 1);
			if (next === '$') {
				result += '$';
				i += 1;
			} else if (next === '&') {
				result += matched;
				i += 1;
			} else if (next === '`') {
				result += position === 0 ? '' : $strSlice(str, 0, position - 1);
				i += 1;
			} else if (next === "'") {
				result += tailPos >= stringLength ? '' : $strSlice(str, tailPos);
				i += 1;
			} else {
				var nextNext = nextIsLast ? null : $charAt(replacement, i + 2);
				if (isDigit(next) && next !== '0' && (nextIsLast || !isDigit(nextNext))) {
					// $1 through $9, and not followed by a digit
					var n = $parseInt(next, 10);
					// if (n > m, impl-defined)
					result += n <= m && typeof captures[n - 1] === 'undefined' ? '' : captures[n - 1];
					i += 1;
				} else if (isDigit(next) && (nextIsLast || isDigit(nextNext))) {
					// $00 through $99
					var nn = next + nextNext;
					var nnI = $parseInt(nn, 10) - 1;
					// if nn === '00' or nn > m, impl-defined
					result += nn <= m && typeof captures[nnI] === 'undefined' ? '' : captures[nnI];
					i += 2;
				} else if (next === '<') {
					if (typeof namedCaptures === 'undefined') {
						result += '$<';
						i += 2;
					} else {
						var endIndex = $indexOf(replacement, '>', i);
						if (endIndex > -1) {
							var groupName = $strSlice(replacement, i + '$<'.length, endIndex);
							var capture = Get(namedCaptures, groupName);

							if (typeof capture !== 'undefined') {
								result += ToString(capture);
							}
							i += ('<' + groupName + '>').length;
						}
					}
				} else {
					result += '$';
				}
			}
		} else {
			// the final $, or else not a $
			result += $charAt(replacement, i);
		}
	}
	return result;
};
'use strict';

var GetIntrinsic = require('get-intrinsic');

var $SyntaxError = require('es-errors/syntax');
var $TypeError = require('es-errors/type');
var $Uint8Array = GetIntrinsic('%Uint8Array%', true);
var isInteger = require('math-intrinsics/isInteger');

var callBound = require('call-bound');

var $slice = callBound('Array.prototype.slice');

var IsDetachedBuffer = require('./IsDetachedBuffer');
var RawBytesToNumeric = require('./RawBytesToNumeric');

var isArrayBuffer = require('is-array-buffer');
var isSharedArrayBuffer = require('is-shared-array-buffer');
var safeConcat = require('safe-array-concat');

var tableTAO = require('./tables/typed-array-objects');

var defaultEndianness = require('../helpers/defaultEndianness');

// https://262.ecma-international.org/11.0/#sec-getvaluefrombuffer

module.exports = function GetValueFromBuffer(arrayBuffer, byteIndex, type, isTypedArray, order) {
	var isSAB = isSharedArrayBuffer(arrayBuffer);
	if (!isArrayBuffer(arrayBuffer) && !isSAB) {
		throw new $TypeError('Assertion failed: `arrayBuffer` must be an ArrayBuffer or a SharedArrayBuffer');
	}

	if (!isInteger(byteIndex)) {
		throw new $TypeError('Assertion failed: `byteIndex` must be an integer');
	}

	if (typeof type !== 'string' || typeof tableTAO.size['$' + type] !== 'number') {
		throw new $TypeError('Assertion failed: `type` must be one of ' + tableTAO.choices);
	}

	if (typeof isTypedArray !== 'boolean') {
		throw new $TypeError('Assertion failed: `isTypedArray` must be a boolean');
	}

	if (order !== 'SeqCst' && order !== 'Unordered') {
		throw new $TypeError('Assertion failed: `order` must be either `SeqCst` or `Unordered`');
	}

	if (arguments.length > 5 && typeof arguments[5] !== 'boolean') {
		throw new $TypeError('Assertion failed: `isLittleEndian` must be a boolean, if present');
	}

	if (IsDetachedBuffer(arrayBuffer)) {
		throw new $TypeError('Assertion failed: `arrayBuffer` is detached'); // step 1
	}

	// 2. Assert: There are sufficient bytes in arrayBuffer starting at byteIndex to represent a value of type.

	if (byteIndex < 0) {
		throw new $TypeError('Assertion failed: `byteIndex` must be non-negative'); // step 3
	}

	// 4. Let block be arrayBuffer.[[ArrayBufferData]].

	var elementSize = tableTAO.size['$' + type]; // step 5
	if (!elementSize) {
		throw new $TypeError('Assertion failed: `type` must be one of ' + tableTAO.choices);
	}

	var rawValue;
	if (isSAB) { // step 6
		/*
		a. Let execution be the [[CandidateExecution]] field of the surrounding agent's Agent Record.
		b. Let eventList be the [[EventList]] field of the element in execution.[[EventLists]] whose [[AgentSignifier]] is AgentSignifier().
		c. If isTypedArray is true and type is "Int8", "Uint8", "Int16", "Uint16", "Int32", or "Uint32", let noTear be true; otherwise let noTear be false.
		d. Let rawValue be a List of length elementSize of nondeterministically chosen byte values.
		e. NOTE: In implementations, rawValue is the result of a non-atomic or atomic read instruction on the underlying hardware. The nondeterminism is a semantic prescription of the memory model to describe observable behaviour of hardware with weak consistency.
		f. Let readEvent be ReadSharedMemory{ [[Order]]: order, [[NoTear]]: noTear, [[Block]]: block, [[ByteIndex]]: byteIndex, [[ElementSize]]: elementSize }.
		g. Append readEvent to eventList.
		h. Append Chosen Value Record { [[Event]]: readEvent, [[ChosenValue]]: rawValue } to execution.[[ChosenValues]].
		*/
		throw new $SyntaxError('SharedArrayBuffer is not supported by this implementation');
	} else {
		// 7. Let rawValue be a List of elementSize containing, in order, the elementSize sequence of bytes starting with block[byteIndex].
		rawValue = $slice(new $Uint8Array(arrayBuffer, byteIndex), 0, elementSize); // step 6
	}

	// 8. If isLittleEndian is not present, set isLittleEndian to either true or false. The choice is implementation dependent and should be the alternative that is most efficient for the implementation. An implementation must use the same value each time this step is executed and the same value must be used for the corresponding step in the SetValueInBuffer abstract operation.
	var isLittleEndian = arguments.length > 5 ? arguments[5] : defaultEndianness === 'little'; // step 8

	var bytes = isLittleEndian
		? $slice(safeConcat([0, 0, 0, 0, 0, 0, 0, 0], rawValue), -elementSize)
		: $slice(safeConcat(rawValue, [0, 0, 0, 0, 0, 0, 0, 0]), 0, elementSize);

	return RawBytesToNumeric(type, bytes, isLittleEndian);
};
'use strict';

var $TypeError = require('es-errors/type');

var inspect = require('object-inspect');

var isPropertyKey = require('../helpers/isPropertyKey');
// var ToObject = require('./ToObject');

// https://262.ecma-international.org/6.0/#sec-getv

module.exports = function GetV(V, P) {
	// 7.3.2.1
	if (!isPropertyKey(P)) {
		throw new $TypeError('Assertion failed: P is not a Property Key, got ' + inspect(P));
	}

	// 7.3.2.2-3
	// var O = ToObject(V);

	// 7.3.2.4
	return V[P];
};
'use strict';

var $TypeError = require('es-errors/type');

var hasOwn = require('hasown');
var isObject = require('es-object-atoms/isObject');

var isPropertyKey = require('../helpers/isPropertyKey');

// https://262.ecma-international.org/6.0/#sec-hasownproperty

module.exports = function HasOwnProperty(O, P) {
	if (!isObject(O)) {
		throw new $TypeError('Assertion failed: `O` must be an Object');
	}
	if (!isPropertyKey(P)) {
		throw new $TypeError('Assertion failed: `P` must be a Property Key');
	}
	return hasOwn(O, P);
};
'use strict';

var $TypeError = require('es-errors/type');
var isObject = require('es-object-atoms/isObject');

var isPropertyKey = require('../helpers/isPropertyKey');

// https://262.ecma-international.org/6.0/#sec-hasproperty

module.exports = function HasProperty(O, P) {
	if (!isObject(O)) {
		throw new $TypeError('Assertion failed: `O` must be an Object');
	}
	if (!isPropertyKey(P)) {
		throw new $TypeError('Assertion failed: `P` must be a Property Key');
	}
	return P in O;
};
'use strict';

var floor = require('./floor');
var modulo = require('./modulo');

var timeConstants = require('../helpers/timeConstants');
var msPerHour = timeConstants.msPerHour;
var HoursPerDay = timeConstants.HoursPerDay;

// https://262.ecma-international.org/5.1/#sec-15.9.1.10

module.exports = function HourFromTime(t) {
	return modulo(floor(t / msPerHour), HoursPerDay);
};
'use strict';

var $EvalError = require('es-errors/eval');

var DaysInYear = require('./DaysInYear');
var YearFromTime = require('./YearFromTime');

// https://262.ecma-international.org/5.1/#sec-15.9.1.3

module.exports = function InLeapYear(t) {
	var days = DaysInYear(YearFromTime(t));
	if (days === 365) {
		return 0;
	}
	if (days === 366) {
		return 1;
	}
	throw new $EvalError('Assertion failed: there are not 365 or 366 days in a year, got: ' + days);
};
'use strict';

var GetIntrinsic = require('get-intrinsic');

var $TypeError = require('es-errors/type');
var isObject = require('es-object-atoms/isObject');

var $hasInstance = GetIntrinsic('%Symbol.hasInstance%', true);

var Call = require('./Call');
var GetMethod = require('./GetMethod');
var IsCallable = require('./IsCallable');
var OrdinaryHasInstance = require('./OrdinaryHasInstance');
var ToBoolean = require('./ToBoolean');

// https://262.ecma-international.org/6.0/#sec-instanceofoperator

module.exports = function InstanceofOperator(O, C) {
	if (!isObject(O)) {
		throw new $TypeError('Assertion failed: Type(O) is not Object');
	}
	var instOfHandler = $hasInstance ? GetMethod(C, $hasInstance) : void 0;
	if (typeof instOfHandler !== 'undefined') {
		return ToBoolean(Call(instOfHandler, C, [O]));
	}
	if (!IsCallable(C)) {
		throw new $TypeError('`C` is not Callable');
	}
	return OrdinaryHasInstance(C, O);
};
'use strict';

var $TypeError = require('es-errors/type');

var GetValueFromBuffer = require('./GetValueFromBuffer');
var IsValidIntegerIndex = require('./IsValidIntegerIndex');

var typedArrayBuffer = require('typed-array-buffer');
var typedArrayByteOffset = require('typed-array-byte-offset');
var whichTypedArray = require('which-typed-array');

var tableTAO = require('./tables/typed-array-objects');

// https://262.ecma-international.org/12.0/#sec-integerindexedelementget

module.exports = function IntegerIndexedElementGet(O, index) {
	var arrayTypeName = whichTypedArray(O); // step 4
	if (!arrayTypeName) {
		throw new $TypeError('Assertion failed: `O` must be a TypedArray'); // step 1
	}

	if (typeof index !== 'number') {
		throw new $TypeError('Assertion failed: `index` must be a Number');
	}

	if (!IsValidIntegerIndex(O, index)) {
		return void undefined; // step 2
	}

	var offset = typedArrayByteOffset(O); // step 3

	var elementType = tableTAO.name['$' + arrayTypeName]; // step 7

	var elementSize = tableTAO.size['$' + elementType]; // step 5

	var indexedPosition = (index * elementSize) + offset; // step 6

	return GetValueFromBuffer(typedArrayBuffer(O), indexedPosition, elementType, true, 'Unordered'); // step 11
};
'use strict';

var $TypeError = require('es-errors/type');

var IsValidIntegerIndex = require('./IsValidIntegerIndex');
var SetValueInBuffer = require('./SetValueInBuffer');
var ToBigInt = require('./ToBigInt');
var ToNumber = require('./ToNumber');

var typedArrayBuffer = require('typed-array-buffer');
var typedArrayByteOffset = require('typed-array-byte-offset');
var whichTypedArray = require('which-typed-array');

var tableTAO = require('./tables/typed-array-objects');

// https://262.ecma-international.org/12.0/#sec-integerindexedelementset

module.exports = function IntegerIndexedElementSet(O, index, value) {
	if (typeof index !== 'number') {
		throw new $TypeError('Assertion failed: `index` must be a Number');
	}

	var arrayTypeName = whichTypedArray(O); // step 4.b
	if (!arrayTypeName) {
		throw new $TypeError('Assertion failed: `O` must be a TypedArray'); // step 1
	}

	var contentType = arrayTypeName === 'BigInt64Array' || arrayTypeName === 'BigUint64Array' ? 'BigInt' : 'Number';
	var numValue = contentType === 'BigInt' ? ToBigInt(value) : ToNumber(value); // steps 2 - 3

	if (IsValidIntegerIndex(O, index)) { // step 4
		var offset = typedArrayByteOffset(O); // step 4.a

		var elementType = tableTAO.name['$' + arrayTypeName]; // step 4.e

		var elementSize = tableTAO.size['$' + elementType]; // step 4.c

		var indexedPosition = (index * elementSize) + offset; // step 4.d

		SetValueInBuffer(typedArrayBuffer(O), indexedPosition, elementType, numValue, true, 'Unordered'); // step 4.e
	}

	// 5. Return NormalCompletion(undefined)
};
'use strict';

var $TypeError = require('es-errors/type');
var isObject = require('es-object-atoms/isObject');

var Call = require('./Call');
var CreateDataProperty = require('./CreateDataProperty');
var EnumerableOwnPropertyNames = require('./EnumerableOwnPropertyNames');
var Get = require('./Get');
var IsArray = require('./IsArray');
var LengthOfArrayLike = require('./LengthOfArrayLike');
var ToString = require('./ToString');

var forEach = require('../helpers/forEach');

// https://262.ecma-international.org/11.0/#sec-internalizejsonproperty

module.exports = function InternalizeJSONProperty(holder, name, reviver) {
	if (!isObject(holder)) {
		throw new $TypeError('Assertion failed: `holder` is not an Object');
	}
	if (typeof name !== 'string') {
		throw new $TypeError('Assertion failed: `name` is not a String');
	}
	if (typeof reviver !== 'function') {
		throw new $TypeError('Assertion failed: `reviver` is not a Function');
	}

	var val = Get(holder, name); // step 1

	if (isObject(val)) { // step 2
		var isArray = IsArray(val); // step 2.a
		if (isArray) { // step 2.b
			var I = 0; // step 2.b.i

			var len = LengthOfArrayLike(val, 'length'); // step 2.b.ii

			while (I < len) { // step 2.b.iii
				var newElement = InternalizeJSONProperty(val, ToString(I), reviver); // step 2.b.iv.1

				if (typeof newElement === 'undefined') { // step 2.b.iii.2
					delete val[ToString(I)]; // step 2.b.iii.2.a
				} else { // step 2.b.iii.3
					CreateDataProperty(val, ToString(I), newElement); // step 2.b.iii.3.a
				}

				I += 1; // step 2.b.iii.4
			}
		} else { // step 2.c
			var keys = EnumerableOwnPropertyNames(val, 'key'); // step 2.c.i

			forEach(keys, function (P) { // step 2.c.ii
				// eslint-disable-next-line no-shadow
				var newElement = InternalizeJSONProperty(val, P, reviver); // step 2.c.ii.1

				if (typeof newElement === 'undefined') { // step 2.c.ii.2
					delete val[P]; // step 2.c.ii.2.a
				} else { // step 2.c.ii.3
					CreateDataProperty(val, P, newElement); // step 2.c.ii.3.a
				}
			});
		}
	}

	return Call(reviver, holder, [name, val]); // step 3
};
'use strict';

var $TypeError = require('es-errors/type');

var Call = require('./Call');
var IsArray = require('./IsArray');
var GetV = require('./GetV');
var isPropertyKey = require('../helpers/isPropertyKey');

// https://262.ecma-international.org/6.0/#sec-invoke

module.exports = function Invoke(O, P) {
	if (!isPropertyKey(P)) {
		throw new $TypeError('Assertion failed: P must be a Property Key');
	}
	var argumentsList = arguments.length > 2 ? arguments[2] : [];
	if (!IsArray(argumentsList)) {
		throw new $TypeError('Assertion failed: optional `argumentsList`, if provided, must be a List');
	}
	var func = GetV(O, P);
	return Call(func, O, argumentsList);
};
'use strict';

var $TypeError = require('es-errors/type');

var hasOwn = require('hasown');

var isPropertyDescriptor = require('../helpers/records/property-descriptor');

// https://262.ecma-international.org/5.1/#sec-8.10.1

module.exports = function IsAccessorDescriptor(Desc) {
	if (typeof Desc === 'undefined') {
		return false;
	}

	if (!isPropertyDescriptor(Desc)) {
		throw new $TypeError('Assertion failed: `Desc` must be a Property Descriptor');
	}

	if (!hasOwn(Desc, '[[Get]]') && !hasOwn(Desc, '[[Set]]')) {
		return false;
	}

	return true;
};
'use strict';

// https://262.ecma-international.org/6.0/#sec-isarray
module.exports = require('../helpers/IsArray');
'use strict';

// https://262.ecma-international.org/11.0/#sec-isbigintelementtype

module.exports = function IsBigIntElementType(type) {
	return type === 'BigUint64' || type === 'BigInt64';
};
'use strict';

// http://262.ecma-international.org/5.1/#sec-9.11

module.exports = require('is-callable');
'use strict';

var ValidateAndApplyPropertyDescriptor = require('./ValidateAndApplyPropertyDescriptor');

// https://262.ecma-international.org/6.0/#sec-iscompatiblepropertydescriptor

module.exports = function IsCompatiblePropertyDescriptor(Extensible, Desc, Current) {
	return ValidateAndApplyPropertyDescriptor(undefined, undefined, Extensible, Desc, Current);
};
'use strict';

var GetIntrinsic = require('get-intrinsic');

var $isConcatSpreadable = GetIntrinsic('%Symbol.isConcatSpreadable%', true);

var Get = require('./Get');
var IsArray = require('./IsArray');
var ToBoolean = require('./ToBoolean');

var isObject = require('es-object-atoms/isObject');

// https://262.ecma-international.org/6.0/#sec-isconcatspreadable

module.exports = function IsConcatSpreadable(O) {
	if (!isObject(O)) {
		return false;
	}
	if ($isConcatSpreadable) {
		var spreadable = Get(O, $isConcatSpreadable);
		if (typeof spreadable !== 'undefined') {
			return ToBoolean(spreadable);
		}
	}
	return IsArray(O);
};
'use strict';

var GetIntrinsic = require('../GetIntrinsic.js');

var $construct = GetIntrinsic('%Reflect.construct%', true);

var DefinePropertyOrThrow = require('./DefinePropertyOrThrow');
try {
	DefinePropertyOrThrow({}, '', { '[[Get]]': function () {} });
} catch (e) {
	// Accessor properties aren't supported
	DefinePropertyOrThrow = null;
}

// https://262.ecma-international.org/6.0/#sec-isconstructor

if (DefinePropertyOrThrow && $construct) {
	var isConstructorMarker = {};
	var badArrayLike = {};
	DefinePropertyOrThrow(badArrayLike, 'length', {
		'[[Get]]': function () {
			throw isConstructorMarker;
		},
		'[[Enumerable]]': true
	});

	module.exports = function IsConstructor(argument) {
		try {
			// `Reflect.construct` invokes `IsConstructor(target)` before `Get(args, 'length')`:
			$construct(argument, badArrayLike);
		} catch (err) {
			return err === isConstructorMarker;
		}
	};
} else {
	module.exports = function IsConstructor(argument) {
		// unfortunately there's no way to truly check this without try/catch `new argument` in old environments
		return typeof argument === 'function' && !!argument.prototype;
	};
}
'use strict';

var $TypeError = require('es-errors/type');

var hasOwn = require('hasown');

var isPropertyDescriptor = require('../helpers/records/property-descriptor');

// https://262.ecma-international.org/5.1/#sec-8.10.2

module.exports = function IsDataDescriptor(Desc) {
	if (typeof Desc === 'undefined') {
		return false;
	}

	if (!isPropertyDescriptor(Desc)) {
		throw new $TypeError('Assertion failed: `Desc` must be a Property Descriptor');
	}

	if (!hasOwn(Desc, '[[Value]]') && !hasOwn(Desc, '[[Writable]]')) {
		return false;
	}

	return true;
};
'use strict';

var $TypeError = require('es-errors/type');

var $byteLength = require('array-buffer-byte-length');
var availableTypedArrays = require('available-typed-arrays')();
var callBound = require('call-bound');
var isArrayBuffer = require('is-array-buffer');
var isSharedArrayBuffer = require('is-shared-array-buffer');

var $sabByteLength = callBound('SharedArrayBuffer.prototype.byteLength', true);

// https://262.ecma-international.org/8.0/#sec-isdetachedbuffer

module.exports = function IsDetachedBuffer(arrayBuffer) {
	var isSAB = isSharedArrayBuffer(arrayBuffer);
	if (!isArrayBuffer(arrayBuffer) && !isSAB) {
		throw new $TypeError('Assertion failed: `arrayBuffer` must be an Object with an [[ArrayBufferData]] internal slot');
	}
	if ((isSAB ? $sabByteLength : $byteLength)(arrayBuffer) === 0) {
		try {
			new global[availableTypedArrays[0]](arrayBuffer); // eslint-disable-line no-new
		} catch (error) {
			return !!error && error.name === 'TypeError';
		}
	}
	return false;
};
'use strict';

var GetIntrinsic = require('get-intrinsic');

var $preventExtensions = GetIntrinsic('%Object.preventExtensions%', true);
var $isExtensible = GetIntrinsic('%Object.isExtensible%', true);

var isPrimitive = require('../helpers/isPrimitive');

// https://262.ecma-international.org/6.0/#sec-isextensible-o

module.exports = $preventExtensions
	? function IsExtensible(obj) {
		return !isPrimitive(obj) && $isExtensible(obj);
	}
	: function IsExtensible(obj) {
		return !isPrimitive(obj);
	};
'use strict';

var $TypeError = require('es-errors/type');

var IsAccessorDescriptor = require('./IsAccessorDescriptor');
var IsDataDescriptor = require('./IsDataDescriptor');

var isPropertyDescriptor = require('../helpers/records/property-descriptor');

// https://262.ecma-international.org/6.0/#sec-isgenericdescriptor

module.exports = function IsGenericDescriptor(Desc) {
	if (typeof Desc === 'undefined') {
		return false;
	}

	if (!isPropertyDescriptor(Desc)) {
		throw new $TypeError('Assertion failed: `Desc` must be a Property Descriptor');
	}

	if (!IsAccessorDescriptor(Desc) && !IsDataDescriptor(Desc)) {
		return true;
	}

	return false;
};
'use strict';

var isInteger = require('math-intrinsics/isInteger');

// https://262.ecma-international.org/12.0/#sec-isinteger

module.exports = function IsIntegralNumber(argument) {
	return isInteger(argument);
};
'use strict';

var IsUnclampedIntegerElementType = require('./IsUnclampedIntegerElementType');
var IsBigIntElementType = require('./IsBigIntElementType');

// https://262.ecma-international.org/11.0/#sec-isnotearconfiguration

module.exports = function IsNoTearConfiguration(type, order) {
	if (IsUnclampedIntegerElementType(type)) {
		return true;
	}
	if (IsBigIntElementType(type) && order !== 'Init' && order !== 'Unordered') {
		return true;
	}
	return false;
};
'use strict';

var callBound = require('call-bound');

var $PromiseThen = callBound('Promise.prototype.then', true);

var isObject = require('es-object-atoms/isObject');

// https://262.ecma-international.org/6.0/#sec-ispromise

module.exports = function IsPromise(x) {
	if (!isObject(x)) {
		return false;
	}
	if (!$PromiseThen) { // Promises are not supported
		return false;
	}
	try {
		$PromiseThen(x); // throws if not a promise
	} catch (e) {
		return false;
	}
	return true;
};
'use strict';

var isPropertyKey = require('../helpers/isPropertyKey');

// https://262.ecma-international.org/6.0/#sec-ispropertykey

module.exports = function IsPropertyKey(argument) {
	return isPropertyKey(argument);
};
'use strict';

var GetIntrinsic = require('get-intrinsic');

var $match = GetIntrinsic('%Symbol.match%', true);

var hasRegExpMatcher = require('is-regex');
var isObject = require('es-object-atoms/isObject');

var ToBoolean = require('./ToBoolean');

// https://262.ecma-international.org/6.0/#sec-isregexp

module.exports = function IsRegExp(argument) {
	if (!isObject(argument)) {
		return false;
	}
	if ($match) {
		var isRegExp = argument[$match];
		if (typeof isRegExp !== 'undefined') {
			return ToBoolean(isRegExp);
		}
	}
	return hasRegExpMatcher(argument);
};
'use strict';

var $TypeError = require('es-errors/type');
var isObject = require('es-object-atoms/isObject');

var isSharedArrayBuffer = require('is-shared-array-buffer');

// https://262.ecma-international.org/8.0/#sec-issharedarraybuffer

module.exports = function IsSharedArrayBuffer(obj) {
	if (!isObject(obj)) {
		throw new $TypeError('Assertion failed: Type(O) is not Object');
	}

	return isSharedArrayBuffer(obj);
};
'use strict';

var $TypeError = require('es-errors/type');

var isPrefixOf = require('../helpers/isPrefixOf');

// var callBound = require('call-bound');

// var $charAt = callBound('String.prototype.charAt');

// https://262.ecma-international.org/9.0/#sec-isstringprefix

module.exports = function IsStringPrefix(p, q) {
	if (typeof p !== 'string') {
		throw new $TypeError('Assertion failed: "p" must be a String');
	}

	if (typeof q !== 'string') {
		throw new $TypeError('Assertion failed: "q" must be a String');
	}

	return isPrefixOf(p, q);
	/*
	if (p === q || p === '') {
		return true;
	}

	var pLength = p.length;
	var qLength = q.length;
	if (pLength >= qLength) {
		return false;
	}

	// assert: pLength < qLength

	for (var i = 0; i < pLength; i += 1) {
		if ($charAt(p, i) !== $charAt(q, i)) {
			return false;
		}
	}
	return true;
	*/
};
'use strict';

// https://262.ecma-international.org/11.0/#sec-isunclampedintegerelementtype

module.exports = function IsUnclampedIntegerElementType(type) {
	return type === 'Int8'
		|| type === 'Uint8'
		|| type === 'Int16'
		|| type === 'Uint16'
		|| type === 'Int32'
		|| type === 'Uint32';
};
'use strict';

// https://262.ecma-international.org/11.0/#sec-isunsignedelementtype

module.exports = function IsUnsignedElementType(type) {
	return type === 'Uint8'
		|| type === 'Uint8C'
		|| type === 'Uint16'
		|| type === 'Uint32'
		|| type === 'BigUint64';
};
'use strict';

var $TypeError = require('es-errors/type');
var isNegativeZero = require('math-intrinsics/isNegativeZero');

var IsDetachedBuffer = require('./IsDetachedBuffer');

var isInteger = require('math-intrinsics/isInteger');
var typedArrayBuffer = require('typed-array-buffer');

// https://262.ecma-international.org/12.0/#sec-isvalidintegerindex

module.exports = function IsValidIntegerIndex(O, index) {
	// Assert: O is an Integer-Indexed exotic object.
	var buffer = typedArrayBuffer(O); // step 1

	if (typeof index !== 'number') {
		throw new $TypeError('Assertion failed: Type(index) is not Number');
	}

	if (IsDetachedBuffer(buffer)) { return false; } // step 2

	if (!isInteger(index)) { return false; } // step 3

	if (isNegativeZero(index)) { return false; } // step 4

	if (index < 0 || index >= O.length) { return false; } // step 5

	return true; // step 6
};
'use strict';

var $TypeError = require('es-errors/type');

var callBound = require('call-bound');

var $indexOf = callBound('String.prototype.indexOf');

var IsArray = require('./IsArray');
var WordCharacters = require('./WordCharacters');

var every = require('../helpers/every');

var isInteger = require('math-intrinsics/isInteger');

var isChar = function isChar(c) {
	return typeof c === 'string';
};

// https://262.ecma-international.org/12.0/#sec-runtime-semantics-iswordchar-abstract-operation

// note: prior to ES2023, this AO erroneously omitted the latter of its arguments.
module.exports = function IsWordChar(e, InputLength, Input, IgnoreCase, Unicode) {
	if (!isInteger(e)) {
		throw new $TypeError('Assertion failed: `e` must be an integer');
	}
	if (!isInteger(InputLength)) {
		throw new $TypeError('Assertion failed: `InputLength` must be an integer');
	}
	if (!IsArray(Input) || !every(Input, isChar)) {
		throw new $TypeError('Assertion failed: `Input` must be a List of characters');
	}
	if (typeof IgnoreCase !== 'boolean' || typeof Unicode !== 'boolean') {
		throw new $TypeError('Assertion failed: `IgnoreCase` and `Unicode` must be booleans');
	}

	if (e === -1 || e === InputLength) {
		return false; // step 1
	}

	var c = Input[e]; // step 2

	var wordChars = WordCharacters(IgnoreCase, Unicode);

	return $indexOf(wordChars, c) > -1; // steps 3-4
};
'use strict';

var GetIterator = require('./GetIterator');
var IteratorStep = require('./IteratorStep');
var IteratorValue = require('./IteratorValue');

// https://262.ecma-international.org/12.0/#sec-iterabletolist

module.exports = function IterableToList(items) {
	var iterator;
	if (arguments.length > 1) {
		iterator = GetIterator(items, 'sync', arguments[1]);
	} else {
		iterator = GetIterator(items, 'sync');
	}
	var values = [];
	var next = true;
	while (next) {
		next = IteratorStep(iterator);
		if (next) {
			var nextValue = IteratorValue(next);
			values[values.length] = nextValue;
		}
	}
	return values;
};
'use strict';

var $TypeError = require('es-errors/type');
var isObject = require('es-object-atoms/isObject');

var Call = require('./Call');
var CompletionRecord = require('./CompletionRecord');
var GetMethod = require('./GetMethod');
var IsCallable = require('./IsCallable');

// https://262.ecma-international.org/6.0/#sec-iteratorclose

module.exports = function IteratorClose(iterator, completion) {
	if (!isObject(iterator)) {
		throw new $TypeError('Assertion failed: Type(iterator) is not Object');
	}
	if (!IsCallable(completion) && !(completion instanceof CompletionRecord)) {
		throw new $TypeError('Assertion failed: completion is not a thunk representing a Completion Record, nor a Completion Record instance');
	}
	var completionThunk = completion instanceof CompletionRecord ? function () { return completion['?'](); } : completion;

	var iteratorReturn = GetMethod(iterator, 'return');

	if (typeof iteratorReturn === 'undefined') {
		return completionThunk();
	}

	var completionRecord;
	try {
		var innerResult = Call(iteratorReturn, iterator, []);
	} catch (e) {
		// if we hit here, then "e" is the innerResult completion that needs re-throwing

		// if the completion is of type "throw", this will throw.
		completionThunk();
		completionThunk = null; // ensure it's not called twice.

		// if not, then return the innerResult completion
		throw e;
	}
	completionRecord = completionThunk(); // if innerResult worked, then throw if the completion does
	completionThunk = null; // ensure it's not called twice.

	if (!isObject(innerResult)) {
		throw new $TypeError('iterator .return must return an object');
	}

	return completionRecord;
};
'use strict';

var $TypeError = require('es-errors/type');
var isObject = require('es-object-atoms/isObject');

var Get = require('./Get');
var ToBoolean = require('./ToBoolean');

// https://262.ecma-international.org/6.0/#sec-iteratorcomplete

module.exports = function IteratorComplete(iterResult) {
	if (!isObject(iterResult)) {
		throw new $TypeError('Assertion failed: Type(iterResult) is not Object');
	}
	return ToBoolean(Get(iterResult, 'done'));
};
'use strict';

var $TypeError = require('es-errors/type');
var isObject = require('es-object-atoms/isObject');

var Invoke = require('./Invoke');

// https://262.ecma-international.org/6.0/#sec-iteratornext

module.exports = function IteratorNext(iterator, value) {
	var result = Invoke(iterator, 'next', arguments.length < 2 ? [] : [value]);
	if (!isObject(result)) {
		throw new $TypeError('iterator next must return an object');
	}
	return result;
};
'use strict';

var IteratorComplete = require('./IteratorComplete');
var IteratorNext = require('./IteratorNext');

// https://262.ecma-international.org/6.0/#sec-iteratorstep

module.exports = function IteratorStep(iterator) {
	var result = IteratorNext(iterator);
	var done = IteratorComplete(result);
	return done === true ? false : result;
};

'use strict';

var $TypeError = require('es-errors/type');
var isObject = require('es-object-atoms/isObject');

var Get = require('./Get');

// https://262.ecma-international.org/6.0/#sec-iteratorvalue

module.exports = function IteratorValue(iterResult) {
	if (!isObject(iterResult)) {
		throw new $TypeError('Assertion failed: Type(iterResult) is not Object');
	}
	return Get(iterResult, 'value');
};

'use strict';

var $TypeError = require('es-errors/type');
var isObject = require('es-object-atoms/isObject');

var Get = require('./Get');
var ToLength = require('./ToLength');

// https://262.ecma-international.org/11.0/#sec-lengthofarraylike

module.exports = function LengthOfArrayLike(obj) {
	if (!isObject(obj)) {
		throw new $TypeError('Assertion failed: `obj` must be an Object');
	}
	return ToLength(Get(obj, 'length'));
};

// TODO: use this all over
'use strict';

var $isFinite = require('math-intrinsics/isFinite');

var msPerDay = require('../helpers/timeConstants').msPerDay;

// https://262.ecma-international.org/5.1/#sec-15.9.1.13

module.exports = function MakeDate(day, time) {
	if (!$isFinite(day) || !$isFinite(time)) {
		return NaN;
	}
	return (day * msPerDay) + time;
};
'use strict';

var GetIntrinsic = require('get-intrinsic');

var $DateUTC = GetIntrinsic('%Date.UTC%');

var $isFinite = require('math-intrinsics/isFinite');

var DateFromTime = require('./DateFromTime');
var Day = require('./Day');
var floor = require('./floor');
var modulo = require('./modulo');
var MonthFromTime = require('./MonthFromTime');
var ToIntegerOrInfinity = require('./ToIntegerOrInfinity');
var YearFromTime = require('./YearFromTime');

// https://262.ecma-international.org/5.1/#sec-15.9.1.12

module.exports = function MakeDay(year, month, date) {
	if (!$isFinite(year) || !$isFinite(month) || !$isFinite(date)) {
		return NaN;
	}
	var y = ToIntegerOrInfinity(year);
	var m = ToIntegerOrInfinity(month);
	var dt = ToIntegerOrInfinity(date);
	var ym = y + floor(m / 12);
	if (!$isFinite(ym)) {
		return NaN;
	}
	var mn = modulo(m, 12);
	var t = $DateUTC(ym, mn, 1);
	if (YearFromTime(t) !== ym || MonthFromTime(t) !== mn || DateFromTime(t) !== 1) {
		return NaN;
	}
	return Day(t) + dt - 1;
};
'use strict';

var $isFinite = require('math-intrinsics/isFinite');
var timeConstants = require('../helpers/timeConstants');
var msPerSecond = timeConstants.msPerSecond;
var msPerMinute = timeConstants.msPerMinute;
var msPerHour = timeConstants.msPerHour;

var ToIntegerOrInfinity = require('./ToIntegerOrInfinity');

// https://262.ecma-international.org/12.0/#sec-maketime

module.exports = function MakeTime(hour, min, sec, ms) {
	if (!$isFinite(hour) || !$isFinite(min) || !$isFinite(sec) || !$isFinite(ms)) {
		return NaN;
	}
	var h = ToIntegerOrInfinity(hour);
	var m = ToIntegerOrInfinity(min);
	var s = ToIntegerOrInfinity(sec);
	var milli = ToIntegerOrInfinity(ms);
	var t = (h * msPerHour) + (m * msPerMinute) + (s * msPerSecond) + milli;
	return t;
};
'use strict';

// https://262.ecma-international.org/6.0/#sec-algorithm-conventions

module.exports = require('math-intrinsics/max');
'use strict';

var floor = require('./floor');
var modulo = require('./modulo');

var timeConstants = require('../helpers/timeConstants');
var msPerMinute = timeConstants.msPerMinute;
var MinutesPerHour = timeConstants.MinutesPerHour;

// https://262.ecma-international.org/5.1/#sec-15.9.1.10

module.exports = function MinFromTime(t) {
	return modulo(floor(t / msPerMinute), MinutesPerHour);
};
'use strict';

// https://262.ecma-international.org/6.0/#sec-algorithm-conventions

module.exports = require('math-intrinsics/min');
'use strict';

var mod = require('../helpers/mod');

// https://262.ecma-international.org/5.1/#sec-5.2

module.exports = function modulo(x, y) {
	return mod(x, y);
};
'use strict';

var $RangeError = require('es-errors/range');

var DayWithinYear = require('./DayWithinYear');
var InLeapYear = require('./InLeapYear');

// https://262.ecma-international.org/5.1/#sec-15.9.1.4

module.exports = function MonthFromTime(t) {
	var day = DayWithinYear(t);
	if (0 <= day && day < 31) {
		return 0;
	}
	var leap = InLeapYear(t);
	if (31 <= day && day < (59 + leap)) {
		return 1;
	}
	if ((59 + leap) <= day && day < (90 + leap)) {
		return 2;
	}
	if ((90 + leap) <= day && day < (120 + leap)) {
		return 3;
	}
	if ((120 + leap) <= day && day < (151 + leap)) {
		return 4;
	}
	if ((151 + leap) <= day && day < (181 + leap)) {
		return 5;
	}
	if ((181 + leap) <= day && day < (212 + leap)) {
		return 6;
	}
	if ((212 + leap) <= day && day < (243 + leap)) {
		return 7;
	}
	if ((243 + leap) <= day && day < (273 + leap)) {
		return 8;
	}
	if ((273 + leap) <= day && day < (304 + leap)) {
		return 9;
	}
	if ((304 + leap) <= day && day < (334 + leap)) {
		return 10;
	}
	if ((334 + leap) <= day && day < (365 + leap)) {
		return 11;
	}

	throw new $RangeError('Assertion failed: `day` is out of range');
};
'use strict';

var modulo = require('./modulo');

var msPerSecond = require('../helpers/timeConstants').msPerSecond;

// https://262.ecma-international.org/5.1/#sec-15.9.1.10

module.exports = function msFromTime(t) {
	return modulo(t, msPerSecond);
};
'use strict';

var $TypeError = require('es-errors/type');

var IsCallable = require('./IsCallable');
var IsConstructor = require('./IsConstructor');

// https://262.ecma-international.org/6.0/#sec-newpromisecapability

module.exports = function NewPromiseCapability(C) {
	if (!IsConstructor(C)) {
		throw new $TypeError('C must be a constructor'); // step 1
	}

	var resolvingFunctions = { '[[Resolve]]': void undefined, '[[Reject]]': void undefined }; // step 3

	var promise = new C(function (resolve, reject) { // steps 4-5
		if (typeof resolvingFunctions['[[Resolve]]'] !== 'undefined' || typeof resolvingFunctions['[[Reject]]'] !== 'undefined') {
			throw new $TypeError('executor has already been called'); // step 4.a, 4.b
		}
		resolvingFunctions['[[Resolve]]'] = resolve; // step 4.c
		resolvingFunctions['[[Reject]]'] = reject; // step 4.d
	}); // step 4-6

	if (!IsCallable(resolvingFunctions['[[Resolve]]']) || !IsCallable(resolvingFunctions['[[Reject]]'])) {
		throw new $TypeError('executor must provide valid resolve and reject functions'); // steps 7-8
	}

	return {
		'[[Promise]]': promise,
		'[[Resolve]]': resolvingFunctions['[[Resolve]]'],
		'[[Reject]]': resolvingFunctions['[[Reject]]']
	}; // step 9
};
'use strict';

var CompletionRecord = require('./CompletionRecord');

// https://262.ecma-international.org/6.0/#sec-normalcompletion

module.exports = function NormalCompletion(value) {
	return new CompletionRecord('normal', value);
};
'use strict';

var $TypeError = require('es-errors/type');

var ToInt32 = require('./ToInt32');
var ToUint32 = require('./ToUint32');

// https://262.ecma-international.org/11.0/#sec-numberbitwiseop

module.exports = function NumberBitwiseOp(op, x, y) {
	if (op !== '&' && op !== '|' && op !== '^') {
		throw new $TypeError('Assertion failed: `op` must be `&`, `|`, or `^`');
	}
	if (typeof x !== 'number' || typeof y !== 'number') {
		throw new $TypeError('Assertion failed: `x` and `y` arguments must be Numbers');
	}
	var lnum = ToInt32(x);
	var rnum = ToUint32(y);
	if (op === '&') {
		return lnum & rnum;
	}
	if (op === '|') {
		return lnum | rnum;
	}
	return lnum ^ rnum;
};
'use strict';

var GetIntrinsic = require('get-intrinsic');

var $BigInt = GetIntrinsic('%BigInt%', true);
var $RangeError = require('es-errors/range');
var $SyntaxError = require('es-errors/syntax');
var $TypeError = require('es-errors/type');

var isInteger = require('math-intrinsics/isInteger');

// https://262.ecma-international.org/12.0/#sec-numbertobigint

module.exports = function NumberToBigInt(number) {
	if (typeof number !== 'number') {
		throw new $TypeError('Assertion failed: `number` must be a String');
	}
	if (!isInteger(number)) {
		throw new $RangeError('The number ' + number + ' cannot be converted to a BigInt because it is not an integer');
	}
	if (!$BigInt) {
		throw new $SyntaxError('BigInts are not supported in this environment');
	}
	return $BigInt(number);
};
'use strict';

var $TypeError = require('es-errors/type');

var hasOwnProperty = require('./HasOwnProperty');
var ToBigInt64 = require('./ToBigInt64');
var ToBigUint64 = require('./ToBigUint64');
var ToInt16 = require('./ToInt16');
var ToInt32 = require('./ToInt32');
var ToInt8 = require('./ToInt8');
var ToUint16 = require('./ToUint16');
var ToUint32 = require('./ToUint32');
var ToUint8 = require('./ToUint8');
var ToUint8Clamp = require('./ToUint8Clamp');

var valueToFloat32Bytes = require('../helpers/valueToFloat32Bytes');
var valueToFloat64Bytes = require('../helpers/valueToFloat64Bytes');
var integerToNBytes = require('../helpers/integerToNBytes');

var tableTAO = require('./tables/typed-array-objects');

// https://262.ecma-international.org/11.0/#table-the-typedarray-constructors
var TypeToAO = {
	__proto__: null,
	$Int8: ToInt8,
	$Uint8: ToUint8,
	$Uint8C: ToUint8Clamp,
	$Int16: ToInt16,
	$Uint16: ToUint16,
	$Int32: ToInt32,
	$Uint32: ToUint32,
	$BigInt64: ToBigInt64,
	$BigUint64: ToBigUint64
};

// https://262.ecma-international.org/11.0/#sec-numerictorawbytes

module.exports = function NumericToRawBytes(type, value, isLittleEndian) {
	if (typeof type !== 'string' || !hasOwnProperty(tableTAO.size, '$' + type)) {
		throw new $TypeError('Assertion failed: `type` must be a TypedArray element type');
	}
	if (typeof value !== 'number' && typeof value !== 'bigint') {
		throw new $TypeError('Assertion failed: `value` must be a Number or a BigInt');
	}
	if (typeof isLittleEndian !== 'boolean') {
		throw new $TypeError('Assertion failed: `isLittleEndian` must be a Boolean');
	}

	if (type === 'Float32') { // step 1
		return valueToFloat32Bytes(value, isLittleEndian);
	} else if (type === 'Float64') { // step 2
		return valueToFloat64Bytes(value, isLittleEndian);
	} // step 3

	var n = tableTAO.size['$' + type]; // step 3.a

	var convOp = TypeToAO['$' + type]; // step 3.b

	var intValue = convOp(value); // step 3.c

	return integerToNBytes(intValue, n, isLittleEndian); // step 3.d, 3.e, 4
};
'use strict';

var DefinePropertyOrThrow = require('./DefinePropertyOrThrow');
var Get = require('./Get');
var OrdinaryGetOwnProperty = require('./OrdinaryGetOwnProperty');
var ToObject = require('./ToObject');
var ToPropertyDescriptor = require('./ToPropertyDescriptor');

var forEach = require('../helpers/forEach');
var OwnPropertyKeys = require('own-keys');

// https://262.ecma-international.org/6.0/#sec-objectdefineproperties

/** @type {<T extends Record<PropertyKey, unknown> = {}>(O: T, Properties: object) => T} */
module.exports = function ObjectDefineProperties(O, Properties) {
	var props = ToObject(Properties); // step 1
	var keys = OwnPropertyKeys(props); // step 2
	/** @type {[string | symbol, import('../types').Descriptor][]} */
	var descriptors = []; // step 3

	forEach(keys, function (nextKey) { // step 4
		var propDesc = OrdinaryGetOwnProperty(props, nextKey); // ToPropertyDescriptor(getOwnPropertyDescriptor(props, nextKey)); // step 4.a
		if (typeof propDesc !== 'undefined' && propDesc['[[Enumerable]]']) { // step 4.b
			var descObj = Get(props, nextKey); // step 4.b.i
			var desc = ToPropertyDescriptor(descObj); // step 4.b.ii
			descriptors[descriptors.length] = [nextKey, desc]; // step 4.b.iii
		}
	});

	forEach(descriptors, function (pair) { // step 5
		var P = pair[0]; // step 5.a
		var desc = pair[1]; // step 5.b
		DefinePropertyOrThrow(O, P, desc); // step 5.c
	});

	return O; // step 6
};
'use strict';

var GetIntrinsic = require('get-intrinsic');
var $TypeError = require('es-errors/type');

var GetPrototypeFromConstructor = require('./GetPrototypeFromConstructor');
var IsArray = require('./IsArray');
var OrdinaryObjectCreate = require('./OrdinaryObjectCreate');

// https://262.ecma-international.org/6.0/#sec-ordinarycreatefromconstructor

module.exports = function OrdinaryCreateFromConstructor(constructor, intrinsicDefaultProto) {
	GetIntrinsic(intrinsicDefaultProto); // throws if not a valid intrinsic
	var proto = GetPrototypeFromConstructor(constructor, intrinsicDefaultProto);
	var slots = arguments.length < 3 ? [] : arguments[2];
	if (!IsArray(slots)) {
		throw new $TypeError('Assertion failed: if provided, `internalSlotsList` must be a List');
	}
	return OrdinaryObjectCreate(proto, slots);
};
'use strict';

var $gOPD = require('gopd');
var $SyntaxError = require('es-errors/syntax');
var $TypeError = require('es-errors/type');
var isObject = require('es-object-atoms/isObject');

var isPropertyDescriptor = require('../helpers/records/property-descriptor');

var IsAccessorDescriptor = require('./IsAccessorDescriptor');
var IsExtensible = require('./IsExtensible');
var isPropertyKey = require('../helpers/isPropertyKey');
var ToPropertyDescriptor = require('./ToPropertyDescriptor');
var SameValue = require('./SameValue');
var ValidateAndApplyPropertyDescriptor = require('./ValidateAndApplyPropertyDescriptor');

// https://262.ecma-international.org/6.0/#sec-ordinarydefineownproperty

module.exports = function OrdinaryDefineOwnProperty(O, P, Desc) {
	if (!isObject(O)) {
		throw new $TypeError('Assertion failed: O must be an Object');
	}
	if (!isPropertyKey(P)) {
		throw new $TypeError('Assertion failed: P must be a Property Key');
	}
	if (!isPropertyDescriptor(Desc)) {
		throw new $TypeError('Assertion failed: Desc must be a Property Descriptor');
	}
	if (!$gOPD) {
		// ES3/IE 8 fallback
		if (IsAccessorDescriptor(Desc)) {
			throw new $SyntaxError('This environment does not support accessor property descriptors.');
		}
		var creatingNormalDataProperty = !(P in O)
			&& Desc['[[Writable]]']
			&& Desc['[[Enumerable]]']
			&& Desc['[[Configurable]]']
			&& '[[Value]]' in Desc;
		var settingExistingDataProperty = (P in O)
			&& (!('[[Configurable]]' in Desc) || Desc['[[Configurable]]'])
			&& (!('[[Enumerable]]' in Desc) || Desc['[[Enumerable]]'])
			&& (!('[[Writable]]' in Desc) || Desc['[[Writable]]'])
			&& '[[Value]]' in Desc;
		if (creatingNormalDataProperty || settingExistingDataProperty) {
			O[P] = Desc['[[Value]]']; // eslint-disable-line no-param-reassign
			return SameValue(O[P], Desc['[[Value]]']);
		}
		throw new $SyntaxError('This environment does not support defining non-writable, non-enumerable, or non-configurable properties');
	}
	var desc = $gOPD(O, P);
	var current = desc && ToPropertyDescriptor(desc);
	var extensible = IsExtensible(O);
	return ValidateAndApplyPropertyDescriptor(O, P, extensible, Desc, current);
};
'use strict';

var $gOPD = require('gopd');
var $TypeError = require('es-errors/type');
var isObject = require('es-object-atoms/isObject');
var callBound = require('call-bound');

var $isEnumerable = callBound('Object.prototype.propertyIsEnumerable');

var hasOwn = require('hasown');

var IsArray = require('./IsArray');
var isPropertyKey = require('../helpers/isPropertyKey');
var IsRegExp = require('./IsRegExp');
var ToPropertyDescriptor = require('./ToPropertyDescriptor');

// https://262.ecma-international.org/6.0/#sec-ordinarygetownproperty

module.exports = function OrdinaryGetOwnProperty(O, P) {
	if (!isObject(O)) {
		throw new $TypeError('Assertion failed: O must be an Object');
	}
	if (!isPropertyKey(P)) {
		throw new $TypeError('Assertion failed: P must be a Property Key');
	}
	if (!hasOwn(O, P)) {
		return void 0;
	}
	if (!$gOPD) {
		// ES3 / IE 8 fallback
		var arrayLength = IsArray(O) && P === 'length';
		var regexLastIndex = IsRegExp(O) && P === 'lastIndex';
		return {
			'[[Configurable]]': !(arrayLength || regexLastIndex),
			'[[Enumerable]]': $isEnumerable(O, P),
			'[[Value]]': O[P],
			'[[Writable]]': true
		};
	}
	return ToPropertyDescriptor($gOPD(O, P));
};
'use strict';

var $TypeError = require('es-errors/type');
var isObject = require('es-object-atoms/isObject');

var $getProto = require('get-proto');

// https://262.ecma-international.org/7.0/#sec-ordinarygetprototypeof

module.exports = function OrdinaryGetPrototypeOf(O) {
	if (!isObject(O)) {
		throw new $TypeError('Assertion failed: O must be an Object');
	}
	if (!$getProto) {
		throw new $TypeError('This environment does not support fetching prototypes.');
	}
	return $getProto(O);
};
'use strict';

var $TypeError = require('es-errors/type');
var isObject = require('es-object-atoms/isObject');

var Get = require('./Get');
var IsCallable = require('./IsCallable');

// https://262.ecma-international.org/6.0/#sec-ordinaryhasinstance

module.exports = function OrdinaryHasInstance(C, O) {
	if (!IsCallable(C)) {
		return false;
	}
	if (!isObject(O)) {
		return false;
	}
	var P = Get(C, 'prototype');
	if (!isObject(P)) {
		throw new $TypeError('OrdinaryHasInstance called on an object with an invalid prototype property.');
	}
	return O instanceof C;
};
'use strict';

var $TypeError = require('es-errors/type');
var isObject = require('es-object-atoms/isObject');

var isPropertyKey = require('../helpers/isPropertyKey');

// https://262.ecma-international.org/6.0/#sec-ordinaryhasproperty

module.exports = function OrdinaryHasProperty(O, P) {
	if (!isObject(O)) {
		throw new $TypeError('Assertion failed: Type(O) is not Object');
	}
	if (!isPropertyKey(P)) {
		throw new $TypeError('Assertion failed: P must be a Property Key');
	}
	return P in O;
};
'use strict';

var GetIntrinsic = require('get-intrinsic');

var $ObjectCreate = GetIntrinsic('%Object.create%', true);
var $TypeError = require('es-errors/type');
var $SyntaxError = require('es-errors/syntax');
var isObject = require('es-object-atoms/isObject');

var IsArray = require('./IsArray');

var forEach = require('../helpers/forEach');

var SLOT = require('internal-slot');

var hasProto = require('has-proto')();

// https://262.ecma-international.org/11.0/#sec-objectcreate

module.exports = function OrdinaryObjectCreate(proto) {
	if (proto !== null && !isObject(proto)) {
		throw new $TypeError('Assertion failed: `proto` must be null or an object');
	}
	var additionalInternalSlotsList = arguments.length < 2 ? [] : arguments[1];
	if (!IsArray(additionalInternalSlotsList)) {
		throw new $TypeError('Assertion failed: `additionalInternalSlotsList` must be an Array');
	}

	// var internalSlotsList = ['[[Prototype]]', '[[Extensible]]']; // step 1
	// internalSlotsList.push(...additionalInternalSlotsList); // step 2
	// var O = MakeBasicObject(internalSlotsList); // step 3
	// setProto(O, proto); // step 4
	// return O; // step 5

	var O;
	if (hasProto) {
		O = { __proto__: proto };
	} else if ($ObjectCreate) {
		O = $ObjectCreate(proto);
	} else {
		if (proto === null) {
			throw new $SyntaxError('native Object.create support is required to create null objects');
		}
		var T = function T() {};
		T.prototype = proto;
		O = new T();
	}

	if (additionalInternalSlotsList.length > 0) {
		forEach(additionalInternalSlotsList, function (slot) {
			SLOT.set(O, slot, void undefined);
		});
	}

	return O;
};
'use strict';

var $TypeError = require('es-errors/type');
var $setProto = require('set-proto');
var isObject = require('es-object-atoms/isObject');

var OrdinaryGetPrototypeOf = require('./OrdinaryGetPrototypeOf');

// https://262.ecma-international.org/7.0/#sec-ordinarysetprototypeof

module.exports = function OrdinarySetPrototypeOf(O, V) {
	if (V !== null && !isObject(V)) {
		throw new $TypeError('Assertion failed: V must be Object or Null');
	}
	/*
	var extensible = IsExtensible(O);
	var current = OrdinaryGetPrototypeOf(O);
	if (SameValue(V, current)) {
		return true;
	}
	if (!extensible) {
		return false;
	}
	*/
	try {
		$setProto(O, V);
	} catch (e) {
		return false;
	}
	return OrdinaryGetPrototypeOf(O) === V;
	/*
	var p = V;
	var done = false;
	while (!done) {
		if (p === null) {
			done = true;
		} else if (SameValue(p, O)) {
			return false;
		} else {
			if (wat) {
				done = true;
			} else {
				p = p.[[Prototype]];
			}
		}
	}
	O.[[Prototype]] = V;
	return true;
	*/
};
'use strict';

var $TypeError = require('es-errors/type');
var isObject = require('es-object-atoms/isObject');

var Call = require('./Call');
var Get = require('./Get');
var IsCallable = require('./IsCallable');

var inspect = require('object-inspect');

// https://262.ecma-international.org/8.0/#sec-ordinarytoprimitive

module.exports = function OrdinaryToPrimitive(O, hint) {
	if (!isObject(O)) {
		throw new $TypeError('Assertion failed: Type(O) is not Object');
	}
	if (/* typeof hint !== 'string' || */ hint !== 'string' && hint !== 'number') {
		throw new $TypeError('Assertion failed: `hint` must be "string" or "number"');
	}

	var methodNames = hint === 'string' ? ['toString', 'valueOf'] : ['valueOf', 'toString'];

	for (var i = 0; i < methodNames.length; i += 1) {
		var name = methodNames[i];
		var method = Get(O, name);
		if (IsCallable(method)) {
			var result = Call(method, O);
			if (!isObject(result)) {
				return result;
			}
		}
	}

	throw new $TypeError('No primitive value for ' + inspect(O));
};
'use strict';

var GetIntrinsic = require('get-intrinsic');
var callBind = require('call-bind');
var $SyntaxError = require('es-errors/syntax');

var $resolve = GetIntrinsic('%Promise.resolve%', true);
var $PromiseResolve = $resolve && callBind($resolve);

// https://262.ecma-international.org/9.0/#sec-promise-resolve

module.exports = function PromiseResolve(C, x) {
	if (!$PromiseResolve) {
		throw new $SyntaxError('This environment does not support Promises.');
	}
	return $PromiseResolve(C, x);
};

'use strict';

var $TypeError = require('es-errors/type');

var callBound = require('call-bound');
var forEach = require('../helpers/forEach');
var isLeadingSurrogate = require('../helpers/isLeadingSurrogate');
var isTrailingSurrogate = require('../helpers/isTrailingSurrogate');

var $charCodeAt = callBound('String.prototype.charCodeAt');
var $strSplit = callBound('String.prototype.split');

var StringToCodePoints = require('./StringToCodePoints');
var UnicodeEscape = require('./UnicodeEscape');
var UTF16EncodeCodePoint = require('./UTF16EncodeCodePoint');

var hasOwn = require('hasown');

// https://262.ecma-international.org/12.0/#sec-quotejsonstring

var escapes = {
	'\u0008': '\\b',
	'\u0009': '\\t',
	'\u000A': '\\n',
	'\u000C': '\\f',
	'\u000D': '\\r',
	'\u0022': '\\"',
	'\u005c': '\\\\'
};

module.exports = function QuoteJSONString(value) {
	if (typeof value !== 'string') {
		throw new $TypeError('Assertion failed: `value` must be a String');
	}
	var product = '"';
	if (value) {
		forEach($strSplit(StringToCodePoints(value), ''), function (C) {
			if (hasOwn(escapes, C)) {
				product += escapes[C];
			} else {
				var cCharCode = $charCodeAt(C, 0);
				if (cCharCode < 0x20 || isLeadingSurrogate(cCharCode) || isTrailingSurrogate(cCharCode)) {
					product += UnicodeEscape(C);
				} else {
					product += UTF16EncodeCodePoint(cCharCode);
				}
			}
		});
	}
	product += '"';
	return product;
};
'use strict';

var GetIntrinsic = require('get-intrinsic');
var callBound = require('call-bound');

var $RangeError = require('es-errors/range');
var $SyntaxError = require('es-errors/syntax');
var $TypeError = require('es-errors/type');
var $BigInt = GetIntrinsic('%BigInt%', true);

var hasOwnProperty = require('./HasOwnProperty');
var IsArray = require('./IsArray');
var IsBigIntElementType = require('./IsBigIntElementType');
var IsUnsignedElementType = require('./IsUnsignedElementType');

var bytesAsFloat32 = require('../helpers/bytesAsFloat32');
var bytesAsFloat64 = require('../helpers/bytesAsFloat64');
var bytesAsInteger = require('../helpers/bytesAsInteger');
var every = require('../helpers/every');
var isByteValue = require('../helpers/isByteValue');

var $reverse = callBound('Array.prototype.reverse');
var $slice = callBound('Array.prototype.slice');

var tableTAO = require('./tables/typed-array-objects');

// https://262.ecma-international.org/11.0/#sec-rawbytestonumeric

module.exports = function RawBytesToNumeric(type, rawBytes, isLittleEndian) {
	if (typeof type !== 'string' || !hasOwnProperty(tableTAO.size, '$' + type)) {
		throw new $TypeError('Assertion failed: `type` must be a TypedArray element type');
	}
	if (!IsArray(rawBytes) || !every(rawBytes, isByteValue)) {
		throw new $TypeError('Assertion failed: `rawBytes` must be an Array of bytes');
	}
	if (typeof isLittleEndian !== 'boolean') {
		throw new $TypeError('Assertion failed: `isLittleEndian` must be a Boolean');
	}

	var elementSize = tableTAO.size['$' + type]; // step 1

	if (rawBytes.length !== elementSize) {
		// this assertion is not in the spec, but it'd be an editorial error if it were ever violated
		throw new $RangeError('Assertion failed: `rawBytes` must have a length of ' + elementSize + ' for type ' + type);
	}

	var isBigInt = IsBigIntElementType(type);
	if (isBigInt && !$BigInt) {
		throw new $SyntaxError('this environment does not support BigInts');
	}

	// eslint-disable-next-line no-param-reassign
	rawBytes = $slice(rawBytes, 0, elementSize);
	if (!isLittleEndian) {
		$reverse(rawBytes); // step 2
	}

	if (type === 'Float32') { // step 3
		return bytesAsFloat32(rawBytes);
	}

	if (type === 'Float64') { // step 4
		return bytesAsFloat64(rawBytes);
	}

	return bytesAsInteger(rawBytes, elementSize, IsUnsignedElementType(type), isBigInt);
};
'use strict';

var GetIntrinsic = require('get-intrinsic');

var $RegExp = GetIntrinsic('%RegExp%');

// var RegExpAlloc = require('./RegExpAlloc');
// var RegExpInitialize = require('./RegExpInitialize');
var ToString = require('./ToString');

// https://262.ecma-international.org/6.0/#sec-regexpcreate

module.exports = function RegExpCreate(P, F) {
	// var obj = RegExpAlloc($RegExp);
	// return RegExpInitialize(obj, P, F);

	// covers spec mechanics; bypass regex brand checking
	var pattern = typeof P === 'undefined' ? '' : ToString(P);
	var flags = typeof F === 'undefined' ? '' : ToString(F);
	return new $RegExp(pattern, flags);
};
'use strict';

var $TypeError = require('es-errors/type');
var isObject = require('es-object-atoms/isObject');
var regexExec = require('call-bound')('RegExp.prototype.exec');

var Call = require('./Call');
var Get = require('./Get');
var IsCallable = require('./IsCallable');

// https://262.ecma-international.org/6.0/#sec-regexpexec

module.exports = function RegExpExec(R, S) {
	if (!isObject(R)) {
		throw new $TypeError('Assertion failed: `R` must be an Object');
	}
	if (typeof S !== 'string') {
		throw new $TypeError('Assertion failed: `S` must be a String');
	}
	var exec = Get(R, 'exec');
	if (IsCallable(exec)) {
		var result = Call(exec, R, [S]);
		if (result === null || isObject(result)) {
			return result;
		}
		throw new $TypeError('"exec" method must return `null` or an Object');
	}
	return regexExec(R, S);
};
'use strict';

module.exports = require('es-object-atoms/RequireObjectCoercible');
'use strict';

var $isNaN = require('math-intrinsics/isNaN');

// http://262.ecma-international.org/5.1/#sec-9.12

module.exports = function SameValue(x, y) {
	if (x === y) { // 0 === -0, but they are not identical.
		if (x === 0) { return 1 / x === 1 / y; }
		return true;
	}
	return $isNaN(x) && $isNaN(y);
};
'use strict';

var $TypeError = require('es-errors/type');

var SameValue = require('./SameValue');
var Type = require('./Type');

// https://262.ecma-international.org/11.0/#sec-samevaluenonnumeric

module.exports = function SameValueNonNumeric(x, y) {
	if (typeof x === 'number' || typeof x === 'bigint') {
		throw new $TypeError('Assertion failed: SameValueNonNumeric does not accept Number or BigInt values');
	}
	if (Type(x) !== Type(y)) {
		throw new $TypeError('SameValueNonNumeric requires two non-numeric values of the same type.');
	}
	return SameValue(x, y);
};
'use strict';

var $isNaN = require('math-intrinsics/isNaN');

// https://262.ecma-international.org/6.0/#sec-samevaluezero

module.exports = function SameValueZero(x, y) {
	return (x === y) || ($isNaN(x) && $isNaN(y));
};
'use strict';

var floor = require('./floor');
var modulo = require('./modulo');

var timeConstants = require('../helpers/timeConstants');
var msPerSecond = timeConstants.msPerSecond;
var SecondsPerMinute = timeConstants.SecondsPerMinute;

// https://262.ecma-international.org/5.1/#sec-15.9.1.10

module.exports = function SecFromTime(t) {
	return modulo(floor(t / msPerSecond), SecondsPerMinute);
};
'use strict';

var $TypeError = require('es-errors/type');
var isInteger = require('math-intrinsics/isInteger');

var DefinePropertyOrThrow = require('./DefinePropertyOrThrow');
var HasOwnProperty = require('./HasOwnProperty');
var IsExtensible = require('./IsExtensible');

// https://262.ecma-international.org/12.0/#sec-setfunctionlength

module.exports = function SetFunctionLength(F, length) {
	if (typeof F !== 'function' || !IsExtensible(F) || HasOwnProperty(F, 'length')) {
		throw new $TypeError('Assertion failed: `F` must be an extensible function and lack an own `length` property');
	}
	if (typeof length !== 'number') {
		throw new $TypeError('Assertion failed: `length` must be a Number');
	}
	if (length !== Infinity && (!isInteger(length) || length < 0)) {
		throw new $TypeError('Assertion failed: `length` must be ∞, or an integer >= 0');
	}
	return DefinePropertyOrThrow(F, 'length', {
		'[[Configurable]]': true,
		'[[Enumerable]]': false,
		'[[Value]]': length,
		'[[Writable]]': false
	});
};
'use strict';

var hasOwn = require('hasown');

var $TypeError = require('es-errors/type');

var getSymbolDescription = require('get-symbol-description');

var DefinePropertyOrThrow = require('./DefinePropertyOrThrow');
var IsExtensible = require('./IsExtensible');

// https://262.ecma-international.org/6.0/#sec-setfunctionname

module.exports = function SetFunctionName(F, name) {
	if (typeof F !== 'function') {
		throw new $TypeError('Assertion failed: `F` must be a function');
	}
	if (!IsExtensible(F) || hasOwn(F, 'name')) {
		throw new $TypeError('Assertion failed: `F` must be extensible, and must not have a `name` own property');
	}
	if (typeof name !== 'symbol' && typeof name !== 'string') {
		throw new $TypeError('Assertion failed: `name` must be a Symbol or a String');
	}
	if (typeof name === 'symbol') {
		var description = getSymbolDescription(name);
		// eslint-disable-next-line no-param-reassign
		name = typeof description === 'undefined' ? '' : '[' + description + ']';
	}
	if (arguments.length > 2) {
		var prefix = arguments[2];
		// eslint-disable-next-line no-param-reassign
		name = prefix + ' ' + name;
	}
	return DefinePropertyOrThrow(F, 'name', {
		'[[Value]]': name,
		'[[Writable]]': false,
		'[[Enumerable]]': false,
		'[[Configurable]]': true
	});
};
'use strict';

var GetIntrinsic = require('get-intrinsic');

var $SyntaxError = require('es-errors/syntax');
var $TypeError = require('es-errors/type');
var isObject = require('es-object-atoms/isObject');
var $gOPD = require('gopd');
var $preventExtensions = GetIntrinsic('%Object.preventExtensions%', true);
var $gOPN = GetIntrinsic('%Object.getOwnPropertyNames%', true);

var forEach = require('../helpers/forEach');

var DefinePropertyOrThrow = require('./DefinePropertyOrThrow');
var IsAccessorDescriptor = require('./IsAccessorDescriptor');
var ToPropertyDescriptor = require('./ToPropertyDescriptor');

// https://262.ecma-international.org/6.0/#sec-setintegritylevel

module.exports = function SetIntegrityLevel(O, level) {
	if (!isObject(O)) {
		throw new $TypeError('Assertion failed: Type(O) is not Object');
	}
	if (level !== 'sealed' && level !== 'frozen') {
		throw new $TypeError('Assertion failed: `level` must be `"sealed"` or `"frozen"`');
	}
	if (!$preventExtensions) {
		throw new $SyntaxError('SetIntegrityLevel requires native `Object.preventExtensions` support');
	}
	var status = $preventExtensions(O);
	if (!status) {
		return false;
	}
	if (!$gOPN) {
		throw new $SyntaxError('SetIntegrityLevel requires native `Object.getOwnPropertyNames` support');
	}
	var theKeys = $gOPN(O);
	if (level === 'sealed') {
		forEach(theKeys, function (k) {
			DefinePropertyOrThrow(O, k, { configurable: false });
		});
	} else if (level === 'frozen') {
		forEach(theKeys, function (k) {
			var currentDesc = $gOPD(O, k);
			if (typeof currentDesc !== 'undefined') {
				var desc;
				if (IsAccessorDescriptor(ToPropertyDescriptor(currentDesc))) {
					desc = { configurable: false };
				} else {
					desc = { configurable: false, writable: false };
				}
				DefinePropertyOrThrow(O, k, desc);
			}
		});
	}
	return true;
};
'use strict';

var $TypeError = require('es-errors/type');
var isObject = require('es-object-atoms/isObject');

var isPropertyKey = require('../helpers/isPropertyKey');
var SameValue = require('./SameValue');

// IE 9 does not throw in strict mode when writability/configurability/extensibility is violated
var noThrowOnStrictViolation = (function () {
	try {
		delete [].length;
		return true;
	} catch (e) {
		return false;
	}
}());

// https://262.ecma-international.org/6.0/#sec-set-o-p-v-throw

module.exports = function Set(O, P, V, Throw) {
	if (!isObject(O)) {
		throw new $TypeError('Assertion failed: `O` must be an Object');
	}
	if (!isPropertyKey(P)) {
		throw new $TypeError('Assertion failed: `P` must be a Property Key');
	}
	if (typeof Throw !== 'boolean') {
		throw new $TypeError('Assertion failed: `Throw` must be a Boolean');
	}
	if (Throw) {
		O[P] = V; // eslint-disable-line no-param-reassign
		if (noThrowOnStrictViolation && !SameValue(O[P], V)) {
			throw new $TypeError('Attempted to assign to readonly property.');
		}
		return true;
	}
	try {
		O[P] = V; // eslint-disable-line no-param-reassign
		return noThrowOnStrictViolation ? SameValue(O[P], V) : true;
	} catch (e) {
		return false;
	}

};
'use strict';

var $RangeError = require('es-errors/range');
var $TypeError = require('es-errors/type');

var isTypedArray = require('is-typed-array');
var typedArrayBuffer = require('typed-array-buffer');
var typedArrayByteOffset = require('typed-array-byte-offset');
var typedArrayLength = require('typed-array-length');
var whichTypedArray = require('which-typed-array');
var isInteger = require('math-intrinsics/isInteger');

var Get = require('./Get');
var IsBigIntElementType = require('./IsBigIntElementType');
var IsDetachedBuffer = require('./IsDetachedBuffer');
var LengthOfArrayLike = require('./LengthOfArrayLike');
var SetValueInBuffer = require('./SetValueInBuffer');
var ToBigInt = require('./ToBigInt');
var ToNumber = require('./ToNumber');
var ToObject = require('./ToObject');
var ToString = require('./ToString');

var tableTAO = require('./tables/typed-array-objects');

// https://262.ecma-international.org/12.0/#sec-settypedarrayfromarraylike

module.exports = function SetTypedArrayFromArrayLike(target, targetOffset, source) {
	var whichTarget = whichTypedArray(target);
	if (!whichTarget) {
		throw new $TypeError('Assertion failed: target must be a TypedArray instance');
	}

	if (targetOffset !== Infinity && (!isInteger(targetOffset) || targetOffset < 0)) {
		throw new $TypeError('Assertion failed: targetOffset must be a non-negative integer or +Infinity');
	}

	if (isTypedArray(source)) {
		throw new $TypeError('Assertion failed: source must not be a TypedArray instance'); // step 1
	}

	var targetBuffer = typedArrayBuffer(target); // step 2

	if (IsDetachedBuffer(targetBuffer)) {
		throw new $TypeError('target’s buffer is detached'); // step 3
	}

	var targetLength = typedArrayLength(target); // step 4

	var targetName = whichTarget; // step 5

	var targetType = tableTAO.name['$' + targetName]; // step 7

	var targetElementSize = tableTAO.size['$' + targetType]; // step 6

	var targetByteOffset = typedArrayByteOffset(target); // step 8

	var src = ToObject(source); // step 9

	var srcLength = LengthOfArrayLike(src); // step 10

	if (targetOffset === Infinity) {
		throw new $RangeError('targetOffset must be a finite integer'); // step 11
	}

	if (srcLength + targetOffset > targetLength) {
		throw new $RangeError('targetOffset + srcLength must be <= target.length'); // step 12
	}

	var targetByteIndex = (targetOffset * targetElementSize) + targetByteOffset; // step 13

	var k = 0; // step 14

	var limit = targetByteIndex + (targetElementSize * srcLength); // step 15

	while (targetByteIndex < limit) { // step 16
		var Pk = ToString(k); // step 16.a

		var value = Get(src, Pk); // step 16.b

		if (IsBigIntElementType(targetType)) {
			value = ToBigInt(value); // step 16.c
		} else {
			value = ToNumber(value); // step 16.d
		}

		if (IsDetachedBuffer(targetBuffer)) {
			throw new $TypeError('target’s buffer is detached'); // step 16.e
		}

		SetValueInBuffer(targetBuffer, targetByteIndex, targetType, value, true, 'Unordered'); // step 16.f

		k += 1; // step 16.g

		targetByteIndex += targetElementSize; // step 16.h
	}
};
'use strict';

var GetIntrinsic = require('get-intrinsic');

var $RangeError = require('es-errors/range');
var $SyntaxError = require('es-errors/syntax');
var $TypeError = require('es-errors/type');
var $ArrayBuffer = GetIntrinsic('%ArrayBuffer%', true);

var typedArrayBuffer = require('typed-array-buffer');
var typedArrayByteLength = require('typed-array-byte-length');
var typedArrayByteOffset = require('typed-array-byte-offset');
var typedArrayLength = require('typed-array-length');
var whichTypedArray = require('which-typed-array');
var isInteger = require('math-intrinsics/isInteger');

var CloneArrayBuffer = require('./CloneArrayBuffer');
var GetValueFromBuffer = require('./GetValueFromBuffer');
var IsDetachedBuffer = require('./IsDetachedBuffer');
var IsSharedArrayBuffer = require('./IsSharedArrayBuffer');
var SameValue = require('./SameValue');
var SetValueInBuffer = require('./SetValueInBuffer');

var tableTAO = require('./tables/typed-array-objects');

// https://262.ecma-international.org/12.0/#sec-settypedarrayfromtypedarray

module.exports = function SetTypedArrayFromTypedArray(target, targetOffset, source) {
	var whichTarget = whichTypedArray(target);
	if (!whichTarget) {
		throw new $TypeError('Assertion failed: target must be a TypedArray instance');
	}

	if (targetOffset !== Infinity && (!isInteger(targetOffset) || targetOffset < 0)) {
		throw new $TypeError('Assertion failed: targetOffset must be a non-negative integer or +Infinity');
	}

	var whichSource = whichTypedArray(source);
	if (!whichSource) {
		throw new $TypeError('Assertion failed: source must be a TypedArray instance'); // step 1
	}

	var targetBuffer = typedArrayBuffer(target); // step 2

	if (IsDetachedBuffer(targetBuffer)) {
		throw new $TypeError('target’s buffer is detached'); // step 3
	}

	var targetLength = typedArrayLength(target); // step 4

	var srcBuffer = typedArrayBuffer(source); // step 5

	if (IsDetachedBuffer(srcBuffer)) {
		throw new $TypeError('source’s buffer is detached'); // step 6
	}

	var targetName = whichTarget; // step 7

	var targetType = tableTAO.name['$' + targetName]; // step 8

	var targetElementSize = tableTAO.size['$' + targetType]; // step 9

	var targetByteOffset = typedArrayByteOffset(target); // step 10

	var srcName = whichSource; // step 11

	var srcType = tableTAO.name['$' + srcName]; // step 12

	var srcElementSize = tableTAO.size['$' + srcType]; // step 13

	var srcLength = typedArrayLength(source); // step 14

	var srcByteOffset = typedArrayByteOffset(source); // step 15

	if (targetOffset === Infinity) {
		throw new $RangeError('targetOffset must be a non-negative integer or +Infinity'); // step 16
	}

	if (srcLength + targetOffset > targetLength) {
		throw new $RangeError('targetOffset + source.length must not be greater than target.length'); // step 17
	}

	var targetContentType = whichTarget === 'BigInt64Array' || whichTarget === 'BigUint64Array' ? 'BigInt' : 'Number';
	var sourceContentType = whichSource === 'BigInt64Array' || whichSource === 'BigUint64Array' ? 'BigInt' : 'Number';
	if (targetContentType !== sourceContentType) {
		throw new $TypeError('source and target must have the same content type'); // step 18
	}

	var same;
	if (IsSharedArrayBuffer(srcBuffer) && IsSharedArrayBuffer(targetBuffer)) { // step 19
		// a. If srcBuffer.[[ArrayBufferData]] and targetBuffer.[[ArrayBufferData]] are the same Shared Data Block values, let same be true; else let same be false.
		throw new $SyntaxError('SharedArrayBuffer is not supported by this implementation');
	} else {
		same = SameValue(srcBuffer, targetBuffer); // step 20
	}

	var srcByteIndex;
	if (same) { // step 21
		var srcByteLength = typedArrayByteLength(source); // step 21.a

		srcBuffer = CloneArrayBuffer(srcBuffer, srcByteOffset, srcByteLength, $ArrayBuffer); // step 21.b

		// c. NOTE: %ArrayBuffer% is used to clone srcBuffer because is it known to not have any observable side-effects.

		srcByteIndex = 0; // step 21.d
	} else {
		srcByteIndex = srcByteOffset; // step 22
	}

	var targetByteIndex = (targetOffset * targetElementSize) + targetByteOffset; // step 23

	var limit = targetByteIndex + (targetElementSize * srcLength); // step 24

	var value;
	if (srcType === targetType) { // step 25
		// a. NOTE: If srcType and targetType are the same, the transfer must be performed in a manner that preserves the bit-level encoding of the source data.

		while (targetByteIndex < limit) { // step 25.b
			value = GetValueFromBuffer(srcBuffer, srcByteIndex, 'Uint8', true, 'Unordered'); // step 25.b.i

			SetValueInBuffer(targetBuffer, targetByteIndex, 'Uint8', value, true, 'Unordered'); // step 25.b.ii

			srcByteIndex += 1; // step 25.b.iii

			targetByteIndex += 1; // step 25.b.iv
		}
	} else { // step 26
		while (targetByteIndex < limit) { // step 26.a
			value = GetValueFromBuffer(srcBuffer, srcByteIndex, srcType, true, 'Unordered'); // step 26.a.i

			SetValueInBuffer(targetBuffer, targetByteIndex, targetType, value, true, 'Unordered'); // step 26.a.ii

			srcByteIndex += srcElementSize; // step 26.a.iii

			targetByteIndex += targetElementSize; // step 26.a.iv
		}
	}
};
'use strict';

var GetIntrinsic = require('get-intrinsic');

var $SyntaxError = require('es-errors/syntax');
var $TypeError = require('es-errors/type');
var isInteger = require('math-intrinsics/isInteger');
var $Uint8Array = GetIntrinsic('%Uint8Array%', true);

var IsBigIntElementType = require('./IsBigIntElementType');
var IsDetachedBuffer = require('./IsDetachedBuffer');
var NumericToRawBytes = require('./NumericToRawBytes');

var isArrayBuffer = require('is-array-buffer');
var isSharedArrayBuffer = require('is-shared-array-buffer');
var hasOwn = require('hasown');

var tableTAO = require('./tables/typed-array-objects');

var defaultEndianness = require('../helpers/defaultEndianness');
var forEach = require('../helpers/forEach');

// https://262.ecma-international.org/12.0/#sec-setvalueinbuffer

/* eslint max-params: 0 */

module.exports = function SetValueInBuffer(arrayBuffer, byteIndex, type, value, isTypedArray, order) {
	var isSAB = isSharedArrayBuffer(arrayBuffer);
	if (!isArrayBuffer(arrayBuffer) && !isSAB) {
		throw new $TypeError('Assertion failed: `arrayBuffer` must be an ArrayBuffer or a SharedArrayBuffer');
	}

	if (!isInteger(byteIndex) || byteIndex < 0) {
		throw new $TypeError('Assertion failed: `byteIndex` must be a non-negative integer');
	}

	if (typeof type !== 'string' || !hasOwn(tableTAO.size, '$' + type)) {
		throw new $TypeError('Assertion failed: `type` must be one of ' + tableTAO.choices);
	}

	if (typeof value !== 'number' && typeof value !== 'bigint') {
		throw new $TypeError('Assertion failed: `value` must be a Number or a BigInt');
	}

	if (typeof isTypedArray !== 'boolean') {
		throw new $TypeError('Assertion failed: `isTypedArray` must be a boolean');
	}
	if (order !== 'SeqCst' && order !== 'Unordered' && order !== 'Init') {
		throw new $TypeError('Assertion failed: `order` must be `"SeqCst"`, `"Unordered"`, or `"Init"`');
	}

	if (arguments.length > 6 && typeof arguments[6] !== 'boolean') {
		throw new $TypeError('Assertion failed: `isLittleEndian` must be a boolean, if present');
	}

	if (IsDetachedBuffer(arrayBuffer)) {
		throw new $TypeError('Assertion failed: ArrayBuffer is detached'); // step 1
	}

	// 2. Assert: There are sufficient bytes in arrayBuffer starting at byteIndex to represent a value of type.

	if (IsBigIntElementType(type) ? typeof value !== 'bigint' : typeof value !== 'number') { // step 3
		throw new $TypeError('Assertion failed: `value` must be a BigInt if type is BigInt64 or BigUint64, otherwise a Number');
	}

	// 4. Let block be arrayBuffer’s [[ArrayBufferData]] internal slot.

	var elementSize = tableTAO.size['$' + type]; // step 5

	// 6. If isLittleEndian is not present, set isLittleEndian to either true or false. The choice is implementation dependent and should be the alternative that is most efficient for the implementation. An implementation must use the same value each time this step is executed and the same value must be used for the corresponding step in the GetValueFromBuffer abstract operation.
	var isLittleEndian = arguments.length > 6 ? arguments[6] : defaultEndianness === 'little'; // step 6

	var rawBytes = NumericToRawBytes(type, value, isLittleEndian); // step 7

	if (isSAB) { // step 8
		/*
			Let execution be the [[CandidateExecution]] field of the surrounding agent's Agent Record.
			Let eventList be the [[EventList]] field of the element in execution.[[EventsRecords]] whose [[AgentSignifier]] is AgentSignifier().
			If isTypedArray is true and IsNoTearConfiguration(type, order) is true, let noTear be true; otherwise let noTear be false.
			Append WriteSharedMemory { [[Order]]: order, [[NoTear]]: noTear, [[Block]]: block, [[ByteIndex]]: byteIndex, [[ElementSize]]: elementSize, [[Payload]]: rawBytes } to eventList.
		*/
		throw new $SyntaxError('SharedArrayBuffer is not supported by this implementation');
	} else {
		// 9. Store the individual bytes of rawBytes into block, in order, starting at block[byteIndex].
		var arr = new $Uint8Array(arrayBuffer, byteIndex, elementSize);
		forEach(rawBytes, function (rawByte, i) {
			arr[i] = rawByte;
		});
	}

	// 10. Return NormalCompletion(undefined).
};
'use strict';

var GetIntrinsic = require('get-intrinsic');

var $species = GetIntrinsic('%Symbol.species%', true);
var $TypeError = require('es-errors/type');
var isObject = require('es-object-atoms/isObject');

var IsConstructor = require('./IsConstructor');

// https://262.ecma-international.org/6.0/#sec-speciesconstructor

module.exports = function SpeciesConstructor(O, defaultConstructor) {
	if (!isObject(O)) {
		throw new $TypeError('Assertion failed: Type(O) is not Object');
	}
	var C = O.constructor;
	if (typeof C === 'undefined') {
		return defaultConstructor;
	}
	if (!isObject(C)) {
		throw new $TypeError('O.constructor is not an Object');
	}
	var S = $species ? C[$species] : void 0;
	if (S == null) {
		return defaultConstructor;
	}
	if (IsConstructor(S)) {
		return S;
	}
	throw new $TypeError('no constructor found');
};
'use strict';

var callBound = require('call-bound');

var $TypeError = require('es-errors/type');
var isInteger = require('math-intrinsics/isInteger');

var $charAt = callBound('String.prototype.charAt');

// https://262.ecma-international.org/12.0/#sec-splitmatch

module.exports = function SplitMatch(S, q, R) {
	if (typeof S !== 'string') {
		throw new $TypeError('Assertion failed: `S` must be a String');
	}
	if (!isInteger(q)) {
		throw new $TypeError('Assertion failed: `q` must be an integer');
	}
	if (typeof R !== 'string') {
		throw new $TypeError('Assertion failed: `R` must be a String');
	}
	var r = R.length;
	var s = S.length;
	if (q + r > s) {
		return 'not-matched';
	}

	for (var i = 0; i < r; i += 1) {
		if ($charAt(S, q + i) !== $charAt(R, i)) {
			return 'not-matched';
		}
	}

	return q + r;
};
'use strict';

var Type = require('./Type');

// https://262.ecma-international.org/5.1/#sec-11.9.6

module.exports = function StrictEqualityComparison(x, y) {
	if (Type(x) !== Type(y)) {
		return false;
	}
	if (typeof x === 'undefined' || x === null) {
		return true;
	}
	return x === y; // shortcut for steps 4-7
};
'use strict';

var GetIntrinsic = require('get-intrinsic');

var $Object = require('es-object-atoms');
var $StringPrototype = GetIntrinsic('%String.prototype%');
var $SyntaxError = require('es-errors/syntax');
var $TypeError = require('es-errors/type');
var setProto = require('set-proto');

var DefinePropertyOrThrow = require('./DefinePropertyOrThrow');

// https://262.ecma-international.org/6.0/#sec-stringcreate

module.exports = function StringCreate(value, prototype) {
	if (typeof value !== 'string') {
		throw new $TypeError('Assertion failed: `S` must be a String');
	}

	var S = $Object(value);
	if (prototype !== $StringPrototype) {
		if (setProto) {
			setProto(S, prototype);
		} else {
			throw new $SyntaxError('StringCreate: a `proto` argument that is not `String.prototype` is not supported in an environment that does not support setting the [[Prototype]]');
		}
	}

	var length = value.length;
	DefinePropertyOrThrow(S, 'length', {
		'[[Configurable]]': false,
		'[[Enumerable]]': false,
		'[[Value]]': length,
		'[[Writable]]': false
	});

	return S;
};
'use strict';

var $TypeError = require('es-errors/type');
var isNegativeZero = require('math-intrinsics/isNegativeZero');
var isObject = require('es-object-atoms/isObject');

var callBound = require('call-bound');
var $charAt = callBound('String.prototype.charAt');
var $stringToString = callBound('String.prototype.toString');

var CanonicalNumericIndexString = require('./CanonicalNumericIndexString');

var isPropertyKey = require('../helpers/isPropertyKey');
var isInteger = require('math-intrinsics/isInteger');

// https://262.ecma-international.org/12.0/#sec-stringgetownproperty

module.exports = function StringGetOwnProperty(S, P) {
	var str;
	if (isObject(S)) {
		try {
			str = $stringToString(S);
		} catch (e) { /**/ }
	}
	if (typeof str !== 'string') {
		throw new $TypeError('Assertion failed: `S` must be a boxed string object');
	}
	if (!isPropertyKey(P)) {
		throw new $TypeError('Assertion failed: P is not a Property Key');
	}
	if (typeof P !== 'string') {
		return void undefined;
	}
	var index = CanonicalNumericIndexString(P);
	var len = str.length;
	if (typeof index === 'undefined' || !isInteger(index) || isNegativeZero(index) || index < 0 || len <= index) {
		return void undefined;
	}
	var resultStr = $charAt(S, index);
	return {
		'[[Configurable]]': false,
		'[[Enumerable]]': true,
		'[[Value]]': resultStr,
		'[[Writable]]': false
	};
};
'use strict';

var callBound = require('call-bound');

var $TypeError = require('es-errors/type');
var isInteger = require('math-intrinsics/isInteger');

var $slice = callBound('String.prototype.slice');

// https://262.ecma-international.org/12.0/#sec-stringindexof

module.exports = function StringIndexOf(string, searchValue, fromIndex) {
	if (typeof string !== 'string') {
		throw new $TypeError('Assertion failed: `string` must be a String');
	}
	if (typeof searchValue !== 'string') {
		throw new $TypeError('Assertion failed: `searchValue` must be a String');
	}
	if (!isInteger(fromIndex) || fromIndex < 0) {
		throw new $TypeError('Assertion failed: `fromIndex` must be a non-negative integer');
	}

	var len = string.length;
	if (searchValue === '' && fromIndex <= len) {
		return fromIndex;
	}

	var searchLen = searchValue.length;
	for (var i = fromIndex; i <= (len - searchLen); i += 1) {
		var candidate = $slice(string, i, i + searchLen);
		if (candidate === searchValue) {
			return i;
		}
	}
	return -1;
};
'use strict';

var $TypeError = require('es-errors/type');

var callBound = require('call-bound');

var ToLength = require('./ToLength');
var ToString = require('./ToString');

var $strSlice = callBound('String.prototype.slice');

// https://262.ecma-international.org/11.0/#sec-stringpad

module.exports = function StringPad(O, maxLength, fillString, placement) {
	if (placement !== 'start' && placement !== 'end') {
		throw new $TypeError('Assertion failed: `placement` must be "start" or "end"');
	}
	var S = ToString(O);
	var intMaxLength = ToLength(maxLength);
	var stringLength = S.length;
	if (intMaxLength <= stringLength) {
		return S;
	}
	var filler = typeof fillString === 'undefined' ? ' ' : ToString(fillString);
	if (filler === '') {
		return S;
	}
	var fillLen = intMaxLength - stringLength;

	// the String value consisting of repeated concatenations of filler truncated to length fillLen.
	var truncatedStringFiller = '';
	while (truncatedStringFiller.length < fillLen) {
		truncatedStringFiller += filler;
	}
	truncatedStringFiller = $strSlice(truncatedStringFiller, 0, fillLen);

	if (placement === 'start') {
		return truncatedStringFiller + S;
	}
	return S + truncatedStringFiller;
};
'use strict';

var GetIntrinsic = require('get-intrinsic');

var $BigInt = GetIntrinsic('%BigInt%', true);
var $TypeError = require('es-errors/type');
var $SyntaxError = require('es-errors/syntax');

// https://262.ecma-international.org/11.0/#sec-stringtobigint

module.exports = function StringToBigInt(argument) {
	if (typeof argument !== 'string') {
		throw new $TypeError('`argument` must be a string');
	}
	if (!$BigInt) {
		throw new $SyntaxError('BigInts are not supported in this environment');
	}
	try {
		return $BigInt(argument);
	} catch (e) {
		return NaN;
	}
};
'use strict';

var $TypeError = require('es-errors/type');

var CodePointAt = require('./CodePointAt');

// https://262.ecma-international.org/12.0/#sec-stringtocodepoints

module.exports = function StringToCodePoints(string) {
	if (typeof string !== 'string') {
		throw new $TypeError('Assertion failed: `string` must be a String');
	}
	var codePoints = [];
	var size = string.length;
	var position = 0;
	while (position < size) {
		var cp = CodePointAt(string, position);
		codePoints[codePoints.length] = cp['[[CodePoint]]'];
		position += cp['[[CodeUnitCount]]'];
	}
	return codePoints;
};
'use strict';

var $TypeError = require('es-errors/type');
var isInteger = require('math-intrinsics/isInteger');
var callBound = require('call-bound');

var $slice = callBound('String.prototype.slice');

// https://262.ecma-international.org/12.0/#substring
module.exports = function substring(S, inclusiveStart, exclusiveEnd) {
	if (typeof S !== 'string' || !isInteger(inclusiveStart) || (arguments.length > 2 && !isInteger(exclusiveEnd))) {
		throw new $TypeError('`S` must be a String, and `inclusiveStart` and `exclusiveEnd` must be integers');
	}
	return $slice(S, inclusiveStart, arguments.length > 2 ? exclusiveEnd : S.length);
};
'use strict';

var $TypeError = require('es-errors/type');

var callBound = require('call-bound');

var $SymbolToString = callBound('Symbol.prototype.toString', true);

// https://262.ecma-international.org/6.0/#sec-symboldescriptivestring

module.exports = function SymbolDescriptiveString(sym) {
	if (typeof sym !== 'symbol') {
		throw new $TypeError('Assertion failed: `sym` must be a Symbol');
	}
	return $SymbolToString(sym);
};
'use strict';

var $gOPD = require('gopd');
var $TypeError = require('es-errors/type');

var every = require('../helpers/every');
var OwnPropertyKeys = require('own-keys');
var isObject = require('es-object-atoms/isObject');

var IsDataDescriptor = require('./IsDataDescriptor');
var IsExtensible = require('./IsExtensible');
var ToPropertyDescriptor = require('./ToPropertyDescriptor');

// https://262.ecma-international.org/6.0/#sec-testintegritylevel

module.exports = function TestIntegrityLevel(O, level) {
	if (!isObject(O)) {
		throw new $TypeError('Assertion failed: Type(O) is not Object');
	}
	if (level !== 'sealed' && level !== 'frozen') {
		throw new $TypeError('Assertion failed: `level` must be `"sealed"` or `"frozen"`');
	}
	var status = IsExtensible(O);
	if (status || !$gOPD) {
		return false;
	}
	var theKeys = OwnPropertyKeys(O);
	return theKeys.length === 0 || every(theKeys, function (k) {
		var currentDesc = $gOPD(O, k);
		if (typeof currentDesc !== 'undefined') {
			if (currentDesc.configurable) {
				return false;
			}
			if (level === 'frozen' && IsDataDescriptor(ToPropertyDescriptor(currentDesc)) && currentDesc.writable) {
				return false;
			}
		}
		return true;
	});
};
'use strict';

var callBound = require('call-bound');

var $SyntaxError = require('es-errors/syntax');
var $bigIntValueOf = callBound('BigInt.prototype.valueOf', true);

// https://262.ecma-international.org/11.0/#sec-thisbigintvalue

module.exports = function thisBigIntValue(value) {
	if (typeof value === 'bigint') {
		return value;
	}
	if (!$bigIntValueOf) {
		throw new $SyntaxError('BigInt is not supported');
	}
	return $bigIntValueOf(value);
};
'use strict';

var $BooleanValueOf = require('call-bound')('Boolean.prototype.valueOf');

// https://262.ecma-international.org/6.0/#sec-properties-of-the-boolean-prototype-object

module.exports = function thisBooleanValue(value) {
	if (typeof value === 'boolean') {
		return value;
	}

	return $BooleanValueOf(value);
};
'use strict';

var callBound = require('call-bound');

var $NumberValueOf = callBound('Number.prototype.valueOf');

// https://262.ecma-international.org/6.0/#sec-properties-of-the-number-prototype-object

module.exports = function thisNumberValue(value) {
	if (typeof value === 'number') {
		return value;
	}

	return $NumberValueOf(value);
};

'use strict';

var $StringValueOf = require('call-bound')('String.prototype.valueOf');

// https://262.ecma-international.org/6.0/#sec-properties-of-the-string-prototype-object

module.exports = function thisStringValue(value) {
	if (typeof value === 'string') {
		return value;
	}

	return $StringValueOf(value);
};
'use strict';

var $SyntaxError = require('es-errors/syntax');
var callBound = require('call-bound');

var $SymbolValueOf = callBound('Symbol.prototype.valueOf', true);

// https://262.ecma-international.org/9.0/#sec-thissymbolvalue

module.exports = function thisSymbolValue(value) {
	if (typeof value === 'symbol') {
		return value;
	}

	if (!$SymbolValueOf) {
		throw new $SyntaxError('Symbols are not supported; thisSymbolValue requires that `value` be a Symbol or a Symbol object');
	}

	return $SymbolValueOf(value);
};
'use strict';

var timeValue = require('../helpers/timeValue');

// https://262.ecma-international.org/6.0/#sec-properties-of-the-date-prototype-object

module.exports = function thisTimeValue(value) {
	return timeValue(value);
};
'use strict';

var CompletionRecord = require('./CompletionRecord');

// https://262.ecma-international.org/9.0/#sec-throwcompletion

module.exports = function ThrowCompletion(argument) {
	return new CompletionRecord('throw', argument);
};
'use strict';

var GetIntrinsic = require('get-intrinsic');

var $Date = GetIntrinsic('%Date%');

var $isFinite = require('math-intrinsics/isFinite');
var abs = require('math-intrinsics/abs');

var ToNumber = require('./ToNumber');

// https://262.ecma-international.org/5.1/#sec-15.9.1.14

module.exports = function TimeClip(time) {
	if (!$isFinite(time) || abs(time) > 8.64e15) {
		return NaN;
	}
	return +new $Date(ToNumber(time));
};

'use strict';

var msPerDay = require('../helpers/timeConstants').msPerDay;

var DayFromYear = require('./DayFromYear');

// https://262.ecma-international.org/5.1/#sec-15.9.1.3

module.exports = function TimeFromYear(y) {
	return msPerDay * DayFromYear(y);
};
'use strict';

var $TypeError = require('es-errors/type');

var $isNaN = require('math-intrinsics/isNaN');
var padTimeComponent = require('../helpers/padTimeComponent');

var HourFromTime = require('./HourFromTime');
var MinFromTime = require('./MinFromTime');
var SecFromTime = require('./SecFromTime');

// https://262.ecma-international.org/9.0/#sec-timestring

module.exports = function TimeString(tv) {
	if (typeof tv !== 'number' || $isNaN(tv)) {
		throw new $TypeError('Assertion failed: `tv` must be a non-NaN Number');
	}
	var hour = HourFromTime(tv);
	var minute = MinFromTime(tv);
	var second = SecFromTime(tv);
	return padTimeComponent(hour) + ':' + padTimeComponent(minute) + ':' + padTimeComponent(second) + '\x20GMT';
};
'use strict';

var modulo = require('./modulo');

var msPerDay = require('../helpers/timeConstants').msPerDay;

// https://262.ecma-international.org/5.1/#sec-15.9.1.2

module.exports = function TimeWithinDay(t) {
	return modulo(t, msPerDay);
};

'use strict';

var GetIntrinsic = require('get-intrinsic');

var $Date = GetIntrinsic('%Date%');
var $TypeError = require('es-errors/type');

var isNaN = require('math-intrinsics/isNaN');

var callBound = require('call-bound');

var $indexOf = callBound('String.prototype.indexOf');
var $slice = callBound('String.prototype.slice');
var $toTimeString = callBound('Date.prototype.toTimeString');

// https://262.ecma-international.org/12.0/#sec-timezoneestring

module.exports = function TimeZoneString(tv) {
	if (typeof tv !== 'number' || isNaN(tv)) {
		throw new $TypeError('Assertion failed: `tv` must be a non-NaN Number'); // steps 1 - 2
	}

	// 3. Let offset be LocalTZA(tv, true).
	// 4. If offset ≥ +0𝔽, then
	//   a. Let offsetSign be "+".
	//   b. Let absOffset be offset.
	// 5. Else,
	//   a. Let offsetSign be "-".
	//   b. Let absOffset be -offset.
	// 6. Let offsetMin be the String representation of MinFromTime(absOffset), formatted as a two-digit decimal number, padded to the left with the code unit 0x0030 (DIGIT ZERO) if necessary.
	// 7. Let offsetHour be the String representation of HourFromTime(absOffset), formatted as a two-digit decimal number, padded to the left with the code unit 0x0030 (DIGIT ZERO) if necessary.
	// 8. Let tzName be an implementation-defined string that is either the empty String or the string-concatenation of the code unit 0x0020 (SPACE), the code unit 0x0028 (LEFT PARENTHESIS), an implementation-defined timezone name, and the code unit 0x0029 (RIGHT PARENTHESIS).
	// 9. Return the string-concatenation of offsetSign, offsetHour, offsetMin, and tzName.

	// hack until LocalTZA, and "implementation-defined string" are available
	var ts = $toTimeString(new $Date(tv));
	return $slice(ts, $indexOf(ts, '(') + 1, $indexOf(ts, ')'));
};
'use strict';

var GetIntrinsic = require('get-intrinsic');

var $BigInt = GetIntrinsic('%BigInt%', true);
var $pow = require('math-intrinsics/pow');

var ToBigInt = require('./ToBigInt');
var BigIntRemainder = require('./BigInt/remainder');

var modBigInt = require('../helpers/modBigInt');

// BigInt(2**63), but node v10.4-v10.8 have a bug where you can't `BigInt(x)` anything larger than MAX_SAFE_INTEGER
var twoSixtyThree = $BigInt && (BigInt($pow(2, 32)) * BigInt($pow(2, 31)));

// BigInt(2**64), but node v10.4-v10.8 have a bug where you can't `BigInt(x)` anything larger than MAX_SAFE_INTEGER
var twoSixtyFour = $BigInt && (BigInt($pow(2, 32)) * BigInt($pow(2, 32)));

// https://262.ecma-international.org/11.0/#sec-tobigint64

module.exports = function ToBigInt64(argument) {
	var n = ToBigInt(argument);
	var int64bit = modBigInt(BigIntRemainder, n, twoSixtyFour);
	return int64bit >= twoSixtyThree ? int64bit - twoSixtyFour : int64bit;
};
'use strict';

var GetIntrinsic = require('get-intrinsic');

var $BigInt = GetIntrinsic('%BigInt%', true);
var $Number = GetIntrinsic('%Number%');
var $TypeError = require('es-errors/type');
var $SyntaxError = require('es-errors/syntax');

var StringToBigInt = require('./StringToBigInt');
var ToPrimitive = require('./ToPrimitive');

var isNaN = require('math-intrinsics/isNaN');

// https://262.ecma-international.org/11.0/#sec-tobigint

module.exports = function ToBigInt(argument) {
	if (!$BigInt) {
		throw new $SyntaxError('BigInts are not supported in this environment');
	}

	var prim = ToPrimitive(argument, $Number);

	if (prim == null) {
		throw new $TypeError('Cannot convert null or undefined to a BigInt');
	}

	if (typeof prim === 'boolean') {
		return prim ? $BigInt(1) : $BigInt(0);
	}

	if (typeof prim === 'number') {
		throw new $TypeError('Cannot convert a Number value to a BigInt');
	}

	if (typeof prim === 'string') {
		var n = StringToBigInt(prim);
		if (isNaN(n)) {
			throw new $TypeError('Failed to parse String to BigInt');
		}
		return n;
	}

	if (typeof prim === 'symbol') {
		throw new $TypeError('Cannot convert a Symbol value to a BigInt');
	}

	if (typeof prim !== 'bigint') {
		throw new $SyntaxError('Assertion failed: unknown primitive type');
	}

	return prim;
};
'use strict';

var GetIntrinsic = require('get-intrinsic');

var $BigInt = GetIntrinsic('%BigInt%', true);

var $pow = require('math-intrinsics/pow');

var ToBigInt = require('./ToBigInt');
var BigIntRemainder = require('./BigInt/remainder');

var modBigInt = require('../helpers/modBigInt');

// BigInt(2**64), but node v10.4-v10.8 have a bug where you can't `BigInt(x)` anything larger than MAX_SAFE_INTEGER
var twoSixtyFour = $BigInt && (BigInt($pow(2, 32)) * BigInt($pow(2, 32)));

// https://262.ecma-international.org/11.0/#sec-tobiguint64

module.exports = function ToBigUint64(argument) {
	var n = ToBigInt(argument);
	var int64bit = modBigInt(BigIntRemainder, n, twoSixtyFour);
	return int64bit;
};
'use strict';

// http://262.ecma-international.org/5.1/#sec-9.2

module.exports = function ToBoolean(value) { return !!value; };
'use strict';

var GetIntrinsic = require('get-intrinsic');

var $TypeError = require('es-errors/type');
var $Date = GetIntrinsic('%Date%');
var $String = GetIntrinsic('%String%');

var $isNaN = require('math-intrinsics/isNaN');

// https://262.ecma-international.org/6.0/#sec-todatestring

module.exports = function ToDateString(tv) {
	if (typeof tv !== 'number') {
		throw new $TypeError('Assertion failed: `tv` must be a Number');
	}
	if ($isNaN(tv)) {
		return 'Invalid Date';
	}
	return $String(new $Date(tv));
};
'use strict';

var $RangeError = require('es-errors/range');

var ToIntegerOrInfinity = require('./ToIntegerOrInfinity');
var ToLength = require('./ToLength');
var SameValue = require('./SameValue');

// https://262.ecma-international.org/8.0/#sec-toindex

module.exports = function ToIndex(value) {
	if (typeof value === 'undefined') {
		return 0;
	}
	var integerIndex = ToIntegerOrInfinity(value);
	if (integerIndex < 0) {
		throw new $RangeError('index must be >= 0');
	}
	var index = ToLength(integerIndex);
	if (!SameValue(integerIndex, index)) {
		throw new $RangeError('index must be >= 0 and < 2 ** 53 - 1');
	}
	return index;
};
'use strict';

var ToUint16 = require('./ToUint16');

// https://262.ecma-international.org/6.0/#sec-toint16

module.exports = function ToInt16(argument) {
	var int16bit = ToUint16(argument);
	return int16bit >= 0x8000 ? int16bit - 0x10000 : int16bit;
};
'use strict';

var ToNumber = require('./ToNumber');

// http://262.ecma-international.org/5.1/#sec-9.5

module.exports = function ToInt32(x) {
	return ToNumber(x) >> 0;
};
'use strict';

var ToUint8 = require('./ToUint8');

// https://262.ecma-international.org/6.0/#sec-toint8

module.exports = function ToInt8(argument) {
	var int8bit = ToUint8(argument);
	return int8bit >= 0x80 ? int8bit - 0x100 : int8bit;
};
'use strict';

var abs = require('./abs');
var floor = require('./floor');
var ToNumber = require('./ToNumber');

var $isNaN = require('math-intrinsics/isNaN');
var $isFinite = require('math-intrinsics/isFinite');
var $sign = require('math-intrinsics/sign');

// https://262.ecma-international.org/12.0/#sec-tointegerorinfinity

module.exports = function ToIntegerOrInfinity(value) {
	var number = ToNumber(value);
	if ($isNaN(number) || number === 0) { return 0; }
	if (!$isFinite(number)) { return number; }
	var integer = floor(abs(number));
	if (integer === 0) { return 0; }
	return $sign(number) * integer;
};
'use strict';

var MAX_SAFE_INTEGER = require('math-intrinsics/constants/maxSafeInteger');

var ToIntegerOrInfinity = require('./ToIntegerOrInfinity');

// https://262.ecma-international.org/12.0/#sec-tolength

module.exports = function ToLength(argument) {
	var len = ToIntegerOrInfinity(argument);
	if (len <= 0) { return 0; } // includes converting -0 to +0
	if (len > MAX_SAFE_INTEGER) { return MAX_SAFE_INTEGER; }
	return len;
};
'use strict';

var GetIntrinsic = require('get-intrinsic');

var $TypeError = require('es-errors/type');
var $Number = GetIntrinsic('%Number%');
var $RegExp = GetIntrinsic('%RegExp%');
var $parseInteger = GetIntrinsic('%parseInt%');

var callBound = require('call-bound');
var regexTester = require('safe-regex-test');
var isPrimitive = require('../helpers/isPrimitive');

var $strSlice = callBound('String.prototype.slice');
var isBinary = regexTester(/^0b[01]+$/i);
var isOctal = regexTester(/^0o[0-7]+$/i);
var isInvalidHexLiteral = regexTester(/^[-+]0x[0-9a-f]+$/i);
var nonWS = ['\u0085', '\u200b', '\ufffe'].join('');
var nonWSregex = new $RegExp('[' + nonWS + ']', 'g');
var hasNonWS = regexTester(nonWSregex);

var $trim = require('string.prototype.trim');

var ToPrimitive = require('./ToPrimitive');

// https://262.ecma-international.org/6.0/#sec-tonumber

module.exports = function ToNumber(argument) {
	var value = isPrimitive(argument) ? argument : ToPrimitive(argument, $Number);
	if (typeof value === 'symbol') {
		throw new $TypeError('Cannot convert a Symbol value to a number');
	}
	if (typeof value === 'bigint') {
		throw new $TypeError('Conversion from \'BigInt\' to \'number\' is not allowed.');
	}
	if (typeof value === 'string') {
		if (isBinary(value)) {
			return ToNumber($parseInteger($strSlice(value, 2), 2));
		} else if (isOctal(value)) {
			return ToNumber($parseInteger($strSlice(value, 2), 8));
		} else if (hasNonWS(value) || isInvalidHexLiteral(value)) {
			return NaN;
		}
		var trimmed = $trim(value);
		if (trimmed !== value) {
			return ToNumber(trimmed);
		}

	}
	return +value;
};
'use strict';

var GetIntrinsic = require('get-intrinsic');

var $Number = GetIntrinsic('%Number%');

var isPrimitive = require('../helpers/isPrimitive');

var ToPrimitive = require('./ToPrimitive');
var ToNumber = require('./ToNumber');

// https://262.ecma-international.org/11.0/#sec-tonumeric

module.exports = function ToNumeric(argument) {
	var primValue = isPrimitive(argument) ? argument : ToPrimitive(argument, $Number);
	if (typeof primValue === 'bigint') {
		return primValue;
	}
	return ToNumber(primValue);
};
'use strict';

// https://262.ecma-international.org/6.0/#sec-toobject

module.exports = require('es-object-atoms/ToObject');
'use strict';

var toPrimitive = require('es-to-primitive/es2015');

// https://262.ecma-international.org/6.0/#sec-toprimitive

module.exports = function ToPrimitive(input) {
	if (arguments.length > 1) {
		return toPrimitive(input, arguments[1]);
	}
	return toPrimitive(input);
};
'use strict';

var hasOwn = require('hasown');

var $TypeError = require('es-errors/type');
var isObject = require('es-object-atoms/isObject');

var IsCallable = require('./IsCallable');
var ToBoolean = require('./ToBoolean');

// https://262.ecma-international.org/5.1/#sec-8.10.5

module.exports = function ToPropertyDescriptor(Obj) {
	if (!isObject(Obj)) {
		throw new $TypeError('ToPropertyDescriptor requires an object');
	}

	var desc = {};
	if (hasOwn(Obj, 'enumerable')) {
		desc['[[Enumerable]]'] = ToBoolean(Obj.enumerable);
	}
	if (hasOwn(Obj, 'configurable')) {
		desc['[[Configurable]]'] = ToBoolean(Obj.configurable);
	}
	if (hasOwn(Obj, 'value')) {
		desc['[[Value]]'] = Obj.value;
	}
	if (hasOwn(Obj, 'writable')) {
		desc['[[Writable]]'] = ToBoolean(Obj.writable);
	}
	if (hasOwn(Obj, 'get')) {
		var getter = Obj.get;
		if (typeof getter !== 'undefined' && !IsCallable(getter)) {
			throw new $TypeError('getter must be a function');
		}
		desc['[[Get]]'] = getter;
	}
	if (hasOwn(Obj, 'set')) {
		var setter = Obj.set;
		if (typeof setter !== 'undefined' && !IsCallable(setter)) {
			throw new $TypeError('setter must be a function');
		}
		desc['[[Set]]'] = setter;
	}

	if ((hasOwn(desc, '[[Get]]') || hasOwn(desc, '[[Set]]')) && (hasOwn(desc, '[[Value]]') || hasOwn(desc, '[[Writable]]'))) {
		throw new $TypeError('Invalid property descriptor. Cannot both specify accessors and a value or writable attribute');
	}
	return desc;
};
'use strict';

var GetIntrinsic = require('get-intrinsic');

var $String = GetIntrinsic('%String%');

var ToPrimitive = require('./ToPrimitive');
var ToString = require('./ToString');

// https://262.ecma-international.org/6.0/#sec-topropertykey

module.exports = function ToPropertyKey(argument) {
	var key = ToPrimitive(argument, $String);
	return typeof key === 'symbol' ? key : ToString(key);
};
'use strict';

var GetIntrinsic = require('get-intrinsic');

var $String = GetIntrinsic('%String%');
var $TypeError = require('es-errors/type');

// https://262.ecma-international.org/6.0/#sec-tostring

module.exports = function ToString(argument) {
	if (typeof argument === 'symbol') {
		throw new $TypeError('Cannot convert a Symbol value to a string');
	}
	return $String(argument);
};
'use strict';

var modulo = require('./modulo');
var ToNumber = require('./ToNumber');

var abs = require('math-intrinsics/abs');
var floor = require('math-intrinsics/floor');
var $isNaN = require('math-intrinsics/isNaN');
var $isFinite = require('math-intrinsics/isFinite');
var $sign = require('math-intrinsics/sign');

// http://262.ecma-international.org/5.1/#sec-9.7

module.exports = function ToUint16(value) {
	var number = ToNumber(value);
	if ($isNaN(number) || number === 0 || !$isFinite(number)) { return 0; }
	var posInt = $sign(number) * floor(abs(number));
	return modulo(posInt, 0x10000);
};
'use strict';

var ToNumber = require('./ToNumber');

// http://262.ecma-international.org/5.1/#sec-9.6

module.exports = function ToUint32(x) {
	return ToNumber(x) >>> 0;
};
'use strict';

var ToNumber = require('./ToNumber');
var floor = require('./floor');

var $isNaN = require('math-intrinsics/isNaN');

// https://262.ecma-international.org/6.0/#sec-touint8clamp

module.exports = function ToUint8Clamp(argument) {
	var number = ToNumber(argument);
	if ($isNaN(number) || number <= 0) { return 0; }
	if (number >= 0xFF) { return 0xFF; }
	var f = floor(number);
	if (f + 0.5 < number) { return f + 1; }
	if (number < f + 0.5) { return f; }
	if (f % 2 !== 0) { return f + 1; }
	return f;
};
'use strict';

var ToNumber = require('./ToNumber');

var $isNaN = require('math-intrinsics/isNaN');
var $isFinite = require('math-intrinsics/isFinite');
var $sign = require('math-intrinsics/sign');
var abs = require('math-intrinsics/abs');
var floor = require('math-intrinsics/floor');
var modulo = require('math-intrinsics/mod');

// https://262.ecma-international.org/6.0/#sec-touint8

module.exports = function ToUint8(argument) {
	var number = ToNumber(argument);
	if ($isNaN(number) || number === 0 || !$isFinite(number)) { return 0; }
	var posInt = $sign(number) * floor(abs(number));
	return modulo(posInt, 0x100);
};
'use strict';

var trimStart = require('string.prototype.trimstart');
var trimEnd = require('string.prototype.trimend');

var $TypeError = require('es-errors/type');

var RequireObjectCoercible = require('./RequireObjectCoercible');
var ToString = require('./ToString');

// https://262.ecma-international.org/10.0/#sec-trimstring

module.exports = function TrimString(string, where) {
	var str = RequireObjectCoercible(string);
	var S = ToString(str);
	var T;
	if (where === 'start') {
		T = trimStart(S);
	} else if (where === 'end') {
		T = trimEnd(S);
	} else if (where === 'start+end') {
		T = trimStart(trimEnd(S));
	} else {
		throw new $TypeError('Assertion failed: invalid `where` value; must be "start", "end", or "start+end"');
	}
	return T;
};
'use strict';

var $SyntaxError = require('es-errors/syntax');
var $TypeError = require('es-errors/type');

var IsArray = require('./IsArray');
var IsConstructor = require('./IsConstructor');
var ValidateTypedArray = require('./ValidateTypedArray');

var availableTypedArrays = require('available-typed-arrays')();
var typedArrayLength = require('typed-array-length');

// https://262.ecma-international.org/7.0/#typedarray-create

module.exports = function TypedArrayCreate(constructor, argumentList) {
	if (!IsConstructor(constructor)) {
		throw new $TypeError('Assertion failed: `constructor` must be a constructor');
	}
	if (!IsArray(argumentList)) {
		throw new $TypeError('Assertion failed: `argumentList` must be a List');
	}
	if (availableTypedArrays.length === 0) {
		throw new $SyntaxError('Assertion failed: Typed Arrays are not supported in this environment');
	}

	// var newTypedArray = Construct(constructor, argumentList); // step 1
	var newTypedArray;
	if (argumentList.length === 0) {
		newTypedArray = new constructor();
	} else if (argumentList.length === 1) {
		newTypedArray = new constructor(argumentList[0]);
	} else if (argumentList.length === 2) {
		newTypedArray = new constructor(argumentList[0], argumentList[1]);
	} else {
		newTypedArray = new constructor(argumentList[0], argumentList[1], argumentList[2]);
	}

	ValidateTypedArray(newTypedArray); // step 2

	if (argumentList.length === 1 && typeof argumentList[0] === 'number') { // step 3
		if (typedArrayLength(newTypedArray) < argumentList[0]) {
			throw new $TypeError('Assertion failed: `argumentList[0]` must be <= `newTypedArray.length`'); // step 3.a
		}
	}

	return newTypedArray; // step 4
};
'use strict';

var $SyntaxError = require('es-errors/syntax');
var $TypeError = require('es-errors/type');

var whichTypedArray = require('which-typed-array');
var availableTypedArrays = require('available-typed-arrays')();

var IsArray = require('./IsArray');
var SpeciesConstructor = require('./SpeciesConstructor');
var TypedArrayCreate = require('./TypedArrayCreate');

var getConstructor = require('../helpers/typedArrayConstructors');

// https://262.ecma-international.org/7.0/#typedarray-species-create

module.exports = function TypedArraySpeciesCreate(exemplar, argumentList) {
	if (availableTypedArrays.length === 0) {
		throw new $SyntaxError('Assertion failed: Typed Arrays are not supported in this environment');
	}

	var kind = whichTypedArray(exemplar);
	if (!kind) {
		throw new $TypeError('Assertion failed: exemplar must be a TypedArray'); // step 1
	}
	if (!IsArray(argumentList)) {
		throw new $TypeError('Assertion failed: `argumentList` must be a List'); // step 1
	}

	var defaultConstructor = getConstructor(kind); // step 2
	if (typeof defaultConstructor !== 'function') {
		throw new $SyntaxError('Assertion failed: `constructor` of `exemplar` (' + kind + ') must exist. Please report this!');
	}
	var constructor = SpeciesConstructor(exemplar, defaultConstructor); // step 3

	return TypedArrayCreate(constructor, argumentList); // step 4
};
'use strict';

var ES5Type = require('../5/Type');

// https://262.ecma-international.org/11.0/#sec-ecmascript-data-types-and-values

module.exports = function Type(x) {
	if (typeof x === 'symbol') {
		return 'Symbol';
	}
	if (typeof x === 'bigint') {
		return 'BigInt';
	}
	return ES5Type(x);
};
'use strict';

var $TypeError = require('es-errors/type');

var callBound = require('call-bound');

var $charCodeAt = callBound('String.prototype.charCodeAt');
var $numberToString = callBound('Number.prototype.toString');
var $toLowerCase = callBound('String.prototype.toLowerCase');

var StringPad = require('./StringPad');

// https://262.ecma-international.org/11.0/#sec-unicodeescape

module.exports = function UnicodeEscape(C) {
	if (typeof C !== 'string' || C.length !== 1) {
		throw new $TypeError('Assertion failed: `C` must be a single code unit');
	}
	var n = $charCodeAt(C, 0);
	if (n > 0xFFFF) {
		throw new $TypeError('`Assertion failed: numeric value of `C` must be <= 0xFFFF');
	}

	return '\\u' + StringPad($toLowerCase($numberToString(n, 16)), 4, '0', 'start');
};
'use strict';

var GetIntrinsic = require('get-intrinsic');

var $TypeError = require('es-errors/type');
var $fromCharCode = GetIntrinsic('%String.fromCharCode%');

var floor = require('./floor');
var modulo = require('./modulo');

var isCodePoint = require('../helpers/isCodePoint');

// https://262.ecma-international.org/12.0/#sec-utf16encoding

module.exports = function UTF16EncodeCodePoint(cp) {
	if (!isCodePoint(cp)) {
		throw new $TypeError('Assertion failed: `cp` must be >= 0 and <= 0x10FFFF');
	}
	if (cp <= 65535) {
		return $fromCharCode(cp);
	}
	var cu1 = $fromCharCode(floor((cp - 65536) / 1024) + 0xD800);
	var cu2 = $fromCharCode(modulo(cp - 65536, 1024) + 0xDC00);
	return cu1 + cu2;
};
'use strict';

var GetIntrinsic = require('get-intrinsic');

var $TypeError = require('es-errors/type');
var $fromCharCode = GetIntrinsic('%String.fromCharCode%');

var isLeadingSurrogate = require('../helpers/isLeadingSurrogate');
var isTrailingSurrogate = require('../helpers/isTrailingSurrogate');

// https://262.ecma-international.org/12.0/#sec-utf16decodesurrogatepair

module.exports = function UTF16SurrogatePairToCodePoint(lead, trail) {
	if (!isLeadingSurrogate(lead) || !isTrailingSurrogate(trail)) {
		throw new $TypeError('Assertion failed: `lead` must be a leading surrogate char code, and `trail` must be a trailing surrogate char code');
	}
	// var cp = (lead - 0xD800) * 0x400 + (trail - 0xDC00) + 0x10000;
	return $fromCharCode(lead) + $fromCharCode(trail);
};
'use strict';

var $TypeError = require('es-errors/type');
var isObject = require('es-object-atoms/isObject');

var DefineOwnProperty = require('../helpers/DefineOwnProperty');
var isPropertyDescriptor = require('../helpers/records/property-descriptor');
var isSamePropertyDescriptor = require('../helpers/isSamePropertyDescriptor');

var FromPropertyDescriptor = require('./FromPropertyDescriptor');
var IsAccessorDescriptor = require('./IsAccessorDescriptor');
var IsDataDescriptor = require('./IsDataDescriptor');
var IsGenericDescriptor = require('./IsGenericDescriptor');
var isPropertyKey = require('../helpers/isPropertyKey');
var SameValue = require('./SameValue');

// https://262.ecma-international.org/6.0/#sec-validateandapplypropertydescriptor
// https://262.ecma-international.org/8.0/#sec-validateandapplypropertydescriptor

// eslint-disable-next-line max-lines-per-function, max-statements
module.exports = function ValidateAndApplyPropertyDescriptor(O, P, extensible, Desc, current) {
	// this uses the ES2017+ logic, since it fixes a number of bugs in the ES2015 logic.
	if (typeof O !== 'undefined' && !isObject(O)) {
		throw new $TypeError('Assertion failed: O must be undefined or an Object');
	}
	if (typeof extensible !== 'boolean') {
		throw new $TypeError('Assertion failed: extensible must be a Boolean');
	}
	if (!isPropertyDescriptor(Desc)) {
		throw new $TypeError('Assertion failed: Desc must be a Property Descriptor');
	}
	if (typeof current !== 'undefined' && !isPropertyDescriptor(current)) {
		throw new $TypeError('Assertion failed: current must be a Property Descriptor, or undefined');
	}
	if (typeof O !== 'undefined' && !isPropertyKey(P)) {
		throw new $TypeError('Assertion failed: if O is not undefined, P must be a Property Key');
	}
	if (typeof current === 'undefined') {
		if (!extensible) {
			return false;
		}
		if (IsGenericDescriptor(Desc) || IsDataDescriptor(Desc)) {
			if (typeof O !== 'undefined') {
				DefineOwnProperty(
					IsDataDescriptor,
					SameValue,
					FromPropertyDescriptor,
					O,
					P,
					{
						'[[Configurable]]': Desc['[[Configurable]]'],
						'[[Enumerable]]': Desc['[[Enumerable]]'],
						'[[Value]]': Desc['[[Value]]'],
						'[[Writable]]': Desc['[[Writable]]']
					}
				);
			}
		} else {
			if (!IsAccessorDescriptor(Desc)) {
				throw new $TypeError('Assertion failed: Desc is not an accessor descriptor');
			}
			if (typeof O !== 'undefined') {
				return DefineOwnProperty(
					IsDataDescriptor,
					SameValue,
					FromPropertyDescriptor,
					O,
					P,
					Desc
				);
			}
		}
		return true;
	}
	if (IsGenericDescriptor(Desc) && !('[[Configurable]]' in Desc) && !('[[Enumerable]]' in Desc)) {
		return true;
	}
	if (isSamePropertyDescriptor({ SameValue: SameValue }, Desc, current)) {
		return true; // removed by ES2017, but should still be correct
	}
	// "if every field in Desc is absent, return true" can't really match the assertion that it's a Property Descriptor
	if (!current['[[Configurable]]']) {
		if (Desc['[[Configurable]]']) {
			return false;
		}
		if ('[[Enumerable]]' in Desc && !Desc['[[Enumerable]]'] === !!current['[[Enumerable]]']) {
			return false;
		}
	}
	if (IsGenericDescriptor(Desc)) {
		// no further validation is required.
	} else if (IsDataDescriptor(current) !== IsDataDescriptor(Desc)) {
		if (!current['[[Configurable]]']) {
			return false;
		}
		if (IsDataDescriptor(current)) {
			if (typeof O !== 'undefined') {
				DefineOwnProperty(
					IsDataDescriptor,
					SameValue,
					FromPropertyDescriptor,
					O,
					P,
					{
						'[[Configurable]]': current['[[Configurable]]'],
						'[[Enumerable]]': current['[[Enumerable]]'],
						'[[Get]]': undefined
					}
				);
			}
		} else if (typeof O !== 'undefined') {
			DefineOwnProperty(
				IsDataDescriptor,
				SameValue,
				FromPropertyDescriptor,
				O,
				P,
				{
					'[[Configurable]]': current['[[Configurable]]'],
					'[[Enumerable]]': current['[[Enumerable]]'],
					'[[Value]]': undefined
				}
			);
		}
	} else if (IsDataDescriptor(current) && IsDataDescriptor(Desc)) {
		if (!current['[[Configurable]]'] && !current['[[Writable]]']) {
			if ('[[Writable]]' in Desc && Desc['[[Writable]]']) {
				return false;
			}
			if ('[[Value]]' in Desc && !SameValue(Desc['[[Value]]'], current['[[Value]]'])) {
				return false;
			}
			return true;
		}
	} else if (IsAccessorDescriptor(current) && IsAccessorDescriptor(Desc)) {
		if (!current['[[Configurable]]']) {
			if ('[[Set]]' in Desc && !SameValue(Desc['[[Set]]'], current['[[Set]]'])) {
				return false;
			}
			if ('[[Get]]' in Desc && !SameValue(Desc['[[Get]]'], current['[[Get]]'])) {
				return false;
			}
			return true;
		}
	} else {
		throw new $TypeError('Assertion failed: current and Desc are not both data, both accessors, or one accessor and one data.');
	}
	if (typeof O !== 'undefined') {
		return DefineOwnProperty(
			IsDataDescriptor,
			SameValue,
			FromPropertyDescriptor,
			O,
			P,
			Desc
		);
	}
	return true;
};
'use strict';

var $RangeError = require('es-errors/range');
var $TypeError = require('es-errors/type');

var ToIndex = require('./ToIndex');

var isTypedArray = require('is-typed-array');
var typedArrayByteOffset = require('typed-array-byte-offset');
var typedArrayLength = require('typed-array-length');
var whichTypedArray = require('which-typed-array');

var tableTAO = require('./tables/typed-array-objects');

// https://262.ecma-international.org/12.0/#sec-validateatomicaccess

module.exports = function ValidateAtomicAccess(typedArray, requestIndex) {
	if (!isTypedArray(typedArray)) {
		throw new $TypeError('Assertion failed: `typedArray` must be a TypedArray'); // step 1
	}

	var length = typedArrayLength(typedArray); // step 2

	var accessIndex = ToIndex(requestIndex); // step 3

	/*
	// this assertion can never be reached
	if (!(accessIndex >= 0)) {
		throw new $TypeError('Assertion failed: accessIndex >= 0'); // step 4
	}
	*/

	if (accessIndex >= length) {
		throw new $RangeError('index out of range'); // step 5
	}

	var arrayTypeName = whichTypedArray(typedArray); // step 6

	var taType = tableTAO.name['$' + arrayTypeName];
	var elementSize = tableTAO.size['$' + taType]; // step 7

	var offset = typedArrayByteOffset(typedArray); // step 8

	return (accessIndex * elementSize) + offset; // step 9
};
'use strict';

var $TypeError = require('es-errors/type');

var IsBigIntElementType = require('./IsBigIntElementType');
var IsUnclampedIntegerElementType = require('./IsUnclampedIntegerElementType');
var ValidateTypedArray = require('./ValidateTypedArray');

var whichTypedArray = require('which-typed-array');

// https://262.ecma-international.org/12.0/#sec-validateintegertypedarray

var tableTAO = require('./tables/typed-array-objects');

module.exports = function ValidateIntegerTypedArray(typedArray) {
	var waitable = arguments.length > 1 ? arguments[1] : false; // step 1

	if (typeof waitable !== 'boolean') {
		throw new $TypeError('Assertion failed: `waitable` must be a Boolean');
	}

	var buffer = ValidateTypedArray(typedArray); // step 2

	var typeName = whichTypedArray(typedArray); // step 3

	var type = tableTAO.name['$' + typeName]; // step 4

	if (waitable) { // step 5
		if (typeName !== 'Int32Array' && typeName !== 'BigInt64Array') {
			throw new $TypeError('Assertion failed: `typedArray` must be an Int32Array or BigInt64Array when `waitable` is true'); // step 5.a
		}
	} else if (!IsUnclampedIntegerElementType(type) && !IsBigIntElementType(type)) {
		throw new $TypeError('Assertion failed: `typedArray` must be an integer TypedArray'); // step 6.a
	}

	return buffer; // step 7
};
'use strict';

var $TypeError = require('es-errors/type');
var isObject = require('es-object-atoms/isObject');

var IsDetachedBuffer = require('./IsDetachedBuffer');

var isTypedArray = require('is-typed-array');
var typedArrayBuffer = require('typed-array-buffer');

// https://262.ecma-international.org/6.0/#sec-validatetypedarray

module.exports = function ValidateTypedArray(O) {
	if (!isObject(O)) {
		throw new $TypeError('Assertion failed: `O` must be an Object'); // step 1
	}
	if (!isTypedArray(O)) {
		throw new $TypeError('Assertion failed: `O` must be a Typed Array'); // steps 2 - 3
	}

	var buffer = typedArrayBuffer(O); // step 4

	if (IsDetachedBuffer(buffer)) {
		throw new $TypeError('`O` must be backed by a non-detached buffer'); // step 5
	}

	return buffer; // step 6
};
'use strict';

var callBound = require('call-bound');

var $TypeError = require('es-errors/type');
var $deref = callBound('WeakRef.prototype.deref', true);

var isWeakRef = require('is-weakref');

var AddToKeptObjects = require('./AddToKeptObjects');

// https://262.ecma-international.org/12.0/#sec-weakrefderef

module.exports = function WeakRefDeref(weakRef) {
	if (!isWeakRef(weakRef)) {
		throw new $TypeError('Assertion failed: `weakRef` must be a WeakRef');
	}
	var target = $deref(weakRef);
	if (target) {
		AddToKeptObjects(target);
	}
	return target;
};
'use strict';

var Day = require('./Day');
var modulo = require('./modulo');

// https://262.ecma-international.org/5.1/#sec-15.9.1.6

module.exports = function WeekDay(t) {
	return modulo(Day(t) + 4, 7);
};
'use strict';

var $TypeError = require('es-errors/type');

var callBound = require('call-bound');
var $indexOf = callBound('String.prototype.indexOf');

var Canonicalize = require('./Canonicalize');

var caseFolding = require('../helpers/caseFolding.json');
var forEach = require('../helpers/forEach');
var OwnPropertyKeys = require('own-keys');

var A = 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789_'; // step 1

// https://262.ecma-international.org/8.0/#sec-runtime-semantics-wordcharacters-abstract-operation

module.exports = function WordCharacters(IgnoreCase, Unicode) {
	if (typeof IgnoreCase !== 'boolean' || typeof Unicode !== 'boolean') {
		throw new $TypeError('Assertion failed: `IgnoreCase` and `Unicode` must be booleans');
	}

	var U = '';
	forEach(OwnPropertyKeys(caseFolding.C), function (c) {
		if (
			$indexOf(A, c) === -1 // c not in A
			&& $indexOf(A, Canonicalize(c, IgnoreCase, Unicode)) > -1 // canonicalized c IS in A
		) {
			U += caseFolding.C[c]; // step 3
		}
	});
	forEach(OwnPropertyKeys(caseFolding.S), function (c) {
		if (
			$indexOf(A, c) === -1 // c not in A
			&& $indexOf(A, Canonicalize(c, IgnoreCase, Unicode)) > -1 // canonicalized c IS in A
		) {
			U += caseFolding.S[c]; // step 3
		}
	});

	if ((!Unicode || !IgnoreCase) && U.length > 0) {
		throw new $TypeError('Assertion failed: `U` must be empty when `IgnoreCase` and `Unicode` are not both true'); // step 4
	}

	return A + U; // step 5, 6
};
'use strict';

var GetIntrinsic = require('get-intrinsic');

var $Date = GetIntrinsic('%Date%');

var callBound = require('call-bound');

var $getUTCFullYear = callBound('Date.prototype.getUTCFullYear');

// https://262.ecma-international.org/5.1/#sec-15.9.1.3

module.exports = function YearFromTime(t) {
	// largest y such that this.TimeFromYear(y) <= t
	return $getUTCFullYear(new $Date(t));
};
'use strict';

var $abs = require('math-intrinsics/abs');

// https://262.ecma-international.org/11.0/#eqn-abs

module.exports = function abs(x) {
	return typeof x === 'bigint' ? BigInt($abs(Number(x))) : $abs(x);
};
'use strict';

var $TypeError = require('es-errors/type');
var isObject = require('es-object-atoms/isObject');
var inspect = require('object-inspect');

var Call = require('./Call');
var Get = require('./Get');
var GetIterator = require('./GetIterator');
var IsCallable = require('./IsCallable');
var IteratorClose = require('./IteratorClose');
var IteratorStep = require('./IteratorStep');
var IteratorValue = require('./IteratorValue');
var ThrowCompletion = require('./ThrowCompletion');

// https://262.ecma-international.org/10.0/#sec-add-entries-from-iterable

module.exports = function AddEntriesFromIterable(target, iterable, adder) {
	if (!IsCallable(adder)) {
		throw new $TypeError('Assertion failed: `adder` is not callable');
	}
	if (iterable == null) {
		throw new $TypeError('Assertion failed: `iterable` is present, and not nullish');
	}
	var iteratorRecord = GetIterator(iterable);
	while (true) { // eslint-disable-line no-constant-condition
		var next = IteratorStep(iteratorRecord);
		if (!next) {
			return target;
		}
		var nextItem = IteratorValue(next);
		if (!isObject(nextItem)) {
			var error = ThrowCompletion(new $TypeError('iterator next must return an Object, got ' + inspect(nextItem)));
			return IteratorClose(iteratorRecord, error);
		}
		try {
			var k = Get(nextItem, '0');
			var v = Get(nextItem, '1');
			Call(adder, target, [k, v]);
		} catch (e) {
			return IteratorClose(iteratorRecord, ThrowCompletion(e));
		}
	}
};
'use strict';

var SLOT = require('internal-slot');

var $TypeError = require('es-errors/type');
var isObject = require('es-object-atoms/isObject');

var ClearKeptObjects = require('./ClearKeptObjects');

// https://262.ecma-international.org/12.0/#sec-addtokeptobjects

module.exports = function AddToKeptObjects(object) {
	if (!isObject(object)) {
		throw new $TypeError('Assertion failed: `object` must be an Object');
	}
	var arr = SLOT.get(ClearKeptObjects, '[[es-abstract internal: KeptAlive]]');
	arr[arr.length] = object;
};
'use strict';

var CodePointAt = require('./CodePointAt');

var $TypeError = require('es-errors/type');
var isInteger = require('math-intrinsics/isInteger');
var MAX_SAFE_INTEGER = require('math-intrinsics/constants/maxSafeInteger');

// https://262.ecma-international.org/12.0/#sec-advancestringindex

module.exports = function AdvanceStringIndex(S, index, unicode) {
	if (typeof S !== 'string') {
		throw new $TypeError('Assertion failed: `S` must be a String');
	}
	if (!isInteger(index) || index < 0 || index > MAX_SAFE_INTEGER) {
		throw new $TypeError('Assertion failed: `length` must be an integer >= 0 and <= 2**53');
	}
	if (typeof unicode !== 'boolean') {
		throw new $TypeError('Assertion failed: `unicode` must be a Boolean');
	}
	if (!unicode) {
		return index + 1;
	}
	var length = S.length;
	if ((index + 1) >= length) {
		return index + 1;
	}
	var cp = CodePointAt(S, index);
	return index + cp['[[CodeUnitCount]]'];
};
'use strict';

var $TypeError = require('es-errors/type');

var HasOwnProperty = require('./HasOwnProperty');
var ToNumeric = require('./ToNumeric');
var ToPrimitive = require('./ToPrimitive');
var ToString = require('./ToString');
var Type = require('./Type');

var NumberAdd = require('./Number/add');
var NumberBitwiseAND = require('./Number/bitwiseAND');
var NumberBitwiseOR = require('./Number/bitwiseOR');
var NumberBitwiseXOR = require('./Number/bitwiseXOR');
var NumberDivide = require('./Number/divide');
var NumberExponentiate = require('./Number/exponentiate');
var NumberLeftShift = require('./Number/leftShift');
var NumberMultiply = require('./Number/multiply');
var NumberRemainder = require('./Number/remainder');
var NumberSignedRightShift = require('./Number/signedRightShift');
var NumberSubtract = require('./Number/subtract');
var NumberUnsignedRightShift = require('./Number/unsignedRightShift');
var BigIntAdd = require('./BigInt/add');
var BigIntBitwiseAND = require('./BigInt/bitwiseAND');
var BigIntBitwiseOR = require('./BigInt/bitwiseOR');
var BigIntBitwiseXOR = require('./BigInt/bitwiseXOR');
var BigIntDivide = require('./BigInt/divide');
var BigIntExponentiate = require('./BigInt/exponentiate');
var BigIntLeftShift = require('./BigInt/leftShift');
var BigIntMultiply = require('./BigInt/multiply');
var BigIntRemainder = require('./BigInt/remainder');
var BigIntSignedRightShift = require('./BigInt/signedRightShift');
var BigIntSubtract = require('./BigInt/subtract');
var BigIntUnsignedRightShift = require('./BigInt/unsignedRightShift');

// https://262.ecma-international.org/12.0/#sec-applystringornumericbinaryoperator

// https://262.ecma-international.org/12.0/#step-applystringornumericbinaryoperator-operations-table
var table = {
	'**': [NumberExponentiate, BigIntExponentiate],
	'*': [NumberMultiply, BigIntMultiply],
	'/': [NumberDivide, BigIntDivide],
	'%': [NumberRemainder, BigIntRemainder],
	'+': [NumberAdd, BigIntAdd],
	'-': [NumberSubtract, BigIntSubtract],
	'<<': [NumberLeftShift, BigIntLeftShift],
	'>>': [NumberSignedRightShift, BigIntSignedRightShift],
	'>>>': [NumberUnsignedRightShift, BigIntUnsignedRightShift],
	'&': [NumberBitwiseAND, BigIntBitwiseAND],
	'^': [NumberBitwiseXOR, BigIntBitwiseXOR],
	'|': [NumberBitwiseOR, BigIntBitwiseOR]
};

module.exports = function ApplyStringOrNumericBinaryOperator(lval, opText, rval) {
	if (typeof opText !== 'string' || !HasOwnProperty(table, opText)) {
		throw new $TypeError('Assertion failed: `opText` must be a valid operation string');
	}
	if (opText === '+') {
		var lprim = ToPrimitive(lval);
		var rprim = ToPrimitive(rval);
		if (typeof lprim === 'string' || typeof rprim === 'string') {
			var lstr = ToString(lprim);
			var rstr = ToString(rprim);
			return lstr + rstr;
		}
		/* eslint no-param-reassign: 1 */
		lval = lprim;
		rval = rprim;
	}
	var lnum = ToNumeric(lval);
	var rnum = ToNumeric(rval);
	if (Type(lnum) !== Type(rnum)) {
		throw new $TypeError('types of ' + lnum + ' and ' + rnum + ' differ');
	}
	var Operation = table[opText][typeof lnum === 'bigint' ? 1 : 0];
	return Operation(lnum, rnum);
};
'use strict';

var GetIntrinsic = require('get-intrinsic');

var $ArrayPrototype = GetIntrinsic('%Array.prototype%');
var $RangeError = require('es-errors/range');
var $SyntaxError = require('es-errors/syntax');
var $TypeError = require('es-errors/type');
var isInteger = require('math-intrinsics/isInteger');
var MAX_ARRAY_LENGTH = require('math-intrinsics/constants/maxArrayLength');
var $setProto = require('set-proto');

// https://262.ecma-international.org/12.0/#sec-arraycreate

module.exports = function ArrayCreate(length) {
	if (!isInteger(length) || length < 0) {
		throw new $TypeError('Assertion failed: `length` must be an integer Number >= 0');
	}
	if (length > MAX_ARRAY_LENGTH) {
		throw new $RangeError('length is greater than (2**32 - 1)');
	}
	var proto = arguments.length > 1 ? arguments[1] : $ArrayPrototype;
	var A = []; // steps 3, 5
	if (proto !== $ArrayPrototype) { // step 4
		if (!$setProto) {
			throw new $SyntaxError('ArrayCreate: a `proto` argument that is not `Array.prototype` is not supported in an environment that does not support setting the [[Prototype]]');
		}
		$setProto(A, proto);
	}
	if (length !== 0) { // bypasses the need for step 6
		A.length = length;
	}
	/* step 6, the above as a shortcut for the below
	OrdinaryDefineOwnProperty(A, 'length', {
		'[[Configurable]]': false,
		'[[Enumerable]]': false,
		'[[Value]]': length,
		'[[Writable]]': true
	});
	*/
	return A;
};
'use strict';

var $RangeError = require('es-errors/range');
var $TypeError = require('es-errors/type');

var assign = require('object.assign');

var isPropertyDescriptor = require('../helpers/records/property-descriptor');

var IsArray = require('./IsArray');
var IsDataDescriptor = require('./IsDataDescriptor');
var OrdinaryDefineOwnProperty = require('./OrdinaryDefineOwnProperty');
var OrdinaryGetOwnProperty = require('./OrdinaryGetOwnProperty');
var ToNumber = require('./ToNumber');
var ToString = require('./ToString');
var ToUint32 = require('./ToUint32');

// https://262.ecma-international.org/6.0/#sec-arraysetlength

// eslint-disable-next-line max-statements, max-lines-per-function
module.exports = function ArraySetLength(A, Desc) {
	if (!IsArray(A)) {
		throw new $TypeError('Assertion failed: A must be an Array');
	}
	if (!isPropertyDescriptor(Desc)) {
		throw new $TypeError('Assertion failed: Desc must be a Property Descriptor');
	}
	if (!('[[Value]]' in Desc)) {
		return OrdinaryDefineOwnProperty(A, 'length', Desc);
	}
	var newLenDesc = assign({}, Desc);
	var newLen = ToUint32(Desc['[[Value]]']);
	var numberLen = ToNumber(Desc['[[Value]]']);
	if (newLen !== numberLen) {
		throw new $RangeError('Invalid array length');
	}
	newLenDesc['[[Value]]'] = newLen;
	var oldLenDesc = OrdinaryGetOwnProperty(A, 'length');
	if (!IsDataDescriptor(oldLenDesc)) {
		throw new $TypeError('Assertion failed: an array had a non-data descriptor on `length`');
	}
	var oldLen = oldLenDesc['[[Value]]'];
	if (newLen >= oldLen) {
		return OrdinaryDefineOwnProperty(A, 'length', newLenDesc);
	}
	if (!oldLenDesc['[[Writable]]']) {
		return false;
	}
	var newWritable;
	if (!('[[Writable]]' in newLenDesc) || newLenDesc['[[Writable]]']) {
		newWritable = true;
	} else {
		newWritable = false;
		newLenDesc['[[Writable]]'] = true;
	}
	var succeeded = OrdinaryDefineOwnProperty(A, 'length', newLenDesc);
	if (!succeeded) {
		return false;
	}
	while (newLen < oldLen) {
		oldLen -= 1;
		// eslint-disable-next-line no-param-reassign
		var deleteSucceeded = delete A[ToString(oldLen)];
		if (!deleteSucceeded) {
			newLenDesc['[[Value]]'] = oldLen + 1;
			if (!newWritable) {
				newLenDesc['[[Writable]]'] = false;
				OrdinaryDefineOwnProperty(A, 'length', newLenDesc);
				return false;
			}
		}
	}
	if (!newWritable) {
		return OrdinaryDefineOwnProperty(A, 'length', { '[[Writable]]': false });
	}
	return true;
};
'use strict';

var GetIntrinsic = require('get-intrinsic');

var $species = GetIntrinsic('%Symbol.species%', true);
var $TypeError = require('es-errors/type');
var isInteger = require('math-intrinsics/isInteger');
var isObject = require('es-object-atoms/isObject');

var ArrayCreate = require('./ArrayCreate');
var Get = require('./Get');
var IsArray = require('./IsArray');
var IsConstructor = require('./IsConstructor');

// https://262.ecma-international.org/12.0/#sec-arrayspeciescreate

module.exports = function ArraySpeciesCreate(originalArray, length) {
	if (!isInteger(length) || length < 0) {
		throw new $TypeError('Assertion failed: length must be an integer >= 0');
	}

	var isArray = IsArray(originalArray);
	if (!isArray) {
		return ArrayCreate(length);
	}

	var C = Get(originalArray, 'constructor');
	// TODO: figure out how to make a cross-realm normal Array, a same-realm Array
	// if (IsConstructor(C)) {
	// 	if C is another realm's Array, C = undefined
	// 	Object.getPrototypeOf(Object.getPrototypeOf(Object.getPrototypeOf(Array))) === null ?
	// }
	if ($species && isObject(C)) {
		C = Get(C, $species);
		if (C === null) {
			C = void 0;
		}
	}

	if (typeof C === 'undefined') {
		return ArrayCreate(length);
	}
	if (!IsConstructor(C)) {
		throw new $TypeError('C must be a constructor');
	}
	return new C(length); // Construct(C, length);
};

'use strict';

var GetIntrinsic = require('get-intrinsic');

var $SyntaxError = require('es-errors/syntax');
var $TypeError = require('es-errors/type');
var isObject = require('es-object-atoms/isObject');
var $Promise = GetIntrinsic('%Promise%', true);

var callBound = require('call-bound');

var CreateIterResultObject = require('./CreateIterResultObject');
var IteratorComplete = require('./IteratorComplete');
var IteratorValue = require('./IteratorValue');
var PromiseResolve = require('./PromiseResolve');

var $then = callBound('Promise.prototype.then', true);

// https://262.ecma-international.org/10.0/#sec-asyncfromsynciteratorcontinuation

module.exports = function AsyncFromSyncIteratorContinuation(result) {
	if (!isObject(result)) {
		throw new $TypeError('Assertion failed: Type(O) is not Object');
	}

	if (arguments.length > 1) {
		throw new $SyntaxError('although AsyncFromSyncIteratorContinuation should take a second argument, it is not used in this implementation');
	}

	if (!$Promise) {
		throw new $SyntaxError('This environment does not support Promises.');
	}

	return new $Promise(function (resolve) {
		var done = IteratorComplete(result); // step 2
		var value = IteratorValue(result); // step 4
		var valueWrapper = PromiseResolve($Promise, value); // step 6

		// eslint-disable-next-line no-shadow
		var onFulfilled = function (value) { // steps 8-9
			return CreateIterResultObject(value, done); // step 8.a
		};
		resolve($then(valueWrapper, onFulfilled)); // step 11
	}); // step 12
};
'use strict';

var GetIntrinsic = require('get-intrinsic');

var $SyntaxError = require('es-errors/syntax');
var $TypeError = require('es-errors/type');
var isObject = require('es-object-atoms/isObject');
var $Promise = GetIntrinsic('%Promise%', true);

var Call = require('./Call');
var CompletionRecord = require('./CompletionRecord');
var GetMethod = require('./GetMethod');

var isIteratorRecord = require('../helpers/records/iterator-record-2023');

var callBound = require('call-bound');

var $then = callBound('Promise.prototype.then', true);

// https://262.ecma-international.org/12.0/#sec-asynciteratorclose

module.exports = function AsyncIteratorClose(iteratorRecord, completion) {
	if (!isIteratorRecord(iteratorRecord)) {
		throw new $TypeError('Assertion failed: `iteratorRecord` must be an Iterator Record'); // step 1
	}

	if (!(completion instanceof CompletionRecord)) {
		throw new $TypeError('Assertion failed: completion is not a Completion Record instance'); // step 2
	}

	if (!$then) {
		throw new $SyntaxError('This environment does not support Promises.');
	}

	var iterator = iteratorRecord['[[Iterator]]']; // step 3

	return $then(
		$then(
			$then(
				new $Promise(function (resolve) {
					resolve(GetMethod(iterator, 'return')); // step 4
					// resolve(Call(ret, iterator, [])); // step 6
				}),
				function (returnV) { // step 5.a
					if (typeof returnV === 'undefined') {
						return completion; // step 5.b
					}
					return Call(returnV, iterator); // step 5.c, 5.d.
				}
			),
			null,
			function (e) {
				if (completion.type() === 'throw') {
					completion['?'](); // step 6
				} else {
					throw e; // step 7
				}
			}
		),
		function (innerResult) { // step 8
			if (completion.type() === 'throw') {
				completion['?'](); // step 6
			}
			if (!isObject(innerResult)) {
				throw new $TypeError('`innerResult` must be an Object'); // step 10
			}
			return completion;
		}
	);
};
'use strict';

var $TypeError = require('es-errors/type');
// var $BigInt = GetIntrinsic('%BigInt%', true);
// var $pow = require('math-intrinsics/pow');

// var BinaryAnd = require('./BinaryAnd');
// var BinaryOr = require('./BinaryOr');
// var BinaryXor = require('./BinaryXor');
// var modulo = require('./modulo');

// var zero = $BigInt && $BigInt(0);
// var negOne = $BigInt && $BigInt(-1);
// var two = $BigInt && $BigInt(2);

// https://262.ecma-international.org/11.0/#sec-bigintbitwiseop

module.exports = function BigIntBitwiseOp(op, x, y) {
	if (op !== '&' && op !== '|' && op !== '^') {
		throw new $TypeError('Assertion failed: `op` must be `&`, `|`, or `^`');
	}
	if (typeof x !== 'bigint' || typeof y !== 'bigint') {
		throw new $TypeError('`x` and `y` must be BigInts');
	}

	if (op === '&') {
		return x & y;
	}
	if (op === '|') {
		return x | y;
	}
	return x ^ y;
	/*
	var result = zero;
	var shift = 0;
	while (x !== zero && x !== negOne && y !== zero && y !== negOne) {
		var xDigit = modulo(x, two);
		var yDigit = modulo(y, two);
		if (op === '&') {
			result += $pow(2, shift) * BinaryAnd(xDigit, yDigit);
		} else if (op === '|') {
			result += $pow(2, shift) * BinaryOr(xDigit, yDigit);
		} else if (op === '^') {
			result += $pow(2, shift) * BinaryXor(xDigit, yDigit);
		}
		shift += 1;
		x = (x - xDigit) / two;
		y = (y - yDigit) / two;
	}
	var tmp;
	if (op === '&') {
		tmp = BinaryAnd(modulo(x, two), modulo(y, two));
	} else if (op === '|') {
		tmp = BinaryAnd(modulo(x, two), modulo(y, two));
	} else {
		tmp = BinaryXor(modulo(x, two), modulo(y, two));
	}
	if (tmp !== 0) {
		result -= $pow(2, shift);
	}
	return result;
	*/
};
'use strict';

var $TypeError = require('es-errors/type');

// https://262.ecma-international.org/11.0/#sec-binaryand

module.exports = function BinaryAnd(x, y) {
	if ((x !== 0 && x !== 1) || (y !== 0 && y !== 1)) {
		throw new $TypeError('Assertion failed: `x` and `y` must be either 0 or 1');
	}
	return x & y;
};
'use strict';

var $TypeError = require('es-errors/type');

// https://262.ecma-international.org/11.0/#sec-binaryor

module.exports = function BinaryOr(x, y) {
	if ((x !== 0 && x !== 1) || (y !== 0 && y !== 1)) {
		throw new $TypeError('Assertion failed: `x` and `y` must be either 0 or 1');
	}
	return x | y;
};
'use strict';

var $TypeError = require('es-errors/type');

// https://262.ecma-international.org/11.0/#sec-binaryxor

module.exports = function BinaryXor(x, y) {
	if ((x !== 0 && x !== 1) || (y !== 0 && y !== 1)) {
		throw new $TypeError('Assertion failed: `x` and `y` must be either 0 or 1');
	}
	return x ^ y;
};
'use strict';

var $TypeError = require('es-errors/type');

var IsArray = require('./IsArray');

var isByteValue = require('../helpers/isByteValue');

// https://262.ecma-international.org/12.0/#sec-bytelistbitwiseop

module.exports = function ByteListBitwiseOp(op, xBytes, yBytes) {
	if (op !== '&' && op !== '^' && op !== '|') {
		throw new $TypeError('Assertion failed: `op` must be `&`, `^`, or `|`');
	}
	if (!IsArray(xBytes) || !IsArray(yBytes) || xBytes.length !== yBytes.length) {
		throw new $TypeError('Assertion failed: `xBytes` and `yBytes` must be same-length sequences of byte values (an integer 0-255, inclusive)');
	}

	var result = [];

	for (var i = 0; i < xBytes.length; i += 1) {
		var xByte = xBytes[i];
		var yByte = yBytes[i];
		if (!isByteValue(xByte) || !isByteValue(yByte)) {
			throw new $TypeError('Assertion failed: `xBytes` and `yBytes` must be same-length sequences of byte values (an integer 0-255, inclusive)');
		}
		var resultByte;
		if (op === '&') {
			resultByte = xByte & yByte;
		} else if (op === '^') {
			resultByte = xByte ^ yByte;
		} else {
			resultByte = xByte | yByte;
		}
		result[result.length] = resultByte;
	}

	return result;
};
'use strict';

var $TypeError = require('es-errors/type');

var IsArray = require('./IsArray');

var isByteValue = require('../helpers/isByteValue');

// https://262.ecma-international.org/12.0/#sec-bytelistequal

module.exports = function ByteListEqual(xBytes, yBytes) {
	if (!IsArray(xBytes) || !IsArray(yBytes)) {
		throw new $TypeError('Assertion failed: `xBytes` and `yBytes` must be sequences of byte values (an integer 0-255, inclusive)');
	}

	if (xBytes.length !== yBytes.length) {
		return false;
	}

	for (var i = 0; i < xBytes.length; i += 1) {
		var xByte = xBytes[i];
		var yByte = yBytes[i];
		if (!isByteValue(xByte) || !isByteValue(yByte)) {
			throw new $TypeError('Assertion failed: `xBytes` and `yBytes` must be sequences of byte values (an integer 0-255, inclusive)');
		}
		if (xByte !== yByte) {
			return false;
		}
	}
	return true;
};
'use strict';

var GetIntrinsic = require('get-intrinsic');
var callBound = require('call-bound');

var $TypeError = require('es-errors/type');

var IsArray = require('./IsArray');

var $apply = GetIntrinsic('%Reflect.apply%', true) || callBound('Function.prototype.apply');

// https://262.ecma-international.org/6.0/#sec-call

module.exports = function Call(F, V) {
	var argumentsList = arguments.length > 2 ? arguments[2] : [];
	if (!IsArray(argumentsList)) {
		throw new $TypeError('Assertion failed: optional `argumentsList`, if provided, must be a List');
	}
	return $apply(F, V, argumentsList);
};
'use strict';

var $TypeError = require('es-errors/type');

var callBound = require('call-bound');
var hasOwn = require('hasown');

var $charCodeAt = callBound('String.prototype.charCodeAt');
var $toUpperCase = callBound('String.prototype.toUpperCase');

var caseFolding = require('../helpers/caseFolding.json');

// https://262.ecma-international.org/6.0/#sec-runtime-semantics-canonicalize-ch

module.exports = function Canonicalize(ch, IgnoreCase, Unicode) {
	if (typeof ch !== 'string') {
		throw new $TypeError('Assertion failed: `ch` must be a character');
	}

	if (typeof IgnoreCase !== 'boolean' || typeof Unicode !== 'boolean') {
		throw new $TypeError('Assertion failed: `IgnoreCase` and `Unicode` must be Booleans');
	}

	if (!IgnoreCase) {
		return ch; // step 1
	}

	if (Unicode) { // step 2
		if (hasOwn(caseFolding.C, ch)) {
			return caseFolding.C[ch];
		}
		if (hasOwn(caseFolding.S, ch)) {
			return caseFolding.S[ch];
		}
		return ch; // step 2.b
	}

	var u = $toUpperCase(ch); // step 2

	if (u.length !== 1) {
		return ch; // step 3
	}

	var cu = u; // step 4

	if ($charCodeAt(ch, 0) >= 128 && $charCodeAt(cu, 0) < 128) {
		return ch; // step 5
	}

	return cu;
};
'use strict';

var $TypeError = require('es-errors/type');

var SameValue = require('./SameValue');
var ToNumber = require('./ToNumber');
var ToString = require('./ToString');

// https://262.ecma-international.org/6.0/#sec-canonicalnumericindexstring

module.exports = function CanonicalNumericIndexString(argument) {
	if (typeof argument !== 'string') {
		throw new $TypeError('Assertion failed: `argument` must be a String');
	}
	if (argument === '-0') { return -0; }
	var n = ToNumber(argument);
	if (SameValue(ToString(n), argument)) { return n; }
	return void 0;
};
'use strict';

var GetIntrinsic = require('get-intrinsic');
var callBound = require('call-bound');

var $fromCharCode = GetIntrinsic('%String.fromCharCode%');
var $TypeError = require('es-errors/type');
var $charCodeAt = callBound('String.prototype.charCodeAt');

var CharSet = require('../helpers/CharSet').CharSet;

module.exports = function CharacterRange(A, B) {
	var a;
	var b;

	if (A instanceof CharSet || B instanceof CharSet) {
		if (!(A instanceof CharSet) || !(B instanceof CharSet)) {
			throw new $TypeError('Assertion failed: CharSets A and B are not both CharSets');
		}

		A.yield(function (c) {
			if (typeof a !== 'undefined') {
				throw new $TypeError('Assertion failed: CharSet A has more than one character');
			}
			a = c;
		});
		B.yield(function (c) {
			if (typeof b !== 'undefined') {
				throw new $TypeError('Assertion failed: CharSet B has more than one character');
			}
			b = c;
		});
	} else {
		if (A.length !== 1 || B.length !== 1) {
			throw new $TypeError('Assertion failed: CharSets A and B contain exactly one character');
		}
		a = A[0];
		b = B[0];
	}

	var i = $charCodeAt(a, 0);
	var j = $charCodeAt(b, 0);

	if (!(i <= j)) {
		throw new $TypeError('Assertion failed: i is not <= j');
	}

	var arr = [];
	for (var k = i; k <= j; k += 1) {
		arr[arr.length] = $fromCharCode(k);
	}
	return arr;
};
'use strict';

var $TypeError = require('es-errors/type');
var max = require('math-intrinsics/max');
var min = require('math-intrinsics/min');

// https://262.ecma-international.org/12.0/#clamping

module.exports = function clamp(x, lower, upper) {
	if (typeof x !== 'number' || typeof lower !== 'number' || typeof upper !== 'number' || !(lower <= upper)) {
		throw new $TypeError('Assertion failed: all three arguments must be MVs, and `lower` must be `<= upper`');
	}
	return min(max(lower, x), upper);
};
'use strict';

var SLOT = require('internal-slot');
var keptObjects = [];

// https://262.ecma-international.org/12.0/#sec-clear-kept-objects

module.exports = function ClearKeptObjects() {
	keptObjects.length = 0;
};

SLOT.set(module.exports, '[[es-abstract internal: KeptAlive]]', keptObjects);
'use strict';

var $TypeError = require('es-errors/type');

var GetPrototypeFromConstructor = require('./GetPrototypeFromConstructor');
var IsConstructor = require('./IsConstructor');
var IsDetachedBuffer = require('./IsDetachedBuffer');
var OrdinarySetPrototypeOf = require('./OrdinarySetPrototypeOf');

var isInteger = require('math-intrinsics/isInteger');
var isArrayBuffer = require('is-array-buffer');
var arrayBufferSlice = require('arraybuffer.prototype.slice');

// https://262.ecma-international.org/12.0/#sec-clonearraybuffer

module.exports = function CloneArrayBuffer(srcBuffer, srcByteOffset, srcLength, cloneConstructor) {
	if (!isArrayBuffer(srcBuffer)) {
		throw new $TypeError('Assertion failed: `srcBuffer` must be an ArrayBuffer instance');
	}
	if (!isInteger(srcByteOffset) || srcByteOffset < 0) {
		throw new $TypeError('Assertion failed: `srcByteOffset` must be a non-negative integer');
	}
	if (!isInteger(srcLength) || srcLength < 0) {
		throw new $TypeError('Assertion failed: `srcLength` must be a non-negative integer');
	}
	if (!IsConstructor(cloneConstructor)) {
		throw new $TypeError('Assertion failed: `cloneConstructor` must be a constructor');
	}

	// 3. Let targetBuffer be ? AllocateArrayBuffer(cloneConstructor, srcLength).
	var proto = GetPrototypeFromConstructor(cloneConstructor, '%ArrayBufferPrototype%'); // step 3, kinda

	if (IsDetachedBuffer(srcBuffer)) {
		throw new $TypeError('`srcBuffer` must not be a detached ArrayBuffer'); // step 4
	}

	/*
    5. Let srcBlock be srcBuffer.[[ArrayBufferData]].
    6. Let targetBlock be targetBuffer.[[ArrayBufferData]].
    7. Perform CopyDataBlockBytes(targetBlock, 0, srcBlock, srcByteOffset, srcLength).
    */
	var targetBuffer = arrayBufferSlice(srcBuffer, srcByteOffset, srcByteOffset + srcLength); // steps 5-7
	OrdinarySetPrototypeOf(targetBuffer, proto); // step 3

	return targetBuffer; // step 8
};
'use strict';

var $TypeError = require('es-errors/type');
var callBound = require('call-bound');
var isLeadingSurrogate = require('../helpers/isLeadingSurrogate');
var isTrailingSurrogate = require('../helpers/isTrailingSurrogate');

var UTF16SurrogatePairToCodePoint = require('./UTF16SurrogatePairToCodePoint');

var $charAt = callBound('String.prototype.charAt');
var $charCodeAt = callBound('String.prototype.charCodeAt');

// https://262.ecma-international.org/12.0/#sec-codepointat

module.exports = function CodePointAt(string, position) {
	if (typeof string !== 'string') {
		throw new $TypeError('Assertion failed: `string` must be a String');
	}
	var size = string.length;
	if (position < 0 || position >= size) {
		throw new $TypeError('Assertion failed: `position` must be >= 0, and < the length of `string`');
	}
	var first = $charCodeAt(string, position);
	var cp = $charAt(string, position);
	var firstIsLeading = isLeadingSurrogate(first);
	var firstIsTrailing = isTrailingSurrogate(first);
	if (!firstIsLeading && !firstIsTrailing) {
		return {
			'[[CodePoint]]': cp,
			'[[CodeUnitCount]]': 1,
			'[[IsUnpairedSurrogate]]': false
		};
	}
	if (firstIsTrailing || (position + 1 === size)) {
		return {
			'[[CodePoint]]': cp,
			'[[CodeUnitCount]]': 1,
			'[[IsUnpairedSurrogate]]': true
		};
	}
	var second = $charCodeAt(string, position + 1);
	if (!isTrailingSurrogate(second)) {
		return {
			'[[CodePoint]]': cp,
			'[[CodeUnitCount]]': 1,
			'[[IsUnpairedSurrogate]]': true
		};
	}

	return {
		'[[CodePoint]]': UTF16SurrogatePairToCodePoint(first, second),
		'[[CodeUnitCount]]': 2,
		'[[IsUnpairedSurrogate]]': false
	};
};
'use strict';

var $TypeError = require('es-errors/type');

var UTF16EncodeCodePoint = require('./UTF16EncodeCodePoint');
var IsArray = require('./IsArray');

var forEach = require('../helpers/forEach');
var isCodePoint = require('../helpers/isCodePoint');

// https://262.ecma-international.org/12.0/#sec-codepointstostring

module.exports = function CodePointsToString(text) {
	if (!IsArray(text)) {
		throw new $TypeError('Assertion failed: `text` must be a sequence of Unicode Code Points');
	}
	var result = '';
	forEach(text, function (cp) {
		if (!isCodePoint(cp)) {
			throw new $TypeError('Assertion failed: `text` must be a sequence of Unicode Code Points');
		}
		result += UTF16EncodeCodePoint(cp);
	});
	return result;
};
'use strict';

var $TypeError = require('es-errors/type');

var hasOwn = require('hasown');

var IsDataDescriptor = require('./IsDataDescriptor');
var IsGenericDescriptor = require('./IsGenericDescriptor');

var isPropertyDescriptor = require('../helpers/records/property-descriptor');

// https://262.ecma-international.org/6.0/#sec-completepropertydescriptor

module.exports = function CompletePropertyDescriptor(Desc) {
	if (!isPropertyDescriptor(Desc)) {
		throw new $TypeError('Assertion failed: `Desc` must be a Property Descriptor');
	}

	/* eslint no-param-reassign: 0 */

	if (IsGenericDescriptor(Desc) || IsDataDescriptor(Desc)) {
		if (!hasOwn(Desc, '[[Value]]')) {
			Desc['[[Value]]'] = void 0;
		}
		if (!hasOwn(Desc, '[[Writable]]')) {
			Desc['[[Writable]]'] = false;
		}
	} else {
		if (!hasOwn(Desc, '[[Get]]')) {
			Desc['[[Get]]'] = void 0;
		}
		if (!hasOwn(Desc, '[[Set]]')) {
			Desc['[[Set]]'] = void 0;
		}
	}
	if (!hasOwn(Desc, '[[Enumerable]]')) {
		Desc['[[Enumerable]]'] = false;
	}
	if (!hasOwn(Desc, '[[Configurable]]')) {
		Desc['[[Configurable]]'] = false;
	}
	return Desc;
};
'use strict';

var $SyntaxError = require('es-errors/syntax');

var SLOT = require('internal-slot');

// https://262.ecma-international.org/7.0/#sec-completion-record-specification-type

var CompletionRecord = function CompletionRecord(type, value) {
	if (!(this instanceof CompletionRecord)) {
		return new CompletionRecord(type, value);
	}
	if (type !== 'normal' && type !== 'break' && type !== 'continue' && type !== 'return' && type !== 'throw') {
		throw new $SyntaxError('Assertion failed: `type` must be one of "normal", "break", "continue", "return", or "throw"');
	}
	SLOT.set(this, '[[Type]]', type);
	SLOT.set(this, '[[Value]]', value);
	// [[Target]] slot?
};

CompletionRecord.prototype.type = function Type() {
	return SLOT.get(this, '[[Type]]');
};

CompletionRecord.prototype.value = function Value() {
	return SLOT.get(this, '[[Value]]');
};

CompletionRecord.prototype['?'] = function ReturnIfAbrupt() {
	var type = SLOT.get(this, '[[Type]]');
	var value = SLOT.get(this, '[[Value]]');

	if (type === 'throw') {
		throw value;
	}
	return value;
};

CompletionRecord.prototype['!'] = function assert() {
	var type = SLOT.get(this, '[[Type]]');

	if (type !== 'normal') {
		throw new $SyntaxError('Assertion failed: Completion Record is not of type "normal"');
	}
	return SLOT.get(this, '[[Value]]');
};

module.exports = CompletionRecord;
'use strict';

var $TypeError = require('es-errors/type');
var isObject = require('es-object-atoms/isObject');
var callBound = require('call-bound');
var OwnPropertyKeys = require('own-keys');

var forEach = require('../helpers/forEach');
var every = require('../helpers/every');
var some = require('../helpers/some');

var $isEnumerable = callBound('Object.prototype.propertyIsEnumerable');

var CreateDataPropertyOrThrow = require('./CreateDataPropertyOrThrow');
var Get = require('./Get');
var IsArray = require('./IsArray');
var isPropertyKey = require('../helpers/isPropertyKey');
var SameValue = require('./SameValue');
var ToNumber = require('./ToNumber');
var ToObject = require('./ToObject');

var isInteger = require('math-intrinsics/isInteger');

// https://262.ecma-international.org/12.0/#sec-copydataproperties

module.exports = function CopyDataProperties(target, source, excludedItems) {
	if (!isObject(target)) {
		throw new $TypeError('Assertion failed: "target" must be an Object');
	}

	if (!IsArray(excludedItems) || !every(excludedItems, isPropertyKey)) {
		throw new $TypeError('Assertion failed: "excludedItems" must be a List of Property Keys');
	}

	if (typeof source === 'undefined' || source === null) {
		return target;
	}

	var from = ToObject(source);

	var keys = OwnPropertyKeys(from);
	forEach(keys, function (nextKey) {
		var excluded = some(excludedItems, function (e) {
			return SameValue(e, nextKey) === true;
		});
		/*
		var excluded = false;

		forEach(excludedItems, function (e) {
			if (SameValue(e, nextKey) === true) {
				excluded = true;
			}
		});
		*/

		var enumerable = $isEnumerable(from, nextKey) || (
		// this is to handle string keys being non-enumerable in older engines
			typeof source === 'string'
			&& nextKey >= 0
			&& isInteger(ToNumber(nextKey))
		);
		if (excluded === false && enumerable) {
			var propValue = Get(from, nextKey);
			CreateDataPropertyOrThrow(target, nextKey, propValue);
		}
	});

	return target;
};
'use strict';

var GetIntrinsic = require('get-intrinsic');

var $SyntaxError = require('es-errors/syntax');
var $TypeError = require('es-errors/type');
var isObject = require('es-object-atoms/isObject');
var $Promise = GetIntrinsic('%Promise%', true);

var AsyncFromSyncIteratorContinuation = require('./AsyncFromSyncIteratorContinuation');
var Call = require('./Call');
var CreateIterResultObject = require('./CreateIterResultObject');
var Get = require('./Get');
var GetMethod = require('./GetMethod');
var IteratorNext = require('./IteratorNext');
var OrdinaryObjectCreate = require('./OrdinaryObjectCreate');

var isIteratorRecord = require('../helpers/records/iterator-record-2023');

var SLOT = require('internal-slot');

var $AsyncFromSyncIteratorPrototype = GetIntrinsic('%AsyncFromSyncIteratorPrototype%', true) || {
	next: function next(value) {
		if (!$Promise) {
			throw new $SyntaxError('This environment does not support Promises.');
		}

		var O = this; // step 1

		SLOT.assert(O, '[[SyncIteratorRecord]]'); // step 2

		var argsLength = arguments.length;

		return new $Promise(function (resolve) { // step 3
			var syncIteratorRecord = SLOT.get(O, '[[SyncIteratorRecord]]'); // step 4
			var result;
			if (argsLength > 0) {
				result = IteratorNext(syncIteratorRecord['[[Iterator]]'], value); // step 5.a
			} else { // step 6
				result = IteratorNext(syncIteratorRecord['[[Iterator]]']);// step 6.a
			}
			resolve(AsyncFromSyncIteratorContinuation(result)); // step 8
		});
	},
	'return': function () {
		if (!$Promise) {
			throw new $SyntaxError('This environment does not support Promises.');
		}

		var O = this; // step 1

		SLOT.assert(O, '[[SyncIteratorRecord]]'); // step 2

		var valueIsPresent = arguments.length > 0;
		var value = valueIsPresent ? arguments[0] : void undefined;

		return new $Promise(function (resolve, reject) { // step 3
			var syncIterator = SLOT.get(O, '[[SyncIteratorRecord]]')['[[Iterator]]']; // step 4
			var iteratorReturn = GetMethod(syncIterator, 'return'); // step 5

			if (typeof iteratorReturn === 'undefined') { // step 7
				var iterResult = CreateIterResultObject(value, true); // step 7.a
				Call(resolve, undefined, [iterResult]); // step 7.b
				return;
			}
			var result;
			if (valueIsPresent) { // step 8
				result = Call(iteratorReturn, syncIterator, [value]); // step 8.a
			} else { // step 9
				result = Call(iteratorReturn, syncIterator); // step 9.a
			}
			if (!isObject(result)) { // step 11
				Call(reject, undefined, [new $TypeError('Iterator `return` method returned a non-object value.')]); // step 11.a
				return;
			}

			resolve(AsyncFromSyncIteratorContinuation(result)); // step 12
		});
	},
	'throw': function () {
		if (!$Promise) {
			throw new $SyntaxError('This environment does not support Promises.');
		}

		var O = this; // step 1

		SLOT.assert(O, '[[SyncIteratorRecord]]'); // step 2

		var valueIsPresent = arguments.length > 0;
		var value = valueIsPresent ? arguments[0] : void undefined;

		return new $Promise(function (resolve, reject) { // step 3
			var syncIterator = SLOT.get(O, '[[SyncIteratorRecord]]')['[[Iterator]]']; // step 4

			var throwMethod = GetMethod(syncIterator, 'throw'); // step 5

			if (typeof throwMethod === 'undefined') { // step 7
				Call(reject, undefined, [value]); // step 7.a
				return;
			}

			var result;
			if (valueIsPresent) { // step 8
				result = Call(throwMethod, syncIterator, [value]); // step 8.a
			} else { // step 9
				result = Call(throwMethod, syncIterator); // step 9.a
			}
			if (!isObject(result)) { // step 11
				Call(reject, undefined, [new $TypeError('Iterator `throw` method returned a non-object value.')]); // step 11.a
				return;
			}

			resolve(AsyncFromSyncIteratorContinuation(result/* , promiseCapability */)); // step 12
		});
	}
};

// https://262.ecma-international.org/11.0/#sec-createasyncfromsynciterator

module.exports = function CreateAsyncFromSyncIterator(syncIteratorRecord) {
	if (!isIteratorRecord(syncIteratorRecord)) {
		throw new $TypeError('Assertion failed: `syncIteratorRecord` must be an Iterator Record');
	}

	// var asyncIterator = OrdinaryObjectCreate(%AsyncFromSyncIteratorPrototype%, « [[SyncIteratorRecord]] »); // step 1
	var asyncIterator = OrdinaryObjectCreate($AsyncFromSyncIteratorPrototype);

	SLOT.set(asyncIterator, '[[SyncIteratorRecord]]', syncIteratorRecord); // step 2

	var nextMethod = Get(asyncIterator, 'next'); // step 3

	return { // steps 3-4
		'[[Iterator]]': asyncIterator,
		'[[NextMethod]]': nextMethod,
		'[[Done]]': false
	};
};
'use strict';

var $TypeError = require('es-errors/type');
var isObject = require('es-object-atoms/isObject');

var isPropertyKey = require('../helpers/isPropertyKey');
var OrdinaryDefineOwnProperty = require('./OrdinaryDefineOwnProperty');

// https://262.ecma-international.org/6.0/#sec-createdataproperty

module.exports = function CreateDataProperty(O, P, V) {
	if (!isObject(O)) {
		throw new $TypeError('Assertion failed: Type(O) is not Object');
	}
	if (!isPropertyKey(P)) {
		throw new $TypeError('Assertion failed: P is not a Property Key');
	}
	var newDesc = {
		'[[Configurable]]': true,
		'[[Enumerable]]': true,
		'[[Value]]': V,
		'[[Writable]]': true
	};
	return OrdinaryDefineOwnProperty(O, P, newDesc);
};
'use strict';

var $TypeError = require('es-errors/type');
var isObject = require('es-object-atoms/isObject');

var CreateDataProperty = require('./CreateDataProperty');

var isPropertyKey = require('../helpers/isPropertyKey');

// // https://262.ecma-international.org/6.0/#sec-createdatapropertyorthrow

module.exports = function CreateDataPropertyOrThrow(O, P, V) {
	if (!isObject(O)) {
		throw new $TypeError('Assertion failed: Type(O) is not Object');
	}
	if (!isPropertyKey(P)) {
		throw new $TypeError('Assertion failed: P is not a Property Key');
	}
	var success = CreateDataProperty(O, P, V);
	if (!success) {
		throw new $TypeError('unable to create data property');
	}
	return success;
};
'use strict';

var $TypeError = require('es-errors/type');

var callBound = require('call-bound');

var $replace = callBound('String.prototype.replace');

var RequireObjectCoercible = require('./RequireObjectCoercible');
var ToString = require('./ToString');

// https://262.ecma-international.org/6.0/#sec-createhtml

module.exports = function CreateHTML(string, tag, attribute, value) {
	if (typeof tag !== 'string' || typeof attribute !== 'string') {
		throw new $TypeError('Assertion failed: `tag` and `attribute` must be strings');
	}
	var str = RequireObjectCoercible(string);
	var S = ToString(str);
	var p1 = '<' + tag;
	if (attribute !== '') {
		var V = ToString(value);
		var escapedV = $replace(V, /\x22/g, '&quot;');
		p1 += '\x20' + attribute + '\x3D\x22' + escapedV + '\x22';
	}
	return p1 + '>' + S + '</' + tag + '>';
};
'use strict';

var $TypeError = require('es-errors/type');

// https://262.ecma-international.org/6.0/#sec-createiterresultobject

module.exports = function CreateIterResultObject(value, done) {
	if (typeof done !== 'boolean') {
		throw new $TypeError('Assertion failed: Type(done) is not Boolean');
	}
	return {
		value: value,
		done: done
	};
};
'use strict';

var callBound = require('call-bound');

var $TypeError = require('es-errors/type');
var isObject = require('es-object-atoms/isObject');
var $indexOf = callBound('Array.prototype.indexOf', true) || callBound('String.prototype.indexOf');

var Get = require('./Get');
var IsArray = require('./IsArray');
var LengthOfArrayLike = require('./LengthOfArrayLike');
var ToString = require('./ToString');
var Type = require('./Type');

var defaultElementTypes = ['Undefined', 'Null', 'Boolean', 'String', 'Symbol', 'Number', 'BigInt', 'Object'];

// https://262.ecma-international.org/11.0/#sec-createlistfromarraylike

module.exports = function CreateListFromArrayLike(obj) {
	var elementTypes = arguments.length > 1
		? arguments[1]
		: defaultElementTypes;

	if (!isObject(obj)) {
		throw new $TypeError('Assertion failed: `obj` must be an Object');
	}
	if (!IsArray(elementTypes)) {
		throw new $TypeError('Assertion failed: `elementTypes`, if provided, must be an array');
	}
	var len = LengthOfArrayLike(obj);
	var list = [];
	var index = 0;
	while (index < len) {
		var indexName = ToString(index);
		var next = Get(obj, indexName);
		var nextType = Type(next);
		if ($indexOf(elementTypes, nextType) < 0) {
			throw new $TypeError('item type ' + nextType + ' is not a valid elementType');
		}
		list[list.length] = next;
		index += 1;
	}
	return list;
};
'use strict';

var $TypeError = require('es-errors/type');
var isObject = require('es-object-atoms/isObject');

var DefineOwnProperty = require('../helpers/DefineOwnProperty');

var FromPropertyDescriptor = require('./FromPropertyDescriptor');
var IsDataDescriptor = require('./IsDataDescriptor');
var isPropertyKey = require('../helpers/isPropertyKey');
var SameValue = require('./SameValue');

// https://262.ecma-international.org/6.0/#sec-createmethodproperty

module.exports = function CreateMethodProperty(O, P, V) {
	if (!isObject(O)) {
		throw new $TypeError('Assertion failed: Type(O) is not Object');
	}

	if (!isPropertyKey(P)) {
		throw new $TypeError('Assertion failed: P is not a Property Key');
	}

	var newDesc = {
		'[[Configurable]]': true,
		'[[Enumerable]]': false,
		'[[Value]]': V,
		'[[Writable]]': true
	};
	return DefineOwnProperty(
		IsDataDescriptor,
		SameValue,
		FromPropertyDescriptor,
		O,
		P,
		newDesc
	);
};
'use strict';

var $TypeError = require('es-errors/type');
var isObject = require('es-object-atoms/isObject');

var DefinePropertyOrThrow = require('./DefinePropertyOrThrow');

var isPropertyKey = require('../helpers/isPropertyKey');

// https://262.ecma-international.org/13.0/#sec-createnonenumerabledatapropertyorthrow

module.exports = function CreateNonEnumerableDataPropertyOrThrow(O, P, V) {
	if (!isObject(O)) {
		throw new $TypeError('Assertion failed: Type(O) is not Object');
	}

	if (!isPropertyKey(P)) {
		throw new $TypeError('Assertion failed: P is not a Property Key');
	}

	var newDesc = {
		'[[Configurable]]': true,
		'[[Enumerable]]': false,
		'[[Value]]': V,
		'[[Writable]]': true
	};
	return DefinePropertyOrThrow(O, P, newDesc);
};
'use strict';

var GetIntrinsic = require('get-intrinsic');
var hasSymbols = require('has-symbols')();

var $TypeError = require('es-errors/type');
var isObject = require('es-object-atoms/isObject');
var IteratorPrototype = GetIntrinsic('%IteratorPrototype%', true);

var AdvanceStringIndex = require('./AdvanceStringIndex');
var CreateIterResultObject = require('./CreateIterResultObject');
var CreateMethodProperty = require('./CreateMethodProperty');
var Get = require('./Get');
var OrdinaryObjectCreate = require('./OrdinaryObjectCreate');
var RegExpExec = require('./RegExpExec');
var Set = require('./Set');
var ToLength = require('./ToLength');
var ToString = require('./ToString');

var SLOT = require('internal-slot');
var setToStringTag = require('es-set-tostringtag');

var RegExpStringIterator = function RegExpStringIterator(R, S, global, fullUnicode) {
	if (typeof S !== 'string') {
		throw new $TypeError('`S` must be a string');
	}
	if (typeof global !== 'boolean') {
		throw new $TypeError('`global` must be a boolean');
	}
	if (typeof fullUnicode !== 'boolean') {
		throw new $TypeError('`fullUnicode` must be a boolean');
	}
	SLOT.set(this, '[[IteratingRegExp]]', R);
	SLOT.set(this, '[[IteratedString]]', S);
	SLOT.set(this, '[[Global]]', global);
	SLOT.set(this, '[[Unicode]]', fullUnicode);
	SLOT.set(this, '[[Done]]', false);
};

if (IteratorPrototype) {
	RegExpStringIterator.prototype = OrdinaryObjectCreate(IteratorPrototype);
}

var RegExpStringIteratorNext = function next() {
	var O = this; // eslint-disable-line no-invalid-this
	if (!isObject(O)) {
		throw new $TypeError('receiver must be an object');
	}
	if (
		!(O instanceof RegExpStringIterator)
		|| !SLOT.has(O, '[[IteratingRegExp]]')
		|| !SLOT.has(O, '[[IteratedString]]')
		|| !SLOT.has(O, '[[Global]]')
		|| !SLOT.has(O, '[[Unicode]]')
		|| !SLOT.has(O, '[[Done]]')
	) {
		throw new $TypeError('"this" value must be a RegExpStringIterator instance');
	}
	if (SLOT.get(O, '[[Done]]')) {
		return CreateIterResultObject(undefined, true);
	}
	var R = SLOT.get(O, '[[IteratingRegExp]]');
	var S = SLOT.get(O, '[[IteratedString]]');
	var global = SLOT.get(O, '[[Global]]');
	var fullUnicode = SLOT.get(O, '[[Unicode]]');
	var match = RegExpExec(R, S);
	if (match === null) {
		SLOT.set(O, '[[Done]]', true);
		return CreateIterResultObject(undefined, true);
	}
	if (global) {
		var matchStr = ToString(Get(match, '0'));
		if (matchStr === '') {
			var thisIndex = ToLength(Get(R, 'lastIndex'));
			var nextIndex = AdvanceStringIndex(S, thisIndex, fullUnicode);
			Set(R, 'lastIndex', nextIndex, true);
		}
		return CreateIterResultObject(match, false);
	}
	SLOT.set(O, '[[Done]]', true);
	return CreateIterResultObject(match, false);
};
CreateMethodProperty(RegExpStringIterator.prototype, 'next', RegExpStringIteratorNext);

if (hasSymbols) {
	setToStringTag(RegExpStringIterator.prototype, 'RegExp String Iterator');

	if (Symbol.iterator && typeof RegExpStringIterator.prototype[Symbol.iterator] !== 'function') {
		var iteratorFn = function SymbolIterator() {
			return this;
		};
		CreateMethodProperty(RegExpStringIterator.prototype, Symbol.iterator, iteratorFn);
	}
}

// https://262.ecma-international.org/11.0/#sec-createregexpstringiterator
module.exports = function CreateRegExpStringIterator(R, S, global, fullUnicode) {
	// assert R.global === global && R.unicode === fullUnicode?
	return new RegExpStringIterator(R, S, global, fullUnicode);
};
'use strict';

var $EvalError = require('es-errors/eval');

var DayWithinYear = require('./DayWithinYear');
var InLeapYear = require('./InLeapYear');
var MonthFromTime = require('./MonthFromTime');

// https://262.ecma-international.org/5.1/#sec-15.9.1.5

module.exports = function DateFromTime(t) {
	var m = MonthFromTime(t);
	var d = DayWithinYear(t);
	if (m === 0) {
		return d + 1;
	}
	if (m === 1) {
		return d - 30;
	}
	var leap = InLeapYear(t);
	if (m === 2) {
		return d - 58 - leap;
	}
	if (m === 3) {
		return d - 89 - leap;
	}
	if (m === 4) {
		return d - 119 - leap;
	}
	if (m === 5) {
		return d - 150 - leap;
	}
	if (m === 6) {
		return d - 180 - leap;
	}
	if (m === 7) {
		return d - 211 - leap;
	}
	if (m === 8) {
		return d - 242 - leap;
	}
	if (m === 9) {
		return d - 272 - leap;
	}
	if (m === 10) {
		return d - 303 - leap;
	}
	if (m === 11) {
		return d - 333 - leap;
	}
	throw new $EvalError('Assertion failed: MonthFromTime returned an impossible value: ' + m);
};
'use strict';

var $TypeError = require('es-errors/type');

var weekdays = ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'];
var months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];

var $isNaN = require('math-intrinsics/isNaN');
var padTimeComponent = require('../helpers/padTimeComponent');

var DateFromTime = require('./DateFromTime');
var MonthFromTime = require('./MonthFromTime');
var WeekDay = require('./WeekDay');
var YearFromTime = require('./YearFromTime');

// https://262.ecma-international.org/9.0/#sec-datestring

module.exports = function DateString(tv) {
	if (typeof tv !== 'number' || $isNaN(tv)) {
		throw new $TypeError('Assertion failed: `tv` must be a non-NaN Number');
	}
	var weekday = weekdays[WeekDay(tv)];
	var month = months[MonthFromTime(tv)];
	var day = padTimeComponent(DateFromTime(tv));
	var year = padTimeComponent(YearFromTime(tv), 4);
	return weekday + '\x20' + month + '\x20' + day + '\x20' + year;
};
'use strict';

var floor = require('./floor');

// https://262.ecma-international.org/5.1/#sec-15.9.1.3

module.exports = function DayFromYear(y) {
	return (365 * (y - 1970)) + floor((y - 1969) / 4) - floor((y - 1901) / 100) + floor((y - 1601) / 400);
};

'use strict';

var floor = require('./floor');

var msPerDay = require('../helpers/timeConstants').msPerDay;

// https://262.ecma-international.org/5.1/#sec-15.9.1.2

module.exports = function Day(t) {
	return floor(t / msPerDay);
};
'use strict';

var modulo = require('./modulo');

// https://262.ecma-international.org/5.1/#sec-15.9.1.3

module.exports = function DaysInYear(y) {
	if (modulo(y, 4) !== 0) {
		return 365;
	}
	if (modulo(y, 100) !== 0) {
		return 366;
	}
	if (modulo(y, 400) !== 0) {
		return 365;
	}
	return 366;
};
'use strict';

var Day = require('./Day');
var DayFromYear = require('./DayFromYear');
var YearFromTime = require('./YearFromTime');

// https://262.ecma-international.org/5.1/#sec-15.9.1.4

module.exports = function DayWithinYear(t) {
	return Day(t) - DayFromYear(YearFromTime(t));
};
'use strict';

var $TypeError = require('es-errors/type');
var isObject = require('es-object-atoms/isObject');

var DefinePropertyOrThrow = require('./DefinePropertyOrThrow');
var IsExtensible = require('./IsExtensible');

var isPropertyKey = require('../helpers/isPropertyKey');

// https://262.ecma-international.org/13.0/#sec-definemethodproperty

module.exports = function DefineMethodProperty(homeObject, key, closure, enumerable) {
	if (!isObject(homeObject)) {
		throw new $TypeError('Assertion failed: `homeObject` is not an Object');
	}
	if (!isPropertyKey(key)) {
		throw new $TypeError('Assertion failed: `key` is not a Property Key or a Private Name');
	}
	if (typeof closure !== 'function') {
		throw new $TypeError('Assertion failed: `closure` is not a function');
	}
	if (typeof enumerable !== 'boolean') {
		throw new $TypeError('Assertion failed: `enumerable` is not a Boolean');
	}

	// 1. Assert: homeObject is an ordinary, extensible object with no non-configurable properties.
	if (!IsExtensible(homeObject)) {
		throw new $TypeError('Assertion failed: `homeObject` is not an ordinary, extensible object, with no non-configurable properties');
	}

	// 2. If key is a Private Name, then
	//  a. Return PrivateElement { [[Key]]: key, [[Kind]]: method, [[Value]]: closure }.
	// 3. Else,
	var desc = { // step 3.a
		'[[Value]]': closure,
		'[[Writable]]': true,
		'[[Enumerable]]': enumerable,
		'[[Configurable]]': true
	};
	DefinePropertyOrThrow(homeObject, key, desc); // step 3.b
};
'use strict';

var $TypeError = require('es-errors/type');
var isObject = require('es-object-atoms/isObject');

var isPropertyDescriptor = require('../helpers/records/property-descriptor');
var DefineOwnProperty = require('../helpers/DefineOwnProperty');

var FromPropertyDescriptor = require('./FromPropertyDescriptor');
var IsDataDescriptor = require('./IsDataDescriptor');
var isPropertyKey = require('../helpers/isPropertyKey');
var SameValue = require('./SameValue');
var ToPropertyDescriptor = require('./ToPropertyDescriptor');

// https://262.ecma-international.org/6.0/#sec-definepropertyorthrow

module.exports = function DefinePropertyOrThrow(O, P, desc) {
	if (!isObject(O)) {
		throw new $TypeError('Assertion failed: Type(O) is not Object');
	}

	if (!isPropertyKey(P)) {
		throw new $TypeError('Assertion failed: P is not a Property Key');
	}

	var Desc = isPropertyDescriptor(desc) ? desc : ToPropertyDescriptor(desc);
	if (!isPropertyDescriptor(Desc)) {
		throw new $TypeError('Assertion failed: Desc is not a valid Property Descriptor');
	}

	return DefineOwnProperty(
		IsDataDescriptor,
		SameValue,
		FromPropertyDescriptor,
		O,
		P,
		Desc
	);
};
'use strict';

var $TypeError = require('es-errors/type');
var isObject = require('es-object-atoms/isObject');

var isPropertyKey = require('../helpers/isPropertyKey');

// https://262.ecma-international.org/6.0/#sec-deletepropertyorthrow

module.exports = function DeletePropertyOrThrow(O, P) {
	if (!isObject(O)) {
		throw new $TypeError('Assertion failed: Type(O) is not Object');
	}

	if (!isPropertyKey(P)) {
		throw new $TypeError('Assertion failed: P is not a Property Key');
	}

	// eslint-disable-next-line no-param-reassign
	var success = delete O[P];
	if (!success) {
		throw new $TypeError('Attempt to delete property failed.');
	}
	return success;
};
'use strict';

var $SyntaxError = require('es-errors/syntax');
var $TypeError = require('es-errors/type');

var IsDetachedBuffer = require('./IsDetachedBuffer');

var isArrayBuffer = require('is-array-buffer');
var isSharedArrayBuffer = require('is-shared-array-buffer');

var MessageChannel;
try {
	// eslint-disable-next-line global-require
	MessageChannel = require('worker_threads').MessageChannel;
} catch (e) { /**/ }

// https://262.ecma-international.org/9.0/#sec-detacharraybuffer

/* globals postMessage */

module.exports = function DetachArrayBuffer(arrayBuffer) {
	if (!isArrayBuffer(arrayBuffer) || isSharedArrayBuffer(arrayBuffer)) {
		throw new $TypeError('Assertion failed: `arrayBuffer` must be an Object with an [[ArrayBufferData]] internal slot, and not a Shared Array Buffer');
	}

	// commented out since there's no way to set or access this key
	// var key = arguments.length > 1 ? arguments[1] : void undefined;

	// if (!SameValue(arrayBuffer[[ArrayBufferDetachKey]], key)) {
	// 	throw new $TypeError('Assertion failed: `key` must be the value of the [[ArrayBufferDetachKey]] internal slot of `arrayBuffer`');
	// }

	if (!IsDetachedBuffer(arrayBuffer)) { // node v21.0.0+ throws when you structuredClone a detached buffer
		if (typeof structuredClone === 'function') {
			structuredClone(arrayBuffer, { transfer: [arrayBuffer] });
		} else if (typeof postMessage === 'function') {
			postMessage('', '/', [arrayBuffer]); // TODO: see if this might trigger listeners
		} else if (MessageChannel) {
			(new MessageChannel()).port1.postMessage(null, [arrayBuffer]);
		} else {
			throw new $SyntaxError('DetachArrayBuffer is not supported in this environment');
		}
	}

	return null;
};
'use strict';

var $TypeError = require('es-errors/type');
var isObject = require('es-object-atoms/isObject');

var objectKeys = require('object-keys');
var safePushApply = require('safe-push-apply');
var callBound = require('call-bound');

var $isEnumerable = callBound('Object.prototype.propertyIsEnumerable');

var forEach = require('../helpers/forEach');

// https://262.ecma-international.org/8.0/#sec-enumerableownproperties

module.exports = function EnumerableOwnPropertyNames(O, kind) {
	if (!isObject(O)) {
		throw new $TypeError('Assertion failed: Type(O) is not Object');
	}

	var keys = objectKeys(O);
	if (kind === 'key') {
		return keys;
	}
	if (kind === 'value' || kind === 'key+value') {
		var results = [];
		forEach(keys, function (key) {
			if ($isEnumerable(O, key)) {
				safePushApply(results, [
					kind === 'value' ? O[key] : [key, O[key]]
				]);
			}
		});
		return results;
	}
	throw new $TypeError('Assertion failed: "kind" is not "key", "value", or "key+value": ' + kind);
};
'use strict';

var $TypeError = require('es-errors/type');

var MAX_SAFE_INTEGER = require('math-intrinsics/constants/maxSafeInteger');

var Call = require('./Call');
var CreateDataPropertyOrThrow = require('./CreateDataPropertyOrThrow');
var Get = require('./Get');
var HasProperty = require('./HasProperty');
var IsArray = require('./IsArray');
var LengthOfArrayLike = require('./LengthOfArrayLike');
var ToString = require('./ToString');

// https://262.ecma-international.org/11.0/#sec-flattenintoarray

module.exports = function FlattenIntoArray(target, source, sourceLen, start, depth) {
	var mapperFunction;
	if (arguments.length > 5) {
		mapperFunction = arguments[5];
	}

	var targetIndex = start;
	var sourceIndex = 0;
	while (sourceIndex < sourceLen) {
		var P = ToString(sourceIndex);
		var exists = HasProperty(source, P);
		if (exists === true) {
			var element = Get(source, P);
			if (typeof mapperFunction !== 'undefined') {
				if (arguments.length <= 6) {
					throw new $TypeError('Assertion failed: thisArg is required when mapperFunction is provided');
				}
				element = Call(mapperFunction, arguments[6], [element, sourceIndex, source]);
			}
			var shouldFlatten = false;
			if (depth > 0) {
				shouldFlatten = IsArray(element);
			}
			if (shouldFlatten) {
				var elementLen = LengthOfArrayLike(element);
				targetIndex = FlattenIntoArray(target, element, elementLen, targetIndex, depth - 1);
			} else {
				if (targetIndex >= MAX_SAFE_INTEGER) {
					throw new $TypeError('index too large');
				}
				CreateDataPropertyOrThrow(target, ToString(targetIndex), element);
				targetIndex += 1;
			}
		}
		sourceIndex += 1;
	}

	return targetIndex;
};
'use strict';

// var modulo = require('./modulo');
var $floor = require('math-intrinsics/floor');

// http://262.ecma-international.org/11.0/#eqn-floor

module.exports = function floor(x) {
	// return x - modulo(x, 1);
	if (typeof x === 'bigint') {
		return x;
	}
	return $floor(x);
};
'use strict';

var $TypeError = require('es-errors/type');

var isPropertyDescriptor = require('../helpers/records/property-descriptor');
var fromPropertyDescriptor = require('../helpers/fromPropertyDescriptor');

// https://262.ecma-international.org/6.0/#sec-frompropertydescriptor

module.exports = function FromPropertyDescriptor(Desc) {
	if (typeof Desc !== 'undefined' && !isPropertyDescriptor(Desc)) {
		throw new $TypeError('Assertion failed: `Desc` must be a Property Descriptor');
	}

	return fromPropertyDescriptor(Desc);
};
'use strict';

var getGlobal = require('globalthis/polyfill');

// https://262.ecma-international.org/6.0/#sec-getglobalobject

module.exports = function GetGlobalObject() {
	return getGlobal();
};
'use strict';

var GetIntrinsic = require('get-intrinsic');

var $TypeError = require('es-errors/type');
var $SyntaxError = require('es-errors/syntax');
var isObject = require('es-object-atoms/isObject');
var $asyncIterator = GetIntrinsic('%Symbol.asyncIterator%', true);

var inspect = require('object-inspect');
var hasSymbols = require('has-symbols')();

var getIteratorMethod = require('../helpers/getIteratorMethod');
var AdvanceStringIndex = require('./AdvanceStringIndex');
var Call = require('./Call');
var GetMethod = require('./GetMethod');

var ES = {
	AdvanceStringIndex: AdvanceStringIndex,
	GetMethod: GetMethod
};

// https://262.ecma-international.org/9.0/#sec-getiterator

module.exports = function GetIterator(obj, hint, method) {
	var actualHint = hint;
	if (arguments.length < 2) {
		actualHint = 'sync';
	}
	if (actualHint !== 'sync' && actualHint !== 'async') {
		throw new $TypeError("Assertion failed: `hint` must be one of 'sync' or 'async', got " + inspect(hint));
	}

	var actualMethod = method;
	if (arguments.length < 3) {
		if (actualHint === 'async') {
			if (hasSymbols && $asyncIterator) {
				actualMethod = GetMethod(obj, $asyncIterator);
			}
			if (actualMethod === undefined) {
				throw new $SyntaxError("async from sync iterators aren't currently supported");
			}
		} else {
			actualMethod = getIteratorMethod(ES, obj);
		}
	}
	var iterator = Call(actualMethod, obj);
	if (!isObject(iterator)) {
		throw new $TypeError('iterator must return an object');
	}

	return iterator;

	// TODO: This should return an IteratorRecord
	/*
	var nextMethod = GetV(iterator, 'next');
	return {
		'[[Iterator]]': iterator,
		'[[NextMethod]]': nextMethod,
		'[[Done]]': false
	};
	*/
};
'use strict';

var $TypeError = require('es-errors/type');

var inspect = require('object-inspect');

var isPropertyKey = require('../helpers/isPropertyKey');

var isObject = require('es-object-atoms/isObject');

// https://262.ecma-international.org/6.0/#sec-get-o-p

module.exports = function Get(O, P) {
	// 7.3.1.1
	if (!isObject(O)) {
		throw new $TypeError('Assertion failed: Type(O) is not Object');
	}
	// 7.3.1.2
	if (!isPropertyKey(P)) {
		throw new $TypeError('Assertion failed: P is not a Property Key, got ' + inspect(P));
	}
	// 7.3.1.3
	return O[P];
};
'use strict';

var $TypeError = require('es-errors/type');

var isMatchRecord = require('../helpers/records/match-record');

// https://262.ecma-international.org/13.0/#sec-getmatchindexpair

module.exports = function GetMatchIndexPair(S, match) {
	if (typeof S !== 'string') {
		throw new $TypeError('Assertion failed: `S` must be a String');
	}
	if (!isMatchRecord(match)) {
		throw new $TypeError('Assertion failed: `match` must be a Match Record');
	}

	if (!(match['[[StartIndex]]'] <= S.length)) {
		throw new $TypeError('`match` [[StartIndex]] must be a non-negative integer <= the length of S');
	}
	if (!(match['[[EndIndex]]'] <= S.length)) {
		throw new $TypeError('`match` [[EndIndex]] must be an integer between [[StartIndex]] and the length of S, inclusive');
	}
	return [match['[[StartIndex]]'], match['[[EndIndex]]']];
};
'use strict';

var $TypeError = require('es-errors/type');

var substring = require('./substring');

var isMatchRecord = require('../helpers/records/match-record');

// https://262.ecma-international.org/13.0/#sec-getmatchstring

module.exports = function GetMatchString(S, match) {
	if (typeof S !== 'string') {
		throw new $TypeError('Assertion failed: `S` must be a String');
	}
	if (!isMatchRecord(match)) {
		throw new $TypeError('Assertion failed: `match` must be a Match Record');
	}

	if (!(match['[[StartIndex]]'] <= S.length)) {
		throw new $TypeError('`match` [[StartIndex]] must be a non-negative integer <= the length of S');
	}
	if (!(match['[[EndIndex]]'] <= S.length)) {
		throw new $TypeError('`match` [[EndIndex]] must be an integer between [[StartIndex]] and the length of S, inclusive');
	}
	return substring(S, match['[[StartIndex]]'], match['[[EndIndex]]']);
};
'use strict';

var $TypeError = require('es-errors/type');

var GetV = require('./GetV');
var IsCallable = require('./IsCallable');
var isPropertyKey = require('../helpers/isPropertyKey');

var inspect = require('object-inspect');

// https://262.ecma-international.org/6.0/#sec-getmethod

module.exports = function GetMethod(O, P) {
	// 7.3.9.1
	if (!isPropertyKey(P)) {
		throw new $TypeError('Assertion failed: P is not a Property Key');
	}

	// 7.3.9.2
	var func = GetV(O, P);

	// 7.3.9.4
	if (func == null) {
		return void 0;
	}

	// 7.3.9.5
	if (!IsCallable(func)) {
		throw new $TypeError(inspect(P) + ' is not a function: ' + inspect(func));
	}

	// 7.3.9.6
	return func;
};
'use strict';

var GetIntrinsic = require('get-intrinsic');

var hasSymbols = require('has-symbols')();

var $TypeError = require('es-errors/type');
var isObject = require('es-object-atoms/isObject');

var $gOPN = GetIntrinsic('%Object.getOwnPropertyNames%', true);
var $gOPS = hasSymbols && GetIntrinsic('%Object.getOwnPropertySymbols%', true);
var keys = require('object-keys');

// https://262.ecma-international.org/6.0/#sec-getownpropertykeys

module.exports = function GetOwnPropertyKeys(O, Type) {
	if (!isObject(O)) {
		throw new $TypeError('Assertion failed: Type(O) is not Object');
	}
	if (Type === 'Symbol') {
		return $gOPS ? $gOPS(O) : [];
	}
	if (Type === 'String') {
		if (!$gOPN) {
			return keys(O);
		}
		return $gOPN(O);
	}
	throw new $TypeError('Assertion failed: `Type` must be `"String"` or `"Symbol"`');
};
'use strict';

var $TypeError = require('es-errors/type');

var Get = require('./Get');
var IsCallable = require('./IsCallable');
var IsConstructor = require('./IsConstructor');

// https://262.ecma-international.org/12.0/#sec-getpromiseresolve

module.exports = function GetPromiseResolve(promiseConstructor) {
	if (!IsConstructor(promiseConstructor)) {
		throw new $TypeError('Assertion failed: `promiseConstructor` must be a constructor');
	}
	var promiseResolve = Get(promiseConstructor, 'resolve');
	if (IsCallable(promiseResolve) === false) {
		throw new $TypeError('`resolve` method is not callable');
	}
	return promiseResolve;
};
'use strict';

var GetIntrinsic = require('get-intrinsic');

var $Function = GetIntrinsic('%Function%');
var $TypeError = require('es-errors/type');
var $SyntaxError = require('es-errors/syntax');

var Get = require('./Get');
var IsConstructor = require('./IsConstructor');

var isObject = require('es-object-atoms/isObject');

// https://262.ecma-international.org/6.0/#sec-getprototypefromconstructor

module.exports = function GetPrototypeFromConstructor(constructor, intrinsicDefaultProto) {
	var intrinsic = GetIntrinsic(intrinsicDefaultProto); // throws if not a valid intrinsic
	if (!isObject(intrinsic)) {
		throw new $TypeError('intrinsicDefaultProto must be an object');
	}
	if (!IsConstructor(constructor)) {
		throw new $TypeError('Assertion failed: `constructor` must be a constructor');
	}
	var proto = Get(constructor, 'prototype');
	if (!isObject(proto)) {
		if (!(constructor instanceof $Function)) {
			// ignore other realms, for now
			throw new $SyntaxError('cross-realm constructors not currently supported');
		}
		proto = intrinsic;
	}
	return proto;
};
'use strict';

var callBound = require('call-bound');
var $TypeError = require('es-errors/type');
var isInteger = require('math-intrinsics/isInteger');

var StringToCodePoints = require('./StringToCodePoints');

var $indexOf = callBound('String.prototype.indexOf');

// https://262.ecma-international.org/13.0/#sec-getstringindex

module.exports = function GetStringIndex(S, e) {
	if (typeof S !== 'string') {
		throw new $TypeError('Assertion failed: `S` must be a String');
	}
	if (!isInteger(e) || e < 0) {
		throw new $TypeError('Assertion failed: `e` must be a non-negative integer');
	}

	if (S === '') {
		return 0;
	}
	var codepoints = StringToCodePoints(S);
	var eUTF = e >= codepoints.length ? S.length : $indexOf(S, codepoints[e]);
	return eUTF;
};
'use strict';

var $TypeError = require('es-errors/type');
var isObject = require('es-object-atoms/isObject');
var regexTester = require('safe-regex-test');
var inspect = require('object-inspect');
var isInteger = require('math-intrinsics/isInteger');

var Get = require('./Get');
var IsArray = require('./IsArray');
var min = require('./min');
var StringIndexOf = require('./StringIndexOf');
var StringToNumber = require('./StringToNumber');
var substring = require('./substring');
var ToString = require('./ToString');

var every = require('../helpers/every');
var isPrefixOf = require('../helpers/isPrefixOf');
var isStringOrUndefined = require('../helpers/isStringOrUndefined');

var startsWithDollarDigit = regexTester(/^\$[0-9]/);

// http://www.ecma-international.org/ecma-262/13.0/#sec-getsubstitution

// eslint-disable-next-line max-statements, max-params, max-lines-per-function
module.exports = function GetSubstitution(matched, str, position, captures, namedCaptures, replacementTemplate) {
	if (typeof matched !== 'string') {
		throw new $TypeError('Assertion failed: `matched` must be a String');
	}

	if (typeof str !== 'string') {
		throw new $TypeError('Assertion failed: `str` must be a String');
	}

	if (!isInteger(position) || position < 0) {
		throw new $TypeError('Assertion failed: `position` must be a nonnegative integer, got ' + inspect(position));
	}

	if (!IsArray(captures) || !every(captures, isStringOrUndefined)) {
		throw new $TypeError('Assertion failed: `captures` must be a possibly-empty List of Strings or `undefined`, got ' + inspect(captures));
	}

	if (typeof namedCaptures !== 'undefined' && !isObject(namedCaptures)) {
		throw new $TypeError('Assertion failed: `namedCaptures` must be `undefined` or an Object');
	}

	if (typeof replacementTemplate !== 'string') {
		throw new $TypeError('Assertion failed: `replacementTemplate` must be a String');
	}

	var stringLength = str.length; // step 1

	if (position > stringLength) {
		throw new $TypeError('Assertion failed: position > stringLength, got ' + inspect(position)); // step 2
	}

	var templateRemainder = replacementTemplate; // step 3

	var result = ''; // step 4

	while (templateRemainder !== '') { // step 5
		// 5.a NOTE: The following steps isolate ref (a prefix of templateRemainder), determine refReplacement (its replacement), and then append that replacement to result.

		var ref, refReplacement, found, capture;
		if (isPrefixOf('$$', templateRemainder)) { // step 5.b
			ref = '$$'; // step 5.b.i
			refReplacement = '$'; // step 5.b.ii
		} else if (isPrefixOf('$`', templateRemainder)) { // step 5.c
			ref = '$`'; // step 5.c.i
			refReplacement = substring(str, 0, position); // step 5.c.ii
		} else if (isPrefixOf('$&', templateRemainder)) { // step 5.d
			ref = '$&'; // step 5.d.i
			refReplacement = matched; // step 5.d.ii
		} else if (isPrefixOf('$\'', templateRemainder)) { // step 5.e
			ref = '$\''; // step 5.e.i
			var matchLength = matched.length; // step 5.e.ii
			var tailPos = position + matchLength; // step 5.e.iii
			refReplacement = substring(str, min(tailPos, stringLength)); // step 5.e.iv
			// 5.e.v NOTE: tailPos can exceed stringLength only if this abstract operation was invoked by a call to the intrinsic @@replace method of %RegExp.prototype% on an object whose "exec" property is not the intrinsic %RegExp.prototype.exec%.
		} else if (startsWithDollarDigit(templateRemainder)) { // step 5.f
			found = false; // step 5.f.i
			for (var d = 2; d > 0; d -= 1) { // step 5.f.ii
				// If found is false and templateRemainder starts with "$" followed by d or more decimal digits, then
				if (!found) { // step 5.f.ii.1
					found = true; // step 5.f.ii.1.a
					ref = substring(templateRemainder, 0, 1 + d); // step 5.f.ii.1.b
					var digits = substring(templateRemainder, 1, 1 + d); // step 5.f.ii.1.c
					var index = StringToNumber(digits); // step 5.f.ii.1.d
					if (index < 0 || index > 99) {
						throw new $TypeError('Assertion failed: `index` must be >= 0 and <= 99'); // step 5.f.ii.1.e
					}
					if (index === 0) { // step 5.f.ii.1.f
						refReplacement = ref;
					} else if (index <= captures.length) { // step 5.f.ii.1.g
						capture = captures[index - 1]; // step 5.f.ii.1.g.i
						if (typeof capture === 'undefined') { // step 5.f.ii.1.g.ii
							refReplacement = ''; // step 5.f.ii.1.g.ii.i
						} else { // step 5.f.ii.1.g.iii
							refReplacement = capture; // step 5.f.ii.1.g.iii.i
						}
					} else { // step 5.f.ii.1.h
						refReplacement = ref; // step 5.f.ii.1.h.i
					}
				}
			}
		} else if (isPrefixOf('$<', templateRemainder)) { // step 5.g
			var gtPos = StringIndexOf(templateRemainder, '>', 0); // step 5.g.i
			if (gtPos === -1 || typeof namedCaptures === 'undefined') { // step 5.g.ii
				ref = '$<'; // step 5.g.ii.1
				refReplacement = ref; // step 5.g.ii.2
			} else { // step 5.g.iii
				ref = substring(templateRemainder, 0, gtPos + 1); // step 5.g.iii.1
				var groupName = substring(templateRemainder, 2, gtPos); // step 5.g.iii.2
				if (!isObject(namedCaptures)) {
					throw new $TypeError('Assertion failed: Type(namedCaptures) is not Object'); // step 5.g.iii.3
				}
				capture = Get(namedCaptures, groupName); // step 5.g.iii.4
				if (typeof capture === 'undefined') { // step 5.g.iii.5
					refReplacement = ''; // step 5.g.iii.5.a
				} else { // step 5.g.iii.6
					refReplacement = ToString(capture); // step 5.g.iii.6.a
				}
			}
		} else { // step 5.h
			ref = substring(templateRemainder, 0, 1); // step 5.h.i
			refReplacement = ref; // step 5.h.ii
		}

		var refLength = ref.length; // step 5.i

		templateRemainder = substring(templateRemainder, refLength); // step 5.j

		result += refReplacement; // step 5.k
	}

	return result; // step 6
};
'use strict';

var GetIntrinsic = require('get-intrinsic');

var $SyntaxError = require('es-errors/syntax');
var $TypeError = require('es-errors/type');
var $Uint8Array = GetIntrinsic('%Uint8Array%', true);
var isInteger = require('math-intrinsics/isInteger');

var callBound = require('call-bound');

var $slice = callBound('Array.prototype.slice');

var IsDetachedBuffer = require('./IsDetachedBuffer');
var RawBytesToNumeric = require('./RawBytesToNumeric');

var isArrayBuffer = require('is-array-buffer');
var isSharedArrayBuffer = require('is-shared-array-buffer');
var safeConcat = require('safe-array-concat');

var tableTAO = require('./tables/typed-array-objects');

var defaultEndianness = require('../helpers/defaultEndianness');

// https://262.ecma-international.org/11.0/#sec-getvaluefrombuffer

module.exports = function GetValueFromBuffer(arrayBuffer, byteIndex, type, isTypedArray, order) {
	var isSAB = isSharedArrayBuffer(arrayBuffer);
	if (!isArrayBuffer(arrayBuffer) && !isSAB) {
		throw new $TypeError('Assertion failed: `arrayBuffer` must be an ArrayBuffer or a SharedArrayBuffer');
	}

	if (!isInteger(byteIndex)) {
		throw new $TypeError('Assertion failed: `byteIndex` must be an integer');
	}

	if (typeof type !== 'string' || typeof tableTAO.size['$' + type] !== 'number') {
		throw new $TypeError('Assertion failed: `type` must be one of ' + tableTAO.choices);
	}

	if (typeof isTypedArray !== 'boolean') {
		throw new $TypeError('Assertion failed: `isTypedArray` must be a boolean');
	}

	if (order !== 'SeqCst' && order !== 'Unordered') {
		throw new $TypeError('Assertion failed: `order` must be either `SeqCst` or `Unordered`');
	}

	if (arguments.length > 5 && typeof arguments[5] !== 'boolean') {
		throw new $TypeError('Assertion failed: `isLittleEndian` must be a boolean, if present');
	}

	if (IsDetachedBuffer(arrayBuffer)) {
		throw new $TypeError('Assertion failed: `arrayBuffer` is detached'); // step 1
	}

	// 2. Assert: There are sufficient bytes in arrayBuffer starting at byteIndex to represent a value of type.

	if (byteIndex < 0) {
		throw new $TypeError('Assertion failed: `byteIndex` must be non-negative'); // step 3
	}

	// 4. Let block be arrayBuffer.[[ArrayBufferData]].

	var elementSize = tableTAO.size['$' + type]; // step 5
	if (!elementSize) {
		throw new $TypeError('Assertion failed: `type` must be one of ' + tableTAO.choices);
	}

	var rawValue;
	if (isSAB) { // step 6
		/*
		a. Let execution be the [[CandidateExecution]] field of the surrounding agent's Agent Record.
		b. Let eventList be the [[EventList]] field of the element in execution.[[EventLists]] whose [[AgentSignifier]] is AgentSignifier().
		c. If isTypedArray is true and type is "Int8", "Uint8", "Int16", "Uint16", "Int32", or "Uint32", let noTear be true; otherwise let noTear be false.
		d. Let rawValue be a List of length elementSize of nondeterministically chosen byte values.
		e. NOTE: In implementations, rawValue is the result of a non-atomic or atomic read instruction on the underlying hardware. The nondeterminism is a semantic prescription of the memory model to describe observable behaviour of hardware with weak consistency.
		f. Let readEvent be ReadSharedMemory{ [[Order]]: order, [[NoTear]]: noTear, [[Block]]: block, [[ByteIndex]]: byteIndex, [[ElementSize]]: elementSize }.
		g. Append readEvent to eventList.
		h. Append Chosen Value Record { [[Event]]: readEvent, [[ChosenValue]]: rawValue } to execution.[[ChosenValues]].
		*/
		throw new $SyntaxError('SharedArrayBuffer is not supported by this implementation');
	} else {
		// 7. Let rawValue be a List of elementSize containing, in order, the elementSize sequence of bytes starting with block[byteIndex].
		rawValue = $slice(new $Uint8Array(arrayBuffer, byteIndex), 0, elementSize); // step 6
	}

	// 8. If isLittleEndian is not present, set isLittleEndian to either true or false. The choice is implementation dependent and should be the alternative that is most efficient for the implementation. An implementation must use the same value each time this step is executed and the same value must be used for the corresponding step in the SetValueInBuffer abstract operation.
	var isLittleEndian = arguments.length > 5 ? arguments[5] : defaultEndianness === 'little'; // step 8

	var bytes = isLittleEndian
		? $slice(safeConcat([0, 0, 0, 0, 0, 0, 0, 0], rawValue), -elementSize)
		: $slice(safeConcat(rawValue, [0, 0, 0, 0, 0, 0, 0, 0]), 0, elementSize);

	return RawBytesToNumeric(type, bytes, isLittleEndian);
};
'use strict';

var $TypeError = require('es-errors/type');

var inspect = require('object-inspect');

var isPropertyKey = require('../helpers/isPropertyKey');
// var ToObject = require('./ToObject');

// https://262.ecma-international.org/6.0/#sec-getv

module.exports = function GetV(V, P) {
	// 7.3.2.1
	if (!isPropertyKey(P)) {
		throw new $TypeError('Assertion failed: P is not a Property Key, got ' + inspect(P));
	}

	// 7.3.2.2-3
	// var O = ToObject(V);

	// 7.3.2.4
	return V[P];
};
'use strict';

var $TypeError = require('es-errors/type');

var hasOwn = require('hasown');
var isObject = require('es-object-atoms/isObject');

var isPropertyKey = require('../helpers/isPropertyKey');

// https://262.ecma-international.org/6.0/#sec-hasownproperty

module.exports = function HasOwnProperty(O, P) {
	if (!isObject(O)) {
		throw new $TypeError('Assertion failed: `O` must be an Object');
	}
	if (!isPropertyKey(P)) {
		throw new $TypeError('Assertion failed: `P` must be a Property Key');
	}
	return hasOwn(O, P);
};
'use strict';

var $TypeError = require('es-errors/type');
var isObject = require('es-object-atoms/isObject');

var isPropertyKey = require('../helpers/isPropertyKey');

// https://262.ecma-international.org/6.0/#sec-hasproperty

module.exports = function HasProperty(O, P) {
	if (!isObject(O)) {
		throw new $TypeError('Assertion failed: `O` must be an Object');
	}
	if (!isPropertyKey(P)) {
		throw new $TypeError('Assertion failed: `P` must be a Property Key');
	}
	return P in O;
};
'use strict';

var floor = require('./floor');
var modulo = require('./modulo');

var timeConstants = require('../helpers/timeConstants');
var msPerHour = timeConstants.msPerHour;
var HoursPerDay = timeConstants.HoursPerDay;

// https://262.ecma-international.org/5.1/#sec-15.9.1.10

module.exports = function HourFromTime(t) {
	return modulo(floor(t / msPerHour), HoursPerDay);
};
'use strict';

var $EvalError = require('es-errors/eval');

var DaysInYear = require('./DaysInYear');
var YearFromTime = require('./YearFromTime');

// https://262.ecma-international.org/5.1/#sec-15.9.1.3

module.exports = function InLeapYear(t) {
	var days = DaysInYear(YearFromTime(t));
	if (days === 365) {
		return 0;
	}
	if (days === 366) {
		return 1;
	}
	throw new $EvalError('Assertion failed: there are not 365 or 366 days in a year, got: ' + days);
};
'use strict';

var $TypeError = require('es-errors/type');
var isObject = require('es-object-atoms/isObject');

var CreateNonEnumerableDataPropertyOrThrow = require('./CreateNonEnumerableDataPropertyOrThrow');
var Get = require('./Get');
var HasProperty = require('./HasProperty');

// https://262.ecma-international.org/13.0/#sec-installerrorcause

module.exports = function InstallErrorCause(O, options) {
	if (!isObject(O)) {
		throw new $TypeError('Assertion failed: Type(O) is not Object');
	}

	if (isObject(options) && HasProperty(options, 'cause')) {
		var cause = Get(options, 'cause');
		CreateNonEnumerableDataPropertyOrThrow(O, 'cause', cause);
	}
};
'use strict';

var GetIntrinsic = require('get-intrinsic');

var $TypeError = require('es-errors/type');
var isObject = require('es-object-atoms/isObject');

var $hasInstance = GetIntrinsic('%Symbol.hasInstance%', true);

var Call = require('./Call');
var GetMethod = require('./GetMethod');
var IsCallable = require('./IsCallable');
var OrdinaryHasInstance = require('./OrdinaryHasInstance');
var ToBoolean = require('./ToBoolean');

// https://262.ecma-international.org/6.0/#sec-instanceofoperator

module.exports = function InstanceofOperator(O, C) {
	if (!isObject(O)) {
		throw new $TypeError('Assertion failed: Type(O) is not Object');
	}
	var instOfHandler = $hasInstance ? GetMethod(C, $hasInstance) : void 0;
	if (typeof instOfHandler !== 'undefined') {
		return ToBoolean(Call(instOfHandler, C, [O]));
	}
	if (!IsCallable(C)) {
		throw new $TypeError('`C` is not Callable');
	}
	return OrdinaryHasInstance(C, O);
};
'use strict';

var $TypeError = require('es-errors/type');

var GetValueFromBuffer = require('./GetValueFromBuffer');
var IsValidIntegerIndex = require('./IsValidIntegerIndex');
var TypedArrayElementSize = require('./TypedArrayElementSize');
var TypedArrayElementType = require('./TypedArrayElementType');

var isTypedArray = require('is-typed-array');
var typedArrayBuffer = require('typed-array-buffer');
var typedArrayByteOffset = require('typed-array-byte-offset');

// https://262.ecma-international.org/13.0/#sec-integerindexedelementget

module.exports = function IntegerIndexedElementGet(O, index) {
	if (!isTypedArray(O)) {
		throw new $TypeError('Assertion failed: `O` must be a TypedArray');
	}

	if (typeof index !== 'number') {
		throw new $TypeError('Assertion failed: `index` must be a Number');
	}

	if (!IsValidIntegerIndex(O, index)) {
		return void undefined; // step 1
	}

	var offset = typedArrayByteOffset(O); // step 2

	var elementSize = TypedArrayElementSize(O); // step 3

	var indexedPosition = (index * elementSize) + offset; // step 4

	var elementType = TypedArrayElementType(O); // step 5

	return GetValueFromBuffer(typedArrayBuffer(O), indexedPosition, elementType, true, 'Unordered'); // step 11
};
'use strict';

var $TypeError = require('es-errors/type');

var IsValidIntegerIndex = require('./IsValidIntegerIndex');
var SetValueInBuffer = require('./SetValueInBuffer');
var ToBigInt = require('./ToBigInt');
var ToNumber = require('./ToNumber');
var TypedArrayElementSize = require('./TypedArrayElementSize');
var TypedArrayElementType = require('./TypedArrayElementType');

var typedArrayBuffer = require('typed-array-buffer');
var typedArrayByteOffset = require('typed-array-byte-offset');
var whichTypedArray = require('which-typed-array');

// https://262.ecma-international.org/13.0/#sec-integerindexedelementset

module.exports = function IntegerIndexedElementSet(O, index, value) {
	var arrayTypeName = whichTypedArray(O);
	if (!arrayTypeName) {
		throw new $TypeError('Assertion failed: `O` must be a TypedArray');
	}

	if (typeof index !== 'number') {
		throw new $TypeError('Assertion failed: `index` must be a Number');
	}

	var contentType = arrayTypeName === 'BigInt64Array' || arrayTypeName === 'BigUint64Array' ? 'BigInt' : 'Number';
	var numValue = contentType === 'BigInt' ? ToBigInt(value) : ToNumber(value); // steps 1 - 2

	if (IsValidIntegerIndex(O, index)) { // step 3
		var offset = typedArrayByteOffset(O); // step 3.a

		var elementSize = TypedArrayElementSize(O); // step 3.b

		var indexedPosition = (index * elementSize) + offset; // step 3.c

		var elementType = TypedArrayElementType(O); // step 3.d

		SetValueInBuffer(typedArrayBuffer(O), indexedPosition, elementType, numValue, true, 'Unordered'); // step 3.e
	}
};
'use strict';

var $TypeError = require('es-errors/type');
var isObject = require('es-object-atoms/isObject');

var Call = require('./Call');
var CreateDataProperty = require('./CreateDataProperty');
var EnumerableOwnPropertyNames = require('./EnumerableOwnPropertyNames');
var Get = require('./Get');
var IsArray = require('./IsArray');
var LengthOfArrayLike = require('./LengthOfArrayLike');
var ToString = require('./ToString');

var forEach = require('../helpers/forEach');

// https://262.ecma-international.org/11.0/#sec-internalizejsonproperty

module.exports = function InternalizeJSONProperty(holder, name, reviver) {
	if (!isObject(holder)) {
		throw new $TypeError('Assertion failed: `holder` is not an Object');
	}
	if (typeof name !== 'string') {
		throw new $TypeError('Assertion failed: `name` is not a String');
	}
	if (typeof reviver !== 'function') {
		throw new $TypeError('Assertion failed: `reviver` is not a Function');
	}

	var val = Get(holder, name); // step 1

	if (isObject(val)) { // step 2
		var isArray = IsArray(val); // step 2.a
		if (isArray) { // step 2.b
			var I = 0; // step 2.b.i

			var len = LengthOfArrayLike(val, 'length'); // step 2.b.ii

			while (I < len) { // step 2.b.iii
				var newElement = InternalizeJSONProperty(val, ToString(I), reviver); // step 2.b.iv.1

				if (typeof newElement === 'undefined') { // step 2.b.iii.2
					delete val[ToString(I)]; // step 2.b.iii.2.a
				} else { // step 2.b.iii.3
					CreateDataProperty(val, ToString(I), newElement); // step 2.b.iii.3.a
				}

				I += 1; // step 2.b.iii.4
			}
		} else { // step 2.c
			var keys = EnumerableOwnPropertyNames(val, 'key'); // step 2.c.i

			forEach(keys, function (P) { // step 2.c.ii
				// eslint-disable-next-line no-shadow
				var newElement = InternalizeJSONProperty(val, P, reviver); // step 2.c.ii.1

				if (typeof newElement === 'undefined') { // step 2.c.ii.2
					delete val[P]; // step 2.c.ii.2.a
				} else { // step 2.c.ii.3
					CreateDataProperty(val, P, newElement); // step 2.c.ii.3.a
				}
			});
		}
	}

	return Call(reviver, holder, [name, val]); // step 3
};
'use strict';

var $TypeError = require('es-errors/type');

var Call = require('./Call');
var IsArray = require('./IsArray');
var GetV = require('./GetV');
var isPropertyKey = require('../helpers/isPropertyKey');

// https://262.ecma-international.org/6.0/#sec-invoke

module.exports = function Invoke(O, P) {
	if (!isPropertyKey(P)) {
		throw new $TypeError('Assertion failed: P must be a Property Key');
	}
	var argumentsList = arguments.length > 2 ? arguments[2] : [];
	if (!IsArray(argumentsList)) {
		throw new $TypeError('Assertion failed: optional `argumentsList`, if provided, must be a List');
	}
	var func = GetV(O, P);
	return Call(func, O, argumentsList);
};
'use strict';

var $TypeError = require('es-errors/type');

var hasOwn = require('hasown');

var isPropertyDescriptor = require('../helpers/records/property-descriptor');

// https://262.ecma-international.org/5.1/#sec-8.10.1

module.exports = function IsAccessorDescriptor(Desc) {
	if (typeof Desc === 'undefined') {
		return false;
	}

	if (!isPropertyDescriptor(Desc)) {
		throw new $TypeError('Assertion failed: `Desc` must be a Property Descriptor');
	}

	if (!hasOwn(Desc, '[[Get]]') && !hasOwn(Desc, '[[Set]]')) {
		return false;
	}

	return true;
};
'use strict';

// https://262.ecma-international.org/6.0/#sec-isarray
module.exports = require('../helpers/IsArray');
'use strict';

// https://262.ecma-international.org/11.0/#sec-isbigintelementtype

module.exports = function IsBigIntElementType(type) {
	return type === 'BigUint64' || type === 'BigInt64';
};
'use strict';

// http://262.ecma-international.org/5.1/#sec-9.11

module.exports = require('is-callable');
'use strict';

var ValidateAndApplyPropertyDescriptor = require('./ValidateAndApplyPropertyDescriptor');

// https://262.ecma-international.org/13.0/#sec-iscompatiblepropertydescriptor

module.exports = function IsCompatiblePropertyDescriptor(Extensible, Desc, Current) {
	return ValidateAndApplyPropertyDescriptor(undefined, '', Extensible, Desc, Current);
};
'use strict';

var GetIntrinsic = require('get-intrinsic');

var $isConcatSpreadable = GetIntrinsic('%Symbol.isConcatSpreadable%', true);

var Get = require('./Get');
var IsArray = require('./IsArray');
var ToBoolean = require('./ToBoolean');

var isObject = require('es-object-atoms/isObject');

// https://262.ecma-international.org/6.0/#sec-isconcatspreadable

module.exports = function IsConcatSpreadable(O) {
	if (!isObject(O)) {
		return false;
	}
	if ($isConcatSpreadable) {
		var spreadable = Get(O, $isConcatSpreadable);
		if (typeof spreadable !== 'undefined') {
			return ToBoolean(spreadable);
		}
	}
	return IsArray(O);
};
'use strict';

var GetIntrinsic = require('../GetIntrinsic.js');

var $construct = GetIntrinsic('%Reflect.construct%', true);

var DefinePropertyOrThrow = require('./DefinePropertyOrThrow');
try {
	DefinePropertyOrThrow({}, '', { '[[Get]]': function () {} });
} catch (e) {
	// Accessor properties aren't supported
	DefinePropertyOrThrow = null;
}

// https://262.ecma-international.org/6.0/#sec-isconstructor

if (DefinePropertyOrThrow && $construct) {
	var isConstructorMarker = {};
	var badArrayLike = {};
	DefinePropertyOrThrow(badArrayLike, 'length', {
		'[[Get]]': function () {
			throw isConstructorMarker;
		},
		'[[Enumerable]]': true
	});

	module.exports = function IsConstructor(argument) {
		try {
			// `Reflect.construct` invokes `IsConstructor(target)` before `Get(args, 'length')`:
			$construct(argument, badArrayLike);
		} catch (err) {
			return err === isConstructorMarker;
		}
	};
} else {
	module.exports = function IsConstructor(argument) {
		// unfortunately there's no way to truly check this without try/catch `new argument` in old environments
		return typeof argument === 'function' && !!argument.prototype;
	};
}
'use strict';

var $TypeError = require('es-errors/type');

var hasOwn = require('hasown');

var isPropertyDescriptor = require('../helpers/records/property-descriptor');

// https://262.ecma-international.org/5.1/#sec-8.10.2

module.exports = function IsDataDescriptor(Desc) {
	if (typeof Desc === 'undefined') {
		return false;
	}

	if (!isPropertyDescriptor(Desc)) {
		throw new $TypeError('Assertion failed: `Desc` must be a Property Descriptor');
	}

	if (!hasOwn(Desc, '[[Value]]') && !hasOwn(Desc, '[[Writable]]')) {
		return false;
	}

	return true;
};
'use strict';

var $TypeError = require('es-errors/type');

var $byteLength = require('array-buffer-byte-length');
var availableTypedArrays = require('available-typed-arrays')();
var callBound = require('call-bound');
var isArrayBuffer = require('is-array-buffer');
var isSharedArrayBuffer = require('is-shared-array-buffer');

var $sabByteLength = callBound('SharedArrayBuffer.prototype.byteLength', true);

// https://262.ecma-international.org/8.0/#sec-isdetachedbuffer

module.exports = function IsDetachedBuffer(arrayBuffer) {
	var isSAB = isSharedArrayBuffer(arrayBuffer);
	if (!isArrayBuffer(arrayBuffer) && !isSAB) {
		throw new $TypeError('Assertion failed: `arrayBuffer` must be an Object with an [[ArrayBufferData]] internal slot');
	}
	if ((isSAB ? $sabByteLength : $byteLength)(arrayBuffer) === 0) {
		try {
			new global[availableTypedArrays[0]](arrayBuffer); // eslint-disable-line no-new
		} catch (error) {
			return !!error && error.name === 'TypeError';
		}
	}
	return false;
};
'use strict';

var GetIntrinsic = require('get-intrinsic');

var $preventExtensions = GetIntrinsic('%Object.preventExtensions%', true);
var $isExtensible = GetIntrinsic('%Object.isExtensible%', true);

var isPrimitive = require('../helpers/isPrimitive');

// https://262.ecma-international.org/6.0/#sec-isextensible-o

module.exports = $preventExtensions
	? function IsExtensible(obj) {
		return !isPrimitive(obj) && $isExtensible(obj);
	}
	: function IsExtensible(obj) {
		return !isPrimitive(obj);
	};
'use strict';

var $TypeError = require('es-errors/type');

var IsAccessorDescriptor = require('./IsAccessorDescriptor');
var IsDataDescriptor = require('./IsDataDescriptor');

var isPropertyDescriptor = require('../helpers/records/property-descriptor');

// https://262.ecma-international.org/6.0/#sec-isgenericdescriptor

module.exports = function IsGenericDescriptor(Desc) {
	if (typeof Desc === 'undefined') {
		return false;
	}

	if (!isPropertyDescriptor(Desc)) {
		throw new $TypeError('Assertion failed: `Desc` must be a Property Descriptor');
	}

	if (!IsAccessorDescriptor(Desc) && !IsDataDescriptor(Desc)) {
		return true;
	}

	return false;
};
'use strict';

var isInteger = require('math-intrinsics/isInteger');

// https://262.ecma-international.org/12.0/#sec-isinteger

module.exports = function IsIntegralNumber(argument) {
	return isInteger(argument);
};
'use strict';

var GetIntrinsic = require('get-intrinsic');

var $Number = GetIntrinsic('%Number%');
var $TypeError = require('es-errors/type');

var $isNaN = require('math-intrinsics/isNaN');

var IsStringPrefix = require('./IsStringPrefix');
var StringToBigInt = require('./StringToBigInt');
var ToNumeric = require('./ToNumeric');
var ToPrimitive = require('./ToPrimitive');

var BigIntLessThan = require('./BigInt/lessThan');
var NumberLessThan = require('./Number/lessThan');

// https://262.ecma-international.org/13.0/#sec-islessthan

// eslint-disable-next-line max-statements, max-lines-per-function
module.exports = function IsLessThan(x, y, LeftFirst) {
	if (typeof LeftFirst !== 'boolean') {
		throw new $TypeError('Assertion failed: LeftFirst argument must be a Boolean');
	}
	var px;
	var py;
	if (LeftFirst) {
		px = ToPrimitive(x, $Number);
		py = ToPrimitive(y, $Number);
	} else {
		py = ToPrimitive(y, $Number);
		px = ToPrimitive(x, $Number);
	}

	if (typeof px === 'string' && typeof py === 'string') {
		if (IsStringPrefix(py, px)) {
			return false;
		}
		if (IsStringPrefix(px, py)) {
			return true;
		}
		/*
		c. Let k be the smallest non-negative integer such that the code unit at index k within px is different from the code unit at index k within py. (There must be such a k, for neither String is a prefix of the other.)
		d. Let m be the integer that is the numeric value of the code unit at index k within px.
		e. Let n be the integer that is the numeric value of the code unit at index k within py.
		f. If m < n, return true. Otherwise, return false.
		*/
		return px < py; // both strings, neither a prefix of the other. shortcut for steps 3 c-f
	}

	var nx;
	var ny;
	if (typeof px === 'bigint' && typeof py === 'string') {
		ny = StringToBigInt(py);
		if (typeof ny === 'undefined') {
			return void undefined;
		}
		return BigIntLessThan(px, ny);
	}
	if (typeof px === 'string' && typeof py === 'bigint') {
		nx = StringToBigInt(px);
		if (typeof nx === 'undefined') {
			return void undefined;
		}
		return BigIntLessThan(nx, py);
	}

	nx = ToNumeric(px);
	ny = ToNumeric(py);

	if (typeof nx === typeof ny) {
		return typeof nx === 'number' ? NumberLessThan(nx, ny) : BigIntLessThan(nx, ny);
	}

	if ($isNaN(nx) || $isNaN(ny)) {
		return void undefined;
	}

	if (nx === -Infinity || ny === Infinity) {
		return true;
	}
	if (nx === Infinity || ny === -Infinity) {
		return false;
	}

	return nx < ny; // by now, these are both finite, and the same type
};
'use strict';

var isFinite = require('math-intrinsics/isFinite');
var isObject = require('es-object-atoms/isObject');

var IsStrictlyEqual = require('./IsStrictlyEqual');
var StringToBigInt = require('./StringToBigInt');
var ToNumber = require('./ToNumber');
var ToPrimitive = require('./ToPrimitive');

var isSameType = require('../helpers/isSameType');

// https://262.ecma-international.org/13.0/#sec-islooselyequal

module.exports = function IsLooselyEqual(x, y) {
	if (isSameType(x, y)) {
		return IsStrictlyEqual(x, y);
	}
	if (x == null && y == null) {
		return true;
	}
	if (typeof x === 'number' && typeof y === 'string') {
		return IsLooselyEqual(x, ToNumber(y));
	}
	if (typeof x === 'string' && typeof y === 'number') {
		return IsLooselyEqual(ToNumber(x), y);
	}
	if (typeof x === 'bigint' && typeof y === 'string') {
		var n = StringToBigInt(y);
		if (typeof n === 'undefined') {
			return false;
		}
		return IsLooselyEqual(x, n);
	}
	if (typeof x === 'string' && typeof y === 'bigint') {
		return IsLooselyEqual(y, x);
	}
	if (typeof x === 'boolean') {
		return IsLooselyEqual(ToNumber(x), y);
	}
	if (typeof y === 'boolean') {
		return IsLooselyEqual(x, ToNumber(y));
	}
	if ((typeof x === 'string' || typeof x === 'number' || typeof x === 'symbol' || typeof x === 'bigint') && isObject(y)) {
		return IsLooselyEqual(x, ToPrimitive(y));
	}
	if (isObject(x) && (typeof y === 'string' || typeof y === 'number' || typeof y === 'symbol' || typeof y === 'bigint')) {
		return IsLooselyEqual(ToPrimitive(x), y);
	}
	if ((typeof x === 'bigint' && typeof y === 'number') || (typeof x === 'number' && typeof y === 'bigint')) {
		if (!isFinite(x) || !isFinite(y)) {
			return false;
		}
		// eslint-disable-next-line eqeqeq
		return x == y; // shortcut for step 13.b.
	}
	return false;
};
'use strict';

var IsUnclampedIntegerElementType = require('./IsUnclampedIntegerElementType');
var IsBigIntElementType = require('./IsBigIntElementType');

// https://262.ecma-international.org/11.0/#sec-isnotearconfiguration

module.exports = function IsNoTearConfiguration(type, order) {
	if (IsUnclampedIntegerElementType(type)) {
		return true;
	}
	if (IsBigIntElementType(type) && order !== 'Init' && order !== 'Unordered') {
		return true;
	}
	return false;
};
'use strict';

var callBound = require('call-bound');

var $PromiseThen = callBound('Promise.prototype.then', true);

var isObject = require('es-object-atoms/isObject');

// https://262.ecma-international.org/6.0/#sec-ispromise

module.exports = function IsPromise(x) {
	if (!isObject(x)) {
		return false;
	}
	if (!$PromiseThen) { // Promises are not supported
		return false;
	}
	try {
		$PromiseThen(x); // throws if not a promise
	} catch (e) {
		return false;
	}
	return true;
};
'use strict';

var isPropertyKey = require('../helpers/isPropertyKey');

// https://262.ecma-international.org/6.0/#sec-ispropertykey

module.exports = function IsPropertyKey(argument) {
	return isPropertyKey(argument);
};
'use strict';

var GetIntrinsic = require('get-intrinsic');

var $match = GetIntrinsic('%Symbol.match%', true);

var hasRegExpMatcher = require('is-regex');
var isObject = require('es-object-atoms/isObject');

var ToBoolean = require('./ToBoolean');

// https://262.ecma-international.org/6.0/#sec-isregexp

module.exports = function IsRegExp(argument) {
	if (!isObject(argument)) {
		return false;
	}
	if ($match) {
		var isRegExp = argument[$match];
		if (typeof isRegExp !== 'undefined') {
			return ToBoolean(isRegExp);
		}
	}
	return hasRegExpMatcher(argument);
};
'use strict';

var $TypeError = require('es-errors/type');
var isObject = require('es-object-atoms/isObject');

var isSharedArrayBuffer = require('is-shared-array-buffer');

// https://262.ecma-international.org/8.0/#sec-issharedarraybuffer

module.exports = function IsSharedArrayBuffer(obj) {
	if (!isObject(obj)) {
		throw new $TypeError('Assertion failed: Type(O) is not Object');
	}

	return isSharedArrayBuffer(obj);
};
'use strict';

var SameValueNonNumeric = require('./SameValueNonNumeric');
var Type = require('./Type');
var BigIntEqual = require('./BigInt/equal');
var NumberEqual = require('./Number/equal');

// https://262.ecma-international.org/13.0/#sec-isstrictlyequal

module.exports = function IsStrictlyEqual(x, y) {
	if (Type(x) !== Type(y)) {
		return false;
	}
	if (typeof x === 'number' || typeof x === 'bigint') {
		return typeof x === 'number' ? NumberEqual(x, y) : BigIntEqual(x, y);
	}
	return SameValueNonNumeric(x, y);
};
'use strict';

var $TypeError = require('es-errors/type');

var StringIndexOf = require('./StringIndexOf');

// https://262.ecma-international.org/13.0/#sec-isstringprefix

module.exports = function IsStringPrefix(p, q) {
	if (typeof p !== 'string') {
		throw new $TypeError('Assertion failed: "p" must be a String');
	}

	if (typeof q !== 'string') {
		throw new $TypeError('Assertion failed: "q" must be a String');
	}

	return StringIndexOf(q, p, 0) === 0;
};
'use strict';

var CodePointAt = require('./CodePointAt');

var $TypeError = require('es-errors/type');

// https://262.ecma-international.org/13.0/#sec-isstringwellformedunicode

module.exports = function IsStringWellFormedUnicode(string) {
	if (typeof string !== 'string') {
		throw new $TypeError('Assertion failed: `string` must be a String');
	}
	var strLen = string.length; // step 1
	var k = 0; // step 2
	while (k !== strLen) { // step 3
		var cp = CodePointAt(string, k); // step 3.a
		if (cp['[[IsUnpairedSurrogate]]']) {
			return false; // step 3.b
		}
		k += cp['[[CodeUnitCount]]']; // step 3.c
	}
	return true; // step 4
};
'use strict';

// https://262.ecma-international.org/11.0/#sec-isunclampedintegerelementtype

module.exports = function IsUnclampedIntegerElementType(type) {
	return type === 'Int8'
		|| type === 'Uint8'
		|| type === 'Int16'
		|| type === 'Uint16'
		|| type === 'Int32'
		|| type === 'Uint32';
};
'use strict';

// https://262.ecma-international.org/11.0/#sec-isunsignedelementtype

module.exports = function IsUnsignedElementType(type) {
	return type === 'Uint8'
		|| type === 'Uint8C'
		|| type === 'Uint16'
		|| type === 'Uint32'
		|| type === 'BigUint64';
};
'use strict';

var $TypeError = require('es-errors/type');
var isNegativeZero = require('math-intrinsics/isNegativeZero');

var IsDetachedBuffer = require('./IsDetachedBuffer');

var isInteger = require('math-intrinsics/isInteger');
var typedArrayBuffer = require('typed-array-buffer');

// https://262.ecma-international.org/12.0/#sec-isvalidintegerindex

module.exports = function IsValidIntegerIndex(O, index) {
	// Assert: O is an Integer-Indexed exotic object.
	var buffer = typedArrayBuffer(O); // step 1

	if (typeof index !== 'number') {
		throw new $TypeError('Assertion failed: Type(index) is not Number');
	}

	if (IsDetachedBuffer(buffer)) { return false; } // step 2

	if (!isInteger(index)) { return false; } // step 3

	if (isNegativeZero(index)) { return false; } // step 4

	if (index < 0 || index >= O.length) { return false; } // step 5

	return true; // step 6
};
'use strict';

var $TypeError = require('es-errors/type');

var callBound = require('call-bound');

var $indexOf = callBound('String.prototype.indexOf');

var IsArray = require('./IsArray');
var WordCharacters = require('./WordCharacters');

var every = require('../helpers/every');

var isInteger = require('math-intrinsics/isInteger');

var isChar = function isChar(c) {
	return typeof c === 'string';
};

// https://262.ecma-international.org/12.0/#sec-runtime-semantics-iswordchar-abstract-operation

// note: prior to ES2023, this AO erroneously omitted the latter of its arguments.
module.exports = function IsWordChar(e, InputLength, Input, IgnoreCase, Unicode) {
	if (!isInteger(e)) {
		throw new $TypeError('Assertion failed: `e` must be an integer');
	}
	if (!isInteger(InputLength)) {
		throw new $TypeError('Assertion failed: `InputLength` must be an integer');
	}
	if (!IsArray(Input) || !every(Input, isChar)) {
		throw new $TypeError('Assertion failed: `Input` must be a List of characters');
	}
	if (typeof IgnoreCase !== 'boolean' || typeof Unicode !== 'boolean') {
		throw new $TypeError('Assertion failed: `IgnoreCase` and `Unicode` must be booleans');
	}

	if (e === -1 || e === InputLength) {
		return false; // step 1
	}

	var c = Input[e]; // step 2

	var wordChars = WordCharacters(IgnoreCase, Unicode);

	return $indexOf(wordChars, c) > -1; // steps 3-4
};
'use strict';

var GetIterator = require('./GetIterator');
var IteratorStep = require('./IteratorStep');
var IteratorValue = require('./IteratorValue');

// https://262.ecma-international.org/12.0/#sec-iterabletolist

module.exports = function IterableToList(items) {
	var iterator;
	if (arguments.length > 1) {
		iterator = GetIterator(items, 'sync', arguments[1]);
	} else {
		iterator = GetIterator(items, 'sync');
	}
	var values = [];
	var next = true;
	while (next) {
		next = IteratorStep(iterator);
		if (next) {
			var nextValue = IteratorValue(next);
			values[values.length] = nextValue;
		}
	}
	return values;
};
'use strict';

var $TypeError = require('es-errors/type');
var isObject = require('es-object-atoms/isObject');

var Call = require('./Call');
var CompletionRecord = require('./CompletionRecord');
var GetMethod = require('./GetMethod');
var IsCallable = require('./IsCallable');

// https://262.ecma-international.org/6.0/#sec-iteratorclose

module.exports = function IteratorClose(iterator, completion) {
	if (!isObject(iterator)) {
		throw new $TypeError('Assertion failed: Type(iterator) is not Object');
	}
	if (!IsCallable(completion) && !(completion instanceof CompletionRecord)) {
		throw new $TypeError('Assertion failed: completion is not a thunk representing a Completion Record, nor a Completion Record instance');
	}
	var completionThunk = completion instanceof CompletionRecord ? function () { return completion['?'](); } : completion;

	var iteratorReturn = GetMethod(iterator, 'return');

	if (typeof iteratorReturn === 'undefined') {
		return completionThunk();
	}

	var completionRecord;
	try {
		var innerResult = Call(iteratorReturn, iterator, []);
	} catch (e) {
		// if we hit here, then "e" is the innerResult completion that needs re-throwing

		// if the completion is of type "throw", this will throw.
		completionThunk();
		completionThunk = null; // ensure it's not called twice.

		// if not, then return the innerResult completion
		throw e;
	}
	completionRecord = completionThunk(); // if innerResult worked, then throw if the completion does
	completionThunk = null; // ensure it's not called twice.

	if (!isObject(innerResult)) {
		throw new $TypeError('iterator .return must return an object');
	}

	return completionRecord;
};
'use strict';

var $TypeError = require('es-errors/type');
var isObject = require('es-object-atoms/isObject');

var Get = require('./Get');
var ToBoolean = require('./ToBoolean');

// https://262.ecma-international.org/6.0/#sec-iteratorcomplete

module.exports = function IteratorComplete(iterResult) {
	if (!isObject(iterResult)) {
		throw new $TypeError('Assertion failed: Type(iterResult) is not Object');
	}
	return ToBoolean(Get(iterResult, 'done'));
};
'use strict';

var $TypeError = require('es-errors/type');
var isObject = require('es-object-atoms/isObject');

var Invoke = require('./Invoke');

// https://262.ecma-international.org/6.0/#sec-iteratornext

module.exports = function IteratorNext(iterator, value) {
	var result = Invoke(iterator, 'next', arguments.length < 2 ? [] : [value]);
	if (!isObject(result)) {
		throw new $TypeError('iterator next must return an object');
	}
	return result;
};
'use strict';

var IteratorComplete = require('./IteratorComplete');
var IteratorNext = require('./IteratorNext');

// https://262.ecma-international.org/6.0/#sec-iteratorstep

module.exports = function IteratorStep(iterator) {
	var result = IteratorNext(iterator);
	var done = IteratorComplete(result);
	return done === true ? false : result;
};

'use strict';

var $TypeError = require('es-errors/type');
var isObject = require('es-object-atoms/isObject');

var Get = require('./Get');

// https://262.ecma-international.org/6.0/#sec-iteratorvalue

module.exports = function IteratorValue(iterResult) {
	if (!isObject(iterResult)) {
		throw new $TypeError('Assertion failed: Type(iterResult) is not Object');
	}
	return Get(iterResult, 'value');
};

'use strict';

var $TypeError = require('es-errors/type');
var isObject = require('es-object-atoms/isObject');

var Get = require('./Get');
var ToLength = require('./ToLength');

// https://262.ecma-international.org/11.0/#sec-lengthofarraylike

module.exports = function LengthOfArrayLike(obj) {
	if (!isObject(obj)) {
		throw new $TypeError('Assertion failed: `obj` must be an Object');
	}
	return ToLength(Get(obj, 'length'));
};

// TODO: use this all over
'use strict';

var $isFinite = require('math-intrinsics/isFinite');

var msPerDay = require('../helpers/timeConstants').msPerDay;

// https://262.ecma-international.org/5.1/#sec-15.9.1.13

module.exports = function MakeDate(day, time) {
	if (!$isFinite(day) || !$isFinite(time)) {
		return NaN;
	}
	return (day * msPerDay) + time;
};
'use strict';

var GetIntrinsic = require('get-intrinsic');

var $DateUTC = GetIntrinsic('%Date.UTC%');

var $isFinite = require('math-intrinsics/isFinite');

var DateFromTime = require('./DateFromTime');
var Day = require('./Day');
var floor = require('./floor');
var modulo = require('./modulo');
var MonthFromTime = require('./MonthFromTime');
var ToIntegerOrInfinity = require('./ToIntegerOrInfinity');
var YearFromTime = require('./YearFromTime');

// https://262.ecma-international.org/5.1/#sec-15.9.1.12

module.exports = function MakeDay(year, month, date) {
	if (!$isFinite(year) || !$isFinite(month) || !$isFinite(date)) {
		return NaN;
	}
	var y = ToIntegerOrInfinity(year);
	var m = ToIntegerOrInfinity(month);
	var dt = ToIntegerOrInfinity(date);
	var ym = y + floor(m / 12);
	if (!$isFinite(ym)) {
		return NaN;
	}
	var mn = modulo(m, 12);
	var t = $DateUTC(ym, mn, 1);
	if (YearFromTime(t) !== ym || MonthFromTime(t) !== mn || DateFromTime(t) !== 1) {
		return NaN;
	}
	return Day(t) + dt - 1;
};
'use strict';

var $TypeError = require('es-errors/type');

var ArrayCreate = require('./ArrayCreate');
var CreateDataPropertyOrThrow = require('./CreateDataPropertyOrThrow');
var GetMatchIndexPair = require('./GetMatchIndexPair');
var IsArray = require('./IsArray');
var OrdinaryObjectCreate = require('./OrdinaryObjectCreate');
var ToString = require('./ToString');

var every = require('../helpers/every');
var isMatchRecord = require('../helpers/records/match-record');

var isStringOrUndefined = function isStringOrUndefined(s) {
	return typeof s === 'undefined' || typeof s === 'string';
};

var isMatchRecordOrUndefined = function isMatchRecordOrUndefined(m) {
	return typeof m === 'undefined' || isMatchRecord(m);
};

var MAX_ARRAY_LENGTH = require('math-intrinsics/constants/maxArrayLength');

// https://262.ecma-international.org/13.0/#sec-getmatchindexpair

module.exports = function MakeMatchIndicesIndexPairArray(S, indices, groupNames, hasGroups) {
	if (typeof S !== 'string') {
		throw new $TypeError('Assertion failed: `S` must be a String');
	}
	if (!IsArray(indices) || !every(indices, isMatchRecordOrUndefined)) {
		throw new $TypeError('Assertion failed: `indices` must be a List of either Match Records or `undefined`');
	}
	if (!IsArray(groupNames) || !every(groupNames, isStringOrUndefined)) {
		throw new $TypeError('Assertion failed: `groupNames` must be a List of either Strings or `undefined`');
	}
	if (typeof hasGroups !== 'boolean') {
		throw new $TypeError('Assertion failed: `hasGroups` must be a Boolean');
	}

	var n = indices.length; // step 1
	if (!(n < MAX_ARRAY_LENGTH)) {
		throw new $TypeError('Assertion failed: `indices` length must be less than the max array size, 2**32 - 1');
	}
	if (groupNames.length !== n - 1) {
		throw new $TypeError('Assertion failed: `groupNames` must have exactly one fewer item than `indices`');
	}

	var A = ArrayCreate(n); // step 5
	var groups = hasGroups ? OrdinaryObjectCreate(null) : void undefined; // step 6-7
	CreateDataPropertyOrThrow(A, 'groups', groups); // step 8

	for (var i = 0; i < n; i += 1) { // step 9
		var matchIndices = indices[i]; // step 9.a
		// eslint-disable-next-line no-negated-condition
		var matchIndexPair = typeof matchIndices !== 'undefined' ? GetMatchIndexPair(S, matchIndices) : void undefined; // step 9.b-9.c
		CreateDataPropertyOrThrow(A, ToString(i), matchIndexPair); // step 9.d
		if (i > 0 && typeof groupNames[i - 1] !== 'undefined') { // step 9.e
			if (!groups) {
				throw new $TypeError('if `hasGroups` is `false`, `groupNames` can only contain `undefined` values');
			}
			CreateDataPropertyOrThrow(groups, groupNames[i - 1], matchIndexPair); // step 9.e.i
		}
	}
	return A; // step 10
};
'use strict';

var $isFinite = require('math-intrinsics/isFinite');
var timeConstants = require('../helpers/timeConstants');
var msPerSecond = timeConstants.msPerSecond;
var msPerMinute = timeConstants.msPerMinute;
var msPerHour = timeConstants.msPerHour;

var ToIntegerOrInfinity = require('./ToIntegerOrInfinity');

// https://262.ecma-international.org/12.0/#sec-maketime

module.exports = function MakeTime(hour, min, sec, ms) {
	if (!$isFinite(hour) || !$isFinite(min) || !$isFinite(sec) || !$isFinite(ms)) {
		return NaN;
	}
	var h = ToIntegerOrInfinity(hour);
	var m = ToIntegerOrInfinity(min);
	var s = ToIntegerOrInfinity(sec);
	var milli = ToIntegerOrInfinity(ms);
	var t = (h * msPerHour) + (m * msPerMinute) + (s * msPerSecond) + milli;
	return t;
};
'use strict';

// https://262.ecma-international.org/6.0/#sec-algorithm-conventions

module.exports = require('math-intrinsics/max');
'use strict';

var floor = require('./floor');
var modulo = require('./modulo');

var timeConstants = require('../helpers/timeConstants');
var msPerMinute = timeConstants.msPerMinute;
var MinutesPerHour = timeConstants.MinutesPerHour;

// https://262.ecma-international.org/5.1/#sec-15.9.1.10

module.exports = function MinFromTime(t) {
	return modulo(floor(t / msPerMinute), MinutesPerHour);
};
'use strict';

// https://262.ecma-international.org/6.0/#sec-algorithm-conventions

module.exports = require('math-intrinsics/min');
'use strict';

var mod = require('../helpers/mod');

// https://262.ecma-international.org/5.1/#sec-5.2

module.exports = function modulo(x, y) {
	return mod(x, y);
};
'use strict';

var $RangeError = require('es-errors/range');

var DayWithinYear = require('./DayWithinYear');
var InLeapYear = require('./InLeapYear');

// https://262.ecma-international.org/5.1/#sec-15.9.1.4

module.exports = function MonthFromTime(t) {
	var day = DayWithinYear(t);
	if (0 <= day && day < 31) {
		return 0;
	}
	var leap = InLeapYear(t);
	if (31 <= day && day < (59 + leap)) {
		return 1;
	}
	if ((59 + leap) <= day && day < (90 + leap)) {
		return 2;
	}
	if ((90 + leap) <= day && day < (120 + leap)) {
		return 3;
	}
	if ((120 + leap) <= day && day < (151 + leap)) {
		return 4;
	}
	if ((151 + leap) <= day && day < (181 + leap)) {
		return 5;
	}
	if ((181 + leap) <= day && day < (212 + leap)) {
		return 6;
	}
	if ((212 + leap) <= day && day < (243 + leap)) {
		return 7;
	}
	if ((243 + leap) <= day && day < (273 + leap)) {
		return 8;
	}
	if ((273 + leap) <= day && day < (304 + leap)) {
		return 9;
	}
	if ((304 + leap) <= day && day < (334 + leap)) {
		return 10;
	}
	if ((334 + leap) <= day && day < (365 + leap)) {
		return 11;
	}

	throw new $RangeError('Assertion failed: `day` is out of range');
};
'use strict';

var modulo = require('./modulo');

var msPerSecond = require('../helpers/timeConstants').msPerSecond;

// https://262.ecma-international.org/5.1/#sec-15.9.1.10

module.exports = function msFromTime(t) {
	return modulo(t, msPerSecond);
};
'use strict';

var $TypeError = require('es-errors/type');

var IsCallable = require('./IsCallable');
var IsConstructor = require('./IsConstructor');

// https://262.ecma-international.org/6.0/#sec-newpromisecapability

module.exports = function NewPromiseCapability(C) {
	if (!IsConstructor(C)) {
		throw new $TypeError('C must be a constructor'); // step 1
	}

	var resolvingFunctions = { '[[Resolve]]': void undefined, '[[Reject]]': void undefined }; // step 3

	var promise = new C(function (resolve, reject) { // steps 4-5
		if (typeof resolvingFunctions['[[Resolve]]'] !== 'undefined' || typeof resolvingFunctions['[[Reject]]'] !== 'undefined') {
			throw new $TypeError('executor has already been called'); // step 4.a, 4.b
		}
		resolvingFunctions['[[Resolve]]'] = resolve; // step 4.c
		resolvingFunctions['[[Reject]]'] = reject; // step 4.d
	}); // step 4-6

	if (!IsCallable(resolvingFunctions['[[Resolve]]']) || !IsCallable(resolvingFunctions['[[Reject]]'])) {
		throw new $TypeError('executor must provide valid resolve and reject functions'); // steps 7-8
	}

	return {
		'[[Promise]]': promise,
		'[[Resolve]]': resolvingFunctions['[[Resolve]]'],
		'[[Reject]]': resolvingFunctions['[[Reject]]']
	}; // step 9
};
'use strict';

var CompletionRecord = require('./CompletionRecord');

// https://262.ecma-international.org/6.0/#sec-normalcompletion

module.exports = function NormalCompletion(value) {
	return new CompletionRecord('normal', value);
};
'use strict';

var $TypeError = require('es-errors/type');

var ToInt32 = require('./ToInt32');
var ToUint32 = require('./ToUint32');

// https://262.ecma-international.org/11.0/#sec-numberbitwiseop

module.exports = function NumberBitwiseOp(op, x, y) {
	if (op !== '&' && op !== '|' && op !== '^') {
		throw new $TypeError('Assertion failed: `op` must be `&`, `|`, or `^`');
	}
	if (typeof x !== 'number' || typeof y !== 'number') {
		throw new $TypeError('Assertion failed: `x` and `y` arguments must be Numbers');
	}
	var lnum = ToInt32(x);
	var rnum = ToUint32(y);
	if (op === '&') {
		return lnum & rnum;
	}
	if (op === '|') {
		return lnum | rnum;
	}
	return lnum ^ rnum;
};
'use strict';

var GetIntrinsic = require('get-intrinsic');

var $BigInt = GetIntrinsic('%BigInt%', true);
var $RangeError = require('es-errors/range');
var $SyntaxError = require('es-errors/syntax');
var $TypeError = require('es-errors/type');

var isInteger = require('math-intrinsics/isInteger');

// https://262.ecma-international.org/12.0/#sec-numbertobigint

module.exports = function NumberToBigInt(number) {
	if (typeof number !== 'number') {
		throw new $TypeError('Assertion failed: `number` must be a String');
	}
	if (!isInteger(number)) {
		throw new $RangeError('The number ' + number + ' cannot be converted to a BigInt because it is not an integer');
	}
	if (!$BigInt) {
		throw new $SyntaxError('BigInts are not supported in this environment');
	}
	return $BigInt(number);
};
'use strict';

var $TypeError = require('es-errors/type');

var hasOwnProperty = require('./HasOwnProperty');
var ToBigInt64 = require('./ToBigInt64');
var ToBigUint64 = require('./ToBigUint64');
var ToInt16 = require('./ToInt16');
var ToInt32 = require('./ToInt32');
var ToInt8 = require('./ToInt8');
var ToUint16 = require('./ToUint16');
var ToUint32 = require('./ToUint32');
var ToUint8 = require('./ToUint8');
var ToUint8Clamp = require('./ToUint8Clamp');

var valueToFloat32Bytes = require('../helpers/valueToFloat32Bytes');
var valueToFloat64Bytes = require('../helpers/valueToFloat64Bytes');
var integerToNBytes = require('../helpers/integerToNBytes');

var tableTAO = require('./tables/typed-array-objects');

// https://262.ecma-international.org/11.0/#table-the-typedarray-constructors
var TypeToAO = {
	__proto__: null,
	$Int8: ToInt8,
	$Uint8: ToUint8,
	$Uint8C: ToUint8Clamp,
	$Int16: ToInt16,
	$Uint16: ToUint16,
	$Int32: ToInt32,
	$Uint32: ToUint32,
	$BigInt64: ToBigInt64,
	$BigUint64: ToBigUint64
};

// https://262.ecma-international.org/11.0/#sec-numerictorawbytes

module.exports = function NumericToRawBytes(type, value, isLittleEndian) {
	if (typeof type !== 'string' || !hasOwnProperty(tableTAO.size, '$' + type)) {
		throw new $TypeError('Assertion failed: `type` must be a TypedArray element type');
	}
	if (typeof value !== 'number' && typeof value !== 'bigint') {
		throw new $TypeError('Assertion failed: `value` must be a Number or a BigInt');
	}
	if (typeof isLittleEndian !== 'boolean') {
		throw new $TypeError('Assertion failed: `isLittleEndian` must be a Boolean');
	}

	if (type === 'Float32') { // step 1
		return valueToFloat32Bytes(value, isLittleEndian);
	} else if (type === 'Float64') { // step 2
		return valueToFloat64Bytes(value, isLittleEndian);
	} // step 3

	var n = tableTAO.size['$' + type]; // step 3.a

	var convOp = TypeToAO['$' + type]; // step 3.b

	var intValue = convOp(value); // step 3.c

	return integerToNBytes(intValue, n, isLittleEndian); // step 3.d, 3.e, 4
};
'use strict';

var DefinePropertyOrThrow = require('./DefinePropertyOrThrow');
var Get = require('./Get');
var OrdinaryGetOwnProperty = require('./OrdinaryGetOwnProperty');
var ToObject = require('./ToObject');
var ToPropertyDescriptor = require('./ToPropertyDescriptor');

var forEach = require('../helpers/forEach');
var OwnPropertyKeys = require('own-keys');

// https://262.ecma-international.org/6.0/#sec-objectdefineproperties

/** @type {<T extends Record<PropertyKey, unknown> = {}>(O: T, Properties: object) => T} */
module.exports = function ObjectDefineProperties(O, Properties) {
	var props = ToObject(Properties); // step 1
	var keys = OwnPropertyKeys(props); // step 2
	/** @type {[string | symbol, import('../types').Descriptor][]} */
	var descriptors = []; // step 3

	forEach(keys, function (nextKey) { // step 4
		var propDesc = OrdinaryGetOwnProperty(props, nextKey); // ToPropertyDescriptor(getOwnPropertyDescriptor(props, nextKey)); // step 4.a
		if (typeof propDesc !== 'undefined' && propDesc['[[Enumerable]]']) { // step 4.b
			var descObj = Get(props, nextKey); // step 4.b.i
			var desc = ToPropertyDescriptor(descObj); // step 4.b.ii
			descriptors[descriptors.length] = [nextKey, desc]; // step 4.b.iii
		}
	});

	forEach(descriptors, function (pair) { // step 5
		var P = pair[0]; // step 5.a
		var desc = pair[1]; // step 5.b
		DefinePropertyOrThrow(O, P, desc); // step 5.c
	});

	return O; // step 6
};
'use strict';

var GetIntrinsic = require('get-intrinsic');
var $TypeError = require('es-errors/type');

var GetPrototypeFromConstructor = require('./GetPrototypeFromConstructor');
var IsArray = require('./IsArray');
var OrdinaryObjectCreate = require('./OrdinaryObjectCreate');

// https://262.ecma-international.org/6.0/#sec-ordinarycreatefromconstructor

module.exports = function OrdinaryCreateFromConstructor(constructor, intrinsicDefaultProto) {
	GetIntrinsic(intrinsicDefaultProto); // throws if not a valid intrinsic
	var proto = GetPrototypeFromConstructor(constructor, intrinsicDefaultProto);
	var slots = arguments.length < 3 ? [] : arguments[2];
	if (!IsArray(slots)) {
		throw new $TypeError('Assertion failed: if provided, `internalSlotsList` must be a List');
	}
	return OrdinaryObjectCreate(proto, slots);
};
'use strict';

var $gOPD = require('gopd');
var $SyntaxError = require('es-errors/syntax');
var $TypeError = require('es-errors/type');
var isObject = require('es-object-atoms/isObject');

var isPropertyDescriptor = require('../helpers/records/property-descriptor');

var IsAccessorDescriptor = require('./IsAccessorDescriptor');
var IsExtensible = require('./IsExtensible');
var isPropertyKey = require('../helpers/isPropertyKey');
var ToPropertyDescriptor = require('./ToPropertyDescriptor');
var SameValue = require('./SameValue');
var ValidateAndApplyPropertyDescriptor = require('./ValidateAndApplyPropertyDescriptor');

// https://262.ecma-international.org/6.0/#sec-ordinarydefineownproperty

module.exports = function OrdinaryDefineOwnProperty(O, P, Desc) {
	if (!isObject(O)) {
		throw new $TypeError('Assertion failed: O must be an Object');
	}
	if (!isPropertyKey(P)) {
		throw new $TypeError('Assertion failed: P must be a Property Key');
	}
	if (!isPropertyDescriptor(Desc)) {
		throw new $TypeError('Assertion failed: Desc must be a Property Descriptor');
	}
	if (!$gOPD) {
		// ES3/IE 8 fallback
		if (IsAccessorDescriptor(Desc)) {
			throw new $SyntaxError('This environment does not support accessor property descriptors.');
		}
		var creatingNormalDataProperty = !(P in O)
			&& Desc['[[Writable]]']
			&& Desc['[[Enumerable]]']
			&& Desc['[[Configurable]]']
			&& '[[Value]]' in Desc;
		var settingExistingDataProperty = (P in O)
			&& (!('[[Configurable]]' in Desc) || Desc['[[Configurable]]'])
			&& (!('[[Enumerable]]' in Desc) || Desc['[[Enumerable]]'])
			&& (!('[[Writable]]' in Desc) || Desc['[[Writable]]'])
			&& '[[Value]]' in Desc;
		if (creatingNormalDataProperty || settingExistingDataProperty) {
			O[P] = Desc['[[Value]]']; // eslint-disable-line no-param-reassign
			return SameValue(O[P], Desc['[[Value]]']);
		}
		throw new $SyntaxError('This environment does not support defining non-writable, non-enumerable, or non-configurable properties');
	}
	var desc = $gOPD(O, P);
	var current = desc && ToPropertyDescriptor(desc);
	var extensible = IsExtensible(O);
	return ValidateAndApplyPropertyDescriptor(O, P, extensible, Desc, current);
};
'use strict';

var $gOPD = require('gopd');
var $TypeError = require('es-errors/type');
var isObject = require('es-object-atoms/isObject');
var callBound = require('call-bound');

var $isEnumerable = callBound('Object.prototype.propertyIsEnumerable');

var hasOwn = require('hasown');

var IsArray = require('./IsArray');
var isPropertyKey = require('../helpers/isPropertyKey');
var IsRegExp = require('./IsRegExp');
var ToPropertyDescriptor = require('./ToPropertyDescriptor');

// https://262.ecma-international.org/6.0/#sec-ordinarygetownproperty

module.exports = function OrdinaryGetOwnProperty(O, P) {
	if (!isObject(O)) {
		throw new $TypeError('Assertion failed: O must be an Object');
	}
	if (!isPropertyKey(P)) {
		throw new $TypeError('Assertion failed: P must be a Property Key');
	}
	if (!hasOwn(O, P)) {
		return void 0;
	}
	if (!$gOPD) {
		// ES3 / IE 8 fallback
		var arrayLength = IsArray(O) && P === 'length';
		var regexLastIndex = IsRegExp(O) && P === 'lastIndex';
		return {
			'[[Configurable]]': !(arrayLength || regexLastIndex),
			'[[Enumerable]]': $isEnumerable(O, P),
			'[[Value]]': O[P],
			'[[Writable]]': true
		};
	}
	return ToPropertyDescriptor($gOPD(O, P));
};
'use strict';

var $TypeError = require('es-errors/type');
var isObject = require('es-object-atoms/isObject');

var $getProto = require('get-proto');

// https://262.ecma-international.org/7.0/#sec-ordinarygetprototypeof

module.exports = function OrdinaryGetPrototypeOf(O) {
	if (!isObject(O)) {
		throw new $TypeError('Assertion failed: O must be an Object');
	}
	if (!$getProto) {
		throw new $TypeError('This environment does not support fetching prototypes.');
	}
	return $getProto(O);
};
'use strict';

var $TypeError = require('es-errors/type');
var isObject = require('es-object-atoms/isObject');

var Get = require('./Get');
var IsCallable = require('./IsCallable');

// https://262.ecma-international.org/6.0/#sec-ordinaryhasinstance

module.exports = function OrdinaryHasInstance(C, O) {
	if (!IsCallable(C)) {
		return false;
	}
	if (!isObject(O)) {
		return false;
	}
	var P = Get(C, 'prototype');
	if (!isObject(P)) {
		throw new $TypeError('OrdinaryHasInstance called on an object with an invalid prototype property.');
	}
	return O instanceof C;
};
'use strict';

var $TypeError = require('es-errors/type');
var isObject = require('es-object-atoms/isObject');

var isPropertyKey = require('../helpers/isPropertyKey');

// https://262.ecma-international.org/6.0/#sec-ordinaryhasproperty

module.exports = function OrdinaryHasProperty(O, P) {
	if (!isObject(O)) {
		throw new $TypeError('Assertion failed: Type(O) is not Object');
	}
	if (!isPropertyKey(P)) {
		throw new $TypeError('Assertion failed: P must be a Property Key');
	}
	return P in O;
};
'use strict';

var GetIntrinsic = require('get-intrinsic');

var $ObjectCreate = GetIntrinsic('%Object.create%', true);
var $TypeError = require('es-errors/type');
var $SyntaxError = require('es-errors/syntax');
var isObject = require('es-object-atoms/isObject');

var IsArray = require('./IsArray');

var forEach = require('../helpers/forEach');

var SLOT = require('internal-slot');

var hasProto = require('has-proto')();

// https://262.ecma-international.org/11.0/#sec-objectcreate

module.exports = function OrdinaryObjectCreate(proto) {
	if (proto !== null && !isObject(proto)) {
		throw new $TypeError('Assertion failed: `proto` must be null or an object');
	}
	var additionalInternalSlotsList = arguments.length < 2 ? [] : arguments[1];
	if (!IsArray(additionalInternalSlotsList)) {
		throw new $TypeError('Assertion failed: `additionalInternalSlotsList` must be an Array');
	}

	// var internalSlotsList = ['[[Prototype]]', '[[Extensible]]']; // step 1
	// internalSlotsList.push(...additionalInternalSlotsList); // step 2
	// var O = MakeBasicObject(internalSlotsList); // step 3
	// setProto(O, proto); // step 4
	// return O; // step 5

	var O;
	if (hasProto) {
		O = { __proto__: proto };
	} else if ($ObjectCreate) {
		O = $ObjectCreate(proto);
	} else {
		if (proto === null) {
			throw new $SyntaxError('native Object.create support is required to create null objects');
		}
		var T = function T() {};
		T.prototype = proto;
		O = new T();
	}

	if (additionalInternalSlotsList.length > 0) {
		forEach(additionalInternalSlotsList, function (slot) {
			SLOT.set(O, slot, void undefined);
		});
	}

	return O;
};
'use strict';

var $TypeError = require('es-errors/type');
var $setProto = require('set-proto');
var isObject = require('es-object-atoms/isObject');

var OrdinaryGetPrototypeOf = require('./OrdinaryGetPrototypeOf');

// https://262.ecma-international.org/7.0/#sec-ordinarysetprototypeof

module.exports = function OrdinarySetPrototypeOf(O, V) {
	if (V !== null && !isObject(V)) {
		throw new $TypeError('Assertion failed: V must be Object or Null');
	}
	/*
	var extensible = IsExtensible(O);
	var current = OrdinaryGetPrototypeOf(O);
	if (SameValue(V, current)) {
		return true;
	}
	if (!extensible) {
		return false;
	}
	*/
	try {
		$setProto(O, V);
	} catch (e) {
		return false;
	}
	return OrdinaryGetPrototypeOf(O) === V;
	/*
	var p = V;
	var done = false;
	while (!done) {
		if (p === null) {
			done = true;
		} else if (SameValue(p, O)) {
			return false;
		} else {
			if (wat) {
				done = true;
			} else {
				p = p.[[Prototype]];
			}
		}
	}
	O.[[Prototype]] = V;
	return true;
	*/
};
'use strict';

var $TypeError = require('es-errors/type');
var isObject = require('es-object-atoms/isObject');

var Call = require('./Call');
var Get = require('./Get');
var IsCallable = require('./IsCallable');

var inspect = require('object-inspect');

// https://262.ecma-international.org/8.0/#sec-ordinarytoprimitive

module.exports = function OrdinaryToPrimitive(O, hint) {
	if (!isObject(O)) {
		throw new $TypeError('Assertion failed: Type(O) is not Object');
	}
	if (/* typeof hint !== 'string' || */ hint !== 'string' && hint !== 'number') {
		throw new $TypeError('Assertion failed: `hint` must be "string" or "number"');
	}

	var methodNames = hint === 'string' ? ['toString', 'valueOf'] : ['valueOf', 'toString'];

	for (var i = 0; i < methodNames.length; i += 1) {
		var name = methodNames[i];
		var method = Get(O, name);
		if (IsCallable(method)) {
			var result = Call(method, O);
			if (!isObject(result)) {
				return result;
			}
		}
	}

	throw new $TypeError('No primitive value for ' + inspect(O));
};
'use strict';

var GetIntrinsic = require('get-intrinsic');
var callBind = require('call-bind');
var $SyntaxError = require('es-errors/syntax');

var $resolve = GetIntrinsic('%Promise.resolve%', true);
var $PromiseResolve = $resolve && callBind($resolve);

// https://262.ecma-international.org/9.0/#sec-promise-resolve

module.exports = function PromiseResolve(C, x) {
	if (!$PromiseResolve) {
		throw new $SyntaxError('This environment does not support Promises.');
	}
	return $PromiseResolve(C, x);
};

'use strict';

var $TypeError = require('es-errors/type');

var callBound = require('call-bound');
var forEach = require('../helpers/forEach');
var isLeadingSurrogate = require('../helpers/isLeadingSurrogate');
var isTrailingSurrogate = require('../helpers/isTrailingSurrogate');

var $charCodeAt = callBound('String.prototype.charCodeAt');
var $strSplit = callBound('String.prototype.split');

var StringToCodePoints = require('./StringToCodePoints');
var UnicodeEscape = require('./UnicodeEscape');
var UTF16EncodeCodePoint = require('./UTF16EncodeCodePoint');

var hasOwn = require('hasown');

// https://262.ecma-international.org/12.0/#sec-quotejsonstring

var escapes = {
	'\u0008': '\\b',
	'\u0009': '\\t',
	'\u000A': '\\n',
	'\u000C': '\\f',
	'\u000D': '\\r',
	'\u0022': '\\"',
	'\u005c': '\\\\'
};

module.exports = function QuoteJSONString(value) {
	if (typeof value !== 'string') {
		throw new $TypeError('Assertion failed: `value` must be a String');
	}
	var product = '"';
	if (value) {
		forEach($strSplit(StringToCodePoints(value), ''), function (C) {
			if (hasOwn(escapes, C)) {
				product += escapes[C];
			} else {
				var cCharCode = $charCodeAt(C, 0);
				if (cCharCode < 0x20 || isLeadingSurrogate(cCharCode) || isTrailingSurrogate(cCharCode)) {
					product += UnicodeEscape(C);
				} else {
					product += UTF16EncodeCodePoint(cCharCode);
				}
			}
		});
	}
	product += '"';
	return product;
};
'use strict';

var GetIntrinsic = require('get-intrinsic');
var callBound = require('call-bound');

var $RangeError = require('es-errors/range');
var $SyntaxError = require('es-errors/syntax');
var $TypeError = require('es-errors/type');
var $BigInt = GetIntrinsic('%BigInt%', true);

var hasOwnProperty = require('./HasOwnProperty');
var IsArray = require('./IsArray');
var IsBigIntElementType = require('./IsBigIntElementType');
var IsUnsignedElementType = require('./IsUnsignedElementType');

var bytesAsFloat32 = require('../helpers/bytesAsFloat32');
var bytesAsFloat64 = require('../helpers/bytesAsFloat64');
var bytesAsInteger = require('../helpers/bytesAsInteger');
var every = require('../helpers/every');
var isByteValue = require('../helpers/isByteValue');

var $reverse = callBound('Array.prototype.reverse');
var $slice = callBound('Array.prototype.slice');

var tableTAO = require('./tables/typed-array-objects');

// https://262.ecma-international.org/11.0/#sec-rawbytestonumeric

module.exports = function RawBytesToNumeric(type, rawBytes, isLittleEndian) {
	if (typeof type !== 'string' || !hasOwnProperty(tableTAO.size, '$' + type)) {
		throw new $TypeError('Assertion failed: `type` must be a TypedArray element type');
	}
	if (!IsArray(rawBytes) || !every(rawBytes, isByteValue)) {
		throw new $TypeError('Assertion failed: `rawBytes` must be an Array of bytes');
	}
	if (typeof isLittleEndian !== 'boolean') {
		throw new $TypeError('Assertion failed: `isLittleEndian` must be a Boolean');
	}

	var elementSize = tableTAO.size['$' + type]; // step 1

	if (rawBytes.length !== elementSize) {
		// this assertion is not in the spec, but it'd be an editorial error if it were ever violated
		throw new $RangeError('Assertion failed: `rawBytes` must have a length of ' + elementSize + ' for type ' + type);
	}

	var isBigInt = IsBigIntElementType(type);
	if (isBigInt && !$BigInt) {
		throw new $SyntaxError('this environment does not support BigInts');
	}

	// eslint-disable-next-line no-param-reassign
	rawBytes = $slice(rawBytes, 0, elementSize);
	if (!isLittleEndian) {
		$reverse(rawBytes); // step 2
	}

	if (type === 'Float32') { // step 3
		return bytesAsFloat32(rawBytes);
	}

	if (type === 'Float64') { // step 4
		return bytesAsFloat64(rawBytes);
	}

	return bytesAsInteger(rawBytes, elementSize, IsUnsignedElementType(type), isBigInt);
};
'use strict';

var GetIntrinsic = require('get-intrinsic');

var $RegExp = GetIntrinsic('%RegExp%');

// var RegExpAlloc = require('./RegExpAlloc');
// var RegExpInitialize = require('./RegExpInitialize');
var ToString = require('./ToString');

// https://262.ecma-international.org/6.0/#sec-regexpcreate

module.exports = function RegExpCreate(P, F) {
	// var obj = RegExpAlloc($RegExp);
	// return RegExpInitialize(obj, P, F);

	// covers spec mechanics; bypass regex brand checking
	var pattern = typeof P === 'undefined' ? '' : ToString(P);
	var flags = typeof F === 'undefined' ? '' : ToString(F);
	return new $RegExp(pattern, flags);
};
'use strict';

var $TypeError = require('es-errors/type');
var isObject = require('es-object-atoms/isObject');
var regexExec = require('call-bound')('RegExp.prototype.exec');

var Call = require('./Call');
var Get = require('./Get');
var IsCallable = require('./IsCallable');

// https://262.ecma-international.org/6.0/#sec-regexpexec

module.exports = function RegExpExec(R, S) {
	if (!isObject(R)) {
		throw new $TypeError('Assertion failed: `R` must be an Object');
	}
	if (typeof S !== 'string') {
		throw new $TypeError('Assertion failed: `S` must be a String');
	}
	var exec = Get(R, 'exec');
	if (IsCallable(exec)) {
		var result = Call(exec, R, [S]);
		if (result === null || isObject(result)) {
			return result;
		}
		throw new $TypeError('"exec" method must return `null` or an Object');
	}
	return regexExec(R, S);
};
'use strict';

var GetIntrinsic = require('get-intrinsic');
var callBound = require('call-bound');

var $TypeError = require('es-errors/type');
var isObject = require('es-object-atoms/isObject');
var $RegExpPrototype = GetIntrinsic('%RegExp.prototype%');

var SameValue = require('./SameValue');

var $indexOf = callBound('String.prototype.indexOf');

var hasRegExpMatcher = require('is-regex');
var getFlags = require('regexp.prototype.flags');

// https://262.ecma-international.org/13.0/#sec-regexphasflag

module.exports = function RegExpHasFlag(R, codeUnit) {
	if (typeof codeUnit !== 'string' || codeUnit.length !== 1) {
		throw new $TypeError('Assertion failed: `string` must be a code unit - a String of length 1');
	}

	if (!isObject(R)) {
		throw new $TypeError('Assertion failed: Type(R) is not Object');
	}

	if (!hasRegExpMatcher(R)) { // step 2
		if (SameValue(R, $RegExpPrototype)) {
			return void undefined; // step 2.a
		}
		throw new $TypeError('`R` must be a RegExp object'); // step 2.b
	}

	var flags = getFlags(R); // step 3

	return $indexOf(flags, codeUnit) > -1; // steps 4-5
};
'use strict';

module.exports = require('es-object-atoms/RequireObjectCoercible');
'use strict';

var $isNaN = require('math-intrinsics/isNaN');

// http://262.ecma-international.org/5.1/#sec-9.12

module.exports = function SameValue(x, y) {
	if (x === y) { // 0 === -0, but they are not identical.
		if (x === 0) { return 1 / x === 1 / y; }
		return true;
	}
	return $isNaN(x) && $isNaN(y);
};
'use strict';

var $TypeError = require('es-errors/type');

var SameValue = require('./SameValue');
var Type = require('./Type');

// https://262.ecma-international.org/11.0/#sec-samevaluenonnumeric

module.exports = function SameValueNonNumeric(x, y) {
	if (typeof x === 'number' || typeof x === 'bigint') {
		throw new $TypeError('Assertion failed: SameValueNonNumeric does not accept Number or BigInt values');
	}
	if (Type(x) !== Type(y)) {
		throw new $TypeError('SameValueNonNumeric requires two non-numeric values of the same type.');
	}
	return SameValue(x, y);
};
'use strict';

var $isNaN = require('math-intrinsics/isNaN');

// https://262.ecma-international.org/6.0/#sec-samevaluezero

module.exports = function SameValueZero(x, y) {
	return (x === y) || ($isNaN(x) && $isNaN(y));
};
'use strict';

var floor = require('./floor');
var modulo = require('./modulo');

var timeConstants = require('../helpers/timeConstants');
var msPerSecond = timeConstants.msPerSecond;
var SecondsPerMinute = timeConstants.SecondsPerMinute;

// https://262.ecma-international.org/5.1/#sec-15.9.1.10

module.exports = function SecFromTime(t) {
	return modulo(floor(t / msPerSecond), SecondsPerMinute);
};
'use strict';

var $TypeError = require('es-errors/type');
var isInteger = require('math-intrinsics/isInteger');

var DefinePropertyOrThrow = require('./DefinePropertyOrThrow');
var HasOwnProperty = require('./HasOwnProperty');
var IsExtensible = require('./IsExtensible');

// https://262.ecma-international.org/12.0/#sec-setfunctionlength

module.exports = function SetFunctionLength(F, length) {
	if (typeof F !== 'function' || !IsExtensible(F) || HasOwnProperty(F, 'length')) {
		throw new $TypeError('Assertion failed: `F` must be an extensible function and lack an own `length` property');
	}
	if (typeof length !== 'number') {
		throw new $TypeError('Assertion failed: `length` must be a Number');
	}
	if (length !== Infinity && (!isInteger(length) || length < 0)) {
		throw new $TypeError('Assertion failed: `length` must be ∞, or an integer >= 0');
	}
	return DefinePropertyOrThrow(F, 'length', {
		'[[Configurable]]': true,
		'[[Enumerable]]': false,
		'[[Value]]': length,
		'[[Writable]]': false
	});
};
'use strict';

var hasOwn = require('hasown');

var $TypeError = require('es-errors/type');

var getSymbolDescription = require('get-symbol-description');

var DefinePropertyOrThrow = require('./DefinePropertyOrThrow');
var IsExtensible = require('./IsExtensible');

// https://262.ecma-international.org/6.0/#sec-setfunctionname

module.exports = function SetFunctionName(F, name) {
	if (typeof F !== 'function') {
		throw new $TypeError('Assertion failed: `F` must be a function');
	}
	if (!IsExtensible(F) || hasOwn(F, 'name')) {
		throw new $TypeError('Assertion failed: `F` must be extensible, and must not have a `name` own property');
	}
	if (typeof name !== 'symbol' && typeof name !== 'string') {
		throw new $TypeError('Assertion failed: `name` must be a Symbol or a String');
	}
	if (typeof name === 'symbol') {
		var description = getSymbolDescription(name);
		// eslint-disable-next-line no-param-reassign
		name = typeof description === 'undefined' ? '' : '[' + description + ']';
	}
	if (arguments.length > 2) {
		var prefix = arguments[2];
		// eslint-disable-next-line no-param-reassign
		name = prefix + ' ' + name;
	}
	return DefinePropertyOrThrow(F, 'name', {
		'[[Value]]': name,
		'[[Writable]]': false,
		'[[Enumerable]]': false,
		'[[Configurable]]': true
	});
};
'use strict';

var GetIntrinsic = require('get-intrinsic');

var $SyntaxError = require('es-errors/syntax');
var $TypeError = require('es-errors/type');
var isObject = require('es-object-atoms/isObject');
var $gOPD = require('gopd');
var $preventExtensions = GetIntrinsic('%Object.preventExtensions%', true);
var $gOPN = GetIntrinsic('%Object.getOwnPropertyNames%', true);

var forEach = require('../helpers/forEach');

var DefinePropertyOrThrow = require('./DefinePropertyOrThrow');
var IsAccessorDescriptor = require('./IsAccessorDescriptor');
var ToPropertyDescriptor = require('./ToPropertyDescriptor');

// https://262.ecma-international.org/6.0/#sec-setintegritylevel

module.exports = function SetIntegrityLevel(O, level) {
	if (!isObject(O)) {
		throw new $TypeError('Assertion failed: Type(O) is not Object');
	}
	if (level !== 'sealed' && level !== 'frozen') {
		throw new $TypeError('Assertion failed: `level` must be `"sealed"` or `"frozen"`');
	}
	if (!$preventExtensions) {
		throw new $SyntaxError('SetIntegrityLevel requires native `Object.preventExtensions` support');
	}
	var status = $preventExtensions(O);
	if (!status) {
		return false;
	}
	if (!$gOPN) {
		throw new $SyntaxError('SetIntegrityLevel requires native `Object.getOwnPropertyNames` support');
	}
	var theKeys = $gOPN(O);
	if (level === 'sealed') {
		forEach(theKeys, function (k) {
			DefinePropertyOrThrow(O, k, { configurable: false });
		});
	} else if (level === 'frozen') {
		forEach(theKeys, function (k) {
			var currentDesc = $gOPD(O, k);
			if (typeof currentDesc !== 'undefined') {
				var desc;
				if (IsAccessorDescriptor(ToPropertyDescriptor(currentDesc))) {
					desc = { configurable: false };
				} else {
					desc = { configurable: false, writable: false };
				}
				DefinePropertyOrThrow(O, k, desc);
			}
		});
	}
	return true;
};
'use strict';

var $TypeError = require('es-errors/type');
var isObject = require('es-object-atoms/isObject');

var isPropertyKey = require('../helpers/isPropertyKey');
var SameValue = require('./SameValue');

// IE 9 does not throw in strict mode when writability/configurability/extensibility is violated
var noThrowOnStrictViolation = (function () {
	try {
		delete [].length;
		return true;
	} catch (e) {
		return false;
	}
}());

// https://262.ecma-international.org/6.0/#sec-set-o-p-v-throw

module.exports = function Set(O, P, V, Throw) {
	if (!isObject(O)) {
		throw new $TypeError('Assertion failed: `O` must be an Object');
	}
	if (!isPropertyKey(P)) {
		throw new $TypeError('Assertion failed: `P` must be a Property Key');
	}
	if (typeof Throw !== 'boolean') {
		throw new $TypeError('Assertion failed: `Throw` must be a Boolean');
	}
	if (Throw) {
		O[P] = V; // eslint-disable-line no-param-reassign
		if (noThrowOnStrictViolation && !SameValue(O[P], V)) {
			throw new $TypeError('Attempted to assign to readonly property.');
		}
		return true;
	}
	try {
		O[P] = V; // eslint-disable-line no-param-reassign
		return noThrowOnStrictViolation ? SameValue(O[P], V) : true;
	} catch (e) {
		return false;
	}

};
'use strict';

var $RangeError = require('es-errors/range');
var $TypeError = require('es-errors/type');

var isInteger = require('math-intrinsics/isInteger');
var isTypedArray = require('is-typed-array');
var typedArrayBuffer = require('typed-array-buffer');
var typedArrayByteOffset = require('typed-array-byte-offset');
var typedArrayLength = require('typed-array-length');
var whichTypedArray = require('which-typed-array');

var Get = require('./Get');
var IsBigIntElementType = require('./IsBigIntElementType');
var IsDetachedBuffer = require('./IsDetachedBuffer');
var LengthOfArrayLike = require('./LengthOfArrayLike');
var SetValueInBuffer = require('./SetValueInBuffer');
var ToBigInt = require('./ToBigInt');
var ToNumber = require('./ToNumber');
var ToObject = require('./ToObject');
var ToString = require('./ToString');
var TypedArrayElementSize = require('./TypedArrayElementSize');
var TypedArrayElementType = require('./TypedArrayElementType');

// https://262.ecma-international.org/13.0/#sec-settypedarrayfromarraylike

module.exports = function SetTypedArrayFromArrayLike(target, targetOffset, source) {
	var whichTarget = whichTypedArray(target);
	if (!whichTarget) {
		throw new $TypeError('Assertion failed: target must be a TypedArray instance');
	}

	if (targetOffset !== Infinity && (!isInteger(targetOffset) || targetOffset < 0)) {
		throw new $TypeError('Assertion failed: targetOffset must be a non-negative integer or +Infinity');
	}

	if (isTypedArray(source)) {
		throw new $TypeError('Assertion failed: source must not be a TypedArray instance');
	}

	var targetBuffer = typedArrayBuffer(target); // step 1

	if (IsDetachedBuffer(targetBuffer)) {
		throw new $TypeError('target’s buffer is detached'); // step 2
	}

	var targetLength = typedArrayLength(target); // step 3

	var targetElementSize = TypedArrayElementSize(target); // step 4

	var targetType = TypedArrayElementType(target); // step 5

	var targetByteOffset = typedArrayByteOffset(target); // step 6

	var src = ToObject(source); // step 7

	var srcLength = LengthOfArrayLike(src); // step 8

	if (targetOffset === Infinity) {
		throw new $RangeError('targetOffset must be a finite integer'); // step 9
	}

	if (srcLength + targetOffset > targetLength) {
		throw new $RangeError('targetOffset + srcLength must be <= target.length'); // step 10
	}

	var targetByteIndex = (targetOffset * targetElementSize) + targetByteOffset; // step 11

	var k = 0; // step 12

	var limit = targetByteIndex + (targetElementSize * srcLength); // step 13

	while (targetByteIndex < limit) { // step 14
		var Pk = ToString(k); // step 14.a

		var value = Get(src, Pk); // step 14.b

		if (IsBigIntElementType(targetType)) {
			value = ToBigInt(value); // step 14.c
		} else {
			value = ToNumber(value); // step 14.d
		}

		if (IsDetachedBuffer(targetBuffer)) {
			throw new $TypeError('target’s buffer is detached'); // step 14.e
		}

		SetValueInBuffer(targetBuffer, targetByteIndex, targetType, value, true, 'Unordered'); // step 14.f

		k += 1; // step 14.g

		targetByteIndex += targetElementSize; // step 14.h
	}
};
'use strict';

var GetIntrinsic = require('get-intrinsic');

var $RangeError = require('es-errors/range');
var $SyntaxError = require('es-errors/syntax');
var $TypeError = require('es-errors/type');
var $ArrayBuffer = GetIntrinsic('%ArrayBuffer%', true);

var typedArrayBuffer = require('typed-array-buffer');
var typedArrayByteLength = require('typed-array-byte-length');
var typedArrayByteOffset = require('typed-array-byte-offset');
var typedArrayLength = require('typed-array-length');
var whichTypedArray = require('which-typed-array');
var isInteger = require('math-intrinsics/isInteger');

var CloneArrayBuffer = require('./CloneArrayBuffer');
var GetValueFromBuffer = require('./GetValueFromBuffer');
var IsDetachedBuffer = require('./IsDetachedBuffer');
var IsSharedArrayBuffer = require('./IsSharedArrayBuffer');
var SameValue = require('./SameValue');
var SetValueInBuffer = require('./SetValueInBuffer');
var TypedArrayElementSize = require('./TypedArrayElementSize');
var TypedArrayElementType = require('./TypedArrayElementType');

// https://262.ecma-international.org/13.0/#sec-settypedarrayfromtypedarray

module.exports = function SetTypedArrayFromTypedArray(target, targetOffset, source) {
	var whichTarget = whichTypedArray(target);
	if (!whichTarget) {
		throw new $TypeError('Assertion failed: target must be a TypedArray instance');
	}

	if (targetOffset !== Infinity && (!isInteger(targetOffset) || targetOffset < 0)) {
		throw new $TypeError('Assertion failed: targetOffset must be a non-negative integer or +Infinity');
	}

	var whichSource = whichTypedArray(source);
	if (!whichSource) {
		throw new $TypeError('Assertion failed: source must be a TypedArray instance');
	}

	var targetBuffer = typedArrayBuffer(target); // step 1

	if (IsDetachedBuffer(targetBuffer)) {
		throw new $TypeError('target’s buffer is detached'); // step 2
	}

	var targetLength = typedArrayLength(target); // step 3

	var srcBuffer = typedArrayBuffer(source); // step 4

	if (IsDetachedBuffer(srcBuffer)) {
		throw new $TypeError('source’s buffer is detached'); // step 5
	}

	var targetType = TypedArrayElementType(target); // step 6

	var targetElementSize = TypedArrayElementSize(target); // step 7

	var targetByteOffset = typedArrayByteOffset(target); // step 8

	var srcType = TypedArrayElementType(source); // step 9

	var srcElementSize = TypedArrayElementSize(source); // step 10

	var srcLength = typedArrayLength(source); // step 11

	var srcByteOffset = typedArrayByteOffset(source); // step 12

	if (targetOffset === Infinity) {
		throw new $RangeError('targetOffset must be a non-negative integer or +Infinity'); // step 13
	}

	if (srcLength + targetOffset > targetLength) {
		throw new $RangeError('targetOffset + source.length must not be greater than target.length'); // step 14
	}

	var targetContentType = whichTarget === 'BigInt64Array' || whichTarget === 'BigUint64Array' ? 'BigInt' : 'Number';
	var sourceContentType = whichSource === 'BigInt64Array' || whichSource === 'BigUint64Array' ? 'BigInt' : 'Number';
	if (targetContentType !== sourceContentType) {
		throw new $TypeError('source and target must have the same content type'); // step 15
	}

	var same;
	if (IsSharedArrayBuffer(srcBuffer) && IsSharedArrayBuffer(targetBuffer)) { // step 16
		// a. If srcBuffer.[[ArrayBufferData]] and targetBuffer.[[ArrayBufferData]] are the same Shared Data Block values, let same be true; else let same be false.
		throw new $SyntaxError('SharedArrayBuffer is not supported by this implementation');
	} else {
		same = SameValue(srcBuffer, targetBuffer); // step 17
	}

	var srcByteIndex;
	if (same) { // step 18
		var srcByteLength = typedArrayByteLength(source); // step 18.a

		srcBuffer = CloneArrayBuffer(srcBuffer, srcByteOffset, srcByteLength, $ArrayBuffer); // step 18.b

		// c. NOTE: %ArrayBuffer% is used to clone srcBuffer because is it known to not have any observable side-effects.

		srcByteIndex = 0; // step 18.d
	} else {
		srcByteIndex = srcByteOffset; // step 19
	}

	var targetByteIndex = (targetOffset * targetElementSize) + targetByteOffset; // step 20

	var limit = targetByteIndex + (targetElementSize * srcLength); // step 21

	var value;
	if (srcType === targetType) { // step 22
		// a. NOTE: If srcType and targetType are the same, the transfer must be performed in a manner that preserves the bit-level encoding of the source data.

		while (targetByteIndex < limit) { // step 22.b
			value = GetValueFromBuffer(srcBuffer, srcByteIndex, 'Uint8', true, 'Unordered'); // step 22.b.i

			SetValueInBuffer(targetBuffer, targetByteIndex, 'Uint8', value, true, 'Unordered'); // step 22.b.ii

			srcByteIndex += 1; // step 22.b.iii

			targetByteIndex += 1; // step 22.b.iv
		}
	} else { // step 23
		while (targetByteIndex < limit) { // step 23.a
			value = GetValueFromBuffer(srcBuffer, srcByteIndex, srcType, true, 'Unordered'); // step 23.a.i

			SetValueInBuffer(targetBuffer, targetByteIndex, targetType, value, true, 'Unordered'); // step 23.a.ii

			srcByteIndex += srcElementSize; // step 23.a.iii

			targetByteIndex += targetElementSize; // step 23.a.iv
		}
	}
};
'use strict';

var GetIntrinsic = require('get-intrinsic');

var $SyntaxError = require('es-errors/syntax');
var $TypeError = require('es-errors/type');
var isInteger = require('math-intrinsics/isInteger');
var $Uint8Array = GetIntrinsic('%Uint8Array%', true);

var IsBigIntElementType = require('./IsBigIntElementType');
var IsDetachedBuffer = require('./IsDetachedBuffer');
var NumericToRawBytes = require('./NumericToRawBytes');

var isArrayBuffer = require('is-array-buffer');
var isSharedArrayBuffer = require('is-shared-array-buffer');
var hasOwn = require('hasown');

var tableTAO = require('./tables/typed-array-objects');

var defaultEndianness = require('../helpers/defaultEndianness');
var forEach = require('../helpers/forEach');

// https://262.ecma-international.org/12.0/#sec-setvalueinbuffer

/* eslint max-params: 0 */

module.exports = function SetValueInBuffer(arrayBuffer, byteIndex, type, value, isTypedArray, order) {
	var isSAB = isSharedArrayBuffer(arrayBuffer);
	if (!isArrayBuffer(arrayBuffer) && !isSAB) {
		throw new $TypeError('Assertion failed: `arrayBuffer` must be an ArrayBuffer or a SharedArrayBuffer');
	}

	if (!isInteger(byteIndex) || byteIndex < 0) {
		throw new $TypeError('Assertion failed: `byteIndex` must be a non-negative integer');
	}

	if (typeof type !== 'string' || !hasOwn(tableTAO.size, '$' + type)) {
		throw new $TypeError('Assertion failed: `type` must be one of ' + tableTAO.choices);
	}

	if (typeof value !== 'number' && typeof value !== 'bigint') {
		throw new $TypeError('Assertion failed: `value` must be a Number or a BigInt');
	}

	if (typeof isTypedArray !== 'boolean') {
		throw new $TypeError('Assertion failed: `isTypedArray` must be a boolean');
	}
	if (order !== 'SeqCst' && order !== 'Unordered' && order !== 'Init') {
		throw new $TypeError('Assertion failed: `order` must be `"SeqCst"`, `"Unordered"`, or `"Init"`');
	}

	if (arguments.length > 6 && typeof arguments[6] !== 'boolean') {
		throw new $TypeError('Assertion failed: `isLittleEndian` must be a boolean, if present');
	}

	if (IsDetachedBuffer(arrayBuffer)) {
		throw new $TypeError('Assertion failed: ArrayBuffer is detached'); // step 1
	}

	// 2. Assert: There are sufficient bytes in arrayBuffer starting at byteIndex to represent a value of type.

	if (IsBigIntElementType(type) ? typeof value !== 'bigint' : typeof value !== 'number') { // step 3
		throw new $TypeError('Assertion failed: `value` must be a BigInt if type is BigInt64 or BigUint64, otherwise a Number');
	}

	// 4. Let block be arrayBuffer’s [[ArrayBufferData]] internal slot.

	var elementSize = tableTAO.size['$' + type]; // step 5

	// 6. If isLittleEndian is not present, set isLittleEndian to either true or false. The choice is implementation dependent and should be the alternative that is most efficient for the implementation. An implementation must use the same value each time this step is executed and the same value must be used for the corresponding step in the GetValueFromBuffer abstract operation.
	var isLittleEndian = arguments.length > 6 ? arguments[6] : defaultEndianness === 'little'; // step 6

	var rawBytes = NumericToRawBytes(type, value, isLittleEndian); // step 7

	if (isSAB) { // step 8
		/*
			Let execution be the [[CandidateExecution]] field of the surrounding agent's Agent Record.
			Let eventList be the [[EventList]] field of the element in execution.[[EventsRecords]] whose [[AgentSignifier]] is AgentSignifier().
			If isTypedArray is true and IsNoTearConfiguration(type, order) is true, let noTear be true; otherwise let noTear be false.
			Append WriteSharedMemory { [[Order]]: order, [[NoTear]]: noTear, [[Block]]: block, [[ByteIndex]]: byteIndex, [[ElementSize]]: elementSize, [[Payload]]: rawBytes } to eventList.
		*/
		throw new $SyntaxError('SharedArrayBuffer is not supported by this implementation');
	} else {
		// 9. Store the individual bytes of rawBytes into block, in order, starting at block[byteIndex].
		var arr = new $Uint8Array(arrayBuffer, byteIndex, elementSize);
		forEach(rawBytes, function (rawByte, i) {
			arr[i] = rawByte;
		});
	}

	// 10. Return NormalCompletion(undefined).
};
'use strict';

var callBound = require('call-bound');

var $TypeError = require('es-errors/type');
var isInteger = require('math-intrinsics/isInteger');
var isObject = require('es-object-atoms/isObject');

var DeletePropertyOrThrow = require('./DeletePropertyOrThrow');
var Get = require('./Get');
var HasProperty = require('./HasProperty');
var Set = require('./Set');
var ToString = require('./ToString');

var isAbstractClosure = require('../helpers/isAbstractClosure');

var $sort = callBound('Array.prototype.sort');

// https://262.ecma-international.org/13.0/#sec-sortindexedproperties

module.exports = function SortIndexedProperties(obj, len, SortCompare) {
	if (!isObject(obj)) {
		throw new $TypeError('Assertion failed: Type(obj) is not Object');
	}
	if (!isInteger(len) || len < 0) {
		throw new $TypeError('Assertion failed: `len` must be an integer >= 0');
	}
	if (!isAbstractClosure(SortCompare) || SortCompare.length !== 2) {
		throw new $TypeError('Assertion failed: `SortCompare` must be an abstract closure taking 2 arguments');
	}

	var items = []; // step 1

	var k = 0; // step 2

	while (k < len) { // step 3
		var Pk = ToString(k);
		var kPresent = HasProperty(obj, Pk);
		if (kPresent) {
			var kValue = Get(obj, Pk);
			items[items.length] = kValue;
		}
		k += 1;
	}

	var itemCount = items.length; // step 4

	$sort(items, SortCompare); // step 5

	var j = 0; // step 6

	while (j < itemCount) { // step 7
		Set(obj, ToString(j), items[j], true);
		j += 1;
	}

	while (j < len) { // step 8
		DeletePropertyOrThrow(obj, ToString(j));
		j += 1;
	}
	return obj; // step 9
};
'use strict';

var GetIntrinsic = require('get-intrinsic');

var $species = GetIntrinsic('%Symbol.species%', true);
var $TypeError = require('es-errors/type');
var isObject = require('es-object-atoms/isObject');

var IsConstructor = require('./IsConstructor');

// https://262.ecma-international.org/6.0/#sec-speciesconstructor

module.exports = function SpeciesConstructor(O, defaultConstructor) {
	if (!isObject(O)) {
		throw new $TypeError('Assertion failed: Type(O) is not Object');
	}
	var C = O.constructor;
	if (typeof C === 'undefined') {
		return defaultConstructor;
	}
	if (!isObject(C)) {
		throw new $TypeError('O.constructor is not an Object');
	}
	var S = $species ? C[$species] : void 0;
	if (S == null) {
		return defaultConstructor;
	}
	if (IsConstructor(S)) {
		return S;
	}
	throw new $TypeError('no constructor found');
};
'use strict';

var GetIntrinsic = require('get-intrinsic');

var $Object = require('es-object-atoms');
var $StringPrototype = GetIntrinsic('%String.prototype%');
var $SyntaxError = require('es-errors/syntax');
var $TypeError = require('es-errors/type');
var setProto = require('set-proto');

var DefinePropertyOrThrow = require('./DefinePropertyOrThrow');

// https://262.ecma-international.org/6.0/#sec-stringcreate

module.exports = function StringCreate(value, prototype) {
	if (typeof value !== 'string') {
		throw new $TypeError('Assertion failed: `S` must be a String');
	}

	var S = $Object(value);
	if (prototype !== $StringPrototype) {
		if (setProto) {
			setProto(S, prototype);
		} else {
			throw new $SyntaxError('StringCreate: a `proto` argument that is not `String.prototype` is not supported in an environment that does not support setting the [[Prototype]]');
		}
	}

	var length = value.length;
	DefinePropertyOrThrow(S, 'length', {
		'[[Configurable]]': false,
		'[[Enumerable]]': false,
		'[[Value]]': length,
		'[[Writable]]': false
	});

	return S;
};
'use strict';

var $TypeError = require('es-errors/type');
var isNegativeZero = require('math-intrinsics/isNegativeZero');
var isObject = require('es-object-atoms/isObject');

var callBound = require('call-bound');
var $charAt = callBound('String.prototype.charAt');
var $stringToString = callBound('String.prototype.toString');

var CanonicalNumericIndexString = require('./CanonicalNumericIndexString');

var isPropertyKey = require('../helpers/isPropertyKey');
var isInteger = require('math-intrinsics/isInteger');

// https://262.ecma-international.org/12.0/#sec-stringgetownproperty

module.exports = function StringGetOwnProperty(S, P) {
	var str;
	if (isObject(S)) {
		try {
			str = $stringToString(S);
		} catch (e) { /**/ }
	}
	if (typeof str !== 'string') {
		throw new $TypeError('Assertion failed: `S` must be a boxed string object');
	}
	if (!isPropertyKey(P)) {
		throw new $TypeError('Assertion failed: P is not a Property Key');
	}
	if (typeof P !== 'string') {
		return void undefined;
	}
	var index = CanonicalNumericIndexString(P);
	var len = str.length;
	if (typeof index === 'undefined' || !isInteger(index) || isNegativeZero(index) || index < 0 || len <= index) {
		return void undefined;
	}
	var resultStr = $charAt(S, index);
	return {
		'[[Configurable]]': false,
		'[[Enumerable]]': true,
		'[[Value]]': resultStr,
		'[[Writable]]': false
	};
};
'use strict';

var callBound = require('call-bound');

var $TypeError = require('es-errors/type');
var isInteger = require('math-intrinsics/isInteger');

var $slice = callBound('String.prototype.slice');

// https://262.ecma-international.org/12.0/#sec-stringindexof

module.exports = function StringIndexOf(string, searchValue, fromIndex) {
	if (typeof string !== 'string') {
		throw new $TypeError('Assertion failed: `string` must be a String');
	}
	if (typeof searchValue !== 'string') {
		throw new $TypeError('Assertion failed: `searchValue` must be a String');
	}
	if (!isInteger(fromIndex) || fromIndex < 0) {
		throw new $TypeError('Assertion failed: `fromIndex` must be a non-negative integer');
	}

	var len = string.length;
	if (searchValue === '' && fromIndex <= len) {
		return fromIndex;
	}

	var searchLen = searchValue.length;
	for (var i = fromIndex; i <= (len - searchLen); i += 1) {
		var candidate = $slice(string, i, i + searchLen);
		if (candidate === searchValue) {
			return i;
		}
	}
	return -1;
};
'use strict';

var $TypeError = require('es-errors/type');

var callBound = require('call-bound');

var ToLength = require('./ToLength');
var ToString = require('./ToString');

var $strSlice = callBound('String.prototype.slice');

// https://262.ecma-international.org/11.0/#sec-stringpad

module.exports = function StringPad(O, maxLength, fillString, placement) {
	if (placement !== 'start' && placement !== 'end') {
		throw new $TypeError('Assertion failed: `placement` must be "start" or "end"');
	}
	var S = ToString(O);
	var intMaxLength = ToLength(maxLength);
	var stringLength = S.length;
	if (intMaxLength <= stringLength) {
		return S;
	}
	var filler = typeof fillString === 'undefined' ? ' ' : ToString(fillString);
	if (filler === '') {
		return S;
	}
	var fillLen = intMaxLength - stringLength;

	// the String value consisting of repeated concatenations of filler truncated to length fillLen.
	var truncatedStringFiller = '';
	while (truncatedStringFiller.length < fillLen) {
		truncatedStringFiller += filler;
	}
	truncatedStringFiller = $strSlice(truncatedStringFiller, 0, fillLen);

	if (placement === 'start') {
		return truncatedStringFiller + S;
	}
	return S + truncatedStringFiller;
};
'use strict';

var GetIntrinsic = require('get-intrinsic');

var $BigInt = GetIntrinsic('%BigInt%', true);
var $TypeError = require('es-errors/type');
var $SyntaxError = require('es-errors/syntax');

// https://262.ecma-international.org/14.0/#sec-stringtobigint

module.exports = function StringToBigInt(argument) {
	if (typeof argument !== 'string') {
		throw new $TypeError('`argument` must be a string');
	}
	if (!$BigInt) {
		throw new $SyntaxError('BigInts are not supported in this environment');
	}
	try {
		return $BigInt(argument);
	} catch (e) {
		return void undefined;
	}
};
'use strict';

var $TypeError = require('es-errors/type');

var CodePointAt = require('./CodePointAt');

// https://262.ecma-international.org/12.0/#sec-stringtocodepoints

module.exports = function StringToCodePoints(string) {
	if (typeof string !== 'string') {
		throw new $TypeError('Assertion failed: `string` must be a String');
	}
	var codePoints = [];
	var size = string.length;
	var position = 0;
	while (position < size) {
		var cp = CodePointAt(string, position);
		codePoints[codePoints.length] = cp['[[CodePoint]]'];
		position += cp['[[CodeUnitCount]]'];
	}
	return codePoints;
};
'use strict';

var GetIntrinsic = require('get-intrinsic');

var $RegExp = GetIntrinsic('%RegExp%');
var $TypeError = require('es-errors/type');
var $parseInteger = GetIntrinsic('%parseInt%');

var callBound = require('call-bound');
var regexTester = require('safe-regex-test');

var $strSlice = callBound('String.prototype.slice');
var isBinary = regexTester(/^0b[01]+$/i);
var isOctal = regexTester(/^0o[0-7]+$/i);
var isInvalidHexLiteral = regexTester(/^[-+]0x[0-9a-f]+$/i);
var nonWS = ['\u0085', '\u200b', '\ufffe'].join('');
var nonWSregex = new $RegExp('[' + nonWS + ']', 'g');
var hasNonWS = regexTester(nonWSregex);

var $trim = require('string.prototype.trim');

// https://262.ecma-international.org/13.0/#sec-stringtonumber

module.exports = function StringToNumber(argument) {
	if (typeof argument !== 'string') {
		throw new $TypeError('Assertion failed: `argument` is not a String');
	}
	if (isBinary(argument)) {
		return +$parseInteger($strSlice(argument, 2), 2);
	}
	if (isOctal(argument)) {
		return +$parseInteger($strSlice(argument, 2), 8);
	}
	if (hasNonWS(argument) || isInvalidHexLiteral(argument)) {
		return NaN;
	}
	var trimmed = $trim(argument);
	if (trimmed !== argument) {
		return StringToNumber(trimmed);
	}
	return +argument;
};
'use strict';

var $TypeError = require('es-errors/type');
var isInteger = require('math-intrinsics/isInteger');
var callBound = require('call-bound');

var $slice = callBound('String.prototype.slice');

// https://262.ecma-international.org/12.0/#substring
module.exports = function substring(S, inclusiveStart, exclusiveEnd) {
	if (typeof S !== 'string' || !isInteger(inclusiveStart) || (arguments.length > 2 && !isInteger(exclusiveEnd))) {
		throw new $TypeError('`S` must be a String, and `inclusiveStart` and `exclusiveEnd` must be integers');
	}
	return $slice(S, inclusiveStart, arguments.length > 2 ? exclusiveEnd : S.length);
};
'use strict';

var $TypeError = require('es-errors/type');

var callBound = require('call-bound');

var $SymbolToString = callBound('Symbol.prototype.toString', true);

// https://262.ecma-international.org/6.0/#sec-symboldescriptivestring

module.exports = function SymbolDescriptiveString(sym) {
	if (typeof sym !== 'symbol') {
		throw new $TypeError('Assertion failed: `sym` must be a Symbol');
	}
	return $SymbolToString(sym);
};
'use strict';

var $gOPD = require('gopd');
var $TypeError = require('es-errors/type');

var every = require('../helpers/every');
var OwnPropertyKeys = require('own-keys');
var isObject = require('es-object-atoms/isObject');

var IsDataDescriptor = require('./IsDataDescriptor');
var IsExtensible = require('./IsExtensible');
var ToPropertyDescriptor = require('./ToPropertyDescriptor');

// https://262.ecma-international.org/6.0/#sec-testintegritylevel

module.exports = function TestIntegrityLevel(O, level) {
	if (!isObject(O)) {
		throw new $TypeError('Assertion failed: Type(O) is not Object');
	}
	if (level !== 'sealed' && level !== 'frozen') {
		throw new $TypeError('Assertion failed: `level` must be `"sealed"` or `"frozen"`');
	}
	var status = IsExtensible(O);
	if (status || !$gOPD) {
		return false;
	}
	var theKeys = OwnPropertyKeys(O);
	return theKeys.length === 0 || every(theKeys, function (k) {
		var currentDesc = $gOPD(O, k);
		if (typeof currentDesc !== 'undefined') {
			if (currentDesc.configurable) {
				return false;
			}
			if (level === 'frozen' && IsDataDescriptor(ToPropertyDescriptor(currentDesc)) && currentDesc.writable) {
				return false;
			}
		}
		return true;
	});
};
'use strict';

var callBound = require('call-bound');

var $SyntaxError = require('es-errors/syntax');
var $bigIntValueOf = callBound('BigInt.prototype.valueOf', true);

// https://262.ecma-international.org/11.0/#sec-thisbigintvalue

module.exports = function thisBigIntValue(value) {
	if (typeof value === 'bigint') {
		return value;
	}
	if (!$bigIntValueOf) {
		throw new $SyntaxError('BigInt is not supported');
	}
	return $bigIntValueOf(value);
};
'use strict';

var $BooleanValueOf = require('call-bound')('Boolean.prototype.valueOf');

// https://262.ecma-international.org/6.0/#sec-properties-of-the-boolean-prototype-object

module.exports = function thisBooleanValue(value) {
	if (typeof value === 'boolean') {
		return value;
	}

	return $BooleanValueOf(value);
};
'use strict';

var callBound = require('call-bound');

var $NumberValueOf = callBound('Number.prototype.valueOf');

// https://262.ecma-international.org/6.0/#sec-properties-of-the-number-prototype-object

module.exports = function thisNumberValue(value) {
	if (typeof value === 'number') {
		return value;
	}

	return $NumberValueOf(value);
};

'use strict';

var $StringValueOf = require('call-bound')('String.prototype.valueOf');

// https://262.ecma-international.org/6.0/#sec-properties-of-the-string-prototype-object

module.exports = function thisStringValue(value) {
	if (typeof value === 'string') {
		return value;
	}

	return $StringValueOf(value);
};
'use strict';

var $SyntaxError = require('es-errors/syntax');
var callBound = require('call-bound');

var $SymbolValueOf = callBound('Symbol.prototype.valueOf', true);

// https://262.ecma-international.org/9.0/#sec-thissymbolvalue

module.exports = function thisSymbolValue(value) {
	if (typeof value === 'symbol') {
		return value;
	}

	if (!$SymbolValueOf) {
		throw new $SyntaxError('Symbols are not supported; thisSymbolValue requires that `value` be a Symbol or a Symbol object');
	}

	return $SymbolValueOf(value);
};
'use strict';

var timeValue = require('../helpers/timeValue');

// https://262.ecma-international.org/6.0/#sec-properties-of-the-date-prototype-object

module.exports = function thisTimeValue(value) {
	return timeValue(value);
};
'use strict';

var CompletionRecord = require('./CompletionRecord');

// https://262.ecma-international.org/9.0/#sec-throwcompletion

module.exports = function ThrowCompletion(argument) {
	return new CompletionRecord('throw', argument);
};
'use strict';

var GetIntrinsic = require('get-intrinsic');

var $Date = GetIntrinsic('%Date%');

var $isFinite = require('math-intrinsics/isFinite');
var abs = require('math-intrinsics/abs');

var ToNumber = require('./ToNumber');

// https://262.ecma-international.org/5.1/#sec-15.9.1.14

module.exports = function TimeClip(time) {
	if (!$isFinite(time) || abs(time) > 8.64e15) {
		return NaN;
	}
	return +new $Date(ToNumber(time));
};

'use strict';

var msPerDay = require('../helpers/timeConstants').msPerDay;

var DayFromYear = require('./DayFromYear');

// https://262.ecma-international.org/5.1/#sec-15.9.1.3

module.exports = function TimeFromYear(y) {
	return msPerDay * DayFromYear(y);
};
'use strict';

var $TypeError = require('es-errors/type');

var $isNaN = require('math-intrinsics/isNaN');

var HourFromTime = require('./HourFromTime');
var MinFromTime = require('./MinFromTime');
var SecFromTime = require('./SecFromTime');
var ToZeroPaddedDecimalString = require('./ToZeroPaddedDecimalString');

// https://262.ecma-international.org/13.0/#sec-timestring

module.exports = function TimeString(tv) {
	if (typeof tv !== 'number' || $isNaN(tv)) {
		throw new $TypeError('Assertion failed: `tv` must be a non-NaN Number');
	}

	var hour = ToZeroPaddedDecimalString(HourFromTime(tv), 2); // step 1

	var minute = ToZeroPaddedDecimalString(MinFromTime(tv), 2); // step 2

	var second = ToZeroPaddedDecimalString(SecFromTime(tv), 2); // step 3

	return hour + ':' + minute + ':' + second + ' GMT'; // step 4
};
'use strict';

var modulo = require('./modulo');

var msPerDay = require('../helpers/timeConstants').msPerDay;

// https://262.ecma-international.org/5.1/#sec-15.9.1.2

module.exports = function TimeWithinDay(t) {
	return modulo(t, msPerDay);
};

'use strict';

var GetIntrinsic = require('get-intrinsic');

var $Date = GetIntrinsic('%Date%');
var $TypeError = require('es-errors/type');

var isNaN = require('math-intrinsics/isNaN');

var callBound = require('call-bound');

var $indexOf = callBound('String.prototype.indexOf');
var $slice = callBound('String.prototype.slice');
var $toTimeString = callBound('Date.prototype.toTimeString');

// https://262.ecma-international.org/13.0/#sec-timezoneestring

module.exports = function TimeZoneString(tv) {
	if (typeof tv !== 'number' || isNaN(tv)) {
		throw new $TypeError('Assertion failed: `tv` must be a non-NaN Number');
	}

	// 1. Let offset be LocalTZA(tv, true).
	// 2. If offset is +0𝔽 or offset > +0𝔽, then
	//   a. Let offsetSign be "+".
	//   b. Let absOffset be offset.
	// 3. Else,
	//   a. Let offsetSign be "-".
	//   b. Let absOffset be -offset.
	// 4. Let offsetMin be ToZeroPaddedDecimalString(ℝ(MinFromTime(absOffset)), 2).
	// 5. Let offsetHour be ToZeroPaddedDecimalString(ℝ(HourFromTime(absOffset)), 2).
	// 6. Let tzName be an implementation-defined string that is either the empty String or the string-concatenation of the code unit 0x0020 (SPACE), the code unit 0x0028 (LEFT PARENTHESIS), an implementation-defined timezone name, and the code unit 0x0029 (RIGHT PARENTHESIS).
	// 7. Return the string-concatenation of offsetSign, offsetHour, offsetMin, and tzName.

	// hack until LocalTZA, and "implementation-defined string" are available
	var ts = $toTimeString(new $Date(tv));
	return $slice(ts, $indexOf(ts, '(') + 1, $indexOf(ts, ')'));
};
'use strict';

var GetIntrinsic = require('get-intrinsic');

var $BigInt = GetIntrinsic('%BigInt%', true);
var $pow = require('math-intrinsics/pow');

var ToBigInt = require('./ToBigInt');
var BigIntRemainder = require('./BigInt/remainder');

var modBigInt = require('../helpers/modBigInt');

// BigInt(2**63), but node v10.4-v10.8 have a bug where you can't `BigInt(x)` anything larger than MAX_SAFE_INTEGER
var twoSixtyThree = $BigInt && (BigInt($pow(2, 32)) * BigInt($pow(2, 31)));

// BigInt(2**64), but node v10.4-v10.8 have a bug where you can't `BigInt(x)` anything larger than MAX_SAFE_INTEGER
var twoSixtyFour = $BigInt && (BigInt($pow(2, 32)) * BigInt($pow(2, 32)));

// https://262.ecma-international.org/11.0/#sec-tobigint64

module.exports = function ToBigInt64(argument) {
	var n = ToBigInt(argument);
	var int64bit = modBigInt(BigIntRemainder, n, twoSixtyFour);
	return int64bit >= twoSixtyThree ? int64bit - twoSixtyFour : int64bit;
};
'use strict';

var GetIntrinsic = require('get-intrinsic');

var $BigInt = GetIntrinsic('%BigInt%', true);
var $Number = GetIntrinsic('%Number%');
var $TypeError = require('es-errors/type');
var $SyntaxError = require('es-errors/syntax');

var StringToBigInt = require('./StringToBigInt');
var ToPrimitive = require('./ToPrimitive');

// https://262.ecma-international.org/13.0/#sec-tobigint

module.exports = function ToBigInt(argument) {
	if (!$BigInt) {
		throw new $SyntaxError('BigInts are not supported in this environment');
	}

	var prim = ToPrimitive(argument, $Number);

	if (prim == null) {
		throw new $TypeError('Cannot convert null or undefined to a BigInt');
	}

	if (typeof prim === 'boolean') {
		return prim ? $BigInt(1) : $BigInt(0);
	}

	if (typeof prim === 'number') {
		throw new $TypeError('Cannot convert a Number value to a BigInt');
	}

	if (typeof prim === 'string') {
		var n = StringToBigInt(prim);
		if (typeof n === 'undefined') {
			throw new $TypeError('Failed to parse String to BigInt');
		}
		return n;
	}

	if (typeof prim === 'symbol') {
		throw new $TypeError('Cannot convert a Symbol value to a BigInt');
	}

	if (typeof prim !== 'bigint') {
		throw new $SyntaxError('Assertion failed: unknown primitive type');
	}

	return prim;
};
'use strict';

var GetIntrinsic = require('get-intrinsic');

var $BigInt = GetIntrinsic('%BigInt%', true);

var $pow = require('math-intrinsics/pow');

var ToBigInt = require('./ToBigInt');
var BigIntRemainder = require('./BigInt/remainder');

var modBigInt = require('../helpers/modBigInt');

// BigInt(2**64), but node v10.4-v10.8 have a bug where you can't `BigInt(x)` anything larger than MAX_SAFE_INTEGER
var twoSixtyFour = $BigInt && (BigInt($pow(2, 32)) * BigInt($pow(2, 32)));

// https://262.ecma-international.org/11.0/#sec-tobiguint64

module.exports = function ToBigUint64(argument) {
	var n = ToBigInt(argument);
	var int64bit = modBigInt(BigIntRemainder, n, twoSixtyFour);
	return int64bit;
};
'use strict';

// http://262.ecma-international.org/5.1/#sec-9.2

module.exports = function ToBoolean(value) { return !!value; };
'use strict';

var GetIntrinsic = require('get-intrinsic');

var $TypeError = require('es-errors/type');
var $Date = GetIntrinsic('%Date%');
var $String = GetIntrinsic('%String%');

var $isNaN = require('math-intrinsics/isNaN');

// https://262.ecma-international.org/6.0/#sec-todatestring

module.exports = function ToDateString(tv) {
	if (typeof tv !== 'number') {
		throw new $TypeError('Assertion failed: `tv` must be a Number');
	}
	if ($isNaN(tv)) {
		return 'Invalid Date';
	}
	return $String(new $Date(tv));
};
'use strict';

var $RangeError = require('es-errors/range');

var ToIntegerOrInfinity = require('./ToIntegerOrInfinity');
var ToLength = require('./ToLength');
var SameValue = require('./SameValue');

// https://262.ecma-international.org/8.0/#sec-toindex

module.exports = function ToIndex(value) {
	if (typeof value === 'undefined') {
		return 0;
	}
	var integerIndex = ToIntegerOrInfinity(value);
	if (integerIndex < 0) {
		throw new $RangeError('index must be >= 0');
	}
	var index = ToLength(integerIndex);
	if (!SameValue(integerIndex, index)) {
		throw new $RangeError('index must be >= 0 and < 2 ** 53 - 1');
	}
	return index;
};
'use strict';

var ToUint16 = require('./ToUint16');

// https://262.ecma-international.org/6.0/#sec-toint16

module.exports = function ToInt16(argument) {
	var int16bit = ToUint16(argument);
	return int16bit >= 0x8000 ? int16bit - 0x10000 : int16bit;
};
'use strict';

var ToNumber = require('./ToNumber');

// http://262.ecma-international.org/5.1/#sec-9.5

module.exports = function ToInt32(x) {
	return ToNumber(x) >> 0;
};
'use strict';

var ToUint8 = require('./ToUint8');

// https://262.ecma-international.org/6.0/#sec-toint8

module.exports = function ToInt8(argument) {
	var int8bit = ToUint8(argument);
	return int8bit >= 0x80 ? int8bit - 0x100 : int8bit;
};
'use strict';

var abs = require('./abs');
var floor = require('./floor');
var ToNumber = require('./ToNumber');

var $isNaN = require('math-intrinsics/isNaN');
var $isFinite = require('math-intrinsics/isFinite');
var $sign = require('math-intrinsics/sign');

// https://262.ecma-international.org/12.0/#sec-tointegerorinfinity

module.exports = function ToIntegerOrInfinity(value) {
	var number = ToNumber(value);
	if ($isNaN(number) || number === 0) { return 0; }
	if (!$isFinite(number)) { return number; }
	var integer = floor(abs(number));
	if (integer === 0) { return 0; }
	return $sign(number) * integer;
};
'use strict';

var MAX_SAFE_INTEGER = require('math-intrinsics/constants/maxSafeInteger');

var ToIntegerOrInfinity = require('./ToIntegerOrInfinity');

// https://262.ecma-international.org/12.0/#sec-tolength

module.exports = function ToLength(argument) {
	var len = ToIntegerOrInfinity(argument);
	if (len <= 0) { return 0; } // includes converting -0 to +0
	if (len > MAX_SAFE_INTEGER) { return MAX_SAFE_INTEGER; }
	return len;
};
'use strict';

var GetIntrinsic = require('get-intrinsic');

var $TypeError = require('es-errors/type');
var $Number = GetIntrinsic('%Number%');
var isPrimitive = require('../helpers/isPrimitive');

var ToPrimitive = require('./ToPrimitive');
var StringToNumber = require('./StringToNumber');

// https://262.ecma-international.org/13.0/#sec-tonumber

module.exports = function ToNumber(argument) {
	var value = isPrimitive(argument) ? argument : ToPrimitive(argument, $Number);
	if (typeof value === 'symbol') {
		throw new $TypeError('Cannot convert a Symbol value to a number');
	}
	if (typeof value === 'bigint') {
		throw new $TypeError('Conversion from \'BigInt\' to \'number\' is not allowed.');
	}
	if (typeof value === 'string') {
		return StringToNumber(value);
	}
	return +value;
};
'use strict';

var GetIntrinsic = require('get-intrinsic');

var $Number = GetIntrinsic('%Number%');

var isPrimitive = require('../helpers/isPrimitive');

var ToPrimitive = require('./ToPrimitive');
var ToNumber = require('./ToNumber');

// https://262.ecma-international.org/11.0/#sec-tonumeric

module.exports = function ToNumeric(argument) {
	var primValue = isPrimitive(argument) ? argument : ToPrimitive(argument, $Number);
	if (typeof primValue === 'bigint') {
		return primValue;
	}
	return ToNumber(primValue);
};
'use strict';

// https://262.ecma-international.org/6.0/#sec-toobject

module.exports = require('es-object-atoms/ToObject');
'use strict';

var toPrimitive = require('es-to-primitive/es2015');

// https://262.ecma-international.org/6.0/#sec-toprimitive

module.exports = function ToPrimitive(input) {
	if (arguments.length > 1) {
		return toPrimitive(input, arguments[1]);
	}
	return toPrimitive(input);
};
'use strict';

var hasOwn = require('hasown');

var $TypeError = require('es-errors/type');
var isObject = require('es-object-atoms/isObject');

var IsCallable = require('./IsCallable');
var ToBoolean = require('./ToBoolean');

// https://262.ecma-international.org/5.1/#sec-8.10.5

module.exports = function ToPropertyDescriptor(Obj) {
	if (!isObject(Obj)) {
		throw new $TypeError('ToPropertyDescriptor requires an object');
	}

	var desc = {};
	if (hasOwn(Obj, 'enumerable')) {
		desc['[[Enumerable]]'] = ToBoolean(Obj.enumerable);
	}
	if (hasOwn(Obj, 'configurable')) {
		desc['[[Configurable]]'] = ToBoolean(Obj.configurable);
	}
	if (hasOwn(Obj, 'value')) {
		desc['[[Value]]'] = Obj.value;
	}
	if (hasOwn(Obj, 'writable')) {
		desc['[[Writable]]'] = ToBoolean(Obj.writable);
	}
	if (hasOwn(Obj, 'get')) {
		var getter = Obj.get;
		if (typeof getter !== 'undefined' && !IsCallable(getter)) {
			throw new $TypeError('getter must be a function');
		}
		desc['[[Get]]'] = getter;
	}
	if (hasOwn(Obj, 'set')) {
		var setter = Obj.set;
		if (typeof setter !== 'undefined' && !IsCallable(setter)) {
			throw new $TypeError('setter must be a function');
		}
		desc['[[Set]]'] = setter;
	}

	if ((hasOwn(desc, '[[Get]]') || hasOwn(desc, '[[Set]]')) && (hasOwn(desc, '[[Value]]') || hasOwn(desc, '[[Writable]]'))) {
		throw new $TypeError('Invalid property descriptor. Cannot both specify accessors and a value or writable attribute');
	}
	return desc;
};
'use strict';

var GetIntrinsic = require('get-intrinsic');

var $String = GetIntrinsic('%String%');

var ToPrimitive = require('./ToPrimitive');
var ToString = require('./ToString');

// https://262.ecma-international.org/6.0/#sec-topropertykey

module.exports = function ToPropertyKey(argument) {
	var key = ToPrimitive(argument, $String);
	return typeof key === 'symbol' ? key : ToString(key);
};
'use strict';

var GetIntrinsic = require('get-intrinsic');

var $String = GetIntrinsic('%String%');
var $TypeError = require('es-errors/type');

// https://262.ecma-international.org/6.0/#sec-tostring

module.exports = function ToString(argument) {
	if (typeof argument === 'symbol') {
		throw new $TypeError('Cannot convert a Symbol value to a string');
	}
	return $String(argument);
};
'use strict';

var modulo = require('./modulo');
var ToNumber = require('./ToNumber');

var abs = require('math-intrinsics/abs');
var floor = require('math-intrinsics/floor');
var $isNaN = require('math-intrinsics/isNaN');
var $isFinite = require('math-intrinsics/isFinite');
var $sign = require('math-intrinsics/sign');

// http://262.ecma-international.org/5.1/#sec-9.7

module.exports = function ToUint16(value) {
	var number = ToNumber(value);
	if ($isNaN(number) || number === 0 || !$isFinite(number)) { return 0; }
	var posInt = $sign(number) * floor(abs(number));
	return modulo(posInt, 0x10000);
};
'use strict';

var ToNumber = require('./ToNumber');

// http://262.ecma-international.org/5.1/#sec-9.6

module.exports = function ToUint32(x) {
	return ToNumber(x) >>> 0;
};
'use strict';

var ToNumber = require('./ToNumber');
var floor = require('./floor');

var $isNaN = require('math-intrinsics/isNaN');

// https://262.ecma-international.org/6.0/#sec-touint8clamp

module.exports = function ToUint8Clamp(argument) {
	var number = ToNumber(argument);
	if ($isNaN(number) || number <= 0) { return 0; }
	if (number >= 0xFF) { return 0xFF; }
	var f = floor(number);
	if (f + 0.5 < number) { return f + 1; }
	if (number < f + 0.5) { return f; }
	if (f % 2 !== 0) { return f + 1; }
	return f;
};
'use strict';

var ToNumber = require('./ToNumber');

var $isNaN = require('math-intrinsics/isNaN');
var $isFinite = require('math-intrinsics/isFinite');
var $sign = require('math-intrinsics/sign');
var abs = require('math-intrinsics/abs');
var floor = require('math-intrinsics/floor');
var modulo = require('math-intrinsics/mod');

// https://262.ecma-international.org/6.0/#sec-touint8

module.exports = function ToUint8(argument) {
	var number = ToNumber(argument);
	if ($isNaN(number) || number === 0 || !$isFinite(number)) { return 0; }
	var posInt = $sign(number) * floor(abs(number));
	return modulo(posInt, 0x100);
};
'use strict';

var GetIntrinsic = require('get-intrinsic');

var $String = GetIntrinsic('%String%');
var $RangeError = require('es-errors/range');
var isInteger = require('math-intrinsics/isInteger');

var StringPad = require('./StringPad');

// https://262.ecma-international.org/13.0/#sec-tozeropaddeddecimalstring

module.exports = function ToZeroPaddedDecimalString(n, minLength) {
	if (!isInteger(n) || n < 0) {
		throw new $RangeError('Assertion failed: `q` must be a non-negative integer');
	}
	var S = $String(n);
	return StringPad(S, minLength, '0', 'start');
};
'use strict';

var trimStart = require('string.prototype.trimstart');
var trimEnd = require('string.prototype.trimend');

var $TypeError = require('es-errors/type');

var RequireObjectCoercible = require('./RequireObjectCoercible');
var ToString = require('./ToString');

// https://262.ecma-international.org/10.0/#sec-trimstring

module.exports = function TrimString(string, where) {
	var str = RequireObjectCoercible(string);
	var S = ToString(str);
	var T;
	if (where === 'start') {
		T = trimStart(S);
	} else if (where === 'end') {
		T = trimEnd(S);
	} else if (where === 'start+end') {
		T = trimStart(trimEnd(S));
	} else {
		throw new $TypeError('Assertion failed: invalid `where` value; must be "start", "end", or "start+end"');
	}
	return T;
};
'use strict';

var $SyntaxError = require('es-errors/syntax');
var $TypeError = require('es-errors/type');

var IsArray = require('./IsArray');
var IsConstructor = require('./IsConstructor');
var ValidateTypedArray = require('./ValidateTypedArray');

var availableTypedArrays = require('available-typed-arrays')();
var typedArrayLength = require('typed-array-length');

// https://262.ecma-international.org/7.0/#typedarray-create

module.exports = function TypedArrayCreate(constructor, argumentList) {
	if (!IsConstructor(constructor)) {
		throw new $TypeError('Assertion failed: `constructor` must be a constructor');
	}
	if (!IsArray(argumentList)) {
		throw new $TypeError('Assertion failed: `argumentList` must be a List');
	}
	if (availableTypedArrays.length === 0) {
		throw new $SyntaxError('Assertion failed: Typed Arrays are not supported in this environment');
	}

	// var newTypedArray = Construct(constructor, argumentList); // step 1
	var newTypedArray;
	if (argumentList.length === 0) {
		newTypedArray = new constructor();
	} else if (argumentList.length === 1) {
		newTypedArray = new constructor(argumentList[0]);
	} else if (argumentList.length === 2) {
		newTypedArray = new constructor(argumentList[0], argumentList[1]);
	} else {
		newTypedArray = new constructor(argumentList[0], argumentList[1], argumentList[2]);
	}

	ValidateTypedArray(newTypedArray); // step 2

	if (argumentList.length === 1 && typeof argumentList[0] === 'number') { // step 3
		if (typedArrayLength(newTypedArray) < argumentList[0]) {
			throw new $TypeError('Assertion failed: `argumentList[0]` must be <= `newTypedArray.length`'); // step 3.a
		}
	}

	return newTypedArray; // step 4
};
'use strict';

var $SyntaxError = require('es-errors/syntax');
var $TypeError = require('es-errors/type');
var isInteger = require('math-intrinsics/isInteger');
var whichTypedArray = require('which-typed-array');

// https://262.ecma-international.org/13.0/#sec-typedarrayelementsize

var tableTAO = require('./tables/typed-array-objects');

module.exports = function TypedArrayElementSize(O) {
	var type = whichTypedArray(O);
	if (!type) {
		throw new $TypeError('Assertion failed: `O` must be a TypedArray');
	}
	var size = tableTAO.size['$' + tableTAO.name['$' + type]];
	if (!isInteger(size) || size < 0) {
		throw new $SyntaxError('Assertion failed: Unknown TypedArray type `' + type + '`');
	}

	return size;
};
'use strict';

var $SyntaxError = require('es-errors/syntax');
var $TypeError = require('es-errors/type');

var whichTypedArray = require('which-typed-array');

// https://262.ecma-international.org/13.0/#sec-typedarrayelementtype

var tableTAO = require('./tables/typed-array-objects');

module.exports = function TypedArrayElementType(O) {
	var type = whichTypedArray(O);
	if (!type) {
		throw new $TypeError('Assertion failed: `O` must be a TypedArray');
	}
	var result = tableTAO.name['$' + type];
	if (typeof result !== 'string') {
		throw new $SyntaxError('Assertion failed: Unknown TypedArray type `' + type + '`');
	}

	return result;
};
'use strict';

var $SyntaxError = require('es-errors/syntax');
var $TypeError = require('es-errors/type');

var whichTypedArray = require('which-typed-array');
var availableTypedArrays = require('available-typed-arrays')();

var IsArray = require('./IsArray');
var SpeciesConstructor = require('./SpeciesConstructor');
var TypedArrayCreate = require('./TypedArrayCreate');

var getConstructor = require('../helpers/typedArrayConstructors');

// https://262.ecma-international.org/7.0/#typedarray-species-create

module.exports = function TypedArraySpeciesCreate(exemplar, argumentList) {
	if (availableTypedArrays.length === 0) {
		throw new $SyntaxError('Assertion failed: Typed Arrays are not supported in this environment');
	}

	var kind = whichTypedArray(exemplar);
	if (!kind) {
		throw new $TypeError('Assertion failed: exemplar must be a TypedArray'); // step 1
	}
	if (!IsArray(argumentList)) {
		throw new $TypeError('Assertion failed: `argumentList` must be a List'); // step 1
	}

	var defaultConstructor = getConstructor(kind); // step 2
	if (typeof defaultConstructor !== 'function') {
		throw new $SyntaxError('Assertion failed: `constructor` of `exemplar` (' + kind + ') must exist. Please report this!');
	}
	var constructor = SpeciesConstructor(exemplar, defaultConstructor); // step 3

	return TypedArrayCreate(constructor, argumentList); // step 4
};
'use strict';

var ES5Type = require('../5/Type');

// https://262.ecma-international.org/11.0/#sec-ecmascript-data-types-and-values

module.exports = function Type(x) {
	if (typeof x === 'symbol') {
		return 'Symbol';
	}
	if (typeof x === 'bigint') {
		return 'BigInt';
	}
	return ES5Type(x);
};
'use strict';

var $TypeError = require('es-errors/type');

var callBound = require('call-bound');

var $charCodeAt = callBound('String.prototype.charCodeAt');
var $numberToString = callBound('Number.prototype.toString');
var $toLowerCase = callBound('String.prototype.toLowerCase');

var StringPad = require('./StringPad');

// https://262.ecma-international.org/11.0/#sec-unicodeescape

module.exports = function UnicodeEscape(C) {
	if (typeof C !== 'string' || C.length !== 1) {
		throw new $TypeError('Assertion failed: `C` must be a single code unit');
	}
	var n = $charCodeAt(C, 0);
	if (n > 0xFFFF) {
		throw new $TypeError('`Assertion failed: numeric value of `C` must be <= 0xFFFF');
	}

	return '\\u' + StringPad($toLowerCase($numberToString(n, 16)), 4, '0', 'start');
};
'use strict';

var GetIntrinsic = require('get-intrinsic');

var $TypeError = require('es-errors/type');
var $fromCharCode = GetIntrinsic('%String.fromCharCode%');

var floor = require('./floor');
var modulo = require('./modulo');

var isCodePoint = require('../helpers/isCodePoint');

// https://262.ecma-international.org/12.0/#sec-utf16encoding

module.exports = function UTF16EncodeCodePoint(cp) {
	if (!isCodePoint(cp)) {
		throw new $TypeError('Assertion failed: `cp` must be >= 0 and <= 0x10FFFF');
	}
	if (cp <= 65535) {
		return $fromCharCode(cp);
	}
	var cu1 = $fromCharCode(floor((cp - 65536) / 1024) + 0xD800);
	var cu2 = $fromCharCode(modulo(cp - 65536, 1024) + 0xDC00);
	return cu1 + cu2;
};
'use strict';

var GetIntrinsic = require('get-intrinsic');

var $TypeError = require('es-errors/type');
var $fromCharCode = GetIntrinsic('%String.fromCharCode%');

var isLeadingSurrogate = require('../helpers/isLeadingSurrogate');
var isTrailingSurrogate = require('../helpers/isTrailingSurrogate');

// https://262.ecma-international.org/12.0/#sec-utf16decodesurrogatepair

module.exports = function UTF16SurrogatePairToCodePoint(lead, trail) {
	if (!isLeadingSurrogate(lead) || !isTrailingSurrogate(trail)) {
		throw new $TypeError('Assertion failed: `lead` must be a leading surrogate char code, and `trail` must be a trailing surrogate char code');
	}
	// var cp = (lead - 0xD800) * 0x400 + (trail - 0xDC00) + 0x10000;
	return $fromCharCode(lead) + $fromCharCode(trail);
};
'use strict';

var $TypeError = require('es-errors/type');
var isObject = require('es-object-atoms/isObject');

var DefineOwnProperty = require('../helpers/DefineOwnProperty');
var isFullyPopulatedPropertyDescriptor = require('../helpers/isFullyPopulatedPropertyDescriptor');
var isPropertyDescriptor = require('../helpers/records/property-descriptor');

var FromPropertyDescriptor = require('./FromPropertyDescriptor');
var IsAccessorDescriptor = require('./IsAccessorDescriptor');
var IsDataDescriptor = require('./IsDataDescriptor');
var IsGenericDescriptor = require('./IsGenericDescriptor');
var isPropertyKey = require('../helpers/isPropertyKey');
var SameValue = require('./SameValue');

// https://262.ecma-international.org/13.0/#sec-validateandapplypropertydescriptor

// see https://github.com/tc39/ecma262/pull/2468 for ES2022 changes

// eslint-disable-next-line max-lines-per-function, max-statements
module.exports = function ValidateAndApplyPropertyDescriptor(O, P, extensible, Desc, current) {
	if (typeof O !== 'undefined' && !isObject(O)) {
		throw new $TypeError('Assertion failed: O must be undefined or an Object');
	}
	if (!isPropertyKey(P)) {
		throw new $TypeError('Assertion failed: P must be a Property Key');
	}
	if (typeof extensible !== 'boolean') {
		throw new $TypeError('Assertion failed: extensible must be a Boolean');
	}
	if (!isPropertyDescriptor(Desc)) {
		throw new $TypeError('Assertion failed: Desc must be a Property Descriptor');
	}
	if (typeof current !== 'undefined' && !isPropertyDescriptor(current)) {
		throw new $TypeError('Assertion failed: current must be a Property Descriptor, or undefined');
	}

	if (typeof current === 'undefined') { // step 2
		if (!extensible) {
			return false; // step 2.a
		}
		if (typeof O === 'undefined') {
			return true; // step 2.b
		}
		if (IsAccessorDescriptor(Desc)) { // step 2.c
			return DefineOwnProperty(
				IsDataDescriptor,
				SameValue,
				FromPropertyDescriptor,
				O,
				P,
				Desc
			);
		}
		// step 2.d
		return DefineOwnProperty(
			IsDataDescriptor,
			SameValue,
			FromPropertyDescriptor,
			O,
			P,
			{
				'[[Configurable]]': !!Desc['[[Configurable]]'],
				'[[Enumerable]]': !!Desc['[[Enumerable]]'],
				'[[Value]]': Desc['[[Value]]'],
				'[[Writable]]': !!Desc['[[Writable]]']
			}
		);
	}

	// 3. Assert: current is a fully populated Property Descriptor.
	if (
		!isFullyPopulatedPropertyDescriptor(
			{
				IsAccessorDescriptor: IsAccessorDescriptor,
				IsDataDescriptor: IsDataDescriptor
			},
			current
		)
	) {
		throw new $TypeError('`current`, when present, must be a fully populated and valid Property Descriptor');
	}

	// 4. If every field in Desc is absent, return true.
	// this can't really match the assertion that it's a Property Descriptor in our JS implementation

	// 5. If current.[[Configurable]] is false, then
	if (!current['[[Configurable]]']) {
		if ('[[Configurable]]' in Desc && Desc['[[Configurable]]']) {
			// step 5.a
			return false;
		}
		if ('[[Enumerable]]' in Desc && !SameValue(Desc['[[Enumerable]]'], current['[[Enumerable]]'])) {
			// step 5.b
			return false;
		}
		if (!IsGenericDescriptor(Desc) && !SameValue(IsAccessorDescriptor(Desc), IsAccessorDescriptor(current))) {
			// step 5.c
			return false;
		}
		if (IsAccessorDescriptor(current)) { // step 5.d
			if ('[[Get]]' in Desc && !SameValue(Desc['[[Get]]'], current['[[Get]]'])) {
				return false;
			}
			if ('[[Set]]' in Desc && !SameValue(Desc['[[Set]]'], current['[[Set]]'])) {
				return false;
			}
		} else if (!current['[[Writable]]']) { // step 5.e
			if ('[[Writable]]' in Desc && Desc['[[Writable]]']) {
				return false;
			}
			if ('[[Value]]' in Desc && !SameValue(Desc['[[Value]]'], current['[[Value]]'])) {
				return false;
			}
		}
	}

	// 6. If O is not undefined, then
	if (typeof O !== 'undefined') {
		var configurable;
		var enumerable;
		if (IsDataDescriptor(current) && IsAccessorDescriptor(Desc)) { // step 6.a
			configurable = ('[[Configurable]]' in Desc ? Desc : current)['[[Configurable]]'];
			enumerable = ('[[Enumerable]]' in Desc ? Desc : current)['[[Enumerable]]'];
			// Replace the property named P of object O with an accessor property having [[Configurable]] and [[Enumerable]] attributes as described by current and each other attribute set to its default value.
			return DefineOwnProperty(
				IsDataDescriptor,
				SameValue,
				FromPropertyDescriptor,
				O,
				P,
				{
					'[[Configurable]]': !!configurable,
					'[[Enumerable]]': !!enumerable,
					'[[Get]]': ('[[Get]]' in Desc ? Desc : current)['[[Get]]'],
					'[[Set]]': ('[[Set]]' in Desc ? Desc : current)['[[Set]]']
				}
			);
		} else if (IsAccessorDescriptor(current) && IsDataDescriptor(Desc)) {
			configurable = ('[[Configurable]]' in Desc ? Desc : current)['[[Configurable]]'];
			enumerable = ('[[Enumerable]]' in Desc ? Desc : current)['[[Enumerable]]'];
			// i. Replace the property named P of object O with a data property having [[Configurable]] and [[Enumerable]] attributes as described by current and each other attribute set to its default value.
			return DefineOwnProperty(
				IsDataDescriptor,
				SameValue,
				FromPropertyDescriptor,
				O,
				P,
				{
					'[[Configurable]]': !!configurable,
					'[[Enumerable]]': !!enumerable,
					'[[Value]]': ('[[Value]]' in Desc ? Desc : current)['[[Value]]'],
					'[[Writable]]': !!('[[Writable]]' in Desc ? Desc : current)['[[Writable]]']
				}
			);
		}

		// For each field of Desc that is present, set the corresponding attribute of the property named P of object O to the value of the field.
		return DefineOwnProperty(
			IsDataDescriptor,
			SameValue,
			FromPropertyDescriptor,
			O,
			P,
			Desc
		);
	}

	return true; // step 7
};
'use strict';

var $RangeError = require('es-errors/range');
var $TypeError = require('es-errors/type');

var ToIndex = require('./ToIndex');
var TypedArrayElementSize = require('./TypedArrayElementSize');

var isTypedArray = require('is-typed-array');
var typedArrayByteOffset = require('typed-array-byte-offset');
var typedArrayLength = require('typed-array-length');

// https://262.ecma-international.org/13.0/#sec-validateatomicaccess

module.exports = function ValidateAtomicAccess(typedArray, requestIndex) {
	if (!isTypedArray(typedArray)) {
		throw new $TypeError('Assertion failed: `typedArray` must be a TypedArray');
	}

	var length = typedArrayLength(typedArray); // step 1

	var accessIndex = ToIndex(requestIndex); // step 2

	/*
	// this assertion can never be reached
	if (!(accessIndex >= 0)) {
		throw new $TypeError('Assertion failed: accessIndex >= 0'); // step 4
	}
	*/

	if (accessIndex >= length) {
		throw new $RangeError('index out of range'); // step 4
	}

	var elementSize = TypedArrayElementSize(typedArray); // step 5

	var offset = typedArrayByteOffset(typedArray); // step 6

	return (accessIndex * elementSize) + offset; // step 7
};
'use strict';

var $TypeError = require('es-errors/type');

var IsBigIntElementType = require('./IsBigIntElementType');
var IsUnclampedIntegerElementType = require('./IsUnclampedIntegerElementType');
var TypedArrayElementType = require('./TypedArrayElementType');
var ValidateTypedArray = require('./ValidateTypedArray');

var whichTypedArray = require('which-typed-array');
var typedArrayBuffer = require('typed-array-buffer');

// https://262.ecma-international.org/13.0/#sec-validateintegertypedarray

module.exports = function ValidateIntegerTypedArray(typedArray) {
	var waitable = arguments.length > 1 ? arguments[1] : false; // step 1

	if (typeof waitable !== 'boolean') {
		throw new $TypeError('Assertion failed: `waitable` must be a Boolean');
	}

	ValidateTypedArray(typedArray); // step 2
	var buffer = typedArrayBuffer(typedArray); // step 3

	if (waitable) { // step 5
		var typeName = whichTypedArray(typedArray);
		if (typeName !== 'Int32Array' && typeName !== 'BigInt64Array') {
			throw new $TypeError('Assertion failed: `typedArray` must be an Int32Array or BigInt64Array when `waitable` is true'); // step 5.a
		}
	} else {
		var type = TypedArrayElementType(typedArray); // step 5.a
		if (!IsUnclampedIntegerElementType(type) && !IsBigIntElementType(type)) {
			throw new $TypeError('Assertion failed: `typedArray` must be an integer TypedArray'); // step 5.b
		}
	}

	return buffer; // step 6
};
'use strict';

var $TypeError = require('es-errors/type');
var isObject = require('es-object-atoms/isObject');

var IsDetachedBuffer = require('./IsDetachedBuffer');

var isTypedArray = require('is-typed-array');
var typedArrayBuffer = require('typed-array-buffer');

// https://262.ecma-international.org/13.0/#sec-validatetypedarray

module.exports = function ValidateTypedArray(O) {
	if (!isObject(O)) {
		throw new $TypeError('Assertion failed: `O` must be an Object'); // step 1
	}
	if (!isTypedArray(O)) {
		throw new $TypeError('Assertion failed: `O` must be a Typed Array'); // steps 1 - 2
	}

	var buffer = typedArrayBuffer(O); // step 3

	if (IsDetachedBuffer(buffer)) {
		throw new $TypeError('`O` must be backed by a non-detached buffer'); // step 4
	}
};
'use strict';

var callBound = require('call-bound');

var $TypeError = require('es-errors/type');
var $deref = callBound('WeakRef.prototype.deref', true);

var isWeakRef = require('is-weakref');

var AddToKeptObjects = require('./AddToKeptObjects');

// https://262.ecma-international.org/12.0/#sec-weakrefderef

module.exports = function WeakRefDeref(weakRef) {
	if (!isWeakRef(weakRef)) {
		throw new $TypeError('Assertion failed: `weakRef` must be a WeakRef');
	}
	var target = $deref(weakRef);
	if (target) {
		AddToKeptObjects(target);
	}
	return target;
};
'use strict';

var Day = require('./Day');
var modulo = require('./modulo');

// https://262.ecma-international.org/5.1/#sec-15.9.1.6

module.exports = function WeekDay(t) {
	return modulo(Day(t) + 4, 7);
};
'use strict';

var $TypeError = require('es-errors/type');

var callBound = require('call-bound');
var $indexOf = callBound('String.prototype.indexOf');

var Canonicalize = require('./Canonicalize');

var caseFolding = require('../helpers/caseFolding.json');
var forEach = require('../helpers/forEach');
var OwnPropertyKeys = require('own-keys');

var A = 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789_'; // step 1

// https://262.ecma-international.org/8.0/#sec-runtime-semantics-wordcharacters-abstract-operation

module.exports = function WordCharacters(IgnoreCase, Unicode) {
	if (typeof IgnoreCase !== 'boolean' || typeof Unicode !== 'boolean') {
		throw new $TypeError('Assertion failed: `IgnoreCase` and `Unicode` must be booleans');
	}

	var U = '';
	forEach(OwnPropertyKeys(caseFolding.C), function (c) {
		if (
			$indexOf(A, c) === -1 // c not in A
			&& $indexOf(A, Canonicalize(c, IgnoreCase, Unicode)) > -1 // canonicalized c IS in A
		) {
			U += caseFolding.C[c]; // step 3
		}
	});
	forEach(OwnPropertyKeys(caseFolding.S), function (c) {
		if (
			$indexOf(A, c) === -1 // c not in A
			&& $indexOf(A, Canonicalize(c, IgnoreCase, Unicode)) > -1 // canonicalized c IS in A
		) {
			U += caseFolding.S[c]; // step 3
		}
	});

	if ((!Unicode || !IgnoreCase) && U.length > 0) {
		throw new $TypeError('Assertion failed: `U` must be empty when `IgnoreCase` and `Unicode` are not both true'); // step 4
	}

	return A + U; // step 5, 6
};
'use strict';

var GetIntrinsic = require('get-intrinsic');

var $Date = GetIntrinsic('%Date%');

var callBound = require('call-bound');

var $getUTCFullYear = callBound('Date.prototype.getUTCFullYear');

// https://262.ecma-international.org/5.1/#sec-15.9.1.3

module.exports = function YearFromTime(t) {
	// largest y such that this.TimeFromYear(y) <= t
	return $getUTCFullYear(new $Date(t));
};
'use strict';

var $abs = require('math-intrinsics/abs');

// https://262.ecma-international.org/11.0/#eqn-abs

module.exports = function abs(x) {
	return typeof x === 'bigint' ? BigInt($abs(Number(x))) : $abs(x);
};
'use strict';

var $TypeError = require('es-errors/type');
var isObject = require('es-object-atoms/isObject');
var inspect = require('object-inspect');

var Call = require('./Call');
var Get = require('./Get');
var GetIterator = require('./GetIterator');
var IsCallable = require('./IsCallable');
var IteratorClose = require('./IteratorClose');
var IteratorStep = require('./IteratorStep');
var IteratorValue = require('./IteratorValue');
var ThrowCompletion = require('./ThrowCompletion');

// https://262.ecma-international.org/14.0/#sec-add-entries-from-iterable

module.exports = function AddEntriesFromIterable(target, iterable, adder) {
	if (!IsCallable(adder)) {
		throw new $TypeError('Assertion failed: `adder` is not callable');
	}
	if (iterable == null) {
		throw new $TypeError('Assertion failed: `iterable` is present, and not nullish');
	}
	var iteratorRecord = GetIterator(iterable, 'sync');
	while (true) { // eslint-disable-line no-constant-condition
		var next = IteratorStep(iteratorRecord);
		if (!next) {
			return target;
		}
		var nextItem = IteratorValue(next);
		if (!isObject(nextItem)) {
			var error = ThrowCompletion(new $TypeError('iterator next must return an Object, got ' + inspect(nextItem)));
			return IteratorClose(iteratorRecord, error);
		}
		try {
			var k = Get(nextItem, '0');
			var v = Get(nextItem, '1');
			Call(adder, target, [k, v]);
		} catch (e) {
			return IteratorClose(iteratorRecord, ThrowCompletion(e));
		}
	}
};
'use strict';

var SLOT = require('internal-slot');

var $TypeError = require('es-errors/type');
var isObject = require('es-object-atoms/isObject');

var ClearKeptObjects = require('./ClearKeptObjects');

// https://262.ecma-international.org/12.0/#sec-addtokeptobjects

module.exports = function AddToKeptObjects(object) {
	if (!isObject(object)) {
		throw new $TypeError('Assertion failed: `object` must be an Object');
	}
	var arr = SLOT.get(ClearKeptObjects, '[[es-abstract internal: KeptAlive]]');
	arr[arr.length] = object;
};
'use strict';

var CodePointAt = require('./CodePointAt');

var $TypeError = require('es-errors/type');
var isInteger = require('math-intrinsics/isInteger');
var MAX_SAFE_INTEGER = require('math-intrinsics/constants/maxSafeInteger');

// https://262.ecma-international.org/12.0/#sec-advancestringindex

module.exports = function AdvanceStringIndex(S, index, unicode) {
	if (typeof S !== 'string') {
		throw new $TypeError('Assertion failed: `S` must be a String');
	}
	if (!isInteger(index) || index < 0 || index > MAX_SAFE_INTEGER) {
		throw new $TypeError('Assertion failed: `length` must be an integer >= 0 and <= 2**53');
	}
	if (typeof unicode !== 'boolean') {
		throw new $TypeError('Assertion failed: `unicode` must be a Boolean');
	}
	if (!unicode) {
		return index + 1;
	}
	var length = S.length;
	if ((index + 1) >= length) {
		return index + 1;
	}
	var cp = CodePointAt(S, index);
	return index + cp['[[CodeUnitCount]]'];
};
'use strict';

var $TypeError = require('es-errors/type');

var HasOwnProperty = require('./HasOwnProperty');
var ToNumeric = require('./ToNumeric');
var ToPrimitive = require('./ToPrimitive');
var ToString = require('./ToString');
var Type = require('./Type');

var NumberAdd = require('./Number/add');
var NumberBitwiseAND = require('./Number/bitwiseAND');
var NumberBitwiseOR = require('./Number/bitwiseOR');
var NumberBitwiseXOR = require('./Number/bitwiseXOR');
var NumberDivide = require('./Number/divide');
var NumberExponentiate = require('./Number/exponentiate');
var NumberLeftShift = require('./Number/leftShift');
var NumberMultiply = require('./Number/multiply');
var NumberRemainder = require('./Number/remainder');
var NumberSignedRightShift = require('./Number/signedRightShift');
var NumberSubtract = require('./Number/subtract');
var NumberUnsignedRightShift = require('./Number/unsignedRightShift');
var BigIntAdd = require('./BigInt/add');
var BigIntBitwiseAND = require('./BigInt/bitwiseAND');
var BigIntBitwiseOR = require('./BigInt/bitwiseOR');
var BigIntBitwiseXOR = require('./BigInt/bitwiseXOR');
var BigIntDivide = require('./BigInt/divide');
var BigIntExponentiate = require('./BigInt/exponentiate');
var BigIntLeftShift = require('./BigInt/leftShift');
var BigIntMultiply = require('./BigInt/multiply');
var BigIntRemainder = require('./BigInt/remainder');
var BigIntSignedRightShift = require('./BigInt/signedRightShift');
var BigIntSubtract = require('./BigInt/subtract');
var BigIntUnsignedRightShift = require('./BigInt/unsignedRightShift');

// https://262.ecma-international.org/12.0/#sec-applystringornumericbinaryoperator

// https://262.ecma-international.org/12.0/#step-applystringornumericbinaryoperator-operations-table
var table = {
	'**': [NumberExponentiate, BigIntExponentiate],
	'*': [NumberMultiply, BigIntMultiply],
	'/': [NumberDivide, BigIntDivide],
	'%': [NumberRemainder, BigIntRemainder],
	'+': [NumberAdd, BigIntAdd],
	'-': [NumberSubtract, BigIntSubtract],
	'<<': [NumberLeftShift, BigIntLeftShift],
	'>>': [NumberSignedRightShift, BigIntSignedRightShift],
	'>>>': [NumberUnsignedRightShift, BigIntUnsignedRightShift],
	'&': [NumberBitwiseAND, BigIntBitwiseAND],
	'^': [NumberBitwiseXOR, BigIntBitwiseXOR],
	'|': [NumberBitwiseOR, BigIntBitwiseOR]
};

module.exports = function ApplyStringOrNumericBinaryOperator(lval, opText, rval) {
	if (typeof opText !== 'string' || !HasOwnProperty(table, opText)) {
		throw new $TypeError('Assertion failed: `opText` must be a valid operation string');
	}
	if (opText === '+') {
		var lprim = ToPrimitive(lval);
		var rprim = ToPrimitive(rval);
		if (typeof lprim === 'string' || typeof rprim === 'string') {
			var lstr = ToString(lprim);
			var rstr = ToString(rprim);
			return lstr + rstr;
		}
		/* eslint no-param-reassign: 1 */
		lval = lprim;
		rval = rprim;
	}
	var lnum = ToNumeric(lval);
	var rnum = ToNumeric(rval);
	if (Type(lnum) !== Type(rnum)) {
		throw new $TypeError('types of ' + lnum + ' and ' + rnum + ' differ');
	}
	var Operation = table[opText][typeof lnum === 'bigint' ? 1 : 0];
	return Operation(lnum, rnum);
};
'use strict';

var GetIntrinsic = require('get-intrinsic');

var $ArrayPrototype = GetIntrinsic('%Array.prototype%');
var $RangeError = require('es-errors/range');
var $SyntaxError = require('es-errors/syntax');
var $TypeError = require('es-errors/type');
var isInteger = require('math-intrinsics/isInteger');
var MAX_ARRAY_LENGTH = require('math-intrinsics/constants/maxArrayLength');
var $setProto = require('set-proto');

// https://262.ecma-international.org/12.0/#sec-arraycreate

module.exports = function ArrayCreate(length) {
	if (!isInteger(length) || length < 0) {
		throw new $TypeError('Assertion failed: `length` must be an integer Number >= 0');
	}
	if (length > MAX_ARRAY_LENGTH) {
		throw new $RangeError('length is greater than (2**32 - 1)');
	}
	var proto = arguments.length > 1 ? arguments[1] : $ArrayPrototype;
	var A = []; // steps 3, 5
	if (proto !== $ArrayPrototype) { // step 4
		if (!$setProto) {
			throw new $SyntaxError('ArrayCreate: a `proto` argument that is not `Array.prototype` is not supported in an environment that does not support setting the [[Prototype]]');
		}
		$setProto(A, proto);
	}
	if (length !== 0) { // bypasses the need for step 6
		A.length = length;
	}
	/* step 6, the above as a shortcut for the below
	OrdinaryDefineOwnProperty(A, 'length', {
		'[[Configurable]]': false,
		'[[Enumerable]]': false,
		'[[Value]]': length,
		'[[Writable]]': true
	});
	*/
	return A;
};
'use strict';

var $RangeError = require('es-errors/range');
var $TypeError = require('es-errors/type');

var assign = require('object.assign');

var isPropertyDescriptor = require('../helpers/records/property-descriptor');

var IsArray = require('./IsArray');
var IsDataDescriptor = require('./IsDataDescriptor');
var OrdinaryDefineOwnProperty = require('./OrdinaryDefineOwnProperty');
var OrdinaryGetOwnProperty = require('./OrdinaryGetOwnProperty');
var ToNumber = require('./ToNumber');
var ToString = require('./ToString');
var ToUint32 = require('./ToUint32');

// https://262.ecma-international.org/6.0/#sec-arraysetlength

// eslint-disable-next-line max-statements, max-lines-per-function
module.exports = function ArraySetLength(A, Desc) {
	if (!IsArray(A)) {
		throw new $TypeError('Assertion failed: A must be an Array');
	}
	if (!isPropertyDescriptor(Desc)) {
		throw new $TypeError('Assertion failed: Desc must be a Property Descriptor');
	}
	if (!('[[Value]]' in Desc)) {
		return OrdinaryDefineOwnProperty(A, 'length', Desc);
	}
	var newLenDesc = assign({}, Desc);
	var newLen = ToUint32(Desc['[[Value]]']);
	var numberLen = ToNumber(Desc['[[Value]]']);
	if (newLen !== numberLen) {
		throw new $RangeError('Invalid array length');
	}
	newLenDesc['[[Value]]'] = newLen;
	var oldLenDesc = OrdinaryGetOwnProperty(A, 'length');
	if (!IsDataDescriptor(oldLenDesc)) {
		throw new $TypeError('Assertion failed: an array had a non-data descriptor on `length`');
	}
	var oldLen = oldLenDesc['[[Value]]'];
	if (newLen >= oldLen) {
		return OrdinaryDefineOwnProperty(A, 'length', newLenDesc);
	}
	if (!oldLenDesc['[[Writable]]']) {
		return false;
	}
	var newWritable;
	if (!('[[Writable]]' in newLenDesc) || newLenDesc['[[Writable]]']) {
		newWritable = true;
	} else {
		newWritable = false;
		newLenDesc['[[Writable]]'] = true;
	}
	var succeeded = OrdinaryDefineOwnProperty(A, 'length', newLenDesc);
	if (!succeeded) {
		return false;
	}
	while (newLen < oldLen) {
		oldLen -= 1;
		// eslint-disable-next-line no-param-reassign
		var deleteSucceeded = delete A[ToString(oldLen)];
		if (!deleteSucceeded) {
			newLenDesc['[[Value]]'] = oldLen + 1;
			if (!newWritable) {
				newLenDesc['[[Writable]]'] = false;
				OrdinaryDefineOwnProperty(A, 'length', newLenDesc);
				return false;
			}
		}
	}
	if (!newWritable) {
		return OrdinaryDefineOwnProperty(A, 'length', { '[[Writable]]': false });
	}
	return true;
};
'use strict';

var GetIntrinsic = require('get-intrinsic');

var $species = GetIntrinsic('%Symbol.species%', true);
var $TypeError = require('es-errors/type');
var isInteger = require('math-intrinsics/isInteger');
var isObject = require('es-object-atoms/isObject');

var ArrayCreate = require('./ArrayCreate');
var Get = require('./Get');
var IsArray = require('./IsArray');
var IsConstructor = require('./IsConstructor');

// https://262.ecma-international.org/12.0/#sec-arrayspeciescreate

module.exports = function ArraySpeciesCreate(originalArray, length) {
	if (!isInteger(length) || length < 0) {
		throw new $TypeError('Assertion failed: length must be an integer >= 0');
	}

	var isArray = IsArray(originalArray);
	if (!isArray) {
		return ArrayCreate(length);
	}

	var C = Get(originalArray, 'constructor');
	// TODO: figure out how to make a cross-realm normal Array, a same-realm Array
	// if (IsConstructor(C)) {
	// 	if C is another realm's Array, C = undefined
	// 	Object.getPrototypeOf(Object.getPrototypeOf(Object.getPrototypeOf(Array))) === null ?
	// }
	if ($species && isObject(C)) {
		C = Get(C, $species);
		if (C === null) {
			C = void 0;
		}
	}

	if (typeof C === 'undefined') {
		return ArrayCreate(length);
	}
	if (!IsConstructor(C)) {
		throw new $TypeError('C must be a constructor');
	}
	return new C(length); // Construct(C, length);
};

'use strict';

var GetIntrinsic = require('get-intrinsic');

var $SyntaxError = require('es-errors/syntax');
var $TypeError = require('es-errors/type');
var isObject = require('es-object-atoms/isObject');
var $Promise = GetIntrinsic('%Promise%', true);

var callBound = require('call-bound');

var CreateIterResultObject = require('./CreateIterResultObject');
var IteratorComplete = require('./IteratorComplete');
var IteratorValue = require('./IteratorValue');
var PromiseResolve = require('./PromiseResolve');

var $then = callBound('Promise.prototype.then', true);

// https://262.ecma-international.org/10.0/#sec-asyncfromsynciteratorcontinuation

module.exports = function AsyncFromSyncIteratorContinuation(result) {
	if (!isObject(result)) {
		throw new $TypeError('Assertion failed: Type(O) is not Object');
	}

	if (arguments.length > 1) {
		throw new $SyntaxError('although AsyncFromSyncIteratorContinuation should take a second argument, it is not used in this implementation');
	}

	if (!$Promise) {
		throw new $SyntaxError('This environment does not support Promises.');
	}

	return new $Promise(function (resolve) {
		var done = IteratorComplete(result); // step 2
		var value = IteratorValue(result); // step 4
		var valueWrapper = PromiseResolve($Promise, value); // step 6

		// eslint-disable-next-line no-shadow
		var onFulfilled = function (value) { // steps 8-9
			return CreateIterResultObject(value, done); // step 8.a
		};
		resolve($then(valueWrapper, onFulfilled)); // step 11
	}); // step 12
};
'use strict';

var GetIntrinsic = require('get-intrinsic');

var $SyntaxError = require('es-errors/syntax');
var $TypeError = require('es-errors/type');
var isObject = require('es-object-atoms/isObject');
var $Promise = GetIntrinsic('%Promise%', true);

var Call = require('./Call');
var CompletionRecord = require('./CompletionRecord');
var GetMethod = require('./GetMethod');

var isIteratorRecord = require('../helpers/records/iterator-record-2023');

var callBound = require('call-bound');

var $then = callBound('Promise.prototype.then', true);

// https://262.ecma-international.org/12.0/#sec-asynciteratorclose

module.exports = function AsyncIteratorClose(iteratorRecord, completion) {
	if (!isIteratorRecord(iteratorRecord)) {
		throw new $TypeError('Assertion failed: `iteratorRecord` must be an Iterator Record'); // step 1
	}

	if (!(completion instanceof CompletionRecord)) {
		throw new $TypeError('Assertion failed: completion is not a Completion Record instance'); // step 2
	}

	if (!$then) {
		throw new $SyntaxError('This environment does not support Promises.');
	}

	var iterator = iteratorRecord['[[Iterator]]']; // step 3

	return $then(
		$then(
			$then(
				new $Promise(function (resolve) {
					resolve(GetMethod(iterator, 'return')); // step 4
					// resolve(Call(ret, iterator, [])); // step 6
				}),
				function (returnV) { // step 5.a
					if (typeof returnV === 'undefined') {
						return completion; // step 5.b
					}
					return Call(returnV, iterator); // step 5.c, 5.d.
				}
			),
			null,
			function (e) {
				if (completion.type() === 'throw') {
					completion['?'](); // step 6
				} else {
					throw e; // step 7
				}
			}
		),
		function (innerResult) { // step 8
			if (completion.type() === 'throw') {
				completion['?'](); // step 6
			}
			if (!isObject(innerResult)) {
				throw new $TypeError('`innerResult` must be an Object'); // step 10
			}
			return completion;
		}
	);
};
'use strict';

var $TypeError = require('es-errors/type');
// var $BigInt = GetIntrinsic('%BigInt%', true);
// var $pow = require('math-intrinsics/pow');

// var BinaryAnd = require('./BinaryAnd');
// var BinaryOr = require('./BinaryOr');
// var BinaryXor = require('./BinaryXor');
// var modulo = require('./modulo');

// var zero = $BigInt && $BigInt(0);
// var negOne = $BigInt && $BigInt(-1);
// var two = $BigInt && $BigInt(2);

// https://262.ecma-international.org/11.0/#sec-bigintbitwiseop

module.exports = function BigIntBitwiseOp(op, x, y) {
	if (op !== '&' && op !== '|' && op !== '^') {
		throw new $TypeError('Assertion failed: `op` must be `&`, `|`, or `^`');
	}
	if (typeof x !== 'bigint' || typeof y !== 'bigint') {
		throw new $TypeError('`x` and `y` must be BigInts');
	}

	if (op === '&') {
		return x & y;
	}
	if (op === '|') {
		return x | y;
	}
	return x ^ y;
	/*
	var result = zero;
	var shift = 0;
	while (x !== zero && x !== negOne && y !== zero && y !== negOne) {
		var xDigit = modulo(x, two);
		var yDigit = modulo(y, two);
		if (op === '&') {
			result += $pow(2, shift) * BinaryAnd(xDigit, yDigit);
		} else if (op === '|') {
			result += $pow(2, shift) * BinaryOr(xDigit, yDigit);
		} else if (op === '^') {
			result += $pow(2, shift) * BinaryXor(xDigit, yDigit);
		}
		shift += 1;
		x = (x - xDigit) / two;
		y = (y - yDigit) / two;
	}
	var tmp;
	if (op === '&') {
		tmp = BinaryAnd(modulo(x, two), modulo(y, two));
	} else if (op === '|') {
		tmp = BinaryAnd(modulo(x, two), modulo(y, two));
	} else {
		tmp = BinaryXor(modulo(x, two), modulo(y, two));
	}
	if (tmp !== 0) {
		result -= $pow(2, shift);
	}
	return result;
	*/
};
'use strict';

var $TypeError = require('es-errors/type');

// https://262.ecma-international.org/11.0/#sec-binaryand

module.exports = function BinaryAnd(x, y) {
	if ((x !== 0 && x !== 1) || (y !== 0 && y !== 1)) {
		throw new $TypeError('Assertion failed: `x` and `y` must be either 0 or 1');
	}
	return x & y;
};
'use strict';

var $TypeError = require('es-errors/type');

// https://262.ecma-international.org/11.0/#sec-binaryor

module.exports = function BinaryOr(x, y) {
	if ((x !== 0 && x !== 1) || (y !== 0 && y !== 1)) {
		throw new $TypeError('Assertion failed: `x` and `y` must be either 0 or 1');
	}
	return x | y;
};
'use strict';

var $TypeError = require('es-errors/type');

// https://262.ecma-international.org/11.0/#sec-binaryxor

module.exports = function BinaryXor(x, y) {
	if ((x !== 0 && x !== 1) || (y !== 0 && y !== 1)) {
		throw new $TypeError('Assertion failed: `x` and `y` must be either 0 or 1');
	}
	return x ^ y;
};
'use strict';

var $TypeError = require('es-errors/type');

var IsArray = require('./IsArray');

var isByteValue = require('../helpers/isByteValue');

// https://262.ecma-international.org/12.0/#sec-bytelistbitwiseop

module.exports = function ByteListBitwiseOp(op, xBytes, yBytes) {
	if (op !== '&' && op !== '^' && op !== '|') {
		throw new $TypeError('Assertion failed: `op` must be `&`, `^`, or `|`');
	}
	if (!IsArray(xBytes) || !IsArray(yBytes) || xBytes.length !== yBytes.length) {
		throw new $TypeError('Assertion failed: `xBytes` and `yBytes` must be same-length sequences of byte values (an integer 0-255, inclusive)');
	}

	var result = [];

	for (var i = 0; i < xBytes.length; i += 1) {
		var xByte = xBytes[i];
		var yByte = yBytes[i];
		if (!isByteValue(xByte) || !isByteValue(yByte)) {
			throw new $TypeError('Assertion failed: `xBytes` and `yBytes` must be same-length sequences of byte values (an integer 0-255, inclusive)');
		}
		var resultByte;
		if (op === '&') {
			resultByte = xByte & yByte;
		} else if (op === '^') {
			resultByte = xByte ^ yByte;
		} else {
			resultByte = xByte | yByte;
		}
		result[result.length] = resultByte;
	}

	return result;
};
'use strict';

var $TypeError = require('es-errors/type');

var IsArray = require('./IsArray');

var isByteValue = require('../helpers/isByteValue');

// https://262.ecma-international.org/12.0/#sec-bytelistequal

module.exports = function ByteListEqual(xBytes, yBytes) {
	if (!IsArray(xBytes) || !IsArray(yBytes)) {
		throw new $TypeError('Assertion failed: `xBytes` and `yBytes` must be sequences of byte values (an integer 0-255, inclusive)');
	}

	if (xBytes.length !== yBytes.length) {
		return false;
	}

	for (var i = 0; i < xBytes.length; i += 1) {
		var xByte = xBytes[i];
		var yByte = yBytes[i];
		if (!isByteValue(xByte) || !isByteValue(yByte)) {
			throw new $TypeError('Assertion failed: `xBytes` and `yBytes` must be sequences of byte values (an integer 0-255, inclusive)');
		}
		if (xByte !== yByte) {
			return false;
		}
	}
	return true;
};
'use strict';

var GetIntrinsic = require('get-intrinsic');
var callBound = require('call-bound');

var $TypeError = require('es-errors/type');

var IsArray = require('./IsArray');

var $apply = GetIntrinsic('%Reflect.apply%', true) || callBound('Function.prototype.apply');

// https://262.ecma-international.org/6.0/#sec-call

module.exports = function Call(F, V) {
	var argumentsList = arguments.length > 2 ? arguments[2] : [];
	if (!IsArray(argumentsList)) {
		throw new $TypeError('Assertion failed: optional `argumentsList`, if provided, must be a List');
	}
	return $apply(F, V, argumentsList);
};
'use strict';

var isObject = require('es-object-atoms/isObject');

var KeyForSymbol = require('./KeyForSymbol');

// https://262.ecma-international.org/14.0/#sec-canbeheldweakly

module.exports = function CanBeHeldWeakly(v) {
	if (isObject(v)) {
		return true; // step 1
	}
	if (typeof v === 'symbol' && typeof KeyForSymbol(v) === 'undefined') {
		return true; // step 2
	}
	return false; // step 3
};
'use strict';

var $TypeError = require('es-errors/type');

var callBound = require('call-bound');
var hasOwn = require('hasown');

var $charCodeAt = callBound('String.prototype.charCodeAt');
var $toUpperCase = callBound('String.prototype.toUpperCase');

var isRegExpRecord = require('../helpers/records/regexp-record');
var caseFolding = require('../helpers/caseFolding.json');

// https://262.ecma-international.org/14.0/#sec-runtime-semantics-canonicalize-ch

module.exports = function Canonicalize(rer, ch) {
	if (!isRegExpRecord(rer)) {
		throw new $TypeError('Assertion failed: `rer` must be a RegExp Record');
	}

	if (typeof ch !== 'string') {
		throw new $TypeError('Assertion failed: `ch` must be a character');
	}

	if (rer['[[Unicode]]'] && rer['[[IgnoreCase]]']) { // step 1
		if (hasOwn(caseFolding.C, ch)) {
			return caseFolding.C[ch];
		}
		if (hasOwn(caseFolding.S, ch)) {
			return caseFolding.S[ch];
		}
		return ch; // step 1.b
	}

	if (!rer['[[IgnoreCase]]']) {
		return ch; // step 2
	}

	var u = $toUpperCase(ch); // step 5

	if (u.length !== 1) {
		return ch; // step 7
	}

	var cu = u; // step 8

	if ($charCodeAt(ch, 0) >= 128 && $charCodeAt(cu, 0) < 128) {
		return ch; // step 9
	}

	return cu; // step 10
};
'use strict';

var $TypeError = require('es-errors/type');

var SameValue = require('./SameValue');
var ToNumber = require('./ToNumber');
var ToString = require('./ToString');

// https://262.ecma-international.org/6.0/#sec-canonicalnumericindexstring

module.exports = function CanonicalNumericIndexString(argument) {
	if (typeof argument !== 'string') {
		throw new $TypeError('Assertion failed: `argument` must be a String');
	}
	if (argument === '-0') { return -0; }
	var n = ToNumber(argument);
	if (SameValue(ToString(n), argument)) { return n; }
	return void 0;
};
'use strict';

var GetIntrinsic = require('get-intrinsic');
var callBound = require('call-bound');

var $fromCharCode = GetIntrinsic('%String.fromCharCode%');
var $TypeError = require('es-errors/type');
var $charCodeAt = callBound('String.prototype.charCodeAt');

var CharSet = require('../helpers/CharSet').CharSet;

module.exports = function CharacterRange(A, B) {
	var a;
	var b;

	if (A instanceof CharSet || B instanceof CharSet) {
		if (!(A instanceof CharSet) || !(B instanceof CharSet)) {
			throw new $TypeError('Assertion failed: CharSets A and B are not both CharSets');
		}

		A.yield(function (c) {
			if (typeof a !== 'undefined') {
				throw new $TypeError('Assertion failed: CharSet A has more than one character');
			}
			a = c;
		});
		B.yield(function (c) {
			if (typeof b !== 'undefined') {
				throw new $TypeError('Assertion failed: CharSet B has more than one character');
			}
			b = c;
		});
	} else {
		if (A.length !== 1 || B.length !== 1) {
			throw new $TypeError('Assertion failed: CharSets A and B contain exactly one character');
		}
		a = A[0];
		b = B[0];
	}

	var i = $charCodeAt(a, 0);
	var j = $charCodeAt(b, 0);

	if (!(i <= j)) {
		throw new $TypeError('Assertion failed: i is not <= j');
	}

	var arr = [];
	for (var k = i; k <= j; k += 1) {
		arr[arr.length] = $fromCharCode(k);
	}
	return arr;
};
'use strict';

var $TypeError = require('es-errors/type');
var max = require('math-intrinsics/max');
var min = require('math-intrinsics/min');

// https://262.ecma-international.org/12.0/#clamping

module.exports = function clamp(x, lower, upper) {
	if (typeof x !== 'number' || typeof lower !== 'number' || typeof upper !== 'number' || !(lower <= upper)) {
		throw new $TypeError('Assertion failed: all three arguments must be MVs, and `lower` must be `<= upper`');
	}
	return min(max(lower, x), upper);
};
'use strict';

var SLOT = require('internal-slot');
var keptObjects = [];

// https://262.ecma-international.org/12.0/#sec-clear-kept-objects

module.exports = function ClearKeptObjects() {
	keptObjects.length = 0;
};

SLOT.set(module.exports, '[[es-abstract internal: KeptAlive]]', keptObjects);
'use strict';

var $TypeError = require('es-errors/type');

var GetPrototypeFromConstructor = require('./GetPrototypeFromConstructor');
var IsConstructor = require('./IsConstructor');
var IsDetachedBuffer = require('./IsDetachedBuffer');
var OrdinarySetPrototypeOf = require('./OrdinarySetPrototypeOf');

var isInteger = require('math-intrinsics/isInteger');
var isArrayBuffer = require('is-array-buffer');
var arrayBufferSlice = require('arraybuffer.prototype.slice');

// https://262.ecma-international.org/12.0/#sec-clonearraybuffer

module.exports = function CloneArrayBuffer(srcBuffer, srcByteOffset, srcLength, cloneConstructor) {
	if (!isArrayBuffer(srcBuffer)) {
		throw new $TypeError('Assertion failed: `srcBuffer` must be an ArrayBuffer instance');
	}
	if (!isInteger(srcByteOffset) || srcByteOffset < 0) {
		throw new $TypeError('Assertion failed: `srcByteOffset` must be a non-negative integer');
	}
	if (!isInteger(srcLength) || srcLength < 0) {
		throw new $TypeError('Assertion failed: `srcLength` must be a non-negative integer');
	}
	if (!IsConstructor(cloneConstructor)) {
		throw new $TypeError('Assertion failed: `cloneConstructor` must be a constructor');
	}

	// 3. Let targetBuffer be ? AllocateArrayBuffer(cloneConstructor, srcLength).
	var proto = GetPrototypeFromConstructor(cloneConstructor, '%ArrayBufferPrototype%'); // step 3, kinda

	if (IsDetachedBuffer(srcBuffer)) {
		throw new $TypeError('`srcBuffer` must not be a detached ArrayBuffer'); // step 4
	}

	/*
    5. Let srcBlock be srcBuffer.[[ArrayBufferData]].
    6. Let targetBlock be targetBuffer.[[ArrayBufferData]].
    7. Perform CopyDataBlockBytes(targetBlock, 0, srcBlock, srcByteOffset, srcLength).
    */
	var targetBuffer = arrayBufferSlice(srcBuffer, srcByteOffset, srcByteOffset + srcLength); // steps 5-7
	OrdinarySetPrototypeOf(targetBuffer, proto); // step 3

	return targetBuffer; // step 8
};
'use strict';

var $TypeError = require('es-errors/type');
var callBound = require('call-bound');
var isLeadingSurrogate = require('../helpers/isLeadingSurrogate');
var isTrailingSurrogate = require('../helpers/isTrailingSurrogate');

var UTF16SurrogatePairToCodePoint = require('./UTF16SurrogatePairToCodePoint');

var $charAt = callBound('String.prototype.charAt');
var $charCodeAt = callBound('String.prototype.charCodeAt');

// https://262.ecma-international.org/12.0/#sec-codepointat

module.exports = function CodePointAt(string, position) {
	if (typeof string !== 'string') {
		throw new $TypeError('Assertion failed: `string` must be a String');
	}
	var size = string.length;
	if (position < 0 || position >= size) {
		throw new $TypeError('Assertion failed: `position` must be >= 0, and < the length of `string`');
	}
	var first = $charCodeAt(string, position);
	var cp = $charAt(string, position);
	var firstIsLeading = isLeadingSurrogate(first);
	var firstIsTrailing = isTrailingSurrogate(first);
	if (!firstIsLeading && !firstIsTrailing) {
		return {
			'[[CodePoint]]': cp,
			'[[CodeUnitCount]]': 1,
			'[[IsUnpairedSurrogate]]': false
		};
	}
	if (firstIsTrailing || (position + 1 === size)) {
		return {
			'[[CodePoint]]': cp,
			'[[CodeUnitCount]]': 1,
			'[[IsUnpairedSurrogate]]': true
		};
	}
	var second = $charCodeAt(string, position + 1);
	if (!isTrailingSurrogate(second)) {
		return {
			'[[CodePoint]]': cp,
			'[[CodeUnitCount]]': 1,
			'[[IsUnpairedSurrogate]]': true
		};
	}

	return {
		'[[CodePoint]]': UTF16SurrogatePairToCodePoint(first, second),
		'[[CodeUnitCount]]': 2,
		'[[IsUnpairedSurrogate]]': false
	};
};
'use strict';

var $TypeError = require('es-errors/type');

var UTF16EncodeCodePoint = require('./UTF16EncodeCodePoint');
var IsArray = require('./IsArray');

var forEach = require('../helpers/forEach');
var isCodePoint = require('../helpers/isCodePoint');

// https://262.ecma-international.org/12.0/#sec-codepointstostring

module.exports = function CodePointsToString(text) {
	if (!IsArray(text)) {
		throw new $TypeError('Assertion failed: `text` must be a sequence of Unicode Code Points');
	}
	var result = '';
	forEach(text, function (cp) {
		if (!isCodePoint(cp)) {
			throw new $TypeError('Assertion failed: `text` must be a sequence of Unicode Code Points');
		}
		result += UTF16EncodeCodePoint(cp);
	});
	return result;
};
'use strict';

var $TypeError = require('es-errors/type');

var Call = require('./Call');
var IsLessThan = require('./IsLessThan');
var ToNumber = require('./ToNumber');
var ToString = require('./ToString');

var isNaN = require('math-intrinsics/isNaN');

// https://262.ecma-international.org/14.0/#sec-comparearrayelements

module.exports = function CompareArrayElements(x, y, compareFn) {
	if (typeof compareFn !== 'function' && typeof compareFn !== 'undefined') {
		throw new $TypeError('Assertion failed: `compareFn` must be a function or undefined');
	}

	if (typeof x === 'undefined' && typeof y === 'undefined') {
		return 0; // step 1
	}

	if (typeof x === 'undefined') {
		return 1; // step 2
	}

	if (typeof y === 'undefined') {
		return -1; // step 3
	}

	if (typeof compareFn !== 'undefined') { // step 4
		var v = ToNumber(Call(compareFn, void undefined, [x, y])); // step 4.a
		if (isNaN(v)) {
			return 0; // step 4.b
		}
		return v; // step 4.c
	}

	var xString = ToString(x); // step 5
	var yString = ToString(y); // step 6
	var xSmaller = IsLessThan(xString, yString, true); // step 7
	if (xSmaller) {
		return -1; // step 8
	}
	var ySmaller = IsLessThan(yString, xString, true); // step 9
	if (ySmaller) {
		return 1; // step 10
	}
	return 0; // step 11
};
'use strict';

var $TypeError = require('es-errors/type');

var Call = require('./Call');
var SameValue = require('./SameValue');
var ToNumber = require('./ToNumber');

var isNaN = require('math-intrinsics/isNaN');

// https://262.ecma-international.org/14.0/#sec-comparetypedarrayelements

module.exports = function CompareTypedArrayElements(x, y, compareFn) {
	if ((typeof x !== 'number' && typeof x !== 'bigint') || typeof x !== typeof y) {
		throw new $TypeError('Assertion failed: `x` and `y` must be either a BigInt or a Number, and both must be the same type');
	}
	if (typeof compareFn !== 'function' && typeof compareFn !== 'undefined') {
		throw new $TypeError('Assertion failed: `compareFn` must be a function or undefined');
	}

	if (typeof compareFn !== 'undefined') { // step 2
		var v = ToNumber(Call(compareFn, void undefined, [x, y])); // step 2.a
		if (isNaN(v)) {
			return 0; // step 2.b
		}
		return v; // step 2.c
	}

	var xNaN = isNaN(x);
	var yNaN = isNaN(y);
	if (xNaN && yNaN) {
		return 0; // step 3
	}

	if (xNaN) {
		return 1; // step 4
	}

	if (yNaN) {
		return -1; // step 5
	}

	if (x < y) {
		return -1; // step 6
	}

	if (x > y) {
		return 1; // step 7
	}

	if (SameValue(x, -0) && SameValue(y, 0)) {
		return -1; // step 8
	}

	if (SameValue(x, 0) && SameValue(y, -0)) {
		return 1; // step 9
	}

	return 0; // step 10
};
'use strict';

var $TypeError = require('es-errors/type');

var hasOwn = require('hasown');

var IsDataDescriptor = require('./IsDataDescriptor');
var IsGenericDescriptor = require('./IsGenericDescriptor');

var isPropertyDescriptor = require('../helpers/records/property-descriptor');

// https://262.ecma-international.org/6.0/#sec-completepropertydescriptor

module.exports = function CompletePropertyDescriptor(Desc) {
	if (!isPropertyDescriptor(Desc)) {
		throw new $TypeError('Assertion failed: `Desc` must be a Property Descriptor');
	}

	/* eslint no-param-reassign: 0 */

	if (IsGenericDescriptor(Desc) || IsDataDescriptor(Desc)) {
		if (!hasOwn(Desc, '[[Value]]')) {
			Desc['[[Value]]'] = void 0;
		}
		if (!hasOwn(Desc, '[[Writable]]')) {
			Desc['[[Writable]]'] = false;
		}
	} else {
		if (!hasOwn(Desc, '[[Get]]')) {
			Desc['[[Get]]'] = void 0;
		}
		if (!hasOwn(Desc, '[[Set]]')) {
			Desc['[[Set]]'] = void 0;
		}
	}
	if (!hasOwn(Desc, '[[Enumerable]]')) {
		Desc['[[Enumerable]]'] = false;
	}
	if (!hasOwn(Desc, '[[Configurable]]')) {
		Desc['[[Configurable]]'] = false;
	}
	return Desc;
};
'use strict';

var $SyntaxError = require('es-errors/syntax');

var SLOT = require('internal-slot');

// https://262.ecma-international.org/7.0/#sec-completion-record-specification-type

var CompletionRecord = function CompletionRecord(type, value) {
	if (!(this instanceof CompletionRecord)) {
		return new CompletionRecord(type, value);
	}
	if (type !== 'normal' && type !== 'break' && type !== 'continue' && type !== 'return' && type !== 'throw') {
		throw new $SyntaxError('Assertion failed: `type` must be one of "normal", "break", "continue", "return", or "throw"');
	}
	SLOT.set(this, '[[Type]]', type);
	SLOT.set(this, '[[Value]]', value);
	// [[Target]] slot?
};

CompletionRecord.prototype.type = function Type() {
	return SLOT.get(this, '[[Type]]');
};

CompletionRecord.prototype.value = function Value() {
	return SLOT.get(this, '[[Value]]');
};

CompletionRecord.prototype['?'] = function ReturnIfAbrupt() {
	var type = SLOT.get(this, '[[Type]]');
	var value = SLOT.get(this, '[[Value]]');

	if (type === 'throw') {
		throw value;
	}
	return value;
};

CompletionRecord.prototype['!'] = function assert() {
	var type = SLOT.get(this, '[[Type]]');

	if (type !== 'normal') {
		throw new $SyntaxError('Assertion failed: Completion Record is not of type "normal"');
	}
	return SLOT.get(this, '[[Value]]');
};

module.exports = CompletionRecord;
'use strict';

var $TypeError = require('es-errors/type');
var isObject = require('es-object-atoms/isObject');
var callBound = require('call-bound');
var OwnPropertyKeys = require('own-keys');

var forEach = require('../helpers/forEach');
var every = require('../helpers/every');
var some = require('../helpers/some');

var $isEnumerable = callBound('Object.prototype.propertyIsEnumerable');

var CreateDataPropertyOrThrow = require('./CreateDataPropertyOrThrow');
var Get = require('./Get');
var IsArray = require('./IsArray');
var isPropertyKey = require('../helpers/isPropertyKey');
var SameValue = require('./SameValue');
var ToNumber = require('./ToNumber');
var ToObject = require('./ToObject');

var isInteger = require('math-intrinsics/isInteger');

// https://262.ecma-international.org/12.0/#sec-copydataproperties

module.exports = function CopyDataProperties(target, source, excludedItems) {
	if (!isObject(target)) {
		throw new $TypeError('Assertion failed: "target" must be an Object');
	}

	if (!IsArray(excludedItems) || !every(excludedItems, isPropertyKey)) {
		throw new $TypeError('Assertion failed: "excludedItems" must be a List of Property Keys');
	}

	if (typeof source === 'undefined' || source === null) {
		return target;
	}

	var from = ToObject(source);

	var keys = OwnPropertyKeys(from);
	forEach(keys, function (nextKey) {
		var excluded = some(excludedItems, function (e) {
			return SameValue(e, nextKey) === true;
		});
		/*
		var excluded = false;

		forEach(excludedItems, function (e) {
			if (SameValue(e, nextKey) === true) {
				excluded = true;
			}
		});
		*/

		var enumerable = $isEnumerable(from, nextKey) || (
		// this is to handle string keys being non-enumerable in older engines
			typeof source === 'string'
			&& nextKey >= 0
			&& isInteger(ToNumber(nextKey))
		);
		if (excluded === false && enumerable) {
			var propValue = Get(from, nextKey);
			CreateDataPropertyOrThrow(target, nextKey, propValue);
		}
	});

	return target;
};
'use strict';

var GetIntrinsic = require('get-intrinsic');

var $SyntaxError = require('es-errors/syntax');
var $TypeError = require('es-errors/type');
var isObject = require('es-object-atoms/isObject');
var $Promise = GetIntrinsic('%Promise%', true);

var AsyncFromSyncIteratorContinuation = require('./AsyncFromSyncIteratorContinuation');
var Call = require('./Call');
var CreateIterResultObject = require('./CreateIterResultObject');
var Get = require('./Get');
var GetMethod = require('./GetMethod');
var IteratorNext = require('./IteratorNext');
var OrdinaryObjectCreate = require('./OrdinaryObjectCreate');

var isIteratorRecord = require('../helpers/records/iterator-record-2023');

var SLOT = require('internal-slot');

var $AsyncFromSyncIteratorPrototype = GetIntrinsic('%AsyncFromSyncIteratorPrototype%', true) || {
	next: function next(value) {
		if (!$Promise) {
			throw new $SyntaxError('This environment does not support Promises.');
		}

		var O = this; // step 1

		SLOT.assert(O, '[[SyncIteratorRecord]]'); // step 2

		var argsLength = arguments.length;

		return new $Promise(function (resolve) { // step 3
			var syncIteratorRecord = SLOT.get(O, '[[SyncIteratorRecord]]'); // step 4
			var result;
			if (argsLength > 0) {
				result = IteratorNext(syncIteratorRecord, value); // step 5.a
			} else { // step 6
				result = IteratorNext(syncIteratorRecord);// step 6.a
			}
			resolve(AsyncFromSyncIteratorContinuation(result)); // step 8
		});
	},
	'return': function () {
		if (!$Promise) {
			throw new $SyntaxError('This environment does not support Promises.');
		}

		var O = this; // step 1

		SLOT.assert(O, '[[SyncIteratorRecord]]'); // step 2

		var valueIsPresent = arguments.length > 0;
		var value = valueIsPresent ? arguments[0] : void undefined;

		return new $Promise(function (resolve, reject) { // step 3
			var syncIterator = SLOT.get(O, '[[SyncIteratorRecord]]')['[[Iterator]]']; // step 4
			var iteratorReturn = GetMethod(syncIterator, 'return'); // step 5

			if (typeof iteratorReturn === 'undefined') { // step 7
				var iterResult = CreateIterResultObject(value, true); // step 7.a
				Call(resolve, undefined, [iterResult]); // step 7.b
				return;
			}
			var result;
			if (valueIsPresent) { // step 8
				result = Call(iteratorReturn, syncIterator, [value]); // step 8.a
			} else { // step 9
				result = Call(iteratorReturn, syncIterator); // step 9.a
			}
			if (!isObject(result)) { // step 11
				Call(reject, undefined, [new $TypeError('Iterator `return` method returned a non-object value.')]); // step 11.a
				return;
			}

			resolve(AsyncFromSyncIteratorContinuation(result)); // step 12
		});
	},
	'throw': function () {
		if (!$Promise) {
			throw new $SyntaxError('This environment does not support Promises.');
		}

		var O = this; // step 1

		SLOT.assert(O, '[[SyncIteratorRecord]]'); // step 2

		var valueIsPresent = arguments.length > 0;
		var value = valueIsPresent ? arguments[0] : void undefined;

		return new $Promise(function (resolve, reject) { // step 3
			var syncIterator = SLOT.get(O, '[[SyncIteratorRecord]]')['[[Iterator]]']; // step 4

			var throwMethod = GetMethod(syncIterator, 'throw'); // step 5

			if (typeof throwMethod === 'undefined') { // step 7
				Call(reject, undefined, [value]); // step 7.a
				return;
			}

			var result;
			if (valueIsPresent) { // step 8
				result = Call(throwMethod, syncIterator, [value]); // step 8.a
			} else { // step 9
				result = Call(throwMethod, syncIterator); // step 9.a
			}
			if (!isObject(result)) { // step 11
				Call(reject, undefined, [new $TypeError('Iterator `throw` method returned a non-object value.')]); // step 11.a
				return;
			}

			resolve(AsyncFromSyncIteratorContinuation(result/* , promiseCapability */)); // step 12
		});
	}
};

// https://262.ecma-international.org/14.0/#sec-createasyncfromsynciterator

module.exports = function CreateAsyncFromSyncIterator(syncIteratorRecord) {
	if (!isIteratorRecord(syncIteratorRecord)) {
		throw new $TypeError('Assertion failed: `syncIteratorRecord` must be an Iterator Record');
	}

	// var asyncIterator = OrdinaryObjectCreate(%AsyncFromSyncIteratorPrototype%, « [[SyncIteratorRecord]] »); // step 1
	var asyncIterator = OrdinaryObjectCreate($AsyncFromSyncIteratorPrototype);

	SLOT.set(asyncIterator, '[[SyncIteratorRecord]]', syncIteratorRecord); // step 2

	var nextMethod = Get(asyncIterator, 'next'); // step 3

	return { // steps 3-4
		'[[Iterator]]': asyncIterator,
		'[[NextMethod]]': nextMethod,
		'[[Done]]': false
	};
};
'use strict';

var $TypeError = require('es-errors/type');
var isObject = require('es-object-atoms/isObject');

var isPropertyKey = require('../helpers/isPropertyKey');
var OrdinaryDefineOwnProperty = require('./OrdinaryDefineOwnProperty');

// https://262.ecma-international.org/6.0/#sec-createdataproperty

module.exports = function CreateDataProperty(O, P, V) {
	if (!isObject(O)) {
		throw new $TypeError('Assertion failed: Type(O) is not Object');
	}
	if (!isPropertyKey(P)) {
		throw new $TypeError('Assertion failed: P is not a Property Key');
	}
	var newDesc = {
		'[[Configurable]]': true,
		'[[Enumerable]]': true,
		'[[Value]]': V,
		'[[Writable]]': true
	};
	return OrdinaryDefineOwnProperty(O, P, newDesc);
};
'use strict';

var $TypeError = require('es-errors/type');
var isObject = require('es-object-atoms/isObject');

var CreateDataProperty = require('./CreateDataProperty');

var isPropertyKey = require('../helpers/isPropertyKey');

// // https://262.ecma-international.org/14.0/#sec-createdatapropertyorthrow

module.exports = function CreateDataPropertyOrThrow(O, P, V) {
	if (!isObject(O)) {
		throw new $TypeError('Assertion failed: Type(O) is not Object');
	}
	if (!isPropertyKey(P)) {
		throw new $TypeError('Assertion failed: P is not a Property Key');
	}
	var success = CreateDataProperty(O, P, V);
	if (!success) {
		throw new $TypeError('unable to create data property');
	}
};
'use strict';

var $TypeError = require('es-errors/type');

var callBound = require('call-bound');

var $replace = callBound('String.prototype.replace');

var RequireObjectCoercible = require('./RequireObjectCoercible');
var ToString = require('./ToString');

// https://262.ecma-international.org/6.0/#sec-createhtml

module.exports = function CreateHTML(string, tag, attribute, value) {
	if (typeof tag !== 'string' || typeof attribute !== 'string') {
		throw new $TypeError('Assertion failed: `tag` and `attribute` must be strings');
	}
	var str = RequireObjectCoercible(string);
	var S = ToString(str);
	var p1 = '<' + tag;
	if (attribute !== '') {
		var V = ToString(value);
		var escapedV = $replace(V, /\x22/g, '&quot;');
		p1 += '\x20' + attribute + '\x3D\x22' + escapedV + '\x22';
	}
	return p1 + '>' + S + '</' + tag + '>';
};
'use strict';

var $TypeError = require('es-errors/type');

// https://262.ecma-international.org/6.0/#sec-createiterresultobject

module.exports = function CreateIterResultObject(value, done) {
	if (typeof done !== 'boolean') {
		throw new $TypeError('Assertion failed: Type(done) is not Boolean');
	}
	return {
		value: value,
		done: done
	};
};
'use strict';

var callBound = require('call-bound');

var $TypeError = require('es-errors/type');
var isObject = require('es-object-atoms/isObject');
var $indexOf = callBound('Array.prototype.indexOf', true) || callBound('String.prototype.indexOf');

var Get = require('./Get');
var IsArray = require('./IsArray');
var LengthOfArrayLike = require('./LengthOfArrayLike');
var ToString = require('./ToString');
var Type = require('./Type');

var defaultElementTypes = ['Undefined', 'Null', 'Boolean', 'String', 'Symbol', 'Number', 'BigInt', 'Object'];

// https://262.ecma-international.org/11.0/#sec-createlistfromarraylike

module.exports = function CreateListFromArrayLike(obj) {
	var elementTypes = arguments.length > 1
		? arguments[1]
		: defaultElementTypes;

	if (!isObject(obj)) {
		throw new $TypeError('Assertion failed: `obj` must be an Object');
	}
	if (!IsArray(elementTypes)) {
		throw new $TypeError('Assertion failed: `elementTypes`, if provided, must be an array');
	}
	var len = LengthOfArrayLike(obj);
	var list = [];
	var index = 0;
	while (index < len) {
		var indexName = ToString(index);
		var next = Get(obj, indexName);
		var nextType = Type(next);
		if ($indexOf(elementTypes, nextType) < 0) {
			throw new $TypeError('item type ' + nextType + ' is not a valid elementType');
		}
		list[list.length] = next;
		index += 1;
	}
	return list;
};
'use strict';

var $TypeError = require('es-errors/type');
var isObject = require('es-object-atoms/isObject');

var DefineOwnProperty = require('../helpers/DefineOwnProperty');

var FromPropertyDescriptor = require('./FromPropertyDescriptor');
var IsDataDescriptor = require('./IsDataDescriptor');
var isPropertyKey = require('../helpers/isPropertyKey');
var SameValue = require('./SameValue');

// https://262.ecma-international.org/6.0/#sec-createmethodproperty

module.exports = function CreateMethodProperty(O, P, V) {
	if (!isObject(O)) {
		throw new $TypeError('Assertion failed: Type(O) is not Object');
	}

	if (!isPropertyKey(P)) {
		throw new $TypeError('Assertion failed: P is not a Property Key');
	}

	var newDesc = {
		'[[Configurable]]': true,
		'[[Enumerable]]': false,
		'[[Value]]': V,
		'[[Writable]]': true
	};
	return DefineOwnProperty(
		IsDataDescriptor,
		SameValue,
		FromPropertyDescriptor,
		O,
		P,
		newDesc
	);
};
'use strict';

var $TypeError = require('es-errors/type');
var isObject = require('es-object-atoms/isObject');

var DefinePropertyOrThrow = require('./DefinePropertyOrThrow');

var isPropertyKey = require('../helpers/isPropertyKey');

// https://262.ecma-international.org/13.0/#sec-createnonenumerabledatapropertyorthrow

module.exports = function CreateNonEnumerableDataPropertyOrThrow(O, P, V) {
	if (!isObject(O)) {
		throw new $TypeError('Assertion failed: Type(O) is not Object');
	}

	if (!isPropertyKey(P)) {
		throw new $TypeError('Assertion failed: P is not a Property Key');
	}

	var newDesc = {
		'[[Configurable]]': true,
		'[[Enumerable]]': false,
		'[[Value]]': V,
		'[[Writable]]': true
	};
	return DefinePropertyOrThrow(O, P, newDesc);
};
'use strict';

var GetIntrinsic = require('get-intrinsic');
var hasSymbols = require('has-symbols')();

var $TypeError = require('es-errors/type');
var isObject = require('es-object-atoms/isObject');
var IteratorPrototype = GetIntrinsic('%IteratorPrototype%', true);

var AdvanceStringIndex = require('./AdvanceStringIndex');
var CreateIterResultObject = require('./CreateIterResultObject');
var CreateMethodProperty = require('./CreateMethodProperty');
var Get = require('./Get');
var OrdinaryObjectCreate = require('./OrdinaryObjectCreate');
var RegExpExec = require('./RegExpExec');
var Set = require('./Set');
var ToLength = require('./ToLength');
var ToString = require('./ToString');

var SLOT = require('internal-slot');
var setToStringTag = require('es-set-tostringtag');

var RegExpStringIterator = function RegExpStringIterator(R, S, global, fullUnicode) {
	if (typeof S !== 'string') {
		throw new $TypeError('`S` must be a string');
	}
	if (typeof global !== 'boolean') {
		throw new $TypeError('`global` must be a boolean');
	}
	if (typeof fullUnicode !== 'boolean') {
		throw new $TypeError('`fullUnicode` must be a boolean');
	}
	SLOT.set(this, '[[IteratingRegExp]]', R);
	SLOT.set(this, '[[IteratedString]]', S);
	SLOT.set(this, '[[Global]]', global);
	SLOT.set(this, '[[Unicode]]', fullUnicode);
	SLOT.set(this, '[[Done]]', false);
};

if (IteratorPrototype) {
	RegExpStringIterator.prototype = OrdinaryObjectCreate(IteratorPrototype);
}

var RegExpStringIteratorNext = function next() {
	var O = this; // eslint-disable-line no-invalid-this
	if (!isObject(O)) {
		throw new $TypeError('receiver must be an object');
	}
	if (
		!(O instanceof RegExpStringIterator)
		|| !SLOT.has(O, '[[IteratingRegExp]]')
		|| !SLOT.has(O, '[[IteratedString]]')
		|| !SLOT.has(O, '[[Global]]')
		|| !SLOT.has(O, '[[Unicode]]')
		|| !SLOT.has(O, '[[Done]]')
	) {
		throw new $TypeError('"this" value must be a RegExpStringIterator instance');
	}
	if (SLOT.get(O, '[[Done]]')) {
		return CreateIterResultObject(undefined, true);
	}
	var R = SLOT.get(O, '[[IteratingRegExp]]');
	var S = SLOT.get(O, '[[IteratedString]]');
	var global = SLOT.get(O, '[[Global]]');
	var fullUnicode = SLOT.get(O, '[[Unicode]]');
	var match = RegExpExec(R, S);
	if (match === null) {
		SLOT.set(O, '[[Done]]', true);
		return CreateIterResultObject(undefined, true);
	}
	if (global) {
		var matchStr = ToString(Get(match, '0'));
		if (matchStr === '') {
			var thisIndex = ToLength(Get(R, 'lastIndex'));
			var nextIndex = AdvanceStringIndex(S, thisIndex, fullUnicode);
			Set(R, 'lastIndex', nextIndex, true);
		}
		return CreateIterResultObject(match, false);
	}
	SLOT.set(O, '[[Done]]', true);
	return CreateIterResultObject(match, false);
};
CreateMethodProperty(RegExpStringIterator.prototype, 'next', RegExpStringIteratorNext);

if (hasSymbols) {
	setToStringTag(RegExpStringIterator.prototype, 'RegExp String Iterator');

	if (Symbol.iterator && typeof RegExpStringIterator.prototype[Symbol.iterator] !== 'function') {
		var iteratorFn = function SymbolIterator() {
			return this;
		};
		CreateMethodProperty(RegExpStringIterator.prototype, Symbol.iterator, iteratorFn);
	}
}

// https://262.ecma-international.org/11.0/#sec-createregexpstringiterator
module.exports = function CreateRegExpStringIterator(R, S, global, fullUnicode) {
	// assert R.global === global && R.unicode === fullUnicode?
	return new RegExpStringIterator(R, S, global, fullUnicode);
};
'use strict';

var $EvalError = require('es-errors/eval');

var DayWithinYear = require('./DayWithinYear');
var InLeapYear = require('./InLeapYear');
var MonthFromTime = require('./MonthFromTime');

// https://262.ecma-international.org/5.1/#sec-15.9.1.5

module.exports = function DateFromTime(t) {
	var m = MonthFromTime(t);
	var d = DayWithinYear(t);
	if (m === 0) {
		return d + 1;
	}
	if (m === 1) {
		return d - 30;
	}
	var leap = InLeapYear(t);
	if (m === 2) {
		return d - 58 - leap;
	}
	if (m === 3) {
		return d - 89 - leap;
	}
	if (m === 4) {
		return d - 119 - leap;
	}
	if (m === 5) {
		return d - 150 - leap;
	}
	if (m === 6) {
		return d - 180 - leap;
	}
	if (m === 7) {
		return d - 211 - leap;
	}
	if (m === 8) {
		return d - 242 - leap;
	}
	if (m === 9) {
		return d - 272 - leap;
	}
	if (m === 10) {
		return d - 303 - leap;
	}
	if (m === 11) {
		return d - 333 - leap;
	}
	throw new $EvalError('Assertion failed: MonthFromTime returned an impossible value: ' + m);
};
'use strict';

var $TypeError = require('es-errors/type');

var weekdays = ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'];
var months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];

var $isNaN = require('math-intrinsics/isNaN');
var padTimeComponent = require('../helpers/padTimeComponent');

var DateFromTime = require('./DateFromTime');
var MonthFromTime = require('./MonthFromTime');
var WeekDay = require('./WeekDay');
var YearFromTime = require('./YearFromTime');

// https://262.ecma-international.org/9.0/#sec-datestring

module.exports = function DateString(tv) {
	if (typeof tv !== 'number' || $isNaN(tv)) {
		throw new $TypeError('Assertion failed: `tv` must be a non-NaN Number');
	}
	var weekday = weekdays[WeekDay(tv)];
	var month = months[MonthFromTime(tv)];
	var day = padTimeComponent(DateFromTime(tv));
	var year = padTimeComponent(YearFromTime(tv), 4);
	return weekday + '\x20' + month + '\x20' + day + '\x20' + year;
};
'use strict';

var floor = require('./floor');

// https://262.ecma-international.org/5.1/#sec-15.9.1.3

module.exports = function DayFromYear(y) {
	return (365 * (y - 1970)) + floor((y - 1969) / 4) - floor((y - 1901) / 100) + floor((y - 1601) / 400);
};

'use strict';

var floor = require('./floor');

var msPerDay = require('../helpers/timeConstants').msPerDay;

// https://262.ecma-international.org/5.1/#sec-15.9.1.2

module.exports = function Day(t) {
	return floor(t / msPerDay);
};
'use strict';

var modulo = require('./modulo');

// https://262.ecma-international.org/5.1/#sec-15.9.1.3

module.exports = function DaysInYear(y) {
	if (modulo(y, 4) !== 0) {
		return 365;
	}
	if (modulo(y, 100) !== 0) {
		return 366;
	}
	if (modulo(y, 400) !== 0) {
		return 365;
	}
	return 366;
};
'use strict';

var Day = require('./Day');
var DayFromYear = require('./DayFromYear');
var YearFromTime = require('./YearFromTime');

// https://262.ecma-international.org/5.1/#sec-15.9.1.4

module.exports = function DayWithinYear(t) {
	return Day(t) - DayFromYear(YearFromTime(t));
};
'use strict';

var callBind = require('call-bind');

var I402 = typeof Intl === 'undefined' ? null : Intl;
var DateTimeFormat = I402 && I402.DateTimeFormat;
var resolvedOptions = DateTimeFormat && callBind(DateTimeFormat.prototype.resolvedOptions);

// https://262.ecma-international.org/14.0/#sec-defaulttimezone
// https://tc39.es/ecma402/2023/#sup-defaulttimezone

module.exports = function DefaultTimeZone() {
	if (DateTimeFormat && resolvedOptions) {
		return resolvedOptions(new DateTimeFormat()).timeZone;

	}
	return 'UTC';
};
'use strict';

var $TypeError = require('es-errors/type');
var isObject = require('es-object-atoms/isObject');

var DefinePropertyOrThrow = require('./DefinePropertyOrThrow');
var IsExtensible = require('./IsExtensible');

var isPropertyKey = require('../helpers/isPropertyKey');

// https://262.ecma-international.org/13.0/#sec-definemethodproperty

module.exports = function DefineMethodProperty(homeObject, key, closure, enumerable) {
	if (!isObject(homeObject)) {
		throw new $TypeError('Assertion failed: `homeObject` is not an Object');
	}
	if (!isPropertyKey(key)) {
		throw new $TypeError('Assertion failed: `key` is not a Property Key or a Private Name');
	}
	if (typeof closure !== 'function') {
		throw new $TypeError('Assertion failed: `closure` is not a function');
	}
	if (typeof enumerable !== 'boolean') {
		throw new $TypeError('Assertion failed: `enumerable` is not a Boolean');
	}

	// 1. Assert: homeObject is an ordinary, extensible object with no non-configurable properties.
	if (!IsExtensible(homeObject)) {
		throw new $TypeError('Assertion failed: `homeObject` is not an ordinary, extensible object, with no non-configurable properties');
	}

	// 2. If key is a Private Name, then
	//  a. Return PrivateElement { [[Key]]: key, [[Kind]]: method, [[Value]]: closure }.
	// 3. Else,
	var desc = { // step 3.a
		'[[Value]]': closure,
		'[[Writable]]': true,
		'[[Enumerable]]': enumerable,
		'[[Configurable]]': true
	};
	DefinePropertyOrThrow(homeObject, key, desc); // step 3.b
};
'use strict';

var $TypeError = require('es-errors/type');
var isObject = require('es-object-atoms/isObject');

var isPropertyDescriptor = require('../helpers/records/property-descriptor');
var DefineOwnProperty = require('../helpers/DefineOwnProperty');

var FromPropertyDescriptor = require('./FromPropertyDescriptor');
var IsDataDescriptor = require('./IsDataDescriptor');
var isPropertyKey = require('../helpers/isPropertyKey');
var SameValue = require('./SameValue');
var ToPropertyDescriptor = require('./ToPropertyDescriptor');

// https://262.ecma-international.org/6.0/#sec-definepropertyorthrow

module.exports = function DefinePropertyOrThrow(O, P, desc) {
	if (!isObject(O)) {
		throw new $TypeError('Assertion failed: Type(O) is not Object');
	}

	if (!isPropertyKey(P)) {
		throw new $TypeError('Assertion failed: P is not a Property Key');
	}

	var Desc = isPropertyDescriptor(desc) ? desc : ToPropertyDescriptor(desc);
	if (!isPropertyDescriptor(Desc)) {
		throw new $TypeError('Assertion failed: Desc is not a valid Property Descriptor');
	}

	return DefineOwnProperty(
		IsDataDescriptor,
		SameValue,
		FromPropertyDescriptor,
		O,
		P,
		Desc
	);
};
'use strict';

var $TypeError = require('es-errors/type');
var isObject = require('es-object-atoms/isObject');

var isPropertyKey = require('../helpers/isPropertyKey');

// https://262.ecma-international.org/6.0/#sec-deletepropertyorthrow

module.exports = function DeletePropertyOrThrow(O, P) {
	if (!isObject(O)) {
		throw new $TypeError('Assertion failed: Type(O) is not Object');
	}

	if (!isPropertyKey(P)) {
		throw new $TypeError('Assertion failed: P is not a Property Key');
	}

	// eslint-disable-next-line no-param-reassign
	var success = delete O[P];
	if (!success) {
		throw new $TypeError('Attempt to delete property failed.');
	}
	return success;
};
'use strict';

var $SyntaxError = require('es-errors/syntax');
var $TypeError = require('es-errors/type');

var IsDetachedBuffer = require('./IsDetachedBuffer');

var isArrayBuffer = require('is-array-buffer');
var isSharedArrayBuffer = require('is-shared-array-buffer');

var MessageChannel;
try {
	// eslint-disable-next-line global-require
	MessageChannel = require('worker_threads').MessageChannel;
} catch (e) { /**/ }

// https://262.ecma-international.org/9.0/#sec-detacharraybuffer

/* globals postMessage */

module.exports = function DetachArrayBuffer(arrayBuffer) {
	if (!isArrayBuffer(arrayBuffer) || isSharedArrayBuffer(arrayBuffer)) {
		throw new $TypeError('Assertion failed: `arrayBuffer` must be an Object with an [[ArrayBufferData]] internal slot, and not a Shared Array Buffer');
	}

	// commented out since there's no way to set or access this key
	// var key = arguments.length > 1 ? arguments[1] : void undefined;

	// if (!SameValue(arrayBuffer[[ArrayBufferDetachKey]], key)) {
	// 	throw new $TypeError('Assertion failed: `key` must be the value of the [[ArrayBufferDetachKey]] internal slot of `arrayBuffer`');
	// }

	if (!IsDetachedBuffer(arrayBuffer)) { // node v21.0.0+ throws when you structuredClone a detached buffer
		if (typeof structuredClone === 'function') {
			structuredClone(arrayBuffer, { transfer: [arrayBuffer] });
		} else if (typeof postMessage === 'function') {
			postMessage('', '/', [arrayBuffer]); // TODO: see if this might trigger listeners
		} else if (MessageChannel) {
			(new MessageChannel()).port1.postMessage(null, [arrayBuffer]);
		} else {
			throw new $SyntaxError('DetachArrayBuffer is not supported in this environment');
		}
	}

	return null;
};
'use strict';

var $TypeError = require('es-errors/type');
var isObject = require('es-object-atoms/isObject');
var objectKeys = require('object-keys');
var safePushApply = require('safe-push-apply');
var callBound = require('call-bound');

var $isEnumerable = callBound('Object.prototype.propertyIsEnumerable');

var forEach = require('../helpers/forEach');

// https://262.ecma-international.org/14.0/#sec-enumerableownproperties

module.exports = function EnumerableOwnProperties(O, kind) {
	if (!isObject(O)) {
		throw new $TypeError('Assertion failed: Type(O) is not Object');
	}

	var keys = objectKeys(O);
	if (kind === 'key') {
		return keys;
	}
	if (kind === 'value' || kind === 'key+value') {
		var results = [];
		forEach(keys, function (key) {
			if ($isEnumerable(O, key)) {
				safePushApply(results, [
					kind === 'value' ? O[key] : [key, O[key]]
				]);
			}
		});
		return results;
	}
	throw new $TypeError('Assertion failed: "kind" is not "key", "value", or "key+value": ' + kind);
};
'use strict';

var $TypeError = require('es-errors/type');
var isInteger = require('math-intrinsics/isInteger');
var isObject = require('es-object-atoms/isObject');

var Call = require('./Call');
var Get = require('./Get');
var ToBoolean = require('./ToBoolean');
var IsCallable = require('./IsCallable');
var ToString = require('./ToString');

// https://262.ecma-international.org/14.0/#sec-findviapredicate

module.exports = function FindViaPredicate(O, len, direction, predicate, thisArg) {
	if (!isObject(O)) {
		throw new $TypeError('Assertion failed: Type(O) is not Object');
	}
	if (!isInteger(len) || len < 0) {
		throw new $TypeError('Assertion failed: len must be a non-negative integer');
	}
	if (direction !== 'ascending' && direction !== 'descending') {
		throw new $TypeError('Assertion failed: direction must be "ascending" or "descending"');
	}

	if (!IsCallable(predicate)) {
		throw new $TypeError('predicate must be callable'); // step 1
	}

	for ( // steps 2-4
		var k = direction === 'ascending' ? 0 : len - 1;
		direction === 'ascending' ? k < len : k >= 0;
		k += 1
	) {
		var Pk = ToString(k); // step 4.a
		var kValue = Get(O, Pk); // step 4.c
		var testResult = Call(predicate, thisArg, [kValue, k, O]); // step 4.d
		if (ToBoolean(testResult)) {
			return { '[[Index]]': k, '[[Value]]': kValue }; // step 4.e
		}
	}
	return { '[[Index]]': -1, '[[Value]]': void undefined }; // step 5
};
'use strict';

var $TypeError = require('es-errors/type');

var MAX_SAFE_INTEGER = require('math-intrinsics/constants/maxSafeInteger');

var Call = require('./Call');
var CreateDataPropertyOrThrow = require('./CreateDataPropertyOrThrow');
var Get = require('./Get');
var HasProperty = require('./HasProperty');
var IsArray = require('./IsArray');
var LengthOfArrayLike = require('./LengthOfArrayLike');
var ToString = require('./ToString');

// https://262.ecma-international.org/11.0/#sec-flattenintoarray

module.exports = function FlattenIntoArray(target, source, sourceLen, start, depth) {
	var mapperFunction;
	if (arguments.length > 5) {
		mapperFunction = arguments[5];
	}

	var targetIndex = start;
	var sourceIndex = 0;
	while (sourceIndex < sourceLen) {
		var P = ToString(sourceIndex);
		var exists = HasProperty(source, P);
		if (exists === true) {
			var element = Get(source, P);
			if (typeof mapperFunction !== 'undefined') {
				if (arguments.length <= 6) {
					throw new $TypeError('Assertion failed: thisArg is required when mapperFunction is provided');
				}
				element = Call(mapperFunction, arguments[6], [element, sourceIndex, source]);
			}
			var shouldFlatten = false;
			if (depth > 0) {
				shouldFlatten = IsArray(element);
			}
			if (shouldFlatten) {
				var elementLen = LengthOfArrayLike(element);
				targetIndex = FlattenIntoArray(target, element, elementLen, targetIndex, depth - 1);
			} else {
				if (targetIndex >= MAX_SAFE_INTEGER) {
					throw new $TypeError('index too large');
				}
				CreateDataPropertyOrThrow(target, ToString(targetIndex), element);
				targetIndex += 1;
			}
		}
		sourceIndex += 1;
	}

	return targetIndex;
};
'use strict';

// var modulo = require('./modulo');
var $floor = require('math-intrinsics/floor');

// http://262.ecma-international.org/11.0/#eqn-floor

module.exports = function floor(x) {
	// return x - modulo(x, 1);
	if (typeof x === 'bigint') {
		return x;
	}
	return $floor(x);
};
'use strict';

var $TypeError = require('es-errors/type');

var isPropertyDescriptor = require('../helpers/records/property-descriptor');
var fromPropertyDescriptor = require('../helpers/fromPropertyDescriptor');

// https://262.ecma-international.org/6.0/#sec-frompropertydescriptor

module.exports = function FromPropertyDescriptor(Desc) {
	if (typeof Desc !== 'undefined' && !isPropertyDescriptor(Desc)) {
		throw new $TypeError('Assertion failed: `Desc` must be a Property Descriptor');
	}

	return fromPropertyDescriptor(Desc);
};
'use strict';

var getGlobal = require('globalthis/polyfill');

// https://262.ecma-international.org/6.0/#sec-getglobalobject

module.exports = function GetGlobalObject() {
	return getGlobal();
};
'use strict';

var $TypeError = require('es-errors/type');
var isObject = require('es-object-atoms/isObject');

var Call = require('./Call');
var GetV = require('./GetV');
var IsCallable = require('./IsCallable');

// https://262.ecma-international.org/14.0/#sec-getiteratorfrommethod

module.exports = function GetIteratorFromMethod(obj, method) {
	if (!IsCallable(method)) {
		throw new $TypeError('method must be a function');
	}

	var iterator = Call(method, obj); // step 1
	if (!isObject(iterator)) {
		throw new $TypeError('iterator must return an object'); // step 2
	}

	var nextMethod = GetV(iterator, 'next'); // step 3
	return { // steps 4-5
		'[[Iterator]]': iterator,
		'[[NextMethod]]': nextMethod,
		'[[Done]]': false
	};
};
'use strict';

var GetIntrinsic = require('get-intrinsic');

var $TypeError = require('es-errors/type');
var $asyncIterator = GetIntrinsic('%Symbol.asyncIterator%', true);

var inspect = require('object-inspect');
var hasSymbols = require('has-symbols')();

var AdvanceStringIndex = require('./AdvanceStringIndex');
var CreateAsyncFromSyncIterator = require('./CreateAsyncFromSyncIterator');
var GetIteratorFromMethod = require('./GetIteratorFromMethod');
var GetMethod = require('./GetMethod');

var getIteratorMethod = require('../helpers/getIteratorMethod');

var ES = {
	AdvanceStringIndex: AdvanceStringIndex,
	GetMethod: GetMethod
};

// https://262.ecma-international.org/14.0/#sec-getiterator

module.exports = function GetIterator(obj, kind) {
	if (kind !== 'sync' && kind !== 'async') {
		throw new $TypeError("Assertion failed: `kind` must be one of 'sync' or 'async', got " + inspect(kind));
	}

	var method;
	if (kind === 'async') { // step 1
		if (hasSymbols && $asyncIterator) {
			method = GetMethod(obj, $asyncIterator); // step 1.a
		}
	}
	if (typeof method === 'undefined') { // step 1.b
		// var syncMethod = GetMethod(obj, $iterator); // step 1.b.i
		var syncMethod = getIteratorMethod(ES, obj);
		if (kind === 'async') {
			if (typeof syncMethod === 'undefined') {
				throw new $TypeError('iterator method is `undefined`'); // step 1.b.ii
			}
			var syncIteratorRecord = GetIteratorFromMethod(obj, syncMethod); // step 1.b.iii
			return CreateAsyncFromSyncIterator(syncIteratorRecord); // step 1.b.iv
		}
		method = syncMethod; // step 2, kind of
	}

	if (typeof method === 'undefined') {
		throw new $TypeError('iterator method is `undefined`'); // step 3
	}
	return GetIteratorFromMethod(obj, method); // step 4
};
'use strict';

var $TypeError = require('es-errors/type');

var inspect = require('object-inspect');

var isPropertyKey = require('../helpers/isPropertyKey');

var isObject = require('es-object-atoms/isObject');

// https://262.ecma-international.org/6.0/#sec-get-o-p

module.exports = function Get(O, P) {
	// 7.3.1.1
	if (!isObject(O)) {
		throw new $TypeError('Assertion failed: Type(O) is not Object');
	}
	// 7.3.1.2
	if (!isPropertyKey(P)) {
		throw new $TypeError('Assertion failed: P is not a Property Key, got ' + inspect(P));
	}
	// 7.3.1.3
	return O[P];
};
'use strict';

var $TypeError = require('es-errors/type');

var isMatchRecord = require('../helpers/records/match-record');

// https://262.ecma-international.org/13.0/#sec-getmatchindexpair

module.exports = function GetMatchIndexPair(S, match) {
	if (typeof S !== 'string') {
		throw new $TypeError('Assertion failed: `S` must be a String');
	}
	if (!isMatchRecord(match)) {
		throw new $TypeError('Assertion failed: `match` must be a Match Record');
	}

	if (!(match['[[StartIndex]]'] <= S.length)) {
		throw new $TypeError('`match` [[StartIndex]] must be a non-negative integer <= the length of S');
	}
	if (!(match['[[EndIndex]]'] <= S.length)) {
		throw new $TypeError('`match` [[EndIndex]] must be an integer between [[StartIndex]] and the length of S, inclusive');
	}
	return [match['[[StartIndex]]'], match['[[EndIndex]]']];
};
'use strict';

var $TypeError = require('es-errors/type');

var substring = require('./substring');

var isMatchRecord = require('../helpers/records/match-record');

// https://262.ecma-international.org/13.0/#sec-getmatchstring

module.exports = function GetMatchString(S, match) {
	if (typeof S !== 'string') {
		throw new $TypeError('Assertion failed: `S` must be a String');
	}
	if (!isMatchRecord(match)) {
		throw new $TypeError('Assertion failed: `match` must be a Match Record');
	}

	if (!(match['[[StartIndex]]'] <= S.length)) {
		throw new $TypeError('`match` [[StartIndex]] must be a non-negative integer <= the length of S');
	}
	if (!(match['[[EndIndex]]'] <= S.length)) {
		throw new $TypeError('`match` [[EndIndex]] must be an integer between [[StartIndex]] and the length of S, inclusive');
	}
	return substring(S, match['[[StartIndex]]'], match['[[EndIndex]]']);
};
'use strict';

var $TypeError = require('es-errors/type');

var GetV = require('./GetV');
var IsCallable = require('./IsCallable');
var isPropertyKey = require('../helpers/isPropertyKey');

var inspect = require('object-inspect');

// https://262.ecma-international.org/6.0/#sec-getmethod

module.exports = function GetMethod(O, P) {
	// 7.3.9.1
	if (!isPropertyKey(P)) {
		throw new $TypeError('Assertion failed: P is not a Property Key');
	}

	// 7.3.9.2
	var func = GetV(O, P);

	// 7.3.9.4
	if (func == null) {
		return void 0;
	}

	// 7.3.9.5
	if (!IsCallable(func)) {
		throw new $TypeError(inspect(P) + ' is not a function: ' + inspect(func));
	}

	// 7.3.9.6
	return func;
};
'use strict';

var $TypeError = require('es-errors/type');

var GetUTCEpochNanoseconds = require('./GetUTCEpochNanoseconds');

var isInteger = require('math-intrinsics/isInteger');

// https://262.ecma-international.org/14.0/#sec-getnamedtimezoneepochnanoseconds

// eslint-disable-next-line max-params
module.exports = function GetNamedTimeZoneEpochNanoseconds(
	timeZoneIdentifier,
	year,
	month,
	day,
	hour,
	minute,
	second,
	millisecond,
	microsecond,
	nanosecond
) {
	if (typeof timeZoneIdentifier !== 'string') {
		throw new $TypeError('Assertion failed: `timeZoneIdentifier` must be a string');
	}
	if (!isInteger(year)) {
		throw new $TypeError('Assertion failed: `year` must be an integral number');
	}
	if (!isInteger(month) || month < 1 || month > 12) {
		throw new $TypeError('Assertion failed: `month` must be an integral number between 1 and 12, inclusive');
	}
	if (!isInteger(day) || day < 1 || day > 31) {
		throw new $TypeError('Assertion failed: `day` must be an integral number between 1 and 31, inclusive');
	}
	if (!isInteger(hour) || hour < 0 || hour > 23) {
		throw new $TypeError('Assertion failed: `hour` must be an integral number between 0 and 23, inclusive');
	}
	if (!isInteger(minute) || minute < 0 || minute > 59) {
		throw new $TypeError('Assertion failed: `minute` must be an integral number between 0 and 59, inclusive');
	}
	if (!isInteger(second) || second < 0 || second > 999) {
		throw new $TypeError('Assertion failed: `second` must be an integral number between 0 and 999, inclusive');
	}
	if (!isInteger(millisecond) || millisecond < 0 || millisecond > 999) {
		throw new $TypeError('Assertion failed: `millisecond` must be an integral number between 0 and 999, inclusive');
	}
	if (!isInteger(microsecond) || microsecond < 0 || microsecond > 999) {
		throw new $TypeError('Assertion failed: `microsecond` must be an integral number between 0 and 999, inclusive');
	}
	if (!isInteger(nanosecond) || nanosecond < 0 || nanosecond > 999) {
		throw new $TypeError('Assertion failed: `nanosecond` must be an integral number between 0 and 999, inclusive');
	}

	if (timeZoneIdentifier !== 'UTC') {
		throw new $TypeError('Assertion failed: only UTC time zone is supported'); // step 1
	}

	var epochNanoseconds = GetUTCEpochNanoseconds(
		year,
		month,
		day,
		hour,
		minute,
		second,
		millisecond,
		microsecond,
		nanosecond
	); // step 2

	return [epochNanoseconds]; // step 3
};
'use strict';

var GetIntrinsic = require('get-intrinsic');

var hasSymbols = require('has-symbols')();

var $TypeError = require('es-errors/type');
var isObject = require('es-object-atoms/isObject');

var $gOPN = GetIntrinsic('%Object.getOwnPropertyNames%', true);
var $gOPS = hasSymbols && GetIntrinsic('%Object.getOwnPropertySymbols%', true);
var keys = require('object-keys');

// https://262.ecma-international.org/6.0/#sec-getownpropertykeys

module.exports = function GetOwnPropertyKeys(O, Type) {
	if (!isObject(O)) {
		throw new $TypeError('Assertion failed: Type(O) is not Object');
	}
	if (Type === 'Symbol') {
		return $gOPS ? $gOPS(O) : [];
	}
	if (Type === 'String') {
		if (!$gOPN) {
			return keys(O);
		}
		return $gOPN(O);
	}
	throw new $TypeError('Assertion failed: `Type` must be `"String"` or `"Symbol"`');
};
'use strict';

var $TypeError = require('es-errors/type');

var Get = require('./Get');
var IsCallable = require('./IsCallable');
var IsConstructor = require('./IsConstructor');

// https://262.ecma-international.org/12.0/#sec-getpromiseresolve

module.exports = function GetPromiseResolve(promiseConstructor) {
	if (!IsConstructor(promiseConstructor)) {
		throw new $TypeError('Assertion failed: `promiseConstructor` must be a constructor');
	}
	var promiseResolve = Get(promiseConstructor, 'resolve');
	if (IsCallable(promiseResolve) === false) {
		throw new $TypeError('`resolve` method is not callable');
	}
	return promiseResolve;
};
'use strict';

var GetIntrinsic = require('get-intrinsic');

var $Function = GetIntrinsic('%Function%');
var $TypeError = require('es-errors/type');
var $SyntaxError = require('es-errors/syntax');

var Get = require('./Get');
var IsConstructor = require('./IsConstructor');

var isObject = require('es-object-atoms/isObject');

// https://262.ecma-international.org/6.0/#sec-getprototypefromconstructor

module.exports = function GetPrototypeFromConstructor(constructor, intrinsicDefaultProto) {
	var intrinsic = GetIntrinsic(intrinsicDefaultProto); // throws if not a valid intrinsic
	if (!isObject(intrinsic)) {
		throw new $TypeError('intrinsicDefaultProto must be an object');
	}
	if (!IsConstructor(constructor)) {
		throw new $TypeError('Assertion failed: `constructor` must be a constructor');
	}
	var proto = Get(constructor, 'prototype');
	if (!isObject(proto)) {
		if (!(constructor instanceof $Function)) {
			// ignore other realms, for now
			throw new $SyntaxError('cross-realm constructors not currently supported');
		}
		proto = intrinsic;
	}
	return proto;
};
'use strict';

var callBound = require('call-bound');
var $TypeError = require('es-errors/type');
var isInteger = require('math-intrinsics/isInteger');

var StringToCodePoints = require('./StringToCodePoints');

var $indexOf = callBound('String.prototype.indexOf');

// https://262.ecma-international.org/13.0/#sec-getstringindex

module.exports = function GetStringIndex(S, e) {
	if (typeof S !== 'string') {
		throw new $TypeError('Assertion failed: `S` must be a String');
	}
	if (!isInteger(e) || e < 0) {
		throw new $TypeError('Assertion failed: `e` must be a non-negative integer');
	}

	if (S === '') {
		return 0;
	}
	var codepoints = StringToCodePoints(S);
	var eUTF = e >= codepoints.length ? S.length : $indexOf(S, codepoints[e]);
	return eUTF;
};
'use strict';

var $TypeError = require('es-errors/type');
var isObject = require('es-object-atoms/isObject');
var inspect = require('object-inspect');
var isInteger = require('math-intrinsics/isInteger');
var regexTester = require('safe-regex-test');

var Get = require('./Get');
var IsArray = require('./IsArray');
var min = require('./min');
var StringIndexOf = require('./StringIndexOf');
var StringToNumber = require('./StringToNumber');
var substring = require('./substring');
var ToString = require('./ToString');

var every = require('../helpers/every');
var isPrefixOf = require('../helpers/isPrefixOf');
var isStringOrUndefined = require('../helpers/isStringOrUndefined');

var startsWithDollarDigit = regexTester(/^\$[0-9]/);
var startsWithDollarTwoDigit = regexTester(/^\$[0-9][0-9]/);

// http://www.ecma-international.org/ecma-262/14.0/#sec-getsubstitution

// eslint-disable-next-line max-statements, max-params, max-lines-per-function
module.exports = function GetSubstitution(matched, str, position, captures, namedCaptures, replacementTemplate) {
	if (typeof matched !== 'string') {
		throw new $TypeError('Assertion failed: `matched` must be a String');
	}

	if (typeof str !== 'string') {
		throw new $TypeError('Assertion failed: `str` must be a String');
	}

	if (!isInteger(position) || position < 0) {
		throw new $TypeError('Assertion failed: `position` must be a nonnegative integer, got ' + inspect(position));
	}

	if (!IsArray(captures) || !every(captures, isStringOrUndefined)) {
		throw new $TypeError('Assertion failed: `captures` must be a possibly-empty List of Strings or `undefined`, got ' + inspect(captures));
	}

	if (typeof namedCaptures !== 'undefined' && !isObject(namedCaptures)) {
		throw new $TypeError('Assertion failed: `namedCaptures` must be `undefined` or an Object');
	}

	if (typeof replacementTemplate !== 'string') {
		throw new $TypeError('Assertion failed: `replacementTemplate` must be a String');
	}

	var stringLength = str.length; // step 1

	if (position > stringLength) {
		throw new $TypeError('Assertion failed: position > stringLength, got ' + inspect(position)); // step 2
	}

	var templateRemainder = replacementTemplate; // step 3

	var result = ''; // step 4

	while (templateRemainder !== '') { // step 5
		// 5.a NOTE: The following steps isolate ref (a prefix of templateRemainder), determine refReplacement (its replacement), and then append that replacement to result.

		var ref, refReplacement, capture;
		if (isPrefixOf('$$', templateRemainder)) { // step 5.b
			ref = '$$'; // step 5.b.i
			refReplacement = '$'; // step 5.b.ii
		} else if (isPrefixOf('$`', templateRemainder)) { // step 5.c
			ref = '$`'; // step 5.c.i
			refReplacement = substring(str, 0, position); // step 5.c.ii
		} else if (isPrefixOf('$&', templateRemainder)) { // step 5.d
			ref = '$&'; // step 5.d.i
			refReplacement = matched; // step 5.d.ii
		} else if (isPrefixOf('$\'', templateRemainder)) { // step 5.e
			ref = '$\''; // step 5.e.i
			var matchLength = matched.length; // step 5.e.ii
			var tailPos = position + matchLength; // step 5.e.iii
			refReplacement = substring(str, min(tailPos, stringLength)); // step 5.e.iv
			// 5.e.v NOTE: tailPos can exceed stringLength only if this abstract operation was invoked by a call to the intrinsic @@replace method of %RegExp.prototype% on an object whose "exec" property is not the intrinsic %RegExp.prototype.exec%.
		} else if (startsWithDollarDigit(templateRemainder)) { // step 5.f
			var digitCount = startsWithDollarTwoDigit(templateRemainder) ? 2 : 1; // step 5.f.i

			ref = substring(templateRemainder, 0, 1 + digitCount); // step 5.f.ii

			var digits = substring(templateRemainder, 1, 1 + digitCount); // step 5.f.iii

			var index = StringToNumber(digits); // step 5.f.iv

			if (index < 0 || index > 99) {
				throw new $TypeError('Assertion failed: `index` must be >= 0 and <= 99'); // step 5.f.v
			}

			var captureLen = captures.length; // step 5.f.vi

			if (1 <= index && index <= captureLen) { // step 5.f.vii
				capture = captures[index - 1]; // step 5.f.vii.1

				if (typeof capture === 'undefined') { // step 5.f.vii.2
					refReplacement = ''; // step 5.f.vii.2.a
				} else { // step 5.f.vii.3
					refReplacement = capture; // step 5.f.vii.3.a
				}
			} else { // step 5.f.viii
				refReplacement = ref; // step 5.f.viii.1
			}
		} else if (isPrefixOf('$<', templateRemainder)) { // step 5.g
			var gtPos = StringIndexOf(templateRemainder, '>', 0); // step 5.g.i
			if (gtPos === -1 || typeof namedCaptures === 'undefined') { // step 5.g.ii
				ref = '$<'; // step 5.g.ii.1
				refReplacement = ref; // step 5.g.ii.2
			} else { // step 5.g.iii
				ref = substring(templateRemainder, 0, gtPos + 1); // step 5.g.iii.1
				var groupName = substring(templateRemainder, 2, gtPos); // step 5.g.iii.2
				if (!isObject(namedCaptures)) {
					throw new $TypeError('Assertion failed: Type(namedCaptures) is not Object'); // step 5.g.iii.3
				}
				capture = Get(namedCaptures, groupName); // step 5.g.iii.4
				if (typeof capture === 'undefined') { // step 5.g.iii.5
					refReplacement = ''; // step 5.g.iii.5.a
				} else { // step 5.g.iii.6
					refReplacement = ToString(capture); // step 5.g.iii.6.a
				}
			}
		} else { // step 5.h
			ref = substring(templateRemainder, 0, 1); // step 5.h.i
			refReplacement = ref; // step 5.h.ii
		}

		var refLength = ref.length; // step 5.i

		templateRemainder = substring(templateRemainder, refLength); // step 5.j

		result += refReplacement; // step 5.k
	}

	return result; // step 6
};
'use strict';

var GetIntrinsic = require('get-intrinsic');

var MakeDay = require('./MakeDay');
var MakeTime = require('./MakeTime');
var MakeDate = require('./MakeDate');

var isInteger = require('math-intrinsics/isInteger');

var $BigInt = GetIntrinsic('%BigInt%', true);
var $SyntaxError = GetIntrinsic('%SyntaxError%');
var $TypeError = GetIntrinsic('%TypeError%');

// https://tc39.es/ecma262/#sec-getutcepochnanoseconds

// eslint-disable-next-line max-params
module.exports = function GetUTCEpochNanoseconds(
	year,
	month,
	day,
	hour,
	minute,
	second,
	millisecond,
	microsecond,
	nanosecond
) {
	if (!isInteger(year)) {
		throw new $TypeError('Assertion failed: `year` must be an integral Number');
	}
	if (!isInteger(month) || month < 1 || month > 12) {
		throw new $TypeError('Assertion failed: `month` must be an integral Number between 1 and 12, inclusive');
	}
	if (!isInteger(day) || day < 1 || day > 31) {
		throw new $TypeError('Assertion failed: `day` must be an integral Number between 1 and 31, inclusive');
	}
	if (!isInteger(hour) || hour < 0 || hour > 23) {
		throw new $TypeError('Assertion failed: `hour` must be an integral Number between 0 and 23, inclusive');
	}
	if (!isInteger(minute) || minute < 0 || minute > 59) {
		throw new $TypeError('Assertion failed: `minute` must be an integral Number between 0 and 59, inclusive');
	}
	if (!isInteger(second) || second < 0 || second > 59) {
		throw new $TypeError('Assertion failed: `second` must be an integral Number between 0 and 59, inclusive');
	}
	if (!isInteger(millisecond) || millisecond < 0 || millisecond > 999) {
		throw new $TypeError('Assertion failed: `millisecond` must be an integral Number between 0 and 999, inclusive');
	}
	if (!isInteger(microsecond) || microsecond < 0 || microsecond > 999) {
		throw new $TypeError('Assertion failed: `microsecond` must be an integral Number between 0 and 999, inclusive');
	}
	if (!isInteger(nanosecond) || nanosecond < 0 || nanosecond > 999) {
		throw new $TypeError('Assertion failed: `nanosecond` must be an integral Number between 0 and 999, inclusive');
	}

	var date = MakeDay(year, month - 1, day); // step 1
	var time = MakeTime(hour, minute, second, millisecond); // step 2
	var ms = MakeDate(date, time); // step 3
	if (!isInteger(ms)) {
		throw new $TypeError('Assertion failed: `ms` from MakeDate is not an integral Number'); // step 4
	}

	if (!$BigInt) {
		throw new $SyntaxError('BigInts are not supported in this environment');
	}
	return $BigInt((ms * 1e6) + (microsecond * 1e3) + nanosecond); // step 5
};
'use strict';

var GetIntrinsic = require('get-intrinsic');

var $SyntaxError = require('es-errors/syntax');
var $TypeError = require('es-errors/type');
var $Uint8Array = GetIntrinsic('%Uint8Array%', true);
var isInteger = require('math-intrinsics/isInteger');

var callBound = require('call-bound');

var $slice = callBound('Array.prototype.slice');

var IsDetachedBuffer = require('./IsDetachedBuffer');
var RawBytesToNumeric = require('./RawBytesToNumeric');

var isArrayBuffer = require('is-array-buffer');
var isSharedArrayBuffer = require('is-shared-array-buffer');
var safeConcat = require('safe-array-concat');

var tableTAO = require('./tables/typed-array-objects');

var defaultEndianness = require('../helpers/defaultEndianness');

// https://262.ecma-international.org/11.0/#sec-getvaluefrombuffer

module.exports = function GetValueFromBuffer(arrayBuffer, byteIndex, type, isTypedArray, order) {
	var isSAB = isSharedArrayBuffer(arrayBuffer);
	if (!isArrayBuffer(arrayBuffer) && !isSAB) {
		throw new $TypeError('Assertion failed: `arrayBuffer` must be an ArrayBuffer or a SharedArrayBuffer');
	}

	if (!isInteger(byteIndex)) {
		throw new $TypeError('Assertion failed: `byteIndex` must be an integer');
	}

	if (typeof type !== 'string' || typeof tableTAO.size['$' + type] !== 'number') {
		throw new $TypeError('Assertion failed: `type` must be one of ' + tableTAO.choices);
	}

	if (typeof isTypedArray !== 'boolean') {
		throw new $TypeError('Assertion failed: `isTypedArray` must be a boolean');
	}

	if (order !== 'SeqCst' && order !== 'Unordered') {
		throw new $TypeError('Assertion failed: `order` must be either `SeqCst` or `Unordered`');
	}

	if (arguments.length > 5 && typeof arguments[5] !== 'boolean') {
		throw new $TypeError('Assertion failed: `isLittleEndian` must be a boolean, if present');
	}

	if (IsDetachedBuffer(arrayBuffer)) {
		throw new $TypeError('Assertion failed: `arrayBuffer` is detached'); // step 1
	}

	// 2. Assert: There are sufficient bytes in arrayBuffer starting at byteIndex to represent a value of type.

	if (byteIndex < 0) {
		throw new $TypeError('Assertion failed: `byteIndex` must be non-negative'); // step 3
	}

	// 4. Let block be arrayBuffer.[[ArrayBufferData]].

	var elementSize = tableTAO.size['$' + type]; // step 5
	if (!elementSize) {
		throw new $TypeError('Assertion failed: `type` must be one of ' + tableTAO.choices);
	}

	var rawValue;
	if (isSAB) { // step 6
		/*
		a. Let execution be the [[CandidateExecution]] field of the surrounding agent's Agent Record.
		b. Let eventList be the [[EventList]] field of the element in execution.[[EventLists]] whose [[AgentSignifier]] is AgentSignifier().
		c. If isTypedArray is true and type is "Int8", "Uint8", "Int16", "Uint16", "Int32", or "Uint32", let noTear be true; otherwise let noTear be false.
		d. Let rawValue be a List of length elementSize of nondeterministically chosen byte values.
		e. NOTE: In implementations, rawValue is the result of a non-atomic or atomic read instruction on the underlying hardware. The nondeterminism is a semantic prescription of the memory model to describe observable behaviour of hardware with weak consistency.
		f. Let readEvent be ReadSharedMemory{ [[Order]]: order, [[NoTear]]: noTear, [[Block]]: block, [[ByteIndex]]: byteIndex, [[ElementSize]]: elementSize }.
		g. Append readEvent to eventList.
		h. Append Chosen Value Record { [[Event]]: readEvent, [[ChosenValue]]: rawValue } to execution.[[ChosenValues]].
		*/
		throw new $SyntaxError('SharedArrayBuffer is not supported by this implementation');
	} else {
		// 7. Let rawValue be a List of elementSize containing, in order, the elementSize sequence of bytes starting with block[byteIndex].
		rawValue = $slice(new $Uint8Array(arrayBuffer, byteIndex), 0, elementSize); // step 6
	}

	// 8. If isLittleEndian is not present, set isLittleEndian to either true or false. The choice is implementation dependent and should be the alternative that is most efficient for the implementation. An implementation must use the same value each time this step is executed and the same value must be used for the corresponding step in the SetValueInBuffer abstract operation.
	var isLittleEndian = arguments.length > 5 ? arguments[5] : defaultEndianness === 'little'; // step 8

	var bytes = isLittleEndian
		? $slice(safeConcat([0, 0, 0, 0, 0, 0, 0, 0], rawValue), -elementSize)
		: $slice(safeConcat(rawValue, [0, 0, 0, 0, 0, 0, 0, 0]), 0, elementSize);

	return RawBytesToNumeric(type, bytes, isLittleEndian);
};
'use strict';

var $TypeError = require('es-errors/type');

var inspect = require('object-inspect');

var isPropertyKey = require('../helpers/isPropertyKey');
// var ToObject = require('./ToObject');

// https://262.ecma-international.org/6.0/#sec-getv

module.exports = function GetV(V, P) {
	// 7.3.2.1
	if (!isPropertyKey(P)) {
		throw new $TypeError('Assertion failed: P is not a Property Key, got ' + inspect(P));
	}

	// 7.3.2.2-3
	// var O = ToObject(V);

	// 7.3.2.4
	return V[P];
};
'use strict';

var $TypeError = require('es-errors/type');

var hasOwn = require('hasown');
var isObject = require('es-object-atoms/isObject');

var isPropertyKey = require('../helpers/isPropertyKey');

// https://262.ecma-international.org/6.0/#sec-hasownproperty

module.exports = function HasOwnProperty(O, P) {
	if (!isObject(O)) {
		throw new $TypeError('Assertion failed: `O` must be an Object');
	}
	if (!isPropertyKey(P)) {
		throw new $TypeError('Assertion failed: `P` must be a Property Key');
	}
	return hasOwn(O, P);
};
'use strict';

var $TypeError = require('es-errors/type');
var isObject = require('es-object-atoms/isObject');

var isPropertyKey = require('../helpers/isPropertyKey');

// https://262.ecma-international.org/6.0/#sec-hasproperty

module.exports = function HasProperty(O, P) {
	if (!isObject(O)) {
		throw new $TypeError('Assertion failed: `O` must be an Object');
	}
	if (!isPropertyKey(P)) {
		throw new $TypeError('Assertion failed: `P` must be a Property Key');
	}
	return P in O;
};
'use strict';

var floor = require('./floor');
var modulo = require('./modulo');

var timeConstants = require('../helpers/timeConstants');
var msPerHour = timeConstants.msPerHour;
var HoursPerDay = timeConstants.HoursPerDay;

// https://262.ecma-international.org/5.1/#sec-15.9.1.10

module.exports = function HourFromTime(t) {
	return modulo(floor(t / msPerHour), HoursPerDay);
};
'use strict';

var $EvalError = require('es-errors/eval');

var DaysInYear = require('./DaysInYear');
var YearFromTime = require('./YearFromTime');

// https://262.ecma-international.org/5.1/#sec-15.9.1.3

module.exports = function InLeapYear(t) {
	var days = DaysInYear(YearFromTime(t));
	if (days === 365) {
		return 0;
	}
	if (days === 366) {
		return 1;
	}
	throw new $EvalError('Assertion failed: there are not 365 or 366 days in a year, got: ' + days);
};
'use strict';

var $TypeError = require('es-errors/type');
var isObject = require('es-object-atoms/isObject');

var CreateNonEnumerableDataPropertyOrThrow = require('./CreateNonEnumerableDataPropertyOrThrow');
var Get = require('./Get');
var HasProperty = require('./HasProperty');

// https://262.ecma-international.org/13.0/#sec-installerrorcause

module.exports = function InstallErrorCause(O, options) {
	if (!isObject(O)) {
		throw new $TypeError('Assertion failed: Type(O) is not Object');
	}

	if (isObject(options) && HasProperty(options, 'cause')) {
		var cause = Get(options, 'cause');
		CreateNonEnumerableDataPropertyOrThrow(O, 'cause', cause);
	}
};
'use strict';

var GetIntrinsic = require('get-intrinsic');

var $TypeError = require('es-errors/type');
var isObject = require('es-object-atoms/isObject');

var $hasInstance = GetIntrinsic('%Symbol.hasInstance%', true);

var Call = require('./Call');
var GetMethod = require('./GetMethod');
var IsCallable = require('./IsCallable');
var OrdinaryHasInstance = require('./OrdinaryHasInstance');
var ToBoolean = require('./ToBoolean');

// https://262.ecma-international.org/6.0/#sec-instanceofoperator

module.exports = function InstanceofOperator(O, C) {
	if (!isObject(O)) {
		throw new $TypeError('Assertion failed: Type(O) is not Object');
	}
	var instOfHandler = $hasInstance ? GetMethod(C, $hasInstance) : void 0;
	if (typeof instOfHandler !== 'undefined') {
		return ToBoolean(Call(instOfHandler, C, [O]));
	}
	if (!IsCallable(C)) {
		throw new $TypeError('`C` is not Callable');
	}
	return OrdinaryHasInstance(C, O);
};
'use strict';

var $TypeError = require('es-errors/type');

var GetValueFromBuffer = require('./GetValueFromBuffer');
var IsValidIntegerIndex = require('./IsValidIntegerIndex');
var TypedArrayElementSize = require('./TypedArrayElementSize');
var TypedArrayElementType = require('./TypedArrayElementType');

var isTypedArray = require('is-typed-array');
var typedArrayBuffer = require('typed-array-buffer');
var typedArrayByteOffset = require('typed-array-byte-offset');

// https://262.ecma-international.org/13.0/#sec-integerindexedelementget

module.exports = function IntegerIndexedElementGet(O, index) {
	if (!isTypedArray(O)) {
		throw new $TypeError('Assertion failed: `O` must be a TypedArray');
	}

	if (typeof index !== 'number') {
		throw new $TypeError('Assertion failed: `index` must be a Number');
	}

	if (!IsValidIntegerIndex(O, index)) {
		return void undefined; // step 1
	}

	var offset = typedArrayByteOffset(O); // step 2

	var elementSize = TypedArrayElementSize(O); // step 3

	var indexedPosition = (index * elementSize) + offset; // step 4

	var elementType = TypedArrayElementType(O); // step 5

	return GetValueFromBuffer(typedArrayBuffer(O), indexedPosition, elementType, true, 'Unordered'); // step 11
};
'use strict';

var $TypeError = require('es-errors/type');

var IsValidIntegerIndex = require('./IsValidIntegerIndex');
var SetValueInBuffer = require('./SetValueInBuffer');
var ToBigInt = require('./ToBigInt');
var ToNumber = require('./ToNumber');
var TypedArrayElementSize = require('./TypedArrayElementSize');
var TypedArrayElementType = require('./TypedArrayElementType');

var typedArrayBuffer = require('typed-array-buffer');
var typedArrayByteOffset = require('typed-array-byte-offset');
var whichTypedArray = require('which-typed-array');

// https://262.ecma-international.org/13.0/#sec-integerindexedelementset

module.exports = function IntegerIndexedElementSet(O, index, value) {
	var arrayTypeName = whichTypedArray(O);
	if (!arrayTypeName) {
		throw new $TypeError('Assertion failed: `O` must be a TypedArray');
	}

	if (typeof index !== 'number') {
		throw new $TypeError('Assertion failed: `index` must be a Number');
	}

	var contentType = arrayTypeName === 'BigInt64Array' || arrayTypeName === 'BigUint64Array' ? 'BigInt' : 'Number';
	var numValue = contentType === 'BigInt' ? ToBigInt(value) : ToNumber(value); // steps 1 - 2

	if (IsValidIntegerIndex(O, index)) { // step 3
		var offset = typedArrayByteOffset(O); // step 3.a

		var elementSize = TypedArrayElementSize(O); // step 3.b

		var indexedPosition = (index * elementSize) + offset; // step 3.c

		var elementType = TypedArrayElementType(O); // step 3.d

		SetValueInBuffer(typedArrayBuffer(O), indexedPosition, elementType, numValue, true, 'Unordered'); // step 3.e
	}
};
'use strict';

var $TypeError = require('es-errors/type');
var isObject = require('es-object-atoms/isObject');

var Call = require('./Call');
var CreateDataProperty = require('./CreateDataProperty');
var EnumerableOwnProperties = require('./EnumerableOwnProperties');
var Get = require('./Get');
var IsArray = require('./IsArray');
var LengthOfArrayLike = require('./LengthOfArrayLike');
var ToString = require('./ToString');

var forEach = require('../helpers/forEach');

// https://262.ecma-international.org/14.0/#sec-internalizejsonproperty

// note: `reviver` was implicitly closed-over until ES2020, where it becomes a third argument

module.exports = function InternalizeJSONProperty(holder, name, reviver) {
	if (!isObject(holder)) {
		throw new $TypeError('Assertion failed: `holder` is not an Object');
	}
	if (typeof name !== 'string') {
		throw new $TypeError('Assertion failed: `name` is not a String');
	}
	if (typeof reviver !== 'function') {
		throw new $TypeError('Assertion failed: `reviver` is not a Function');
	}

	var val = Get(holder, name); // step 1

	if (isObject(val)) { // step 2
		var isArray = IsArray(val); // step 2.a
		if (isArray) { // step 2.b
			var I = 0; // step 2.b.i

			var len = LengthOfArrayLike(val); // step 2.b.ii

			while (I < len) { // step 2.b.iii
				var newElement = InternalizeJSONProperty(val, ToString(I), reviver); // step 2.b.iv.1

				if (typeof newElement === 'undefined') { // step 2.b.iii.2
					delete val[ToString(I)]; // step 2.b.iii.2.a
				} else { // step 2.b.iii.3
					CreateDataProperty(val, ToString(I), newElement); // step 2.b.iii.3.a
				}

				I += 1; // step 2.b.iii.4
			}
		} else { // step 2.c
			var keys = EnumerableOwnProperties(val, 'key'); // step 2.c.i

			forEach(keys, function (P) { // step 2.c.ii
				// eslint-disable-next-line no-shadow
				var newElement = InternalizeJSONProperty(val, P, reviver); // step 2.c.ii.1

				if (typeof newElement === 'undefined') { // step 2.c.ii.2
					delete val[P]; // step 2.c.ii.2.a
				} else { // step 2.c.ii.3
					CreateDataProperty(val, P, newElement); // step 2.c.ii.3.a
				}
			});
		}
	}

	return Call(reviver, holder, [name, val]); // step 3
};
'use strict';

var $TypeError = require('es-errors/type');

var Call = require('./Call');
var IsArray = require('./IsArray');
var GetV = require('./GetV');
var isPropertyKey = require('../helpers/isPropertyKey');

// https://262.ecma-international.org/6.0/#sec-invoke

module.exports = function Invoke(O, P) {
	if (!isPropertyKey(P)) {
		throw new $TypeError('Assertion failed: P must be a Property Key');
	}
	var argumentsList = arguments.length > 2 ? arguments[2] : [];
	if (!IsArray(argumentsList)) {
		throw new $TypeError('Assertion failed: optional `argumentsList`, if provided, must be a List');
	}
	var func = GetV(O, P);
	return Call(func, O, argumentsList);
};
'use strict';

var $TypeError = require('es-errors/type');

var hasOwn = require('hasown');

var isPropertyDescriptor = require('../helpers/records/property-descriptor');

// https://262.ecma-international.org/5.1/#sec-8.10.1

module.exports = function IsAccessorDescriptor(Desc) {
	if (typeof Desc === 'undefined') {
		return false;
	}

	if (!isPropertyDescriptor(Desc)) {
		throw new $TypeError('Assertion failed: `Desc` must be a Property Descriptor');
	}

	if (!hasOwn(Desc, '[[Get]]') && !hasOwn(Desc, '[[Set]]')) {
		return false;
	}

	return true;
};
'use strict';

// https://262.ecma-international.org/6.0/#sec-isarray
module.exports = require('../helpers/IsArray');
'use strict';

// https://262.ecma-international.org/11.0/#sec-isbigintelementtype

module.exports = function IsBigIntElementType(type) {
	return type === 'BigUint64' || type === 'BigInt64';
};
'use strict';

// http://262.ecma-international.org/5.1/#sec-9.11

module.exports = require('is-callable');
'use strict';

var ValidateAndApplyPropertyDescriptor = require('./ValidateAndApplyPropertyDescriptor');

// https://262.ecma-international.org/13.0/#sec-iscompatiblepropertydescriptor

module.exports = function IsCompatiblePropertyDescriptor(Extensible, Desc, Current) {
	return ValidateAndApplyPropertyDescriptor(undefined, '', Extensible, Desc, Current);
};
'use strict';

var GetIntrinsic = require('get-intrinsic');

var $isConcatSpreadable = GetIntrinsic('%Symbol.isConcatSpreadable%', true);

var Get = require('./Get');
var IsArray = require('./IsArray');
var ToBoolean = require('./ToBoolean');

var isObject = require('es-object-atoms/isObject');

// https://262.ecma-international.org/6.0/#sec-isconcatspreadable

module.exports = function IsConcatSpreadable(O) {
	if (!isObject(O)) {
		return false;
	}
	if ($isConcatSpreadable) {
		var spreadable = Get(O, $isConcatSpreadable);
		if (typeof spreadable !== 'undefined') {
			return ToBoolean(spreadable);
		}
	}
	return IsArray(O);
};
'use strict';

var GetIntrinsic = require('../GetIntrinsic.js');

var $construct = GetIntrinsic('%Reflect.construct%', true);

var DefinePropertyOrThrow = require('./DefinePropertyOrThrow');
try {
	DefinePropertyOrThrow({}, '', { '[[Get]]': function () {} });
} catch (e) {
	// Accessor properties aren't supported
	DefinePropertyOrThrow = null;
}

// https://262.ecma-international.org/6.0/#sec-isconstructor

if (DefinePropertyOrThrow && $construct) {
	var isConstructorMarker = {};
	var badArrayLike = {};
	DefinePropertyOrThrow(badArrayLike, 'length', {
		'[[Get]]': function () {
			throw isConstructorMarker;
		},
		'[[Enumerable]]': true
	});

	module.exports = function IsConstructor(argument) {
		try {
			// `Reflect.construct` invokes `IsConstructor(target)` before `Get(args, 'length')`:
			$construct(argument, badArrayLike);
		} catch (err) {
			return err === isConstructorMarker;
		}
	};
} else {
	module.exports = function IsConstructor(argument) {
		// unfortunately there's no way to truly check this without try/catch `new argument` in old environments
		return typeof argument === 'function' && !!argument.prototype;
	};
}
'use strict';

var $TypeError = require('es-errors/type');

var hasOwn = require('hasown');

var isPropertyDescriptor = require('../helpers/records/property-descriptor');

// https://262.ecma-international.org/5.1/#sec-8.10.2

module.exports = function IsDataDescriptor(Desc) {
	if (typeof Desc === 'undefined') {
		return false;
	}

	if (!isPropertyDescriptor(Desc)) {
		throw new $TypeError('Assertion failed: `Desc` must be a Property Descriptor');
	}

	if (!hasOwn(Desc, '[[Value]]') && !hasOwn(Desc, '[[Writable]]')) {
		return false;
	}

	return true;
};
'use strict';

var $TypeError = require('es-errors/type');

var $byteLength = require('array-buffer-byte-length');
var availableTypedArrays = require('available-typed-arrays')();
var callBound = require('call-bound');
var isArrayBuffer = require('is-array-buffer');
var isSharedArrayBuffer = require('is-shared-array-buffer');

var $sabByteLength = callBound('SharedArrayBuffer.prototype.byteLength', true);

// https://262.ecma-international.org/8.0/#sec-isdetachedbuffer

module.exports = function IsDetachedBuffer(arrayBuffer) {
	var isSAB = isSharedArrayBuffer(arrayBuffer);
	if (!isArrayBuffer(arrayBuffer) && !isSAB) {
		throw new $TypeError('Assertion failed: `arrayBuffer` must be an Object with an [[ArrayBufferData]] internal slot');
	}
	if ((isSAB ? $sabByteLength : $byteLength)(arrayBuffer) === 0) {
		try {
			new global[availableTypedArrays[0]](arrayBuffer); // eslint-disable-line no-new
		} catch (error) {
			return !!error && error.name === 'TypeError';
		}
	}
	return false;
};
'use strict';

var GetIntrinsic = require('get-intrinsic');

var $preventExtensions = GetIntrinsic('%Object.preventExtensions%', true);
var $isExtensible = GetIntrinsic('%Object.isExtensible%', true);

var isPrimitive = require('../helpers/isPrimitive');

// https://262.ecma-international.org/6.0/#sec-isextensible-o

module.exports = $preventExtensions
	? function IsExtensible(obj) {
		return !isPrimitive(obj) && $isExtensible(obj);
	}
	: function IsExtensible(obj) {
		return !isPrimitive(obj);
	};
'use strict';

var $TypeError = require('es-errors/type');

var IsAccessorDescriptor = require('./IsAccessorDescriptor');
var IsDataDescriptor = require('./IsDataDescriptor');

var isPropertyDescriptor = require('../helpers/records/property-descriptor');

// https://262.ecma-international.org/6.0/#sec-isgenericdescriptor

module.exports = function IsGenericDescriptor(Desc) {
	if (typeof Desc === 'undefined') {
		return false;
	}

	if (!isPropertyDescriptor(Desc)) {
		throw new $TypeError('Assertion failed: `Desc` must be a Property Descriptor');
	}

	if (!IsAccessorDescriptor(Desc) && !IsDataDescriptor(Desc)) {
		return true;
	}

	return false;
};
'use strict';

var truncate = require('./truncate');

var $isFinite = require('math-intrinsics/isFinite');

// https://262.ecma-international.org/14.0/#sec-isintegralnumber

module.exports = function IsIntegralNumber(argument) {
	if (typeof argument !== 'number' || !$isFinite(argument)) {
		return false;
	}
	return truncate(argument) === argument;
};
'use strict';

var GetIntrinsic = require('get-intrinsic');

var $Number = GetIntrinsic('%Number%');
var $TypeError = require('es-errors/type');
var min = require('math-intrinsics/min');
var $isNaN = require('math-intrinsics/isNaN');

var $charCodeAt = require('call-bound')('String.prototype.charCodeAt');

var StringToBigInt = require('./StringToBigInt');
var ToNumeric = require('./ToNumeric');
var ToPrimitive = require('./ToPrimitive');

var BigIntLessThan = require('./BigInt/lessThan');
var NumberLessThan = require('./Number/lessThan');

// https://262.ecma-international.org/14.0/#sec-islessthan

// eslint-disable-next-line max-statements, max-lines-per-function
module.exports = function IsLessThan(x, y, LeftFirst) {
	if (typeof LeftFirst !== 'boolean') {
		throw new $TypeError('Assertion failed: LeftFirst argument must be a Boolean');
	}
	var px;
	var py;
	if (LeftFirst) {
		px = ToPrimitive(x, $Number);
		py = ToPrimitive(y, $Number);
	} else {
		py = ToPrimitive(y, $Number);
		px = ToPrimitive(x, $Number);
	}

	if (typeof px === 'string' && typeof py === 'string') { // step 3
		// a. Let lx be the length of px.
		// b. Let ly be the length of py.
		// c. For each integer i starting with 0 such that i < min(lx, ly), in ascending order, do
		// i. Let cx be the integer that is the numeric value of the code unit at index i within px.
		// ii. Let cy be the integer that is the numeric value of the code unit at index i within py.
		// iii. If cx < cy, return true.
		// iv. If cx > cy, return false.
		// d. If lx < ly, return true. Otherwise, return false.

		var lx = px.length; // step 3.a
		var ly = py.length; // step 3.b
		for (var i = 0; i < min(lx, ly); i++) { // step 3.c
			var cx = $charCodeAt(px, i); // step 3.c.i
			var cy = $charCodeAt(py, i); // step 3.c.ii
			if (cx < cy) {
				return true; // step 3.c.iii
			}
			if (cx > cy) {
				return false; // step 3.c.iv
			}
		}
		return lx < ly; // step 3.d
	}

	var nx;
	var ny;
	if (typeof px === 'bigint' && typeof py === 'string') {
		ny = StringToBigInt(py);
		if (typeof ny === 'undefined') {
			return void undefined;
		}
		return BigIntLessThan(px, ny);
	}
	if (typeof px === 'string' && typeof py === 'bigint') {
		nx = StringToBigInt(px);
		if (typeof nx === 'undefined') {
			return void undefined;
		}
		return BigIntLessThan(nx, py);
	}

	nx = ToNumeric(px);
	ny = ToNumeric(py);

	if (typeof nx === typeof ny) {
		return typeof nx === 'number' ? NumberLessThan(nx, ny) : BigIntLessThan(nx, ny);
	}

	if ($isNaN(nx) || $isNaN(ny)) {
		return void undefined;
	}

	if (nx === -Infinity || ny === Infinity) {
		return true;
	}
	if (nx === Infinity || ny === -Infinity) {
		return false;
	}

	return nx < ny; // by now, these are both finite, and the same type
};
'use strict';

var isFinite = require('math-intrinsics/isFinite');
var isObject = require('es-object-atoms/isObject');

var IsStrictlyEqual = require('./IsStrictlyEqual');
var StringToBigInt = require('./StringToBigInt');
var ToNumber = require('./ToNumber');
var ToPrimitive = require('./ToPrimitive');

var isSameType = require('../helpers/isSameType');

// https://262.ecma-international.org/13.0/#sec-islooselyequal

module.exports = function IsLooselyEqual(x, y) {
	if (isSameType(x, y)) {
		return IsStrictlyEqual(x, y);
	}
	if (x == null && y == null) {
		return true;
	}
	if (typeof x === 'number' && typeof y === 'string') {
		return IsLooselyEqual(x, ToNumber(y));
	}
	if (typeof x === 'string' && typeof y === 'number') {
		return IsLooselyEqual(ToNumber(x), y);
	}
	if (typeof x === 'bigint' && typeof y === 'string') {
		var n = StringToBigInt(y);
		if (typeof n === 'undefined') {
			return false;
		}
		return IsLooselyEqual(x, n);
	}
	if (typeof x === 'string' && typeof y === 'bigint') {
		return IsLooselyEqual(y, x);
	}
	if (typeof x === 'boolean') {
		return IsLooselyEqual(ToNumber(x), y);
	}
	if (typeof y === 'boolean') {
		return IsLooselyEqual(x, ToNumber(y));
	}
	if ((typeof x === 'string' || typeof x === 'number' || typeof x === 'symbol' || typeof x === 'bigint') && isObject(y)) {
		return IsLooselyEqual(x, ToPrimitive(y));
	}
	if (isObject(x) && (typeof y === 'string' || typeof y === 'number' || typeof y === 'symbol' || typeof y === 'bigint')) {
		return IsLooselyEqual(ToPrimitive(x), y);
	}
	if ((typeof x === 'bigint' && typeof y === 'number') || (typeof x === 'number' && typeof y === 'bigint')) {
		if (!isFinite(x) || !isFinite(y)) {
			return false;
		}
		// eslint-disable-next-line eqeqeq
		return x == y; // shortcut for step 13.b.
	}
	return false;
};
'use strict';

var IsUnclampedIntegerElementType = require('./IsUnclampedIntegerElementType');
var IsBigIntElementType = require('./IsBigIntElementType');

// https://262.ecma-international.org/11.0/#sec-isnotearconfiguration

module.exports = function IsNoTearConfiguration(type, order) {
	if (IsUnclampedIntegerElementType(type)) {
		return true;
	}
	if (IsBigIntElementType(type) && order !== 'Init' && order !== 'Unordered') {
		return true;
	}
	return false;
};
'use strict';

var callBound = require('call-bound');

var $PromiseThen = callBound('Promise.prototype.then', true);

var isObject = require('es-object-atoms/isObject');

// https://262.ecma-international.org/6.0/#sec-ispromise

module.exports = function IsPromise(x) {
	if (!isObject(x)) {
		return false;
	}
	if (!$PromiseThen) { // Promises are not supported
		return false;
	}
	try {
		$PromiseThen(x); // throws if not a promise
	} catch (e) {
		return false;
	}
	return true;
};
'use strict';

var isPropertyKey = require('../helpers/isPropertyKey');

// https://262.ecma-international.org/6.0/#sec-ispropertykey

module.exports = function IsPropertyKey(argument) {
	return isPropertyKey(argument);
};
'use strict';

var GetIntrinsic = require('get-intrinsic');

var $match = GetIntrinsic('%Symbol.match%', true);

var hasRegExpMatcher = require('is-regex');
var isObject = require('es-object-atoms/isObject');

var ToBoolean = require('./ToBoolean');

// https://262.ecma-international.org/6.0/#sec-isregexp

module.exports = function IsRegExp(argument) {
	if (!isObject(argument)) {
		return false;
	}
	if ($match) {
		var isRegExp = argument[$match];
		if (typeof isRegExp !== 'undefined') {
			return ToBoolean(isRegExp);
		}
	}
	return hasRegExpMatcher(argument);
};
'use strict';

var $TypeError = require('es-errors/type');
var isObject = require('es-object-atoms/isObject');

var isSharedArrayBuffer = require('is-shared-array-buffer');

// https://262.ecma-international.org/8.0/#sec-issharedarraybuffer

module.exports = function IsSharedArrayBuffer(obj) {
	if (!isObject(obj)) {
		throw new $TypeError('Assertion failed: Type(O) is not Object');
	}

	return isSharedArrayBuffer(obj);
};
'use strict';

var SameValueNonNumber = require('./SameValueNonNumber');
var Type = require('./Type');
var NumberEqual = require('./Number/equal');

// https://262.ecma-international.org/14.0/#sec-isstrictlyequal

module.exports = function IsStrictlyEqual(x, y) {
	if (Type(x) !== Type(y)) {
		return false;
	}
	return typeof x === 'number' ? NumberEqual(x, y) : SameValueNonNumber(x, y);
};
'use strict';

var CodePointAt = require('./CodePointAt');

var $TypeError = require('es-errors/type');

// https://262.ecma-international.org/14.0/#sec-isstringwellformedunicode

module.exports = function IsStringWellFormedUnicode(string) {
	if (typeof string !== 'string') {
		throw new $TypeError('Assertion failed: `string` must be a String');
	}
	var len = string.length; // step 1
	var k = 0; // step 2
	while (k < len) { // step 3
		var cp = CodePointAt(string, k); // step 3.a
		if (cp['[[IsUnpairedSurrogate]]']) {
			return false; // step 3.b
		}
		k += cp['[[CodeUnitCount]]']; // step 3.c
	}
	return true; // step 4
};
'use strict';

var $TypeError = require('es-errors/type');

var regexTester = require('safe-regex-test');

// https://tc39.es/ecma262/#sec-istimezoneoffsetstring

// implementation taken from https://github.com/tc39/proposal-temporal/blob/21ee5b13f0672990c807475ba094092d19dd6dc5/polyfill/lib/ecmascript.mjs#L2140

var OFFSET = /^([+\u2212-])([01][0-9]|2[0-3])(?::?([0-5][0-9])(?::?([0-5][0-9])(?:[.,](\d{1,9}))?)?)?$/;

var testOffset = regexTester(OFFSET);

module.exports = function IsTimeZoneOffsetString(offsetString) {
	if (typeof offsetString !== 'string') {
		throw new $TypeError('Assertion failed: `offsetString` must be a String');
	}
	return testOffset(offsetString);
};
'use strict';

// https://262.ecma-international.org/11.0/#sec-isunclampedintegerelementtype

module.exports = function IsUnclampedIntegerElementType(type) {
	return type === 'Int8'
		|| type === 'Uint8'
		|| type === 'Int16'
		|| type === 'Uint16'
		|| type === 'Int32'
		|| type === 'Uint32';
};
'use strict';

// https://262.ecma-international.org/11.0/#sec-isunsignedelementtype

module.exports = function IsUnsignedElementType(type) {
	return type === 'Uint8'
		|| type === 'Uint8C'
		|| type === 'Uint16'
		|| type === 'Uint32'
		|| type === 'BigUint64';
};
'use strict';

var $TypeError = require('es-errors/type');
var isNegativeZero = require('math-intrinsics/isNegativeZero');

var IsDetachedBuffer = require('./IsDetachedBuffer');

var isInteger = require('math-intrinsics/isInteger');
var typedArrayBuffer = require('typed-array-buffer');

// https://262.ecma-international.org/12.0/#sec-isvalidintegerindex

module.exports = function IsValidIntegerIndex(O, index) {
	// Assert: O is an Integer-Indexed exotic object.
	var buffer = typedArrayBuffer(O); // step 1

	if (typeof index !== 'number') {
		throw new $TypeError('Assertion failed: Type(index) is not Number');
	}

	if (IsDetachedBuffer(buffer)) { return false; } // step 2

	if (!isInteger(index)) { return false; } // step 3

	if (isNegativeZero(index)) { return false; } // step 4

	if (index < 0 || index >= O.length) { return false; } // step 5

	return true; // step 6
};
'use strict';

var $TypeError = require('es-errors/type');
var callBound = require('call-bound');
var isInteger = require('math-intrinsics/isInteger');

var $indexOf = callBound('String.prototype.indexOf');

var IsArray = require('./IsArray');
var WordCharacters = require('./WordCharacters');

var every = require('../helpers/every');
var isRegExpRecord = require('../helpers/records/regexp-record');

var isChar = function isChar(c) {
	return typeof c === 'string';
};

// https://262.ecma-international.org/14.0/#sec-runtime-semantics-iswordchar-abstract-operation

module.exports = function IsWordChar(rer, Input, e) {
	if (!isRegExpRecord(rer)) {
		throw new $TypeError('Assertion failed: `rer` must be a RegExp Record');
	}
	if (!IsArray(Input) || !every(Input, isChar)) {
		throw new $TypeError('Assertion failed: `Input` must be a List of characters');
	}

	if (!isInteger(e)) {
		throw new $TypeError('Assertion failed: `e` must be an integer');
	}

	var InputLength = Input.length; // step 1

	if (e === -1 || e === InputLength) {
		return false; // step 2
	}

	var c = Input[e]; // step 3

	return $indexOf(WordCharacters(rer), c) > -1; // steps 4-5
};
'use strict';

var $TypeError = require('es-errors/type');
var isObject = require('es-object-atoms/isObject');

var Call = require('./Call');
var CompletionRecord = require('./CompletionRecord');
var GetMethod = require('./GetMethod');
var IsCallable = require('./IsCallable');

var isIteratorRecord = require('../helpers/records/iterator-record-2023');

// https://262.ecma-international.org/14.0/#sec-iteratorclose

module.exports = function IteratorClose(iteratorRecord, completion) {
	if (!isIteratorRecord(iteratorRecord)) {
		throw new $TypeError('Assertion failed: `iteratorRecord` must be an Iterator Record'); // step 1
	}
	if (!isObject(iteratorRecord['[[Iterator]]'])) {
		throw new $TypeError('Assertion failed: iteratorRecord.[[Iterator]] must be an Object'); // step 1
	}

	if (!IsCallable(completion) && !(completion instanceof CompletionRecord)) { // step 2
		throw new $TypeError('Assertion failed: completion is not a thunk representing a Completion Record, nor a Completion Record instance');
	}
	var completionThunk = completion instanceof CompletionRecord ? function () { return completion['?'](); } : completion;

	var iterator = iteratorRecord['[[Iterator]]']; // step 3

	var iteratorReturn;
	try {
		iteratorReturn = GetMethod(iterator, 'return'); // step 4
	} catch (e) {
		completionThunk(); // throws if `completion` is a throw completion // step 6
		completionThunk = null; // ensure it's not called twice.
		throw e; // step 7
	}
	if (typeof iteratorReturn === 'undefined') {
		return completionThunk(); // step 5.a - 5.b
	}

	var innerResult;
	try {
		innerResult = Call(iteratorReturn, iterator, []);
	} catch (e) {
		// if we hit here, then "e" is the innerResult completion that needs re-throwing

		completionThunk(); // throws if `completion` is a throw completion // step 6
		completionThunk = null; // ensure it's not called twice.

		// if not, then return the innerResult completion
		throw e; // step 7
	}
	var completionRecord = completionThunk(); // if innerResult worked, then throw if the completion does
	completionThunk = null; // ensure it's not called twice.

	if (!isObject(innerResult)) {
		throw new $TypeError('iterator .return must return an object');
	}

	return completionRecord;
};
'use strict';

var $TypeError = require('es-errors/type');
var isObject = require('es-object-atoms/isObject');

var Get = require('./Get');
var ToBoolean = require('./ToBoolean');

// https://262.ecma-international.org/6.0/#sec-iteratorcomplete

module.exports = function IteratorComplete(iterResult) {
	if (!isObject(iterResult)) {
		throw new $TypeError('Assertion failed: Type(iterResult) is not Object');
	}
	return ToBoolean(Get(iterResult, 'done'));
};
'use strict';

var $TypeError = require('es-errors/type');
var isObject = require('es-object-atoms/isObject');

var Call = require('./Call');

var isIteratorRecord = require('../helpers/records/iterator-record-2023');

// https://262.ecma-international.org/14.0/#sec-iteratornext

module.exports = function IteratorNext(iteratorRecord) {
	if (!isIteratorRecord(iteratorRecord)) {
		throw new $TypeError('Assertion failed: `iteratorRecord` must be an Iterator Record'); // step 1
	}

	var result;
	if (arguments.length < 2) { // step 1
		result = Call(iteratorRecord['[[NextMethod]]'], iteratorRecord['[[Iterator]]']); // step 1.a
	} else { // step 2
		result = Call(iteratorRecord['[[NextMethod]]'], iteratorRecord['[[Iterator]]'], [arguments[1]]); // step 2.a
	}

	if (!isObject(result)) {
		throw new $TypeError('iterator next must return an object'); // step 3
	}
	return result; // step 4
};
'use strict';

var $TypeError = require('es-errors/type');

var IteratorComplete = require('./IteratorComplete');
var IteratorNext = require('./IteratorNext');

var isIteratorRecord = require('../helpers/records/iterator-record-2023');

// https://262.ecma-international.org/14.0/#sec-iteratorstep

module.exports = function IteratorStep(iteratorRecord) {
	if (!isIteratorRecord(iteratorRecord)) {
		throw new $TypeError('Assertion failed: `iteratorRecord` must be an Iterator Record'); // step 1
	}

	var result = IteratorNext(iteratorRecord); // step 1
	var done = IteratorComplete(result); // step 2
	return done === true ? false : result; // steps 3-4
};

'use strict';

var $TypeError = require('es-errors/type');

var IteratorStep = require('./IteratorStep');
var IteratorValue = require('./IteratorValue');

var isIteratorRecord = require('../helpers/records/iterator-record-2023');

// https://262.ecma-international.org/14.0/#sec-iteratortolist

module.exports = function IteratorToList(iteratorRecord) {
	if (!isIteratorRecord(iteratorRecord)) {
		throw new $TypeError('Assertion failed: `iteratorRecord` must be an Iterator Record'); // step 1
	}

	var values = []; // step 1
	var next = true; // step 2
	while (next) { // step 3
		next = IteratorStep(iteratorRecord); // step 3.a
		if (next) {
			var nextValue = IteratorValue(next); // step 3.b.i
			values[values.length] = nextValue; // step 3.b.ii
		}
	}
	return values; // step 4
};
'use strict';

var $TypeError = require('es-errors/type');
var isObject = require('es-object-atoms/isObject');

var Get = require('./Get');

// https://262.ecma-international.org/6.0/#sec-iteratorvalue

module.exports = function IteratorValue(iterResult) {
	if (!isObject(iterResult)) {
		throw new $TypeError('Assertion failed: Type(iterResult) is not Object');
	}
	return Get(iterResult, 'value');
};

'use strict';

var $TypeError = require('es-errors/type');

var callBound = require('call-bound');

var $keyFor = callBound('Symbol.keyFor', true);

// https://262.ecma-international.org/14.0/#sec-keyforsymbol

module.exports = function KeyForSymbol(sym) {
	if (typeof sym !== 'symbol') {
		throw new $TypeError('Assertion failed: `sym` must be a Symbol');
	}
	return $keyFor(sym);
};
'use strict';

var $TypeError = require('es-errors/type');
var isObject = require('es-object-atoms/isObject');

var Get = require('./Get');
var ToLength = require('./ToLength');

// https://262.ecma-international.org/11.0/#sec-lengthofarraylike

module.exports = function LengthOfArrayLike(obj) {
	if (!isObject(obj)) {
		throw new $TypeError('Assertion failed: `obj` must be an Object');
	}
	return ToLength(Get(obj, 'length'));
};

// TODO: use this all over
'use strict';

var $isFinite = require('math-intrinsics/isFinite');

var msPerDay = require('../helpers/timeConstants').msPerDay;

// https://262.ecma-international.org/5.1/#sec-15.9.1.13

module.exports = function MakeDate(day, time) {
	if (!$isFinite(day) || !$isFinite(time)) {
		return NaN;
	}
	return (day * msPerDay) + time;
};
'use strict';

var GetIntrinsic = require('get-intrinsic');

var $DateUTC = GetIntrinsic('%Date.UTC%');

var $isFinite = require('math-intrinsics/isFinite');

var DateFromTime = require('./DateFromTime');
var Day = require('./Day');
var floor = require('./floor');
var modulo = require('./modulo');
var MonthFromTime = require('./MonthFromTime');
var ToIntegerOrInfinity = require('./ToIntegerOrInfinity');
var YearFromTime = require('./YearFromTime');

// https://262.ecma-international.org/5.1/#sec-15.9.1.12

module.exports = function MakeDay(year, month, date) {
	if (!$isFinite(year) || !$isFinite(month) || !$isFinite(date)) {
		return NaN;
	}
	var y = ToIntegerOrInfinity(year);
	var m = ToIntegerOrInfinity(month);
	var dt = ToIntegerOrInfinity(date);
	var ym = y + floor(m / 12);
	if (!$isFinite(ym)) {
		return NaN;
	}
	var mn = modulo(m, 12);
	var t = $DateUTC(ym, mn, 1);
	if (YearFromTime(t) !== ym || MonthFromTime(t) !== mn || DateFromTime(t) !== 1) {
		return NaN;
	}
	return Day(t) + dt - 1;
};
'use strict';

var $TypeError = require('es-errors/type');

var ArrayCreate = require('./ArrayCreate');
var CreateDataPropertyOrThrow = require('./CreateDataPropertyOrThrow');
var GetMatchIndexPair = require('./GetMatchIndexPair');
var IsArray = require('./IsArray');
var OrdinaryObjectCreate = require('./OrdinaryObjectCreate');
var ToString = require('./ToString');

var every = require('../helpers/every');
var isMatchRecord = require('../helpers/records/match-record');

var isStringOrUndefined = function isStringOrUndefined(s) {
	return typeof s === 'undefined' || typeof s === 'string';
};

var isMatchRecordOrUndefined = function isMatchRecordOrUndefined(m) {
	return typeof m === 'undefined' || isMatchRecord(m);
};

var MAX_ARRAY_LENGTH = require('math-intrinsics/constants/maxArrayLength');

// https://262.ecma-international.org/13.0/#sec-getmatchindexpair

module.exports = function MakeMatchIndicesIndexPairArray(S, indices, groupNames, hasGroups) {
	if (typeof S !== 'string') {
		throw new $TypeError('Assertion failed: `S` must be a String');
	}
	if (!IsArray(indices) || !every(indices, isMatchRecordOrUndefined)) {
		throw new $TypeError('Assertion failed: `indices` must be a List of either Match Records or `undefined`');
	}
	if (!IsArray(groupNames) || !every(groupNames, isStringOrUndefined)) {
		throw new $TypeError('Assertion failed: `groupNames` must be a List of either Strings or `undefined`');
	}
	if (typeof hasGroups !== 'boolean') {
		throw new $TypeError('Assertion failed: `hasGroups` must be a Boolean');
	}

	var n = indices.length; // step 1
	if (!(n < MAX_ARRAY_LENGTH)) {
		throw new $TypeError('Assertion failed: `indices` length must be less than the max array size, 2**32 - 1');
	}
	if (groupNames.length !== n - 1) {
		throw new $TypeError('Assertion failed: `groupNames` must have exactly one fewer item than `indices`');
	}

	var A = ArrayCreate(n); // step 5
	var groups = hasGroups ? OrdinaryObjectCreate(null) : void undefined; // step 6-7
	CreateDataPropertyOrThrow(A, 'groups', groups); // step 8

	for (var i = 0; i < n; i += 1) { // step 9
		var matchIndices = indices[i]; // step 9.a
		// eslint-disable-next-line no-negated-condition
		var matchIndexPair = typeof matchIndices !== 'undefined' ? GetMatchIndexPair(S, matchIndices) : void undefined; // step 9.b-9.c
		CreateDataPropertyOrThrow(A, ToString(i), matchIndexPair); // step 9.d
		if (i > 0 && typeof groupNames[i - 1] !== 'undefined') { // step 9.e
			if (!groups) {
				throw new $TypeError('if `hasGroups` is `false`, `groupNames` can only contain `undefined` values');
			}
			CreateDataPropertyOrThrow(groups, groupNames[i - 1], matchIndexPair); // step 9.e.i
		}
	}
	return A; // step 10
};
'use strict';

var $isFinite = require('math-intrinsics/isFinite');
var timeConstants = require('../helpers/timeConstants');
var msPerSecond = timeConstants.msPerSecond;
var msPerMinute = timeConstants.msPerMinute;
var msPerHour = timeConstants.msPerHour;

var ToIntegerOrInfinity = require('./ToIntegerOrInfinity');

// https://262.ecma-international.org/12.0/#sec-maketime

module.exports = function MakeTime(hour, min, sec, ms) {
	if (!$isFinite(hour) || !$isFinite(min) || !$isFinite(sec) || !$isFinite(ms)) {
		return NaN;
	}
	var h = ToIntegerOrInfinity(hour);
	var m = ToIntegerOrInfinity(min);
	var s = ToIntegerOrInfinity(sec);
	var milli = ToIntegerOrInfinity(ms);
	var t = (h * msPerHour) + (m * msPerMinute) + (s * msPerSecond) + milli;
	return t;
};
'use strict';

// https://262.ecma-international.org/6.0/#sec-algorithm-conventions

module.exports = require('math-intrinsics/max');
'use strict';

var floor = require('./floor');
var modulo = require('./modulo');

var timeConstants = require('../helpers/timeConstants');
var msPerMinute = timeConstants.msPerMinute;
var MinutesPerHour = timeConstants.MinutesPerHour;

// https://262.ecma-international.org/5.1/#sec-15.9.1.10

module.exports = function MinFromTime(t) {
	return modulo(floor(t / msPerMinute), MinutesPerHour);
};
'use strict';

// https://262.ecma-international.org/6.0/#sec-algorithm-conventions

module.exports = require('math-intrinsics/min');
'use strict';

var mod = require('../helpers/mod');

// https://262.ecma-international.org/5.1/#sec-5.2

module.exports = function modulo(x, y) {
	return mod(x, y);
};
'use strict';

var $RangeError = require('es-errors/range');

var DayWithinYear = require('./DayWithinYear');
var InLeapYear = require('./InLeapYear');

// https://262.ecma-international.org/5.1/#sec-15.9.1.4

module.exports = function MonthFromTime(t) {
	var day = DayWithinYear(t);
	if (0 <= day && day < 31) {
		return 0;
	}
	var leap = InLeapYear(t);
	if (31 <= day && day < (59 + leap)) {
		return 1;
	}
	if ((59 + leap) <= day && day < (90 + leap)) {
		return 2;
	}
	if ((90 + leap) <= day && day < (120 + leap)) {
		return 3;
	}
	if ((120 + leap) <= day && day < (151 + leap)) {
		return 4;
	}
	if ((151 + leap) <= day && day < (181 + leap)) {
		return 5;
	}
	if ((181 + leap) <= day && day < (212 + leap)) {
		return 6;
	}
	if ((212 + leap) <= day && day < (243 + leap)) {
		return 7;
	}
	if ((243 + leap) <= day && day < (273 + leap)) {
		return 8;
	}
	if ((273 + leap) <= day && day < (304 + leap)) {
		return 9;
	}
	if ((304 + leap) <= day && day < (334 + leap)) {
		return 10;
	}
	if ((334 + leap) <= day && day < (365 + leap)) {
		return 11;
	}

	throw new $RangeError('Assertion failed: `day` is out of range');
};
'use strict';

var modulo = require('./modulo');

var msPerSecond = require('../helpers/timeConstants').msPerSecond;

// https://262.ecma-international.org/5.1/#sec-15.9.1.10

module.exports = function msFromTime(t) {
	return modulo(t, msPerSecond);
};
'use strict';

var $TypeError = require('es-errors/type');

var IsCallable = require('./IsCallable');
var IsConstructor = require('./IsConstructor');

// https://262.ecma-international.org/6.0/#sec-newpromisecapability

module.exports = function NewPromiseCapability(C) {
	if (!IsConstructor(C)) {
		throw new $TypeError('C must be a constructor'); // step 1
	}

	var resolvingFunctions = { '[[Resolve]]': void undefined, '[[Reject]]': void undefined }; // step 3

	var promise = new C(function (resolve, reject) { // steps 4-5
		if (typeof resolvingFunctions['[[Resolve]]'] !== 'undefined' || typeof resolvingFunctions['[[Reject]]'] !== 'undefined') {
			throw new $TypeError('executor has already been called'); // step 4.a, 4.b
		}
		resolvingFunctions['[[Resolve]]'] = resolve; // step 4.c
		resolvingFunctions['[[Reject]]'] = reject; // step 4.d
	}); // step 4-6

	if (!IsCallable(resolvingFunctions['[[Resolve]]']) || !IsCallable(resolvingFunctions['[[Reject]]'])) {
		throw new $TypeError('executor must provide valid resolve and reject functions'); // steps 7-8
	}

	return {
		'[[Promise]]': promise,
		'[[Resolve]]': resolvingFunctions['[[Resolve]]'],
		'[[Reject]]': resolvingFunctions['[[Reject]]']
	}; // step 9
};
'use strict';

var CompletionRecord = require('./CompletionRecord');

// https://262.ecma-international.org/6.0/#sec-normalcompletion

module.exports = function NormalCompletion(value) {
	return new CompletionRecord('normal', value);
};
'use strict';

var $TypeError = require('es-errors/type');

var ToInt32 = require('./ToInt32');
var ToUint32 = require('./ToUint32');

// https://262.ecma-international.org/11.0/#sec-numberbitwiseop

module.exports = function NumberBitwiseOp(op, x, y) {
	if (op !== '&' && op !== '|' && op !== '^') {
		throw new $TypeError('Assertion failed: `op` must be `&`, `|`, or `^`');
	}
	if (typeof x !== 'number' || typeof y !== 'number') {
		throw new $TypeError('Assertion failed: `x` and `y` arguments must be Numbers');
	}
	var lnum = ToInt32(x);
	var rnum = ToUint32(y);
	if (op === '&') {
		return lnum & rnum;
	}
	if (op === '|') {
		return lnum | rnum;
	}
	return lnum ^ rnum;
};
'use strict';

var GetIntrinsic = require('get-intrinsic');

var $BigInt = GetIntrinsic('%BigInt%', true);
var $RangeError = require('es-errors/range');
var $SyntaxError = require('es-errors/syntax');
var $TypeError = require('es-errors/type');

var isInteger = require('math-intrinsics/isInteger');

// https://262.ecma-international.org/12.0/#sec-numbertobigint

module.exports = function NumberToBigInt(number) {
	if (typeof number !== 'number') {
		throw new $TypeError('Assertion failed: `number` must be a String');
	}
	if (!isInteger(number)) {
		throw new $RangeError('The number ' + number + ' cannot be converted to a BigInt because it is not an integer');
	}
	if (!$BigInt) {
		throw new $SyntaxError('BigInts are not supported in this environment');
	}
	return $BigInt(number);
};
'use strict';

var $TypeError = require('es-errors/type');

var hasOwnProperty = require('./HasOwnProperty');
var ToBigInt64 = require('./ToBigInt64');
var ToBigUint64 = require('./ToBigUint64');
var ToInt16 = require('./ToInt16');
var ToInt32 = require('./ToInt32');
var ToInt8 = require('./ToInt8');
var ToUint16 = require('./ToUint16');
var ToUint32 = require('./ToUint32');
var ToUint8 = require('./ToUint8');
var ToUint8Clamp = require('./ToUint8Clamp');

var valueToFloat32Bytes = require('../helpers/valueToFloat32Bytes');
var valueToFloat64Bytes = require('../helpers/valueToFloat64Bytes');
var integerToNBytes = require('../helpers/integerToNBytes');

var tableTAO = require('./tables/typed-array-objects');

// https://262.ecma-international.org/11.0/#table-the-typedarray-constructors
var TypeToAO = {
	__proto__: null,
	$Int8: ToInt8,
	$Uint8: ToUint8,
	$Uint8C: ToUint8Clamp,
	$Int16: ToInt16,
	$Uint16: ToUint16,
	$Int32: ToInt32,
	$Uint32: ToUint32,
	$BigInt64: ToBigInt64,
	$BigUint64: ToBigUint64
};

// https://262.ecma-international.org/11.0/#sec-numerictorawbytes

module.exports = function NumericToRawBytes(type, value, isLittleEndian) {
	if (typeof type !== 'string' || !hasOwnProperty(tableTAO.size, '$' + type)) {
		throw new $TypeError('Assertion failed: `type` must be a TypedArray element type');
	}
	if (typeof value !== 'number' && typeof value !== 'bigint') {
		throw new $TypeError('Assertion failed: `value` must be a Number or a BigInt');
	}
	if (typeof isLittleEndian !== 'boolean') {
		throw new $TypeError('Assertion failed: `isLittleEndian` must be a Boolean');
	}

	if (type === 'Float32') { // step 1
		return valueToFloat32Bytes(value, isLittleEndian);
	} else if (type === 'Float64') { // step 2
		return valueToFloat64Bytes(value, isLittleEndian);
	} // step 3

	var n = tableTAO.size['$' + type]; // step 3.a

	var convOp = TypeToAO['$' + type]; // step 3.b

	var intValue = convOp(value); // step 3.c

	return integerToNBytes(intValue, n, isLittleEndian); // step 3.d, 3.e, 4
};
'use strict';

var DefinePropertyOrThrow = require('./DefinePropertyOrThrow');
var Get = require('./Get');
var OrdinaryGetOwnProperty = require('./OrdinaryGetOwnProperty');
var ToObject = require('./ToObject');
var ToPropertyDescriptor = require('./ToPropertyDescriptor');

var forEach = require('../helpers/forEach');
var OwnPropertyKeys = require('own-keys');

// https://262.ecma-international.org/6.0/#sec-objectdefineproperties

/** @type {<T extends Record<PropertyKey, unknown> = {}>(O: T, Properties: object) => T} */
module.exports = function ObjectDefineProperties(O, Properties) {
	var props = ToObject(Properties); // step 1
	var keys = OwnPropertyKeys(props); // step 2
	/** @type {[string | symbol, import('../types').Descriptor][]} */
	var descriptors = []; // step 3

	forEach(keys, function (nextKey) { // step 4
		var propDesc = OrdinaryGetOwnProperty(props, nextKey); // ToPropertyDescriptor(getOwnPropertyDescriptor(props, nextKey)); // step 4.a
		if (typeof propDesc !== 'undefined' && propDesc['[[Enumerable]]']) { // step 4.b
			var descObj = Get(props, nextKey); // step 4.b.i
			var desc = ToPropertyDescriptor(descObj); // step 4.b.ii
			descriptors[descriptors.length] = [nextKey, desc]; // step 4.b.iii
		}
	});

	forEach(descriptors, function (pair) { // step 5
		var P = pair[0]; // step 5.a
		var desc = pair[1]; // step 5.b
		DefinePropertyOrThrow(O, P, desc); // step 5.c
	});

	return O; // step 6
};
'use strict';

var GetIntrinsic = require('get-intrinsic');
var $TypeError = require('es-errors/type');

var GetPrototypeFromConstructor = require('./GetPrototypeFromConstructor');
var IsArray = require('./IsArray');
var OrdinaryObjectCreate = require('./OrdinaryObjectCreate');

// https://262.ecma-international.org/6.0/#sec-ordinarycreatefromconstructor

module.exports = function OrdinaryCreateFromConstructor(constructor, intrinsicDefaultProto) {
	GetIntrinsic(intrinsicDefaultProto); // throws if not a valid intrinsic
	var proto = GetPrototypeFromConstructor(constructor, intrinsicDefaultProto);
	var slots = arguments.length < 3 ? [] : arguments[2];
	if (!IsArray(slots)) {
		throw new $TypeError('Assertion failed: if provided, `internalSlotsList` must be a List');
	}
	return OrdinaryObjectCreate(proto, slots);
};
'use strict';

var $gOPD = require('gopd');
var $SyntaxError = require('es-errors/syntax');
var $TypeError = require('es-errors/type');
var isObject = require('es-object-atoms/isObject');

var isPropertyDescriptor = require('../helpers/records/property-descriptor');

var IsAccessorDescriptor = require('./IsAccessorDescriptor');
var IsExtensible = require('./IsExtensible');
var isPropertyKey = require('../helpers/isPropertyKey');
var ToPropertyDescriptor = require('./ToPropertyDescriptor');
var SameValue = require('./SameValue');
var ValidateAndApplyPropertyDescriptor = require('./ValidateAndApplyPropertyDescriptor');

// https://262.ecma-international.org/6.0/#sec-ordinarydefineownproperty

module.exports = function OrdinaryDefineOwnProperty(O, P, Desc) {
	if (!isObject(O)) {
		throw new $TypeError('Assertion failed: O must be an Object');
	}
	if (!isPropertyKey(P)) {
		throw new $TypeError('Assertion failed: P must be a Property Key');
	}
	if (!isPropertyDescriptor(Desc)) {
		throw new $TypeError('Assertion failed: Desc must be a Property Descriptor');
	}
	if (!$gOPD) {
		// ES3/IE 8 fallback
		if (IsAccessorDescriptor(Desc)) {
			throw new $SyntaxError('This environment does not support accessor property descriptors.');
		}
		var creatingNormalDataProperty = !(P in O)
			&& Desc['[[Writable]]']
			&& Desc['[[Enumerable]]']
			&& Desc['[[Configurable]]']
			&& '[[Value]]' in Desc;
		var settingExistingDataProperty = (P in O)
			&& (!('[[Configurable]]' in Desc) || Desc['[[Configurable]]'])
			&& (!('[[Enumerable]]' in Desc) || Desc['[[Enumerable]]'])
			&& (!('[[Writable]]' in Desc) || Desc['[[Writable]]'])
			&& '[[Value]]' in Desc;
		if (creatingNormalDataProperty || settingExistingDataProperty) {
			O[P] = Desc['[[Value]]']; // eslint-disable-line no-param-reassign
			return SameValue(O[P], Desc['[[Value]]']);
		}
		throw new $SyntaxError('This environment does not support defining non-writable, non-enumerable, or non-configurable properties');
	}
	var desc = $gOPD(O, P);
	var current = desc && ToPropertyDescriptor(desc);
	var extensible = IsExtensible(O);
	return ValidateAndApplyPropertyDescriptor(O, P, extensible, Desc, current);
};
'use strict';

var $gOPD = require('gopd');
var $TypeError = require('es-errors/type');
var isObject = require('es-object-atoms/isObject');
var callBound = require('call-bound');

var $isEnumerable = callBound('Object.prototype.propertyIsEnumerable');

var hasOwn = require('hasown');

var IsArray = require('./IsArray');
var isPropertyKey = require('../helpers/isPropertyKey');
var IsRegExp = require('./IsRegExp');
var ToPropertyDescriptor = require('./ToPropertyDescriptor');

// https://262.ecma-international.org/6.0/#sec-ordinarygetownproperty

module.exports = function OrdinaryGetOwnProperty(O, P) {
	if (!isObject(O)) {
		throw new $TypeError('Assertion failed: O must be an Object');
	}
	if (!isPropertyKey(P)) {
		throw new $TypeError('Assertion failed: P must be a Property Key');
	}
	if (!hasOwn(O, P)) {
		return void 0;
	}
	if (!$gOPD) {
		// ES3 / IE 8 fallback
		var arrayLength = IsArray(O) && P === 'length';
		var regexLastIndex = IsRegExp(O) && P === 'lastIndex';
		return {
			'[[Configurable]]': !(arrayLength || regexLastIndex),
			'[[Enumerable]]': $isEnumerable(O, P),
			'[[Value]]': O[P],
			'[[Writable]]': true
		};
	}
	return ToPropertyDescriptor($gOPD(O, P));
};
'use strict';

var $TypeError = require('es-errors/type');
var isObject = require('es-object-atoms/isObject');

var $getProto = require('get-proto');

// https://262.ecma-international.org/7.0/#sec-ordinarygetprototypeof

module.exports = function OrdinaryGetPrototypeOf(O) {
	if (!isObject(O)) {
		throw new $TypeError('Assertion failed: O must be an Object');
	}
	if (!$getProto) {
		throw new $TypeError('This environment does not support fetching prototypes.');
	}
	return $getProto(O);
};
'use strict';

var $TypeError = require('es-errors/type');
var isObject = require('es-object-atoms/isObject');

var Get = require('./Get');
var IsCallable = require('./IsCallable');

// https://262.ecma-international.org/6.0/#sec-ordinaryhasinstance

module.exports = function OrdinaryHasInstance(C, O) {
	if (!IsCallable(C)) {
		return false;
	}
	if (!isObject(O)) {
		return false;
	}
	var P = Get(C, 'prototype');
	if (!isObject(P)) {
		throw new $TypeError('OrdinaryHasInstance called on an object with an invalid prototype property.');
	}
	return O instanceof C;
};
'use strict';

var $TypeError = require('es-errors/type');
var isObject = require('es-object-atoms/isObject');

var isPropertyKey = require('../helpers/isPropertyKey');

// https://262.ecma-international.org/6.0/#sec-ordinaryhasproperty

module.exports = function OrdinaryHasProperty(O, P) {
	if (!isObject(O)) {
		throw new $TypeError('Assertion failed: Type(O) is not Object');
	}
	if (!isPropertyKey(P)) {
		throw new $TypeError('Assertion failed: P must be a Property Key');
	}
	return P in O;
};
'use strict';

var GetIntrinsic = require('get-intrinsic');

var $ObjectCreate = GetIntrinsic('%Object.create%', true);
var $TypeError = require('es-errors/type');
var $SyntaxError = require('es-errors/syntax');
var isObject = require('es-object-atoms/isObject');

var IsArray = require('./IsArray');

var forEach = require('../helpers/forEach');

var SLOT = require('internal-slot');

var hasProto = require('has-proto')();

// https://262.ecma-international.org/11.0/#sec-objectcreate

module.exports = function OrdinaryObjectCreate(proto) {
	if (proto !== null && !isObject(proto)) {
		throw new $TypeError('Assertion failed: `proto` must be null or an object');
	}
	var additionalInternalSlotsList = arguments.length < 2 ? [] : arguments[1];
	if (!IsArray(additionalInternalSlotsList)) {
		throw new $TypeError('Assertion failed: `additionalInternalSlotsList` must be an Array');
	}

	// var internalSlotsList = ['[[Prototype]]', '[[Extensible]]']; // step 1
	// internalSlotsList.push(...additionalInternalSlotsList); // step 2
	// var O = MakeBasicObject(internalSlotsList); // step 3
	// setProto(O, proto); // step 4
	// return O; // step 5

	var O;
	if (hasProto) {
		O = { __proto__: proto };
	} else if ($ObjectCreate) {
		O = $ObjectCreate(proto);
	} else {
		if (proto === null) {
			throw new $SyntaxError('native Object.create support is required to create null objects');
		}
		var T = function T() {};
		T.prototype = proto;
		O = new T();
	}

	if (additionalInternalSlotsList.length > 0) {
		forEach(additionalInternalSlotsList, function (slot) {
			SLOT.set(O, slot, void undefined);
		});
	}

	return O;
};
'use strict';

var $TypeError = require('es-errors/type');
var $setProto = require('set-proto');
var isObject = require('es-object-atoms/isObject');

var OrdinaryGetPrototypeOf = require('./OrdinaryGetPrototypeOf');

// https://262.ecma-international.org/7.0/#sec-ordinarysetprototypeof

module.exports = function OrdinarySetPrototypeOf(O, V) {
	if (V !== null && !isObject(V)) {
		throw new $TypeError('Assertion failed: V must be Object or Null');
	}
	/*
	var extensible = IsExtensible(O);
	var current = OrdinaryGetPrototypeOf(O);
	if (SameValue(V, current)) {
		return true;
	}
	if (!extensible) {
		return false;
	}
	*/
	try {
		$setProto(O, V);
	} catch (e) {
		return false;
	}
	return OrdinaryGetPrototypeOf(O) === V;
	/*
	var p = V;
	var done = false;
	while (!done) {
		if (p === null) {
			done = true;
		} else if (SameValue(p, O)) {
			return false;
		} else {
			if (wat) {
				done = true;
			} else {
				p = p.[[Prototype]];
			}
		}
	}
	O.[[Prototype]] = V;
	return true;
	*/
};
'use strict';

var $TypeError = require('es-errors/type');
var isObject = require('es-object-atoms/isObject');

var Call = require('./Call');
var Get = require('./Get');
var IsCallable = require('./IsCallable');

var inspect = require('object-inspect');

// https://262.ecma-international.org/8.0/#sec-ordinarytoprimitive

module.exports = function OrdinaryToPrimitive(O, hint) {
	if (!isObject(O)) {
		throw new $TypeError('Assertion failed: Type(O) is not Object');
	}
	if (/* typeof hint !== 'string' || */ hint !== 'string' && hint !== 'number') {
		throw new $TypeError('Assertion failed: `hint` must be "string" or "number"');
	}

	var methodNames = hint === 'string' ? ['toString', 'valueOf'] : ['valueOf', 'toString'];

	for (var i = 0; i < methodNames.length; i += 1) {
		var name = methodNames[i];
		var method = Get(O, name);
		if (IsCallable(method)) {
			var result = Call(method, O);
			if (!isObject(result)) {
				return result;
			}
		}
	}

	throw new $TypeError('No primitive value for ' + inspect(O));
};
'use strict';

var $SyntaxError = require('es-errors/syntax');
var $TypeError = require('es-errors/type');

var substring = require('./substring');

var isInteger = require('math-intrinsics/isInteger');
var isNaN = require('math-intrinsics/isNaN');

// https://262.ecma-international.org/14.0/#sec-parsehexoctet

module.exports = function ParseHexOctet(string, position) {
	if (typeof string !== 'string') {
		throw new $TypeError('Assertion failed: `string` must be a String');
	}
	if (!isInteger(position) || position < 0) {
		throw new $TypeError('Assertion failed: `position` must be a nonnegative integer');
	}

	var len = string.length; // step 1
	if ((position + 2) > len) { // step 2
		var error = new $SyntaxError('requested a position on a string that does not contain 2 characters at that position'); // step 2.a
		return [error]; // step 2.b
	}
	var hexDigits = substring(string, position, position + 2); // step 3

	var n = +('0x' + hexDigits);
	if (isNaN(n)) {
		return [new $SyntaxError('Invalid hexadecimal characters')];
	}
	return n;

	/*
	4. Let _parseResult_ be ParseText(StringToCodePoints(_hexDigits_), |HexDigits[~Sep]|).
    5. If _parseResult_ is not a Parse Node, return _parseResult_.
    6. Let _n_ be the unsigned 8-bit value corresponding with the MV of _parseResult_.
    7. Return _n_.
    */
};
'use strict';

var GetIntrinsic = require('get-intrinsic');
var callBind = require('call-bind');
var $SyntaxError = require('es-errors/syntax');

var $resolve = GetIntrinsic('%Promise.resolve%', true);
var $PromiseResolve = $resolve && callBind($resolve);

// https://262.ecma-international.org/9.0/#sec-promise-resolve

module.exports = function PromiseResolve(C, x) {
	if (!$PromiseResolve) {
		throw new $SyntaxError('This environment does not support Promises.');
	}
	return $PromiseResolve(C, x);
};

'use strict';

var $TypeError = require('es-errors/type');

var callBound = require('call-bound');
var forEach = require('../helpers/forEach');
var isLeadingSurrogate = require('../helpers/isLeadingSurrogate');
var isTrailingSurrogate = require('../helpers/isTrailingSurrogate');

var $charCodeAt = callBound('String.prototype.charCodeAt');
var $strSplit = callBound('String.prototype.split');

var StringToCodePoints = require('./StringToCodePoints');
var UnicodeEscape = require('./UnicodeEscape');
var UTF16EncodeCodePoint = require('./UTF16EncodeCodePoint');

var hasOwn = require('hasown');

// https://262.ecma-international.org/12.0/#sec-quotejsonstring

var escapes = {
	'\u0008': '\\b',
	'\u0009': '\\t',
	'\u000A': '\\n',
	'\u000C': '\\f',
	'\u000D': '\\r',
	'\u0022': '\\"',
	'\u005c': '\\\\'
};

module.exports = function QuoteJSONString(value) {
	if (typeof value !== 'string') {
		throw new $TypeError('Assertion failed: `value` must be a String');
	}
	var product = '"';
	if (value) {
		forEach($strSplit(StringToCodePoints(value), ''), function (C) {
			if (hasOwn(escapes, C)) {
				product += escapes[C];
			} else {
				var cCharCode = $charCodeAt(C, 0);
				if (cCharCode < 0x20 || isLeadingSurrogate(cCharCode) || isTrailingSurrogate(cCharCode)) {
					product += UnicodeEscape(C);
				} else {
					product += UTF16EncodeCodePoint(cCharCode);
				}
			}
		});
	}
	product += '"';
	return product;
};
'use strict';

var GetIntrinsic = require('get-intrinsic');
var callBound = require('call-bound');

var $RangeError = require('es-errors/range');
var $SyntaxError = require('es-errors/syntax');
var $TypeError = require('es-errors/type');
var $BigInt = GetIntrinsic('%BigInt%', true);

var hasOwnProperty = require('./HasOwnProperty');
var IsArray = require('./IsArray');
var IsBigIntElementType = require('./IsBigIntElementType');
var IsUnsignedElementType = require('./IsUnsignedElementType');

var bytesAsFloat32 = require('../helpers/bytesAsFloat32');
var bytesAsFloat64 = require('../helpers/bytesAsFloat64');
var bytesAsInteger = require('../helpers/bytesAsInteger');
var every = require('../helpers/every');
var isByteValue = require('../helpers/isByteValue');

var $reverse = callBound('Array.prototype.reverse');
var $slice = callBound('Array.prototype.slice');

var tableTAO = require('./tables/typed-array-objects');

// https://262.ecma-international.org/11.0/#sec-rawbytestonumeric

module.exports = function RawBytesToNumeric(type, rawBytes, isLittleEndian) {
	if (typeof type !== 'string' || !hasOwnProperty(tableTAO.size, '$' + type)) {
		throw new $TypeError('Assertion failed: `type` must be a TypedArray element type');
	}
	if (!IsArray(rawBytes) || !every(rawBytes, isByteValue)) {
		throw new $TypeError('Assertion failed: `rawBytes` must be an Array of bytes');
	}
	if (typeof isLittleEndian !== 'boolean') {
		throw new $TypeError('Assertion failed: `isLittleEndian` must be a Boolean');
	}

	var elementSize = tableTAO.size['$' + type]; // step 1

	if (rawBytes.length !== elementSize) {
		// this assertion is not in the spec, but it'd be an editorial error if it were ever violated
		throw new $RangeError('Assertion failed: `rawBytes` must have a length of ' + elementSize + ' for type ' + type);
	}

	var isBigInt = IsBigIntElementType(type);
	if (isBigInt && !$BigInt) {
		throw new $SyntaxError('this environment does not support BigInts');
	}

	// eslint-disable-next-line no-param-reassign
	rawBytes = $slice(rawBytes, 0, elementSize);
	if (!isLittleEndian) {
		$reverse(rawBytes); // step 2
	}

	if (type === 'Float32') { // step 3
		return bytesAsFloat32(rawBytes);
	}

	if (type === 'Float64') { // step 4
		return bytesAsFloat64(rawBytes);
	}

	return bytesAsInteger(rawBytes, elementSize, IsUnsignedElementType(type), isBigInt);
};
'use strict';

var GetIntrinsic = require('get-intrinsic');

var $RegExp = GetIntrinsic('%RegExp%');

// var RegExpAlloc = require('./RegExpAlloc');
// var RegExpInitialize = require('./RegExpInitialize');
var ToString = require('./ToString');

// https://262.ecma-international.org/6.0/#sec-regexpcreate

module.exports = function RegExpCreate(P, F) {
	// var obj = RegExpAlloc($RegExp);
	// return RegExpInitialize(obj, P, F);

	// covers spec mechanics; bypass regex brand checking
	var pattern = typeof P === 'undefined' ? '' : ToString(P);
	var flags = typeof F === 'undefined' ? '' : ToString(F);
	return new $RegExp(pattern, flags);
};
'use strict';

var $TypeError = require('es-errors/type');
var isObject = require('es-object-atoms/isObject');
var regexExec = require('call-bound')('RegExp.prototype.exec');

var Call = require('./Call');
var Get = require('./Get');
var IsCallable = require('./IsCallable');

// https://262.ecma-international.org/6.0/#sec-regexpexec

module.exports = function RegExpExec(R, S) {
	if (!isObject(R)) {
		throw new $TypeError('Assertion failed: `R` must be an Object');
	}
	if (typeof S !== 'string') {
		throw new $TypeError('Assertion failed: `S` must be a String');
	}
	var exec = Get(R, 'exec');
	if (IsCallable(exec)) {
		var result = Call(exec, R, [S]);
		if (result === null || isObject(result)) {
			return result;
		}
		throw new $TypeError('"exec" method must return `null` or an Object');
	}
	return regexExec(R, S);
};
'use strict';

var GetIntrinsic = require('get-intrinsic');
var callBound = require('call-bound');

var $TypeError = require('es-errors/type');
var isObject = require('es-object-atoms/isObject');
var $RegExpPrototype = GetIntrinsic('%RegExp.prototype%');

var SameValue = require('./SameValue');

var $indexOf = callBound('String.prototype.indexOf');

var hasRegExpMatcher = require('is-regex');
var getFlags = require('regexp.prototype.flags');

// https://262.ecma-international.org/13.0/#sec-regexphasflag

module.exports = function RegExpHasFlag(R, codeUnit) {
	if (typeof codeUnit !== 'string' || codeUnit.length !== 1) {
		throw new $TypeError('Assertion failed: `string` must be a code unit - a String of length 1');
	}

	if (!isObject(R)) {
		throw new $TypeError('Assertion failed: Type(R) is not Object');
	}

	if (!hasRegExpMatcher(R)) { // step 2
		if (SameValue(R, $RegExpPrototype)) {
			return void undefined; // step 2.a
		}
		throw new $TypeError('`R` must be a RegExp object'); // step 2.b
	}

	var flags = getFlags(R); // step 3

	return $indexOf(flags, codeUnit) > -1; // steps 4-5
};
'use strict';

module.exports = require('es-object-atoms/RequireObjectCoercible');
'use strict';

var $isNaN = require('math-intrinsics/isNaN');

// http://262.ecma-international.org/5.1/#sec-9.12

module.exports = function SameValue(x, y) {
	if (x === y) { // 0 === -0, but they are not identical.
		if (x === 0) { return 1 / x === 1 / y; }
		return true;
	}
	return $isNaN(x) && $isNaN(y);
};
'use strict';

var $TypeError = require('es-errors/type');

var SameValue = require('./SameValue');
var Type = require('./Type');

// https://262.ecma-international.org/14.0/#sec-samevaluenonnumeric

module.exports = function SameValueNonNumber(x, y) {
	if (typeof x === 'number') {
		throw new $TypeError('Assertion failed: SameValueNonNumber does not accept Number values');
	}
	if (Type(x) !== Type(y)) {
		throw new $TypeError('SameValueNonNumber requires two non-Number values of the same type.');
	}
	return SameValue(x, y);
};
'use strict';

var $isNaN = require('math-intrinsics/isNaN');

// https://262.ecma-international.org/6.0/#sec-samevaluezero

module.exports = function SameValueZero(x, y) {
	return (x === y) || ($isNaN(x) && $isNaN(y));
};
'use strict';

var floor = require('./floor');
var modulo = require('./modulo');

var timeConstants = require('../helpers/timeConstants');
var msPerSecond = timeConstants.msPerSecond;
var SecondsPerMinute = timeConstants.SecondsPerMinute;

// https://262.ecma-international.org/5.1/#sec-15.9.1.10

module.exports = function SecFromTime(t) {
	return modulo(floor(t / msPerSecond), SecondsPerMinute);
};
'use strict';

var $TypeError = require('es-errors/type');
var isInteger = require('math-intrinsics/isInteger');

var DefinePropertyOrThrow = require('./DefinePropertyOrThrow');
var HasOwnProperty = require('./HasOwnProperty');
var IsExtensible = require('./IsExtensible');

// https://262.ecma-international.org/12.0/#sec-setfunctionlength

module.exports = function SetFunctionLength(F, length) {
	if (typeof F !== 'function' || !IsExtensible(F) || HasOwnProperty(F, 'length')) {
		throw new $TypeError('Assertion failed: `F` must be an extensible function and lack an own `length` property');
	}
	if (typeof length !== 'number') {
		throw new $TypeError('Assertion failed: `length` must be a Number');
	}
	if (length !== Infinity && (!isInteger(length) || length < 0)) {
		throw new $TypeError('Assertion failed: `length` must be ∞, or an integer >= 0');
	}
	return DefinePropertyOrThrow(F, 'length', {
		'[[Configurable]]': true,
		'[[Enumerable]]': false,
		'[[Value]]': length,
		'[[Writable]]': false
	});
};
'use strict';

var hasOwn = require('hasown');

var $TypeError = require('es-errors/type');

var getSymbolDescription = require('get-symbol-description');

var DefinePropertyOrThrow = require('./DefinePropertyOrThrow');
var IsExtensible = require('./IsExtensible');

// https://262.ecma-international.org/6.0/#sec-setfunctionname

module.exports = function SetFunctionName(F, name) {
	if (typeof F !== 'function') {
		throw new $TypeError('Assertion failed: `F` must be a function');
	}
	if (!IsExtensible(F) || hasOwn(F, 'name')) {
		throw new $TypeError('Assertion failed: `F` must be extensible, and must not have a `name` own property');
	}
	if (typeof name !== 'symbol' && typeof name !== 'string') {
		throw new $TypeError('Assertion failed: `name` must be a Symbol or a String');
	}
	if (typeof name === 'symbol') {
		var description = getSymbolDescription(name);
		// eslint-disable-next-line no-param-reassign
		name = typeof description === 'undefined' ? '' : '[' + description + ']';
	}
	if (arguments.length > 2) {
		var prefix = arguments[2];
		// eslint-disable-next-line no-param-reassign
		name = prefix + ' ' + name;
	}
	return DefinePropertyOrThrow(F, 'name', {
		'[[Value]]': name,
		'[[Writable]]': false,
		'[[Enumerable]]': false,
		'[[Configurable]]': true
	});
};
'use strict';

var GetIntrinsic = require('get-intrinsic');

var $SyntaxError = require('es-errors/syntax');
var $TypeError = require('es-errors/type');
var isObject = require('es-object-atoms/isObject');
var $gOPD = require('gopd');
var $preventExtensions = GetIntrinsic('%Object.preventExtensions%', true);
var $gOPN = GetIntrinsic('%Object.getOwnPropertyNames%', true);

var forEach = require('../helpers/forEach');

var DefinePropertyOrThrow = require('./DefinePropertyOrThrow');
var IsAccessorDescriptor = require('./IsAccessorDescriptor');
var ToPropertyDescriptor = require('./ToPropertyDescriptor');

// https://262.ecma-international.org/6.0/#sec-setintegritylevel

module.exports = function SetIntegrityLevel(O, level) {
	if (!isObject(O)) {
		throw new $TypeError('Assertion failed: Type(O) is not Object');
	}
	if (level !== 'sealed' && level !== 'frozen') {
		throw new $TypeError('Assertion failed: `level` must be `"sealed"` or `"frozen"`');
	}
	if (!$preventExtensions) {
		throw new $SyntaxError('SetIntegrityLevel requires native `Object.preventExtensions` support');
	}
	var status = $preventExtensions(O);
	if (!status) {
		return false;
	}
	if (!$gOPN) {
		throw new $SyntaxError('SetIntegrityLevel requires native `Object.getOwnPropertyNames` support');
	}
	var theKeys = $gOPN(O);
	if (level === 'sealed') {
		forEach(theKeys, function (k) {
			DefinePropertyOrThrow(O, k, { configurable: false });
		});
	} else if (level === 'frozen') {
		forEach(theKeys, function (k) {
			var currentDesc = $gOPD(O, k);
			if (typeof currentDesc !== 'undefined') {
				var desc;
				if (IsAccessorDescriptor(ToPropertyDescriptor(currentDesc))) {
					desc = { configurable: false };
				} else {
					desc = { configurable: false, writable: false };
				}
				DefinePropertyOrThrow(O, k, desc);
			}
		});
	}
	return true;
};
'use strict';

var $TypeError = require('es-errors/type');
var isObject = require('es-object-atoms/isObject');

var isPropertyKey = require('../helpers/isPropertyKey');
var SameValue = require('./SameValue');

// IE 9 does not throw in strict mode when writability/configurability/extensibility is violated
var noThrowOnStrictViolation = (function () {
	try {
		delete [].length;
		return true;
	} catch (e) {
		return false;
	}
}());

// https://262.ecma-international.org/6.0/#sec-set-o-p-v-throw

module.exports = function Set(O, P, V, Throw) {
	if (!isObject(O)) {
		throw new $TypeError('Assertion failed: `O` must be an Object');
	}
	if (!isPropertyKey(P)) {
		throw new $TypeError('Assertion failed: `P` must be a Property Key');
	}
	if (typeof Throw !== 'boolean') {
		throw new $TypeError('Assertion failed: `Throw` must be a Boolean');
	}
	if (Throw) {
		O[P] = V; // eslint-disable-line no-param-reassign
		if (noThrowOnStrictViolation && !SameValue(O[P], V)) {
			throw new $TypeError('Attempted to assign to readonly property.');
		}
		return true;
	}
	try {
		O[P] = V; // eslint-disable-line no-param-reassign
		return noThrowOnStrictViolation ? SameValue(O[P], V) : true;
	} catch (e) {
		return false;
	}

};
'use strict';

var $RangeError = require('es-errors/range');
var $TypeError = require('es-errors/type');
var isInteger = require('math-intrinsics/isInteger');

var isTypedArray = require('is-typed-array');
var typedArrayBuffer = require('typed-array-buffer');
var typedArrayLength = require('typed-array-length');
var whichTypedArray = require('which-typed-array');

var Get = require('./Get');
var IntegerIndexedElementSet = require('./IntegerIndexedElementSet');
var IsDetachedBuffer = require('./IsDetachedBuffer');
var LengthOfArrayLike = require('./LengthOfArrayLike');
var ToObject = require('./ToObject');
var ToString = require('./ToString');

// https://262.ecma-international.org/14.0/#sec-settypedarrayfromarraylike

module.exports = function SetTypedArrayFromArrayLike(target, targetOffset, source) {
	var whichTarget = whichTypedArray(target);
	if (!whichTarget) {
		throw new $TypeError('Assertion failed: target must be a TypedArray instance');
	}

	if (targetOffset !== Infinity && (!isInteger(targetOffset) || targetOffset < 0)) {
		throw new $TypeError('Assertion failed: targetOffset must be a non-negative integer or +Infinity');
	}

	if (isTypedArray(source)) {
		throw new $TypeError('Assertion failed: source must not be a TypedArray instance');
	}

	var targetBuffer = typedArrayBuffer(target); // step 1

	if (IsDetachedBuffer(targetBuffer)) {
		throw new $TypeError('target’s buffer is detached'); // step 2
	}

	var targetLength = typedArrayLength(target); // step 3

	var src = ToObject(source); // step 4

	var srcLength = LengthOfArrayLike(src); // step 5

	if (targetOffset === Infinity) {
		throw new $RangeError('targetOffset must be a finite integer'); // step 6
	}

	if (srcLength + targetOffset > targetLength) {
		throw new $RangeError('targetOffset + srcLength must be <= target.length'); // step 7
	}

	var k = 0; // step 8

	while (k < srcLength) { // step 9
		var Pk = ToString(k); // step 9.a

		var value = Get(src, Pk); // step 9.b

		var targetIndex = targetOffset + k; // step 9.c

		IntegerIndexedElementSet(target, targetIndex, value); // step 9.d

		k += 1; // step 9.e
	}
};
'use strict';

var $RangeError = require('es-errors/range');
var $SyntaxError = require('es-errors/syntax');
var $TypeError = require('es-errors/type');
var GetIntrinsic = require('get-intrinsic');
var isInteger = require('math-intrinsics/isInteger');
var typedArrayBuffer = require('typed-array-buffer');
var typedArrayByteLength = require('typed-array-byte-length');
var typedArrayByteOffset = require('typed-array-byte-offset');
var typedArrayLength = require('typed-array-length');
var whichTypedArray = require('which-typed-array');

var CloneArrayBuffer = require('./CloneArrayBuffer');
var GetValueFromBuffer = require('./GetValueFromBuffer');
var IsDetachedBuffer = require('./IsDetachedBuffer');
var IsSharedArrayBuffer = require('./IsSharedArrayBuffer');
var SameValue = require('./SameValue');
var SetValueInBuffer = require('./SetValueInBuffer');
var TypedArrayElementSize = require('./TypedArrayElementSize');
var TypedArrayElementType = require('./TypedArrayElementType');

var $ArrayBuffer = GetIntrinsic('%ArrayBuffer%', true);

// https://262.ecma-international.org/14.0/#sec-settypedarrayfromtypedarray

module.exports = function SetTypedArrayFromTypedArray(target, targetOffset, source) {
	var whichTarget = whichTypedArray(target);
	if (!whichTarget) {
		throw new $TypeError('Assertion failed: target must be a TypedArray instance');
	}

	if (targetOffset !== Infinity && (!isInteger(targetOffset) || targetOffset < 0)) {
		throw new $TypeError('Assertion failed: targetOffset must be a non-negative integer or +Infinity');
	}

	var whichSource = whichTypedArray(source);
	if (!whichSource) {
		throw new $TypeError('Assertion failed: source must be a TypedArray instance');
	}

	var targetBuffer = typedArrayBuffer(target); // step 1

	if (IsDetachedBuffer(targetBuffer)) {
		throw new $TypeError('target’s buffer is detached'); // step 2
	}

	var targetLength = typedArrayLength(target); // step 3

	var srcBuffer = typedArrayBuffer(source); // step 4

	if (IsDetachedBuffer(srcBuffer)) {
		throw new $TypeError('source’s buffer is detached'); // step 5
	}

	var targetType = TypedArrayElementType(target); // step 6

	var targetElementSize = TypedArrayElementSize(target); // step 7

	var targetByteOffset = typedArrayByteOffset(target); // step 8

	var srcType = TypedArrayElementType(source); // step 9

	var srcElementSize = TypedArrayElementSize(source); // step 10

	var srcLength = typedArrayLength(source); // step 11

	var srcByteOffset = typedArrayByteOffset(source); // step 12

	if (targetOffset === Infinity) {
		throw new $RangeError('targetOffset must be a non-negative integer or +Infinity'); // step 13
	}

	if (srcLength + targetOffset > targetLength) {
		throw new $RangeError('targetOffset + source.length must not be greater than target.length'); // step 14
	}

	var targetContentType = whichTarget === 'BigInt64Array' || whichTarget === 'BigUint64Array' ? 'BigInt' : 'Number';
	var sourceContentType = whichSource === 'BigInt64Array' || whichSource === 'BigUint64Array' ? 'BigInt' : 'Number';
	if (targetContentType !== sourceContentType) {
		throw new $TypeError('source and target must have the same content type'); // step 15
	}

	var sameSharedArrayBuffer = false;
	if (IsSharedArrayBuffer(srcBuffer) && IsSharedArrayBuffer(targetBuffer)) { // step 16
		// a. If srcBuffer.[[ArrayBufferData]] and targetBuffer.[[ArrayBufferData]] are the same Shared Data Block values, let same be true; else let same be false.
		throw new $SyntaxError('SharedArrayBuffer is not supported by this implementation');
	}

	var srcByteIndex;
	if (SameValue(srcBuffer, targetBuffer) || sameSharedArrayBuffer) { // step 17
		var srcByteLength = typedArrayByteLength(source); // step 17.a

		srcBuffer = CloneArrayBuffer(srcBuffer, srcByteOffset, srcByteLength, $ArrayBuffer); // step 17.b

		srcByteIndex = 0; // step 17.c
	} else {
		srcByteIndex = srcByteOffset; // step 18
	}

	var targetByteIndex = (targetOffset * targetElementSize) + targetByteOffset; // step 19

	var limit = targetByteIndex + (targetElementSize * srcLength); // step 20

	var value;
	if (srcType === targetType) { // step 21
		// a. NOTE: The transfer must be performed in a manner that preserves the bit-level encoding of the source data.

		while (targetByteIndex < limit) { // step 21.b
			value = GetValueFromBuffer(srcBuffer, srcByteIndex, 'Uint8', true, 'Unordered'); // step 21.b.i

			SetValueInBuffer(targetBuffer, targetByteIndex, 'Uint8', value, true, 'Unordered'); // step 21.b.ii

			srcByteIndex += 1; // step 21.b.iii

			targetByteIndex += 1; // step 21.b.iv
		}
	} else { // step 22
		while (targetByteIndex < limit) { // step 22.a
			value = GetValueFromBuffer(srcBuffer, srcByteIndex, srcType, true, 'Unordered'); // step 22.a.i

			SetValueInBuffer(targetBuffer, targetByteIndex, targetType, value, true, 'Unordered'); // step 22.a.ii

			srcByteIndex += srcElementSize; // step 22.a.iii

			targetByteIndex += targetElementSize; // step 22.a.iv
		}
	}
};
'use strict';

var GetIntrinsic = require('get-intrinsic');

var $SyntaxError = require('es-errors/syntax');
var $TypeError = require('es-errors/type');
var isInteger = require('math-intrinsics/isInteger');
var $Uint8Array = GetIntrinsic('%Uint8Array%', true);

var IsBigIntElementType = require('./IsBigIntElementType');
var IsDetachedBuffer = require('./IsDetachedBuffer');
var NumericToRawBytes = require('./NumericToRawBytes');

var isArrayBuffer = require('is-array-buffer');
var isSharedArrayBuffer = require('is-shared-array-buffer');
var hasOwn = require('hasown');

var tableTAO = require('./tables/typed-array-objects');

var defaultEndianness = require('../helpers/defaultEndianness');
var forEach = require('../helpers/forEach');

// https://262.ecma-international.org/12.0/#sec-setvalueinbuffer

/* eslint max-params: 0 */

module.exports = function SetValueInBuffer(arrayBuffer, byteIndex, type, value, isTypedArray, order) {
	var isSAB = isSharedArrayBuffer(arrayBuffer);
	if (!isArrayBuffer(arrayBuffer) && !isSAB) {
		throw new $TypeError('Assertion failed: `arrayBuffer` must be an ArrayBuffer or a SharedArrayBuffer');
	}

	if (!isInteger(byteIndex) || byteIndex < 0) {
		throw new $TypeError('Assertion failed: `byteIndex` must be a non-negative integer');
	}

	if (typeof type !== 'string' || !hasOwn(tableTAO.size, '$' + type)) {
		throw new $TypeError('Assertion failed: `type` must be one of ' + tableTAO.choices);
	}

	if (typeof value !== 'number' && typeof value !== 'bigint') {
		throw new $TypeError('Assertion failed: `value` must be a Number or a BigInt');
	}

	if (typeof isTypedArray !== 'boolean') {
		throw new $TypeError('Assertion failed: `isTypedArray` must be a boolean');
	}
	if (order !== 'SeqCst' && order !== 'Unordered' && order !== 'Init') {
		throw new $TypeError('Assertion failed: `order` must be `"SeqCst"`, `"Unordered"`, or `"Init"`');
	}

	if (arguments.length > 6 && typeof arguments[6] !== 'boolean') {
		throw new $TypeError('Assertion failed: `isLittleEndian` must be a boolean, if present');
	}

	if (IsDetachedBuffer(arrayBuffer)) {
		throw new $TypeError('Assertion failed: ArrayBuffer is detached'); // step 1
	}

	// 2. Assert: There are sufficient bytes in arrayBuffer starting at byteIndex to represent a value of type.

	if (IsBigIntElementType(type) ? typeof value !== 'bigint' : typeof value !== 'number') { // step 3
		throw new $TypeError('Assertion failed: `value` must be a BigInt if type is BigInt64 or BigUint64, otherwise a Number');
	}

	// 4. Let block be arrayBuffer’s [[ArrayBufferData]] internal slot.

	var elementSize = tableTAO.size['$' + type]; // step 5

	// 6. If isLittleEndian is not present, set isLittleEndian to either true or false. The choice is implementation dependent and should be the alternative that is most efficient for the implementation. An implementation must use the same value each time this step is executed and the same value must be used for the corresponding step in the GetValueFromBuffer abstract operation.
	var isLittleEndian = arguments.length > 6 ? arguments[6] : defaultEndianness === 'little'; // step 6

	var rawBytes = NumericToRawBytes(type, value, isLittleEndian); // step 7

	if (isSAB) { // step 8
		/*
			Let execution be the [[CandidateExecution]] field of the surrounding agent's Agent Record.
			Let eventList be the [[EventList]] field of the element in execution.[[EventsRecords]] whose [[AgentSignifier]] is AgentSignifier().
			If isTypedArray is true and IsNoTearConfiguration(type, order) is true, let noTear be true; otherwise let noTear be false.
			Append WriteSharedMemory { [[Order]]: order, [[NoTear]]: noTear, [[Block]]: block, [[ByteIndex]]: byteIndex, [[ElementSize]]: elementSize, [[Payload]]: rawBytes } to eventList.
		*/
		throw new $SyntaxError('SharedArrayBuffer is not supported by this implementation');
	} else {
		// 9. Store the individual bytes of rawBytes into block, in order, starting at block[byteIndex].
		var arr = new $Uint8Array(arrayBuffer, byteIndex, elementSize);
		forEach(rawBytes, function (rawByte, i) {
			arr[i] = rawByte;
		});
	}

	// 10. Return NormalCompletion(undefined).
};
'use strict';

var $TypeError = require('es-errors/type');
var callBound = require('call-bound');
var isInteger = require('math-intrinsics/isInteger');
var isObject = require('es-object-atoms/isObject');

var Get = require('./Get');
var HasProperty = require('./HasProperty');
var ToString = require('./ToString');

var isAbstractClosure = require('../helpers/isAbstractClosure');

var $sort = callBound('Array.prototype.sort');

// https://262.ecma-international.org/14.0/#sec-sortindexedproperties

module.exports = function SortIndexedProperties(obj, len, SortCompare, holes) {
	if (!isObject(obj)) {
		throw new $TypeError('Assertion failed: Type(obj) is not Object');
	}
	if (!isInteger(len) || len < 0) {
		throw new $TypeError('Assertion failed: `len` must be an integer >= 0');
	}
	if (!isAbstractClosure(SortCompare) || SortCompare.length !== 2) {
		throw new $TypeError('Assertion failed: `SortCompare` must be an abstract closure taking 2 arguments');
	}
	if (holes !== 'skip-holes' && holes !== 'read-through-holes') {
		throw new $TypeError('Assertion failed: `holes` must be either ~skip-holes~ or ~read-through-holes~');
	}

	var items = []; // step 1

	var k = 0; // step 2

	while (k < len) { // step 3
		var Pk = ToString(k);
		var kRead = holes === 'skip-holes' ? HasProperty(obj, Pk) : true; // step 3.b - 3.c
		if (kRead) { // step 3.d
			var kValue = Get(obj, Pk);
			items[items.length] = kValue;
		}
		k += 1; // step 3.e
	}

	$sort(items, SortCompare); // step 4

	return items; // step 5
};
'use strict';

var GetIntrinsic = require('get-intrinsic');

var $species = GetIntrinsic('%Symbol.species%', true);
var $TypeError = require('es-errors/type');
var isObject = require('es-object-atoms/isObject');

var IsConstructor = require('./IsConstructor');

// https://262.ecma-international.org/6.0/#sec-speciesconstructor

module.exports = function SpeciesConstructor(O, defaultConstructor) {
	if (!isObject(O)) {
		throw new $TypeError('Assertion failed: Type(O) is not Object');
	}
	var C = O.constructor;
	if (typeof C === 'undefined') {
		return defaultConstructor;
	}
	if (!isObject(C)) {
		throw new $TypeError('O.constructor is not an Object');
	}
	var S = $species ? C[$species] : void 0;
	if (S == null) {
		return defaultConstructor;
	}
	if (IsConstructor(S)) {
		return S;
	}
	throw new $TypeError('no constructor found');
};
'use strict';

var GetIntrinsic = require('get-intrinsic');

var $Object = require('es-object-atoms');
var $StringPrototype = GetIntrinsic('%String.prototype%');
var $SyntaxError = require('es-errors/syntax');
var $TypeError = require('es-errors/type');
var setProto = require('set-proto');

var DefinePropertyOrThrow = require('./DefinePropertyOrThrow');

// https://262.ecma-international.org/6.0/#sec-stringcreate

module.exports = function StringCreate(value, prototype) {
	if (typeof value !== 'string') {
		throw new $TypeError('Assertion failed: `S` must be a String');
	}

	var S = $Object(value);
	if (prototype !== $StringPrototype) {
		if (setProto) {
			setProto(S, prototype);
		} else {
			throw new $SyntaxError('StringCreate: a `proto` argument that is not `String.prototype` is not supported in an environment that does not support setting the [[Prototype]]');
		}
	}

	var length = value.length;
	DefinePropertyOrThrow(S, 'length', {
		'[[Configurable]]': false,
		'[[Enumerable]]': false,
		'[[Value]]': length,
		'[[Writable]]': false
	});

	return S;
};
'use strict';

var $TypeError = require('es-errors/type');
var isNegativeZero = require('math-intrinsics/isNegativeZero');
var isObject = require('es-object-atoms/isObject');

var callBound = require('call-bound');
var $charAt = callBound('String.prototype.charAt');
var $stringToString = callBound('String.prototype.toString');

var CanonicalNumericIndexString = require('./CanonicalNumericIndexString');

var isPropertyKey = require('../helpers/isPropertyKey');
var isInteger = require('math-intrinsics/isInteger');

// https://262.ecma-international.org/12.0/#sec-stringgetownproperty

module.exports = function StringGetOwnProperty(S, P) {
	var str;
	if (isObject(S)) {
		try {
			str = $stringToString(S);
		} catch (e) { /**/ }
	}
	if (typeof str !== 'string') {
		throw new $TypeError('Assertion failed: `S` must be a boxed string object');
	}
	if (!isPropertyKey(P)) {
		throw new $TypeError('Assertion failed: P is not a Property Key');
	}
	if (typeof P !== 'string') {
		return void undefined;
	}
	var index = CanonicalNumericIndexString(P);
	var len = str.length;
	if (typeof index === 'undefined' || !isInteger(index) || isNegativeZero(index) || index < 0 || len <= index) {
		return void undefined;
	}
	var resultStr = $charAt(S, index);
	return {
		'[[Configurable]]': false,
		'[[Enumerable]]': true,
		'[[Value]]': resultStr,
		'[[Writable]]': false
	};
};
'use strict';

var callBound = require('call-bound');

var $TypeError = require('es-errors/type');
var isInteger = require('math-intrinsics/isInteger');

var $slice = callBound('String.prototype.slice');

// https://262.ecma-international.org/12.0/#sec-stringindexof

module.exports = function StringIndexOf(string, searchValue, fromIndex) {
	if (typeof string !== 'string') {
		throw new $TypeError('Assertion failed: `string` must be a String');
	}
	if (typeof searchValue !== 'string') {
		throw new $TypeError('Assertion failed: `searchValue` must be a String');
	}
	if (!isInteger(fromIndex) || fromIndex < 0) {
		throw new $TypeError('Assertion failed: `fromIndex` must be a non-negative integer');
	}

	var len = string.length;
	if (searchValue === '' && fromIndex <= len) {
		return fromIndex;
	}

	var searchLen = searchValue.length;
	for (var i = fromIndex; i <= (len - searchLen); i += 1) {
		var candidate = $slice(string, i, i + searchLen);
		if (candidate === searchValue) {
			return i;
		}
	}
	return -1;
};
'use strict';

var $TypeError = require('es-errors/type');

var callBound = require('call-bound');

var ToLength = require('./ToLength');
var ToString = require('./ToString');

var $strSlice = callBound('String.prototype.slice');

// https://262.ecma-international.org/11.0/#sec-stringpad

module.exports = function StringPad(O, maxLength, fillString, placement) {
	if (placement !== 'start' && placement !== 'end') {
		throw new $TypeError('Assertion failed: `placement` must be "start" or "end"');
	}
	var S = ToString(O);
	var intMaxLength = ToLength(maxLength);
	var stringLength = S.length;
	if (intMaxLength <= stringLength) {
		return S;
	}
	var filler = typeof fillString === 'undefined' ? ' ' : ToString(fillString);
	if (filler === '') {
		return S;
	}
	var fillLen = intMaxLength - stringLength;

	// the String value consisting of repeated concatenations of filler truncated to length fillLen.
	var truncatedStringFiller = '';
	while (truncatedStringFiller.length < fillLen) {
		truncatedStringFiller += filler;
	}
	truncatedStringFiller = $strSlice(truncatedStringFiller, 0, fillLen);

	if (placement === 'start') {
		return truncatedStringFiller + S;
	}
	return S + truncatedStringFiller;
};
'use strict';

var GetIntrinsic = require('get-intrinsic');

var $BigInt = GetIntrinsic('%BigInt%', true);
var $TypeError = require('es-errors/type');
var $SyntaxError = require('es-errors/syntax');

// https://262.ecma-international.org/14.0/#sec-stringtobigint

module.exports = function StringToBigInt(argument) {
	if (typeof argument !== 'string') {
		throw new $TypeError('`argument` must be a string');
	}
	if (!$BigInt) {
		throw new $SyntaxError('BigInts are not supported in this environment');
	}
	try {
		return $BigInt(argument);
	} catch (e) {
		return void undefined;
	}
};
'use strict';

var $TypeError = require('es-errors/type');

var CodePointAt = require('./CodePointAt');

// https://262.ecma-international.org/12.0/#sec-stringtocodepoints

module.exports = function StringToCodePoints(string) {
	if (typeof string !== 'string') {
		throw new $TypeError('Assertion failed: `string` must be a String');
	}
	var codePoints = [];
	var size = string.length;
	var position = 0;
	while (position < size) {
		var cp = CodePointAt(string, position);
		codePoints[codePoints.length] = cp['[[CodePoint]]'];
		position += cp['[[CodeUnitCount]]'];
	}
	return codePoints;
};
'use strict';

var GetIntrinsic = require('get-intrinsic');

var $RegExp = GetIntrinsic('%RegExp%');
var $TypeError = require('es-errors/type');
var $parseInteger = GetIntrinsic('%parseInt%');

var callBound = require('call-bound');
var regexTester = require('safe-regex-test');

var $strSlice = callBound('String.prototype.slice');
var isBinary = regexTester(/^0b[01]+$/i);
var isOctal = regexTester(/^0o[0-7]+$/i);
var isInvalidHexLiteral = regexTester(/^[-+]0x[0-9a-f]+$/i);
var nonWS = ['\u0085', '\u200b', '\ufffe'].join('');
var nonWSregex = new $RegExp('[' + nonWS + ']', 'g');
var hasNonWS = regexTester(nonWSregex);

var $trim = require('string.prototype.trim');

// https://262.ecma-international.org/13.0/#sec-stringtonumber

module.exports = function StringToNumber(argument) {
	if (typeof argument !== 'string') {
		throw new $TypeError('Assertion failed: `argument` is not a String');
	}
	if (isBinary(argument)) {
		return +$parseInteger($strSlice(argument, 2), 2);
	}
	if (isOctal(argument)) {
		return +$parseInteger($strSlice(argument, 2), 8);
	}
	if (hasNonWS(argument) || isInvalidHexLiteral(argument)) {
		return NaN;
	}
	var trimmed = $trim(argument);
	if (trimmed !== argument) {
		return StringToNumber(trimmed);
	}
	return +argument;
};
'use strict';

var $TypeError = require('es-errors/type');
var isInteger = require('math-intrinsics/isInteger');
var callBound = require('call-bound');

var $slice = callBound('String.prototype.slice');

// https://262.ecma-international.org/12.0/#substring
module.exports = function substring(S, inclusiveStart, exclusiveEnd) {
	if (typeof S !== 'string' || !isInteger(inclusiveStart) || (arguments.length > 2 && !isInteger(exclusiveEnd))) {
		throw new $TypeError('`S` must be a String, and `inclusiveStart` and `exclusiveEnd` must be integers');
	}
	return $slice(S, inclusiveStart, arguments.length > 2 ? exclusiveEnd : S.length);
};
'use strict';

var $TypeError = require('es-errors/type');

var callBound = require('call-bound');

var $SymbolToString = callBound('Symbol.prototype.toString', true);

// https://262.ecma-international.org/6.0/#sec-symboldescriptivestring

module.exports = function SymbolDescriptiveString(sym) {
	if (typeof sym !== 'symbol') {
		throw new $TypeError('Assertion failed: `sym` must be a Symbol');
	}
	return $SymbolToString(sym);
};
'use strict';

var $gOPD = require('gopd');
var $TypeError = require('es-errors/type');

var every = require('../helpers/every');
var OwnPropertyKeys = require('own-keys');
var isObject = require('es-object-atoms/isObject');

var IsDataDescriptor = require('./IsDataDescriptor');
var IsExtensible = require('./IsExtensible');
var ToPropertyDescriptor = require('./ToPropertyDescriptor');

// https://262.ecma-international.org/6.0/#sec-testintegritylevel

module.exports = function TestIntegrityLevel(O, level) {
	if (!isObject(O)) {
		throw new $TypeError('Assertion failed: Type(O) is not Object');
	}
	if (level !== 'sealed' && level !== 'frozen') {
		throw new $TypeError('Assertion failed: `level` must be `"sealed"` or `"frozen"`');
	}
	var status = IsExtensible(O);
	if (status || !$gOPD) {
		return false;
	}
	var theKeys = OwnPropertyKeys(O);
	return theKeys.length === 0 || every(theKeys, function (k) {
		var currentDesc = $gOPD(O, k);
		if (typeof currentDesc !== 'undefined') {
			if (currentDesc.configurable) {
				return false;
			}
			if (level === 'frozen' && IsDataDescriptor(ToPropertyDescriptor(currentDesc)) && currentDesc.writable) {
				return false;
			}
		}
		return true;
	});
};
'use strict';

var callBound = require('call-bound');

var $SyntaxError = require('es-errors/syntax');
var $bigIntValueOf = callBound('BigInt.prototype.valueOf', true);

// https://262.ecma-international.org/11.0/#sec-thisbigintvalue

module.exports = function thisBigIntValue(value) {
	if (typeof value === 'bigint') {
		return value;
	}
	if (!$bigIntValueOf) {
		throw new $SyntaxError('BigInt is not supported');
	}
	return $bigIntValueOf(value);
};
'use strict';

var $BooleanValueOf = require('call-bound')('Boolean.prototype.valueOf');

// https://262.ecma-international.org/6.0/#sec-properties-of-the-boolean-prototype-object

module.exports = function thisBooleanValue(value) {
	if (typeof value === 'boolean') {
		return value;
	}

	return $BooleanValueOf(value);
};
'use strict';

var callBound = require('call-bound');

var $NumberValueOf = callBound('Number.prototype.valueOf');

// https://262.ecma-international.org/6.0/#sec-properties-of-the-number-prototype-object

module.exports = function thisNumberValue(value) {
	if (typeof value === 'number') {
		return value;
	}

	return $NumberValueOf(value);
};

'use strict';

var $StringValueOf = require('call-bound')('String.prototype.valueOf');

// https://262.ecma-international.org/6.0/#sec-properties-of-the-string-prototype-object

module.exports = function thisStringValue(value) {
	if (typeof value === 'string') {
		return value;
	}

	return $StringValueOf(value);
};
'use strict';

var $SyntaxError = require('es-errors/syntax');
var callBound = require('call-bound');

var $SymbolValueOf = callBound('Symbol.prototype.valueOf', true);

// https://262.ecma-international.org/9.0/#sec-thissymbolvalue

module.exports = function thisSymbolValue(value) {
	if (typeof value === 'symbol') {
		return value;
	}

	if (!$SymbolValueOf) {
		throw new $SyntaxError('Symbols are not supported; thisSymbolValue requires that `value` be a Symbol or a Symbol object');
	}

	return $SymbolValueOf(value);
};
'use strict';

var timeValue = require('../helpers/timeValue');

// https://262.ecma-international.org/6.0/#sec-properties-of-the-date-prototype-object

module.exports = function thisTimeValue(value) {
	return timeValue(value);
};
'use strict';

var CompletionRecord = require('./CompletionRecord');

// https://262.ecma-international.org/9.0/#sec-throwcompletion

module.exports = function ThrowCompletion(argument) {
	return new CompletionRecord('throw', argument);
};
'use strict';

var GetIntrinsic = require('get-intrinsic');

var $Date = GetIntrinsic('%Date%');

var $isFinite = require('math-intrinsics/isFinite');
var abs = require('math-intrinsics/abs');

var ToNumber = require('./ToNumber');

// https://262.ecma-international.org/5.1/#sec-15.9.1.14

module.exports = function TimeClip(time) {
	if (!$isFinite(time) || abs(time) > 8.64e15) {
		return NaN;
	}
	return +new $Date(ToNumber(time));
};

'use strict';

var msPerDay = require('../helpers/timeConstants').msPerDay;

var DayFromYear = require('./DayFromYear');

// https://262.ecma-international.org/5.1/#sec-15.9.1.3

module.exports = function TimeFromYear(y) {
	return msPerDay * DayFromYear(y);
};
'use strict';

var $TypeError = require('es-errors/type');

var $isNaN = require('math-intrinsics/isNaN');

var HourFromTime = require('./HourFromTime');
var MinFromTime = require('./MinFromTime');
var SecFromTime = require('./SecFromTime');
var ToZeroPaddedDecimalString = require('./ToZeroPaddedDecimalString');

// https://262.ecma-international.org/13.0/#sec-timestring

module.exports = function TimeString(tv) {
	if (typeof tv !== 'number' || $isNaN(tv)) {
		throw new $TypeError('Assertion failed: `tv` must be a non-NaN Number');
	}

	var hour = ToZeroPaddedDecimalString(HourFromTime(tv), 2); // step 1

	var minute = ToZeroPaddedDecimalString(MinFromTime(tv), 2); // step 2

	var second = ToZeroPaddedDecimalString(SecFromTime(tv), 2); // step 3

	return hour + ':' + minute + ':' + second + ' GMT'; // step 4
};
'use strict';

var modulo = require('./modulo');

var msPerDay = require('../helpers/timeConstants').msPerDay;

// https://262.ecma-international.org/5.1/#sec-15.9.1.2

module.exports = function TimeWithinDay(t) {
	return modulo(t, msPerDay);
};

'use strict';

var GetIntrinsic = require('get-intrinsic');

var $Date = GetIntrinsic('%Date%');
var $TypeError = require('es-errors/type');
var callBound = require('call-bound');
var isInteger = require('math-intrinsics/isInteger');

var $indexOf = callBound('String.prototype.indexOf');
var $slice = callBound('String.prototype.slice');
var $toTimeString = callBound('Date.prototype.toTimeString');

// https://262.ecma-international.org/14.0/#sec-timezoneestring

module.exports = function TimeZoneString(tv) {
	if (!isInteger(tv)) {
		throw new $TypeError('Assertion failed: `tv` must be an integral Number');
	}

	// 1. Let localTimeZone be DefaultTimeZone().
	// 2. If IsTimeZoneOffsetString(localTimeZone) is true, then
	//   a. Let offsetNs be ParseTimeZoneOffsetString(localTimeZone).
	// 3. Else,
	//   a. Let offsetNs be GetNamedTimeZoneOffsetNanoseconds(localTimeZone, ℤ(ℝ(tv) × 106)).
	// 4. Let offset be 𝔽(truncate(offsetNs / 106)).
	// 5. If offset is +0𝔽 or offset > +0𝔽, then
	//   a. Let offsetSign be "+".
	//   b. Let absOffset be offset.
	// 6. Else,
	//   a. Let offsetSign be "-".
	//   b. Let absOffset be -offset.
	// 7. Let offsetMin be ToZeroPaddedDecimalString(ℝ(MinFromTime(absOffset)), 2).
	// 8. Let offsetHour be ToZeroPaddedDecimalString(ℝ(HourFromTime(absOffset)), 2).
	// 9. Let tzName be an implementation-defined string that is either the empty String or the string-concatenation of the code unit 0x0020 (SPACE), the code unit 0x0028 (LEFT PARENTHESIS), an implementation-defined timezone name, and the code unit 0x0029 (RIGHT PARENTHESIS).
	// 10. Return the string-concatenation of offsetSign, offsetHour, offsetMin, and tzName.

	// hack until DefaultTimeZone, IsTimeZoneOffsetString, ParseTimeZoneOffsetString, GetNamedTimeZoneOffsetNanoseconds, and "implementation-defined string" are available
	var ts = $toTimeString(new $Date(tv));
	return $slice(ts, $indexOf(ts, '(') + 1, $indexOf(ts, ')'));
};
'use strict';

var GetIntrinsic = require('get-intrinsic');

var $BigInt = GetIntrinsic('%BigInt%', true);
var $pow = require('math-intrinsics/pow');

var ToBigInt = require('./ToBigInt');
var BigIntRemainder = require('./BigInt/remainder');

var modBigInt = require('../helpers/modBigInt');

// BigInt(2**63), but node v10.4-v10.8 have a bug where you can't `BigInt(x)` anything larger than MAX_SAFE_INTEGER
var twoSixtyThree = $BigInt && (BigInt($pow(2, 32)) * BigInt($pow(2, 31)));

// BigInt(2**64), but node v10.4-v10.8 have a bug where you can't `BigInt(x)` anything larger than MAX_SAFE_INTEGER
var twoSixtyFour = $BigInt && (BigInt($pow(2, 32)) * BigInt($pow(2, 32)));

// https://262.ecma-international.org/11.0/#sec-tobigint64

module.exports = function ToBigInt64(argument) {
	var n = ToBigInt(argument);
	var int64bit = modBigInt(BigIntRemainder, n, twoSixtyFour);
	return int64bit >= twoSixtyThree ? int64bit - twoSixtyFour : int64bit;
};
'use strict';

var GetIntrinsic = require('get-intrinsic');

var $BigInt = GetIntrinsic('%BigInt%', true);
var $Number = GetIntrinsic('%Number%');
var $TypeError = require('es-errors/type');
var $SyntaxError = require('es-errors/syntax');

var StringToBigInt = require('./StringToBigInt');
var ToPrimitive = require('./ToPrimitive');

// https://262.ecma-international.org/13.0/#sec-tobigint

module.exports = function ToBigInt(argument) {
	if (!$BigInt) {
		throw new $SyntaxError('BigInts are not supported in this environment');
	}

	var prim = ToPrimitive(argument, $Number);

	if (prim == null) {
		throw new $TypeError('Cannot convert null or undefined to a BigInt');
	}

	if (typeof prim === 'boolean') {
		return prim ? $BigInt(1) : $BigInt(0);
	}

	if (typeof prim === 'number') {
		throw new $TypeError('Cannot convert a Number value to a BigInt');
	}

	if (typeof prim === 'string') {
		var n = StringToBigInt(prim);
		if (typeof n === 'undefined') {
			throw new $TypeError('Failed to parse String to BigInt');
		}
		return n;
	}

	if (typeof prim === 'symbol') {
		throw new $TypeError('Cannot convert a Symbol value to a BigInt');
	}

	if (typeof prim !== 'bigint') {
		throw new $SyntaxError('Assertion failed: unknown primitive type');
	}

	return prim;
};
'use strict';

var GetIntrinsic = require('get-intrinsic');

var $BigInt = GetIntrinsic('%BigInt%', true);

var $pow = require('math-intrinsics/pow');

var ToBigInt = require('./ToBigInt');
var BigIntRemainder = require('./BigInt/remainder');

var modBigInt = require('../helpers/modBigInt');

// BigInt(2**64), but node v10.4-v10.8 have a bug where you can't `BigInt(x)` anything larger than MAX_SAFE_INTEGER
var twoSixtyFour = $BigInt && (BigInt($pow(2, 32)) * BigInt($pow(2, 32)));

// https://262.ecma-international.org/11.0/#sec-tobiguint64

module.exports = function ToBigUint64(argument) {
	var n = ToBigInt(argument);
	var int64bit = modBigInt(BigIntRemainder, n, twoSixtyFour);
	return int64bit;
};
'use strict';

// http://262.ecma-international.org/5.1/#sec-9.2

module.exports = function ToBoolean(value) { return !!value; };
'use strict';

var GetIntrinsic = require('get-intrinsic');

var $TypeError = require('es-errors/type');
var $Date = GetIntrinsic('%Date%');
var $String = GetIntrinsic('%String%');

var $isNaN = require('math-intrinsics/isNaN');

// https://262.ecma-international.org/6.0/#sec-todatestring

module.exports = function ToDateString(tv) {
	if (typeof tv !== 'number') {
		throw new $TypeError('Assertion failed: `tv` must be a Number');
	}
	if ($isNaN(tv)) {
		return 'Invalid Date';
	}
	return $String(new $Date(tv));
};
'use strict';

var $RangeError = require('es-errors/range');

var ToIntegerOrInfinity = require('./ToIntegerOrInfinity');
var ToLength = require('./ToLength');
var SameValue = require('./SameValue');

// https://262.ecma-international.org/8.0/#sec-toindex

module.exports = function ToIndex(value) {
	if (typeof value === 'undefined') {
		return 0;
	}
	var integerIndex = ToIntegerOrInfinity(value);
	if (integerIndex < 0) {
		throw new $RangeError('index must be >= 0');
	}
	var index = ToLength(integerIndex);
	if (!SameValue(integerIndex, index)) {
		throw new $RangeError('index must be >= 0 and < 2 ** 53 - 1');
	}
	return index;
};
'use strict';

var modulo = require('./modulo');
var ToNumber = require('./ToNumber');
var truncate = require('./truncate');

var isFinite = require('math-intrinsics/isFinite');

// https://262.ecma-international.org/14.0/#sec-toint16

var two16 = 0x10000; // Math.pow(2, 16);

module.exports = function ToInt16(argument) {
	var number = ToNumber(argument);
	if (!isFinite(number) || number === 0) {
		return 0;
	}
	var int = truncate(number);
	var int16bit = modulo(int, two16);
	return int16bit >= 0x8000 ? int16bit - two16 : int16bit;
};
'use strict';

var modulo = require('./modulo');
var ToNumber = require('./ToNumber');
var truncate = require('./truncate');

var isFinite = require('math-intrinsics/isFinite');

// https://262.ecma-international.org/14.0/#sec-toint32

var two31 = 0x80000000; // Math.pow(2, 31);
var two32 = 0x100000000; // Math.pow(2, 32);

module.exports = function ToInt32(argument) {
	var number = ToNumber(argument);
	if (!isFinite(number) || number === 0) {
		return 0;
	}
	var int = truncate(number);
	var int32bit = modulo(int, two32);
	var result = int32bit >= two31 ? int32bit - two32 : int32bit;
	return result === 0 ? 0 : result; // in the spec, these are math values, so we filter out -0 here
};
'use strict';

var modulo = require('./modulo');
var ToNumber = require('./ToNumber');
var truncate = require('./truncate');

var isFinite = require('math-intrinsics/isFinite');

// https://262.ecma-international.org/14.0/#sec-toint8

module.exports = function ToInt8(argument) {
	var number = ToNumber(argument);
	if (!isFinite(number) || number === 0) {
		return 0;
	}
	var int = truncate(number);
	var int8bit = modulo(int, 0x100);
	return int8bit >= 0x80 ? int8bit - 0x100 : int8bit;
};
'use strict';

var ToNumber = require('./ToNumber');
var truncate = require('./truncate');

var $isNaN = require('math-intrinsics/isNaN');
var $isFinite = require('math-intrinsics/isFinite');

// https://262.ecma-international.org/14.0/#sec-tointegerorinfinity

module.exports = function ToIntegerOrInfinity(value) {
	var number = ToNumber(value);
	if ($isNaN(number) || number === 0) { return 0; }
	if (!$isFinite(number)) { return number; }
	return truncate(number);
};
'use strict';

var MAX_SAFE_INTEGER = require('math-intrinsics/constants/maxSafeInteger');

var ToIntegerOrInfinity = require('./ToIntegerOrInfinity');

// https://262.ecma-international.org/12.0/#sec-tolength

module.exports = function ToLength(argument) {
	var len = ToIntegerOrInfinity(argument);
	if (len <= 0) { return 0; } // includes converting -0 to +0
	if (len > MAX_SAFE_INTEGER) { return MAX_SAFE_INTEGER; }
	return len;
};
'use strict';

var GetIntrinsic = require('get-intrinsic');

var $TypeError = require('es-errors/type');
var $Number = GetIntrinsic('%Number%');
var isPrimitive = require('../helpers/isPrimitive');

var ToPrimitive = require('./ToPrimitive');
var StringToNumber = require('./StringToNumber');

// https://262.ecma-international.org/13.0/#sec-tonumber

module.exports = function ToNumber(argument) {
	var value = isPrimitive(argument) ? argument : ToPrimitive(argument, $Number);
	if (typeof value === 'symbol') {
		throw new $TypeError('Cannot convert a Symbol value to a number');
	}
	if (typeof value === 'bigint') {
		throw new $TypeError('Conversion from \'BigInt\' to \'number\' is not allowed.');
	}
	if (typeof value === 'string') {
		return StringToNumber(value);
	}
	return +value;
};
'use strict';

var GetIntrinsic = require('get-intrinsic');

var $Number = GetIntrinsic('%Number%');

var isPrimitive = require('../helpers/isPrimitive');

var ToPrimitive = require('./ToPrimitive');
var ToNumber = require('./ToNumber');

// https://262.ecma-international.org/11.0/#sec-tonumeric

module.exports = function ToNumeric(argument) {
	var primValue = isPrimitive(argument) ? argument : ToPrimitive(argument, $Number);
	if (typeof primValue === 'bigint') {
		return primValue;
	}
	return ToNumber(primValue);
};
'use strict';

// https://262.ecma-international.org/6.0/#sec-toobject

module.exports = require('es-object-atoms/ToObject');
'use strict';

var toPrimitive = require('es-to-primitive/es2015');

// https://262.ecma-international.org/6.0/#sec-toprimitive

module.exports = function ToPrimitive(input) {
	if (arguments.length > 1) {
		return toPrimitive(input, arguments[1]);
	}
	return toPrimitive(input);
};
'use strict';

var hasOwn = require('hasown');

var $TypeError = require('es-errors/type');
var isObject = require('es-object-atoms/isObject');

var IsCallable = require('./IsCallable');
var ToBoolean = require('./ToBoolean');

// https://262.ecma-international.org/5.1/#sec-8.10.5

module.exports = function ToPropertyDescriptor(Obj) {
	if (!isObject(Obj)) {
		throw new $TypeError('ToPropertyDescriptor requires an object');
	}

	var desc = {};
	if (hasOwn(Obj, 'enumerable')) {
		desc['[[Enumerable]]'] = ToBoolean(Obj.enumerable);
	}
	if (hasOwn(Obj, 'configurable')) {
		desc['[[Configurable]]'] = ToBoolean(Obj.configurable);
	}
	if (hasOwn(Obj, 'value')) {
		desc['[[Value]]'] = Obj.value;
	}
	if (hasOwn(Obj, 'writable')) {
		desc['[[Writable]]'] = ToBoolean(Obj.writable);
	}
	if (hasOwn(Obj, 'get')) {
		var getter = Obj.get;
		if (typeof getter !== 'undefined' && !IsCallable(getter)) {
			throw new $TypeError('getter must be a function');
		}
		desc['[[Get]]'] = getter;
	}
	if (hasOwn(Obj, 'set')) {
		var setter = Obj.set;
		if (typeof setter !== 'undefined' && !IsCallable(setter)) {
			throw new $TypeError('setter must be a function');
		}
		desc['[[Set]]'] = setter;
	}

	if ((hasOwn(desc, '[[Get]]') || hasOwn(desc, '[[Set]]')) && (hasOwn(desc, '[[Value]]') || hasOwn(desc, '[[Writable]]'))) {
		throw new $TypeError('Invalid property descriptor. Cannot both specify accessors and a value or writable attribute');
	}
	return desc;
};
'use strict';

var GetIntrinsic = require('get-intrinsic');

var $String = GetIntrinsic('%String%');

var ToPrimitive = require('./ToPrimitive');
var ToString = require('./ToString');

// https://262.ecma-international.org/6.0/#sec-topropertykey

module.exports = function ToPropertyKey(argument) {
	var key = ToPrimitive(argument, $String);
	return typeof key === 'symbol' ? key : ToString(key);
};
'use strict';

var GetIntrinsic = require('get-intrinsic');

var $String = GetIntrinsic('%String%');
var $TypeError = require('es-errors/type');

// https://262.ecma-international.org/6.0/#sec-tostring

module.exports = function ToString(argument) {
	if (typeof argument === 'symbol') {
		throw new $TypeError('Cannot convert a Symbol value to a string');
	}
	return $String(argument);
};
'use strict';

var modulo = require('./modulo');
var ToNumber = require('./ToNumber');
var truncate = require('./truncate');

var isFinite = require('math-intrinsics/isFinite');

// https://262.ecma-international.org/14.0/#sec-touint16

var two16 = 0x10000; // Math.pow(2, 16)

module.exports = function ToUint16(argument) {
	var number = ToNumber(argument);
	if (!isFinite(number) || number === 0) {
		return 0;
	}
	var int = truncate(number);
	var int16bit = modulo(int, two16);
	return int16bit === 0 ? 0 : int16bit; // in the spec, these are math values, so we filter out -0 here
};
'use strict';

var modulo = require('./modulo');
var ToNumber = require('./ToNumber');
var truncate = require('./truncate');

var isFinite = require('math-intrinsics/isFinite');

// https://262.ecma-international.org/14.0/#sec-touint32

var two32 = 0x100000000; // Math.pow(2, 32);

module.exports = function ToUint32(argument) {
	var number = ToNumber(argument);
	if (!isFinite(number) || number === 0) {
		return 0;
	}
	var int = truncate(number);
	var int32bit = modulo(int, two32);
	return int32bit === 0 ? 0 : int32bit; // in the spec, these are math values, so we filter out -0 here
};
'use strict';

var ToNumber = require('./ToNumber');
var floor = require('./floor');

var $isNaN = require('math-intrinsics/isNaN');

// https://262.ecma-international.org/6.0/#sec-touint8clamp

module.exports = function ToUint8Clamp(argument) {
	var number = ToNumber(argument);
	if ($isNaN(number) || number <= 0) { return 0; }
	if (number >= 0xFF) { return 0xFF; }
	var f = floor(number);
	if (f + 0.5 < number) { return f + 1; }
	if (number < f + 0.5) { return f; }
	if (f % 2 !== 0) { return f + 1; }
	return f;
};
'use strict';

var isFinite = require('math-intrinsics/isFinite');

var modulo = require('./modulo');
var ToNumber = require('./ToNumber');
var truncate = require('./truncate');

// https://262.ecma-international.org/14.0/#sec-touint8

module.exports = function ToUint8(argument) {
	var number = ToNumber(argument);
	if (!isFinite(number) || number === 0) {
		return 0;
	}
	var int = truncate(number);
	var int8bit = modulo(int, 0x100);
	return int8bit;
};
'use strict';

var GetIntrinsic = require('get-intrinsic');

var $String = GetIntrinsic('%String%');
var $RangeError = require('es-errors/range');
var isInteger = require('math-intrinsics/isInteger');

var StringPad = require('./StringPad');

// https://262.ecma-international.org/13.0/#sec-tozeropaddeddecimalstring

module.exports = function ToZeroPaddedDecimalString(n, minLength) {
	if (!isInteger(n) || n < 0) {
		throw new $RangeError('Assertion failed: `q` must be a non-negative integer');
	}
	var S = $String(n);
	return StringPad(S, minLength, '0', 'start');
};
'use strict';

var trimStart = require('string.prototype.trimstart');
var trimEnd = require('string.prototype.trimend');

var $TypeError = require('es-errors/type');

var RequireObjectCoercible = require('./RequireObjectCoercible');
var ToString = require('./ToString');

// https://262.ecma-international.org/10.0/#sec-trimstring

module.exports = function TrimString(string, where) {
	var str = RequireObjectCoercible(string);
	var S = ToString(str);
	var T;
	if (where === 'start') {
		T = trimStart(S);
	} else if (where === 'end') {
		T = trimEnd(S);
	} else if (where === 'start+end') {
		T = trimStart(trimEnd(S));
	} else {
		throw new $TypeError('Assertion failed: invalid `where` value; must be "start", "end", or "start+end"');
	}
	return T;
};
'use strict';

var floor = require('./floor');

var $TypeError = require('es-errors/type');

// https://262.ecma-international.org/14.0/#eqn-truncate

module.exports = function truncate(x) {
	if (typeof x !== 'number' && typeof x !== 'bigint') {
		throw new $TypeError('argument must be a Number or a BigInt');
	}
	var result = x < 0 ? -floor(-x) : floor(x);
	return result === 0 ? 0 : result; // in the spec, these are math values, so we filter out -0 here
};
'use strict';

var $SyntaxError = require('es-errors/syntax');
var $TypeError = require('es-errors/type');

var IsArray = require('./IsArray');
var IsConstructor = require('./IsConstructor');
var ValidateTypedArray = require('./ValidateTypedArray');

var availableTypedArrays = require('available-typed-arrays')();
var typedArrayLength = require('typed-array-length');

// https://262.ecma-international.org/7.0/#typedarray-create

module.exports = function TypedArrayCreate(constructor, argumentList) {
	if (!IsConstructor(constructor)) {
		throw new $TypeError('Assertion failed: `constructor` must be a constructor');
	}
	if (!IsArray(argumentList)) {
		throw new $TypeError('Assertion failed: `argumentList` must be a List');
	}
	if (availableTypedArrays.length === 0) {
		throw new $SyntaxError('Assertion failed: Typed Arrays are not supported in this environment');
	}

	// var newTypedArray = Construct(constructor, argumentList); // step 1
	var newTypedArray;
	if (argumentList.length === 0) {
		newTypedArray = new constructor();
	} else if (argumentList.length === 1) {
		newTypedArray = new constructor(argumentList[0]);
	} else if (argumentList.length === 2) {
		newTypedArray = new constructor(argumentList[0], argumentList[1]);
	} else {
		newTypedArray = new constructor(argumentList[0], argumentList[1], argumentList[2]);
	}

	ValidateTypedArray(newTypedArray); // step 2

	if (argumentList.length === 1 && typeof argumentList[0] === 'number') { // step 3
		if (typedArrayLength(newTypedArray) < argumentList[0]) {
			throw new $TypeError('Assertion failed: `argumentList[0]` must be <= `newTypedArray.length`'); // step 3.a
		}
	}

	return newTypedArray; // step 4
};
'use strict';

var $SyntaxError = require('es-errors/syntax');
var $TypeError = require('es-errors/type');

var whichTypedArray = require('which-typed-array');
var availableTypedArrays = require('available-typed-arrays')();

var IsArray = require('./IsArray');
var TypedArrayCreate = require('./TypedArrayCreate');

var getConstructor = require('../helpers/typedArrayConstructors');

// https://262.ecma-international.org/14.0/#sec-typedarray-create-same-type

module.exports = function TypedArrayCreateSameType(exemplar, argumentList) {
	if (availableTypedArrays.length === 0) {
		throw new $SyntaxError('Assertion failed: Typed Arrays are not supported in this environment');
	}

	var kind = whichTypedArray(exemplar);
	if (!kind) {
		throw new $TypeError('Assertion failed: exemplar must be a TypedArray'); // step 1
	}
	if (!IsArray(argumentList)) {
		throw new $TypeError('Assertion failed: `argumentList` must be a List'); // step 1
	}

	var constructor = getConstructor(kind); // step 2
	if (typeof constructor !== 'function') {
		throw new $SyntaxError('Assertion failed: `constructor` of `exemplar` (' + kind + ') must exist. Please report this!');
	}

	return TypedArrayCreate(constructor, argumentList); // steps 3 - 6
};
'use strict';

var $SyntaxError = require('es-errors/syntax');
var $TypeError = require('es-errors/type');
var isInteger = require('math-intrinsics/isInteger');
var whichTypedArray = require('which-typed-array');

// https://262.ecma-international.org/13.0/#sec-typedarrayelementsize

var tableTAO = require('./tables/typed-array-objects');

module.exports = function TypedArrayElementSize(O) {
	var type = whichTypedArray(O);
	if (!type) {
		throw new $TypeError('Assertion failed: `O` must be a TypedArray');
	}
	var size = tableTAO.size['$' + tableTAO.name['$' + type]];
	if (!isInteger(size) || size < 0) {
		throw new $SyntaxError('Assertion failed: Unknown TypedArray type `' + type + '`');
	}

	return size;
};
'use strict';

var $SyntaxError = require('es-errors/syntax');
var $TypeError = require('es-errors/type');

var whichTypedArray = require('which-typed-array');

// https://262.ecma-international.org/13.0/#sec-typedarrayelementtype

var tableTAO = require('./tables/typed-array-objects');

module.exports = function TypedArrayElementType(O) {
	var type = whichTypedArray(O);
	if (!type) {
		throw new $TypeError('Assertion failed: `O` must be a TypedArray');
	}
	var result = tableTAO.name['$' + type];
	if (typeof result !== 'string') {
		throw new $SyntaxError('Assertion failed: Unknown TypedArray type `' + type + '`');
	}

	return result;
};
'use strict';

var $SyntaxError = require('es-errors/syntax');
var $TypeError = require('es-errors/type');

var whichTypedArray = require('which-typed-array');
var availableTypedArrays = require('available-typed-arrays')();

var IsArray = require('./IsArray');
var SpeciesConstructor = require('./SpeciesConstructor');
var TypedArrayCreate = require('./TypedArrayCreate');

var getConstructor = require('../helpers/typedArrayConstructors');

// https://262.ecma-international.org/7.0/#typedarray-species-create

module.exports = function TypedArraySpeciesCreate(exemplar, argumentList) {
	if (availableTypedArrays.length === 0) {
		throw new $SyntaxError('Assertion failed: Typed Arrays are not supported in this environment');
	}

	var kind = whichTypedArray(exemplar);
	if (!kind) {
		throw new $TypeError('Assertion failed: exemplar must be a TypedArray'); // step 1
	}
	if (!IsArray(argumentList)) {
		throw new $TypeError('Assertion failed: `argumentList` must be a List'); // step 1
	}

	var defaultConstructor = getConstructor(kind); // step 2
	if (typeof defaultConstructor !== 'function') {
		throw new $SyntaxError('Assertion failed: `constructor` of `exemplar` (' + kind + ') must exist. Please report this!');
	}
	var constructor = SpeciesConstructor(exemplar, defaultConstructor); // step 3

	return TypedArrayCreate(constructor, argumentList); // step 4
};
'use strict';

var ES5Type = require('../5/Type');

// https://262.ecma-international.org/11.0/#sec-ecmascript-data-types-and-values

module.exports = function Type(x) {
	if (typeof x === 'symbol') {
		return 'Symbol';
	}
	if (typeof x === 'bigint') {
		return 'BigInt';
	}
	return ES5Type(x);
};
'use strict';

var $TypeError = require('es-errors/type');

var callBound = require('call-bound');

var $charCodeAt = callBound('String.prototype.charCodeAt');
var $numberToString = callBound('Number.prototype.toString');
var $toLowerCase = callBound('String.prototype.toLowerCase');

var StringPad = require('./StringPad');

// https://262.ecma-international.org/11.0/#sec-unicodeescape

module.exports = function UnicodeEscape(C) {
	if (typeof C !== 'string' || C.length !== 1) {
		throw new $TypeError('Assertion failed: `C` must be a single code unit');
	}
	var n = $charCodeAt(C, 0);
	if (n > 0xFFFF) {
		throw new $TypeError('`Assertion failed: numeric value of `C` must be <= 0xFFFF');
	}

	return '\\u' + StringPad($toLowerCase($numberToString(n, 16)), 4, '0', 'start');
};
'use strict';

var GetIntrinsic = require('get-intrinsic');

var $TypeError = require('es-errors/type');
var $fromCharCode = GetIntrinsic('%String.fromCharCode%');

var floor = require('./floor');
var modulo = require('./modulo');

var isCodePoint = require('../helpers/isCodePoint');

// https://262.ecma-international.org/12.0/#sec-utf16encoding

module.exports = function UTF16EncodeCodePoint(cp) {
	if (!isCodePoint(cp)) {
		throw new $TypeError('Assertion failed: `cp` must be >= 0 and <= 0x10FFFF');
	}
	if (cp <= 65535) {
		return $fromCharCode(cp);
	}
	var cu1 = $fromCharCode(floor((cp - 65536) / 1024) + 0xD800);
	var cu2 = $fromCharCode(modulo(cp - 65536, 1024) + 0xDC00);
	return cu1 + cu2;
};
'use strict';

var GetIntrinsic = require('get-intrinsic');

var $TypeError = require('es-errors/type');
var $fromCharCode = GetIntrinsic('%String.fromCharCode%');

var isLeadingSurrogate = require('../helpers/isLeadingSurrogate');
var isTrailingSurrogate = require('../helpers/isTrailingSurrogate');

// https://262.ecma-international.org/12.0/#sec-utf16decodesurrogatepair

module.exports = function UTF16SurrogatePairToCodePoint(lead, trail) {
	if (!isLeadingSurrogate(lead) || !isTrailingSurrogate(trail)) {
		throw new $TypeError('Assertion failed: `lead` must be a leading surrogate char code, and `trail` must be a trailing surrogate char code');
	}
	// var cp = (lead - 0xD800) * 0x400 + (trail - 0xDC00) + 0x10000;
	return $fromCharCode(lead) + $fromCharCode(trail);
};
'use strict';

var $TypeError = require('es-errors/type');
var isObject = require('es-object-atoms/isObject');

var DefineOwnProperty = require('../helpers/DefineOwnProperty');
var isFullyPopulatedPropertyDescriptor = require('../helpers/isFullyPopulatedPropertyDescriptor');
var isPropertyDescriptor = require('../helpers/records/property-descriptor');

var FromPropertyDescriptor = require('./FromPropertyDescriptor');
var IsAccessorDescriptor = require('./IsAccessorDescriptor');
var IsDataDescriptor = require('./IsDataDescriptor');
var IsGenericDescriptor = require('./IsGenericDescriptor');
var isPropertyKey = require('../helpers/isPropertyKey');
var SameValue = require('./SameValue');

// https://262.ecma-international.org/13.0/#sec-validateandapplypropertydescriptor

// see https://github.com/tc39/ecma262/pull/2468 for ES2022 changes

// eslint-disable-next-line max-lines-per-function, max-statements
module.exports = function ValidateAndApplyPropertyDescriptor(O, P, extensible, Desc, current) {
	if (typeof O !== 'undefined' && !isObject(O)) {
		throw new $TypeError('Assertion failed: O must be undefined or an Object');
	}
	if (!isPropertyKey(P)) {
		throw new $TypeError('Assertion failed: P must be a Property Key');
	}
	if (typeof extensible !== 'boolean') {
		throw new $TypeError('Assertion failed: extensible must be a Boolean');
	}
	if (!isPropertyDescriptor(Desc)) {
		throw new $TypeError('Assertion failed: Desc must be a Property Descriptor');
	}
	if (typeof current !== 'undefined' && !isPropertyDescriptor(current)) {
		throw new $TypeError('Assertion failed: current must be a Property Descriptor, or undefined');
	}

	if (typeof current === 'undefined') { // step 2
		if (!extensible) {
			return false; // step 2.a
		}
		if (typeof O === 'undefined') {
			return true; // step 2.b
		}
		if (IsAccessorDescriptor(Desc)) { // step 2.c
			return DefineOwnProperty(
				IsDataDescriptor,
				SameValue,
				FromPropertyDescriptor,
				O,
				P,
				Desc
			);
		}
		// step 2.d
		return DefineOwnProperty(
			IsDataDescriptor,
			SameValue,
			FromPropertyDescriptor,
			O,
			P,
			{
				'[[Configurable]]': !!Desc['[[Configurable]]'],
				'[[Enumerable]]': !!Desc['[[Enumerable]]'],
				'[[Value]]': Desc['[[Value]]'],
				'[[Writable]]': !!Desc['[[Writable]]']
			}
		);
	}

	// 3. Assert: current is a fully populated Property Descriptor.
	if (
		!isFullyPopulatedPropertyDescriptor(
			{
				IsAccessorDescriptor: IsAccessorDescriptor,
				IsDataDescriptor: IsDataDescriptor
			},
			current
		)
	) {
		throw new $TypeError('`current`, when present, must be a fully populated and valid Property Descriptor');
	}

	// 4. If every field in Desc is absent, return true.
	// this can't really match the assertion that it's a Property Descriptor in our JS implementation

	// 5. If current.[[Configurable]] is false, then
	if (!current['[[Configurable]]']) {
		if ('[[Configurable]]' in Desc && Desc['[[Configurable]]']) {
			// step 5.a
			return false;
		}
		if ('[[Enumerable]]' in Desc && !SameValue(Desc['[[Enumerable]]'], current['[[Enumerable]]'])) {
			// step 5.b
			return false;
		}
		if (!IsGenericDescriptor(Desc) && !SameValue(IsAccessorDescriptor(Desc), IsAccessorDescriptor(current))) {
			// step 5.c
			return false;
		}
		if (IsAccessorDescriptor(current)) { // step 5.d
			if ('[[Get]]' in Desc && !SameValue(Desc['[[Get]]'], current['[[Get]]'])) {
				return false;
			}
			if ('[[Set]]' in Desc && !SameValue(Desc['[[Set]]'], current['[[Set]]'])) {
				return false;
			}
		} else if (!current['[[Writable]]']) { // step 5.e
			if ('[[Writable]]' in Desc && Desc['[[Writable]]']) {
				return false;
			}
			if ('[[Value]]' in Desc && !SameValue(Desc['[[Value]]'], current['[[Value]]'])) {
				return false;
			}
		}
	}

	// 6. If O is not undefined, then
	if (typeof O !== 'undefined') {
		var configurable;
		var enumerable;
		if (IsDataDescriptor(current) && IsAccessorDescriptor(Desc)) { // step 6.a
			configurable = ('[[Configurable]]' in Desc ? Desc : current)['[[Configurable]]'];
			enumerable = ('[[Enumerable]]' in Desc ? Desc : current)['[[Enumerable]]'];
			// Replace the property named P of object O with an accessor property having [[Configurable]] and [[Enumerable]] attributes as described by current and each other attribute set to its default value.
			return DefineOwnProperty(
				IsDataDescriptor,
				SameValue,
				FromPropertyDescriptor,
				O,
				P,
				{
					'[[Configurable]]': !!configurable,
					'[[Enumerable]]': !!enumerable,
					'[[Get]]': ('[[Get]]' in Desc ? Desc : current)['[[Get]]'],
					'[[Set]]': ('[[Set]]' in Desc ? Desc : current)['[[Set]]']
				}
			);
		} else if (IsAccessorDescriptor(current) && IsDataDescriptor(Desc)) {
			configurable = ('[[Configurable]]' in Desc ? Desc : current)['[[Configurable]]'];
			enumerable = ('[[Enumerable]]' in Desc ? Desc : current)['[[Enumerable]]'];
			// i. Replace the property named P of object O with a data property having [[Configurable]] and [[Enumerable]] attributes as described by current and each other attribute set to its default value.
			return DefineOwnProperty(
				IsDataDescriptor,
				SameValue,
				FromPropertyDescriptor,
				O,
				P,
				{
					'[[Configurable]]': !!configurable,
					'[[Enumerable]]': !!enumerable,
					'[[Value]]': ('[[Value]]' in Desc ? Desc : current)['[[Value]]'],
					'[[Writable]]': !!('[[Writable]]' in Desc ? Desc : current)['[[Writable]]']
				}
			);
		}

		// For each field of Desc that is present, set the corresponding attribute of the property named P of object O to the value of the field.
		return DefineOwnProperty(
			IsDataDescriptor,
			SameValue,
			FromPropertyDescriptor,
			O,
			P,
			Desc
		);
	}

	return true; // step 7
};
'use strict';

var $RangeError = require('es-errors/range');
var $TypeError = require('es-errors/type');

var ToIndex = require('./ToIndex');
var TypedArrayElementSize = require('./TypedArrayElementSize');

var isTypedArray = require('is-typed-array');
var typedArrayByteOffset = require('typed-array-byte-offset');
var typedArrayLength = require('typed-array-length');

// https://262.ecma-international.org/13.0/#sec-validateatomicaccess

module.exports = function ValidateAtomicAccess(typedArray, requestIndex) {
	if (!isTypedArray(typedArray)) {
		throw new $TypeError('Assertion failed: `typedArray` must be a TypedArray');
	}

	var length = typedArrayLength(typedArray); // step 1

	var accessIndex = ToIndex(requestIndex); // step 2

	/*
	// this assertion can never be reached
	if (!(accessIndex >= 0)) {
		throw new $TypeError('Assertion failed: accessIndex >= 0'); // step 4
	}
	*/

	if (accessIndex >= length) {
		throw new $RangeError('index out of range'); // step 4
	}

	var elementSize = TypedArrayElementSize(typedArray); // step 5

	var offset = typedArrayByteOffset(typedArray); // step 6

	return (accessIndex * elementSize) + offset; // step 7
};
'use strict';

var $TypeError = require('es-errors/type');

var IsBigIntElementType = require('./IsBigIntElementType');
var IsUnclampedIntegerElementType = require('./IsUnclampedIntegerElementType');
var TypedArrayElementType = require('./TypedArrayElementType');
var ValidateTypedArray = require('./ValidateTypedArray');

var whichTypedArray = require('which-typed-array');
var typedArrayBuffer = require('typed-array-buffer');

// https://262.ecma-international.org/13.0/#sec-validateintegertypedarray

module.exports = function ValidateIntegerTypedArray(typedArray) {
	var waitable = arguments.length > 1 ? arguments[1] : false; // step 1

	if (typeof waitable !== 'boolean') {
		throw new $TypeError('Assertion failed: `waitable` must be a Boolean');
	}

	ValidateTypedArray(typedArray); // step 2
	var buffer = typedArrayBuffer(typedArray); // step 3

	if (waitable) { // step 5
		var typeName = whichTypedArray(typedArray);
		if (typeName !== 'Int32Array' && typeName !== 'BigInt64Array') {
			throw new $TypeError('Assertion failed: `typedArray` must be an Int32Array or BigInt64Array when `waitable` is true'); // step 5.a
		}
	} else {
		var type = TypedArrayElementType(typedArray); // step 5.a
		if (!IsUnclampedIntegerElementType(type) && !IsBigIntElementType(type)) {
			throw new $TypeError('Assertion failed: `typedArray` must be an integer TypedArray'); // step 5.b
		}
	}

	return buffer; // step 6
};
'use strict';

var $TypeError = require('es-errors/type');
var isObject = require('es-object-atoms/isObject');

var IsDetachedBuffer = require('./IsDetachedBuffer');

var isTypedArray = require('is-typed-array');
var typedArrayBuffer = require('typed-array-buffer');

// https://262.ecma-international.org/13.0/#sec-validatetypedarray

module.exports = function ValidateTypedArray(O) {
	if (!isObject(O)) {
		throw new $TypeError('Assertion failed: `O` must be an Object'); // step 1
	}
	if (!isTypedArray(O)) {
		throw new $TypeError('Assertion failed: `O` must be a Typed Array'); // steps 1 - 2
	}

	var buffer = typedArrayBuffer(O); // step 3

	if (IsDetachedBuffer(buffer)) {
		throw new $TypeError('`O` must be backed by a non-detached buffer'); // step 4
	}
};
'use strict';

var callBound = require('call-bound');

var $TypeError = require('es-errors/type');
var $deref = callBound('WeakRef.prototype.deref', true);

var isWeakRef = require('is-weakref');

var AddToKeptObjects = require('./AddToKeptObjects');

// https://262.ecma-international.org/12.0/#sec-weakrefderef

module.exports = function WeakRefDeref(weakRef) {
	if (!isWeakRef(weakRef)) {
		throw new $TypeError('Assertion failed: `weakRef` must be a WeakRef');
	}
	var target = $deref(weakRef);
	if (target) {
		AddToKeptObjects(target);
	}
	return target;
};
'use strict';

var Day = require('./Day');
var modulo = require('./modulo');

// https://262.ecma-international.org/5.1/#sec-15.9.1.6

module.exports = function WeekDay(t) {
	return modulo(Day(t) + 4, 7);
};
'use strict';

var $TypeError = require('es-errors/type');

var callBound = require('call-bound');
var $indexOf = callBound('String.prototype.indexOf');

var Canonicalize = require('./Canonicalize');

var caseFolding = require('../helpers/caseFolding.json');
var forEach = require('../helpers/forEach');
var isRegExpRecord = require('../helpers/records/regexp-record');
var OwnPropertyKeys = require('own-keys');

var basicWordChars = 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789_'; // step 1

// https://262.ecma-international.org/14.0/#sec-runtime-semantics-wordcharacters-abstract-operation

module.exports = function WordCharacters(rer) {
	if (!isRegExpRecord(rer)) {
		throw new $TypeError('Assertion failed: `rer` must be a RegExp Record');
	}

	var extraWordChars = '';
	forEach(OwnPropertyKeys(caseFolding.C), function (c) {
		if (
			$indexOf(basicWordChars, c) === -1 // c not in A
			&& $indexOf(basicWordChars, Canonicalize(rer, c)) > -1 // canonicalized c IS in A
		) {
			extraWordChars += caseFolding.C[c]; // step 3
		}
	});
	forEach(OwnPropertyKeys(caseFolding.S), function (c) {
		if (
			$indexOf(basicWordChars, c) === -1 // c not in A
			&& $indexOf(basicWordChars, Canonicalize(rer, c)) > -1 // canonicalized c IS in A
		) {
			extraWordChars += caseFolding.S[c]; // step 3
		}
	});

	if ((!rer['[[Unicode]]'] || !rer['[[IgnoreCase]]']) && extraWordChars.length > 0) {
		throw new $TypeError('Assertion failed: `extraWordChars` must be empty when `rer.[[IgnoreCase]]` and `rer.[[Unicode]]` are not both true'); // step 3
	}

	return basicWordChars + extraWordChars; // step 4
};
'use strict';

var GetIntrinsic = require('get-intrinsic');

var $Date = GetIntrinsic('%Date%');

var callBound = require('call-bound');

var $getUTCFullYear = callBound('Date.prototype.getUTCFullYear');

// https://262.ecma-international.org/5.1/#sec-15.9.1.3

module.exports = function YearFromTime(t) {
	// largest y such that this.TimeFromYear(y) <= t
	return $getUTCFullYear(new $Date(t));
};
'use strict';

var $abs = require('math-intrinsics/abs');

// https://262.ecma-international.org/11.0/#eqn-abs

module.exports = function abs(x) {
	return typeof x === 'bigint' ? BigInt($abs(Number(x))) : $abs(x);
};
'use strict';

var $TypeError = require('es-errors/type');
var isObject = require('es-object-atoms/isObject');
var inspect = require('object-inspect');

var Call = require('./Call');
var Get = require('./Get');
var GetIterator = require('./GetIterator');
var IsCallable = require('./IsCallable');
var IteratorClose = require('./IteratorClose');
var IteratorStep = require('./IteratorStep');
var IteratorValue = require('./IteratorValue');
var ThrowCompletion = require('./ThrowCompletion');

// https://262.ecma-international.org/15.0/#sec-add-entries-from-iterable

module.exports = function AddEntriesFromIterable(target, iterable, adder) {
	if (!IsCallable(adder)) {
		throw new $TypeError('Assertion failed: `adder` is not callable');
	}
	if (iterable == null) {
		throw new $TypeError('Assertion failed: `iterable` is present, and not nullish');
	}
	var iteratorRecord = GetIterator(iterable, 'SYNC');
	while (true) { // eslint-disable-line no-constant-condition
		var next = IteratorStep(iteratorRecord);
		if (!next) {
			return target;
		}
		var nextItem = IteratorValue(next);
		if (!isObject(nextItem)) {
			var error = ThrowCompletion(new $TypeError('iterator next must return an Object, got ' + inspect(nextItem)));
			return IteratorClose(iteratorRecord, error);
		}
		try {
			var k = Get(nextItem, '0');
			var v = Get(nextItem, '1');
			Call(adder, target, [k, v]);
		} catch (e) {
			return IteratorClose(iteratorRecord, ThrowCompletion(e));
		}
	}
};
'use strict';

var SLOT = require('internal-slot');

var $TypeError = require('es-errors/type');
var isObject = require('es-object-atoms/isObject');

var ClearKeptObjects = require('./ClearKeptObjects');

// https://262.ecma-international.org/12.0/#sec-addtokeptobjects

module.exports = function AddToKeptObjects(object) {
	if (!isObject(object)) {
		throw new $TypeError('Assertion failed: `object` must be an Object');
	}
	var arr = SLOT.get(ClearKeptObjects, '[[es-abstract internal: KeptAlive]]');
	arr[arr.length] = object;
};
'use strict';

var $TypeError = require('es-errors/type');

var SameValue = require('./SameValue');

var IsArray = require('../helpers/IsArray');
var every = require('../helpers/every');
var forEach = require('../helpers/forEach');

var hasOwn = require('hasown');

var isKeyedGroup = function (group) {
	return hasOwn(group, '[[Key]]')
        && hasOwn(group, '[[Elements]]')
        && IsArray(group['[[Elements]]']);
};

// https://262.ecma-international.org/15.0/#sec-add-value-to-keyed-group

module.exports = function AddValueToKeyedGroup(groups, key, value) {
	if (!IsArray(groups) || (groups.length > 0 && !every(groups, isKeyedGroup))) {
		throw new $TypeError('Assertion failed: `groups` must be a List of Records with [[Key]] and [[Elements]]');
	}

	var matched = 0;
	forEach(groups, function (g) { // step 1
		if (SameValue(g['[[Key]]'], key)) { // step 2
			matched += 1;
			if (matched > 1) {
				throw new $TypeError('Assertion failed: Exactly one element of groups meets this criterion'); // step 2.a
			}

			var arr = g['[[Elements]]'];
			arr[arr.length] = value; // step 2.b
		}
	});

	if (matched === 0) {
		var group = { '[[Key]]': key, '[[Elements]]': [value] }; // step 2

		// eslint-disable-next-line no-param-reassign
		groups[groups.length] = group; // step 3
	}
};
'use strict';

var CodePointAt = require('./CodePointAt');

var $TypeError = require('es-errors/type');
var isInteger = require('math-intrinsics/isInteger');
var MAX_SAFE_INTEGER = require('math-intrinsics/constants/maxSafeInteger');

// https://262.ecma-international.org/12.0/#sec-advancestringindex

module.exports = function AdvanceStringIndex(S, index, unicode) {
	if (typeof S !== 'string') {
		throw new $TypeError('Assertion failed: `S` must be a String');
	}
	if (!isInteger(index) || index < 0 || index > MAX_SAFE_INTEGER) {
		throw new $TypeError('Assertion failed: `length` must be an integer >= 0 and <= 2**53');
	}
	if (typeof unicode !== 'boolean') {
		throw new $TypeError('Assertion failed: `unicode` must be a Boolean');
	}
	if (!unicode) {
		return index + 1;
	}
	var length = S.length;
	if ((index + 1) >= length) {
		return index + 1;
	}
	var cp = CodePointAt(S, index);
	return index + cp['[[CodeUnitCount]]'];
};
'use strict';

var $TypeError = require('es-errors/type');

var HasEitherUnicodeFlag = require('./HasEitherUnicodeFlag');

var isRegExpRecord = require('../helpers/records/regexp-record');

var CharSet = require('../helpers/CharSet');

// https://262.ecma-international.org/15.0/#sec-allcharacters

module.exports = function AllCharacters(rer) {
	if (!isRegExpRecord(rer)) {
		throw new $TypeError('Assertion failed: `rer` must be a RegExp Record');
	}

	if (rer['[[UnicodeSets]]'] && rer['[[IgnoreCase]]']) { // step 1
		//   1. Return the CharSet containing all Unicode code points _c_ that do not have a <a href="https://www.unicode.org/reports/tr44/#Simple_Case_Folding">Simple Case Folding</a> mapping (that is, scf(_c_)=_c_).
		return CharSet.getNonSimpleCaseFoldingCodePoints(); // step 1.a
	} else if (HasEitherUnicodeFlag(rer)) { // step 2
		//   1. Return the CharSet containing all code point values.
		return CharSet.getCodePoints(); // step 3.a
	// eslint-disable-next-line no-else-return
	} else { // step 3
		//   1. Return the CharSet containing all code unit values.
		return CharSet.getCodeUnits(); // step 3.a
	}
};
'use strict';

var $TypeError = require('es-errors/type');

var HasOwnProperty = require('./HasOwnProperty');
var ToNumeric = require('./ToNumeric');
var ToPrimitive = require('./ToPrimitive');
var ToString = require('./ToString');
var Type = require('./Type');

var NumberAdd = require('./Number/add');
var NumberBitwiseAND = require('./Number/bitwiseAND');
var NumberBitwiseOR = require('./Number/bitwiseOR');
var NumberBitwiseXOR = require('./Number/bitwiseXOR');
var NumberDivide = require('./Number/divide');
var NumberExponentiate = require('./Number/exponentiate');
var NumberLeftShift = require('./Number/leftShift');
var NumberMultiply = require('./Number/multiply');
var NumberRemainder = require('./Number/remainder');
var NumberSignedRightShift = require('./Number/signedRightShift');
var NumberSubtract = require('./Number/subtract');
var NumberUnsignedRightShift = require('./Number/unsignedRightShift');
var BigIntAdd = require('./BigInt/add');
var BigIntBitwiseAND = require('./BigInt/bitwiseAND');
var BigIntBitwiseOR = require('./BigInt/bitwiseOR');
var BigIntBitwiseXOR = require('./BigInt/bitwiseXOR');
var BigIntDivide = require('./BigInt/divide');
var BigIntExponentiate = require('./BigInt/exponentiate');
var BigIntLeftShift = require('./BigInt/leftShift');
var BigIntMultiply = require('./BigInt/multiply');
var BigIntRemainder = require('./BigInt/remainder');
var BigIntSignedRightShift = require('./BigInt/signedRightShift');
var BigIntSubtract = require('./BigInt/subtract');
var BigIntUnsignedRightShift = require('./BigInt/unsignedRightShift');

// https://262.ecma-international.org/12.0/#sec-applystringornumericbinaryoperator

// https://262.ecma-international.org/12.0/#step-applystringornumericbinaryoperator-operations-table
var table = {
	'**': [NumberExponentiate, BigIntExponentiate],
	'*': [NumberMultiply, BigIntMultiply],
	'/': [NumberDivide, BigIntDivide],
	'%': [NumberRemainder, BigIntRemainder],
	'+': [NumberAdd, BigIntAdd],
	'-': [NumberSubtract, BigIntSubtract],
	'<<': [NumberLeftShift, BigIntLeftShift],
	'>>': [NumberSignedRightShift, BigIntSignedRightShift],
	'>>>': [NumberUnsignedRightShift, BigIntUnsignedRightShift],
	'&': [NumberBitwiseAND, BigIntBitwiseAND],
	'^': [NumberBitwiseXOR, BigIntBitwiseXOR],
	'|': [NumberBitwiseOR, BigIntBitwiseOR]
};

module.exports = function ApplyStringOrNumericBinaryOperator(lval, opText, rval) {
	if (typeof opText !== 'string' || !HasOwnProperty(table, opText)) {
		throw new $TypeError('Assertion failed: `opText` must be a valid operation string');
	}
	if (opText === '+') {
		var lprim = ToPrimitive(lval);
		var rprim = ToPrimitive(rval);
		if (typeof lprim === 'string' || typeof rprim === 'string') {
			var lstr = ToString(lprim);
			var rstr = ToString(rprim);
			return lstr + rstr;
		}
		/* eslint no-param-reassign: 1 */
		lval = lprim;
		rval = rprim;
	}
	var lnum = ToNumeric(lval);
	var rnum = ToNumeric(rval);
	if (Type(lnum) !== Type(rnum)) {
		throw new $TypeError('types of ' + lnum + ' and ' + rnum + ' differ');
	}
	var Operation = table[opText][typeof lnum === 'bigint' ? 1 : 0];
	return Operation(lnum, rnum);
};
'use strict';

var $TypeError = require('es-errors/type');

// https://262.ecma-international.org/15.0/#sec-arraybufferbytelength

var IsDetachedBuffer = require('./IsDetachedBuffer');

var isArrayBuffer = require('is-array-buffer');
var isSharedArrayBuffer = require('is-shared-array-buffer');
var arrayBufferByteLength = require('array-buffer-byte-length');

var callBound = require('call-bound');
var $sabByteLength = callBound('SharedArrayBuffer.prototype.byteLength', true);

var isGrowable = false; // TODO: support this

module.exports = function ArrayBufferByteLength(arrayBuffer, order) {
	var isSAB = isSharedArrayBuffer(arrayBuffer);
	if (!isArrayBuffer(arrayBuffer) && !isSAB) {
		throw new $TypeError('Assertion failed: `arrayBuffer` must be an ArrayBuffer or a SharedArrayBuffer');
	}
	if (order !== 'SEQ-CST' && order !== 'UNORDERED') {
		throw new $TypeError('Assertion failed: `order` must be ~SEQ-CST~ or ~UNORDERED~');
	}

	// 1. If IsSharedArrayBuffer(arrayBuffer) is true and arrayBuffer has an [[ArrayBufferByteLengthData]] internal slot, then
	// TODO: see if IsFixedLengthArrayBuffer can be used here in the spec instead
	if (isSAB && isGrowable) { // step 1
		// a. Let bufferByteLengthBlock be arrayBuffer.[[ArrayBufferByteLengthData]].
		// b. Let rawLength be GetRawBytesFromSharedBlock(bufferByteLengthBlock, 0, BIGUINT64, true, order).
		// c. Let isLittleEndian be the value of the [[LittleEndian]] field of the surrounding agent's Agent Record.
		// d. Return ℝ(RawBytesToNumeric(BIGUINT64, rawLength, isLittleEndian)).
	}

	if (IsDetachedBuffer(arrayBuffer)) {
		throw new $TypeError('Assertion failed: `arrayBuffer` must not be detached'); // step 2
	}

	return isSAB ? $sabByteLength(arrayBuffer) : arrayBufferByteLength(arrayBuffer);
};
'use strict';

var GetIntrinsic = require('get-intrinsic');

var min = require('math-intrinsics/min');
var $TypeError = require('es-errors/type');
var $ArrayBuffer = GetIntrinsic('%ArrayBuffer%', true);
var $Uint8Array = GetIntrinsic('%Uint8Array%', true);

var callBound = require('call-bound');

var byteLength = require('array-buffer-byte-length');
var $maxByteLength = callBound('%ArrayBuffer.prototype.maxByteLength%', true);
var copy = function copyAB(src, start, end) {
	var that = new $Uint8Array(src);
	if (typeof end === 'undefined') {
		end = that.length; // eslint-disable-line no-param-reassign
	}
	var result = new $ArrayBuffer(end - start);
	var resultArray = new $Uint8Array(result);
	for (var i = 0; i < resultArray.length; i++) {
		resultArray[i] = that[i + start];
	}
	return result;
};
var $abSlice = callBound('%ArrayBuffer.prototype.slice%', true)
	|| function slice(ab, a, b) { // in node < 0.11, slice is an own nonconfigurable property
		return ab.slice ? ab.slice(a, b) : copy(ab, a, b); // node 0.8 lacks `slice`
	};

var DetachArrayBuffer = require('./DetachArrayBuffer');
var IsDetachedBuffer = require('./IsDetachedBuffer');
var IsFixedLengthArrayBuffer = require('./IsFixedLengthArrayBuffer');
var ToIndex = require('./ToIndex');

var isArrayBuffer = require('is-array-buffer');
var isSharedArrayBuffer = require('is-shared-array-buffer');

// https://262.ecma-international.org/15.0/#sec-arraybuffercopyanddetach

module.exports = function ArrayBufferCopyAndDetach(arrayBuffer, newLength, preserveResizability) {
	if (preserveResizability !== 'PRESERVE-RESIZABILITY' && preserveResizability !== 'FIXED-LENGTH') {
		throw new $TypeError('`preserveResizability` must be ~PRESERVE-RESIZABILITY~ or ~FIXED-LENGTH~');
	}

	if (!isArrayBuffer(arrayBuffer) || isSharedArrayBuffer(arrayBuffer)) {
		throw new $TypeError('`arrayBuffer` must be a non-shared ArrayBuffer'); // steps 1 - 2
	}

	var abByteLength;

	var newByteLength;
	if (typeof newLength === 'undefined') { // step 3
		newByteLength = byteLength(arrayBuffer); // step 3.a
		abByteLength = newByteLength;
	} else { // step 4
		newByteLength = ToIndex(newLength); // step 4.a
	}

	if (IsDetachedBuffer(arrayBuffer)) {
		throw new $TypeError('`arrayBuffer` must not be detached'); // step 5
	}

	var newMaxByteLength;
	if (preserveResizability === 'PRESERVE-RESIZABILITY' && !IsFixedLengthArrayBuffer(arrayBuffer)) { // step 6
		newMaxByteLength = $maxByteLength(arrayBuffer); // step 6.a
	} else { // step 7
		newMaxByteLength = 'EMPTY'; // step 7.a
	}

	// commented out since there's no way to set or access this key

	// 8. If arrayBuffer.[[ArrayBufferDetachKey]] is not undefined, throw a TypeError exception.

	// 9. Let newBuffer be ? AllocateArrayBuffer(%ArrayBuffer%, newByteLength, newMaxByteLength).
	var newBuffer = newMaxByteLength === 'EMPTY' ? new $ArrayBuffer(newByteLength) : new $ArrayBuffer(newByteLength, { maxByteLength: newMaxByteLength });

	if (typeof abByteLength !== 'number') {
		abByteLength = byteLength(arrayBuffer);
	}
	var copyLength = min(newByteLength, abByteLength); // step 10
	if (newByteLength > copyLength || newMaxByteLength !== 'EMPTY') {
		var taNew = new $Uint8Array(newBuffer);
		var taOld = new $Uint8Array(arrayBuffer);
		for (var i = 0; i < copyLength; i++) {
			taNew[i] = taOld[i];
		}
	} else {
		newBuffer = $abSlice(arrayBuffer, 0, copyLength); // ? optimization for when the new buffer will not be larger than the old one
	}
	/*
	11. Let fromBlock be arrayBuffer.[[ArrayBufferData]].
	12. Let toBlock be newBuffer.[[ArrayBufferData]].
	13. Perform CopyDataBlockBytes(toBlock, 0, fromBlock, 0, copyLength).
	14. NOTE: Neither creation of the new Data Block nor copying from the old Data Block are observable. Implementations may implement this method as a zero-copy move or a realloc.
	*/

	DetachArrayBuffer(arrayBuffer); // step 15

	return newBuffer; // step 16
};
'use strict';

var GetIntrinsic = require('get-intrinsic');

var $ArrayPrototype = GetIntrinsic('%Array.prototype%');
var $RangeError = require('es-errors/range');
var $SyntaxError = require('es-errors/syntax');
var $TypeError = require('es-errors/type');
var isInteger = require('math-intrinsics/isInteger');
var MAX_ARRAY_LENGTH = require('math-intrinsics/constants/maxArrayLength');
var $setProto = require('set-proto');

// https://262.ecma-international.org/12.0/#sec-arraycreate

module.exports = function ArrayCreate(length) {
	if (!isInteger(length) || length < 0) {
		throw new $TypeError('Assertion failed: `length` must be an integer Number >= 0');
	}
	if (length > MAX_ARRAY_LENGTH) {
		throw new $RangeError('length is greater than (2**32 - 1)');
	}
	var proto = arguments.length > 1 ? arguments[1] : $ArrayPrototype;
	var A = []; // steps 3, 5
	if (proto !== $ArrayPrototype) { // step 4
		if (!$setProto) {
			throw new $SyntaxError('ArrayCreate: a `proto` argument that is not `Array.prototype` is not supported in an environment that does not support setting the [[Prototype]]');
		}
		$setProto(A, proto);
	}
	if (length !== 0) { // bypasses the need for step 6
		A.length = length;
	}
	/* step 6, the above as a shortcut for the below
	OrdinaryDefineOwnProperty(A, 'length', {
		'[[Configurable]]': false,
		'[[Enumerable]]': false,
		'[[Value]]': length,
		'[[Writable]]': true
	});
	*/
	return A;
};
'use strict';

var $RangeError = require('es-errors/range');
var $TypeError = require('es-errors/type');

var assign = require('object.assign');

var isPropertyDescriptor = require('../helpers/records/property-descriptor');

var IsArray = require('./IsArray');
var IsDataDescriptor = require('./IsDataDescriptor');
var OrdinaryDefineOwnProperty = require('./OrdinaryDefineOwnProperty');
var OrdinaryGetOwnProperty = require('./OrdinaryGetOwnProperty');
var ToNumber = require('./ToNumber');
var ToString = require('./ToString');
var ToUint32 = require('./ToUint32');

// https://262.ecma-international.org/6.0/#sec-arraysetlength

// eslint-disable-next-line max-statements, max-lines-per-function
module.exports = function ArraySetLength(A, Desc) {
	if (!IsArray(A)) {
		throw new $TypeError('Assertion failed: A must be an Array');
	}
	if (!isPropertyDescriptor(Desc)) {
		throw new $TypeError('Assertion failed: Desc must be a Property Descriptor');
	}
	if (!('[[Value]]' in Desc)) {
		return OrdinaryDefineOwnProperty(A, 'length', Desc);
	}
	var newLenDesc = assign({}, Desc);
	var newLen = ToUint32(Desc['[[Value]]']);
	var numberLen = ToNumber(Desc['[[Value]]']);
	if (newLen !== numberLen) {
		throw new $RangeError('Invalid array length');
	}
	newLenDesc['[[Value]]'] = newLen;
	var oldLenDesc = OrdinaryGetOwnProperty(A, 'length');
	if (!IsDataDescriptor(oldLenDesc)) {
		throw new $TypeError('Assertion failed: an array had a non-data descriptor on `length`');
	}
	var oldLen = oldLenDesc['[[Value]]'];
	if (newLen >= oldLen) {
		return OrdinaryDefineOwnProperty(A, 'length', newLenDesc);
	}
	if (!oldLenDesc['[[Writable]]']) {
		return false;
	}
	var newWritable;
	if (!('[[Writable]]' in newLenDesc) || newLenDesc['[[Writable]]']) {
		newWritable = true;
	} else {
		newWritable = false;
		newLenDesc['[[Writable]]'] = true;
	}
	var succeeded = OrdinaryDefineOwnProperty(A, 'length', newLenDesc);
	if (!succeeded) {
		return false;
	}
	while (newLen < oldLen) {
		oldLen -= 1;
		// eslint-disable-next-line no-param-reassign
		var deleteSucceeded = delete A[ToString(oldLen)];
		if (!deleteSucceeded) {
			newLenDesc['[[Value]]'] = oldLen + 1;
			if (!newWritable) {
				newLenDesc['[[Writable]]'] = false;
				OrdinaryDefineOwnProperty(A, 'length', newLenDesc);
				return false;
			}
		}
	}
	if (!newWritable) {
		return OrdinaryDefineOwnProperty(A, 'length', { '[[Writable]]': false });
	}
	return true;
};
'use strict';

var GetIntrinsic = require('get-intrinsic');

var $species = GetIntrinsic('%Symbol.species%', true);
var $TypeError = require('es-errors/type');
var isInteger = require('math-intrinsics/isInteger');
var isObject = require('es-object-atoms/isObject');

var ArrayCreate = require('./ArrayCreate');
var Get = require('./Get');
var IsArray = require('./IsArray');
var IsConstructor = require('./IsConstructor');

// https://262.ecma-international.org/12.0/#sec-arrayspeciescreate

module.exports = function ArraySpeciesCreate(originalArray, length) {
	if (!isInteger(length) || length < 0) {
		throw new $TypeError('Assertion failed: length must be an integer >= 0');
	}

	var isArray = IsArray(originalArray);
	if (!isArray) {
		return ArrayCreate(length);
	}

	var C = Get(originalArray, 'constructor');
	// TODO: figure out how to make a cross-realm normal Array, a same-realm Array
	// if (IsConstructor(C)) {
	// 	if C is another realm's Array, C = undefined
	// 	Object.getPrototypeOf(Object.getPrototypeOf(Object.getPrototypeOf(Array))) === null ?
	// }
	if ($species && isObject(C)) {
		C = Get(C, $species);
		if (C === null) {
			C = void 0;
		}
	}

	if (typeof C === 'undefined') {
		return ArrayCreate(length);
	}
	if (!IsConstructor(C)) {
		throw new $TypeError('C must be a constructor');
	}
	return new C(length); // Construct(C, length);
};

'use strict';

var GetIntrinsic = require('get-intrinsic');

var $SyntaxError = require('es-errors/syntax');
var $TypeError = require('es-errors/type');
var isObject = require('es-object-atoms/isObject');
var $Promise = GetIntrinsic('%Promise%', true);

var callBound = require('call-bound');

var CreateIterResultObject = require('./CreateIterResultObject');
var IteratorComplete = require('./IteratorComplete');
var IteratorValue = require('./IteratorValue');
var PromiseResolve = require('./PromiseResolve');

var $then = callBound('Promise.prototype.then', true);

// https://262.ecma-international.org/10.0/#sec-asyncfromsynciteratorcontinuation

module.exports = function AsyncFromSyncIteratorContinuation(result) {
	if (!isObject(result)) {
		throw new $TypeError('Assertion failed: Type(O) is not Object');
	}

	if (arguments.length > 1) {
		throw new $SyntaxError('although AsyncFromSyncIteratorContinuation should take a second argument, it is not used in this implementation');
	}

	if (!$Promise) {
		throw new $SyntaxError('This environment does not support Promises.');
	}

	return new $Promise(function (resolve) {
		var done = IteratorComplete(result); // step 2
		var value = IteratorValue(result); // step 4
		var valueWrapper = PromiseResolve($Promise, value); // step 6

		// eslint-disable-next-line no-shadow
		var onFulfilled = function (value) { // steps 8-9
			return CreateIterResultObject(value, done); // step 8.a
		};
		resolve($then(valueWrapper, onFulfilled)); // step 11
	}); // step 12
};
'use strict';

var GetIntrinsic = require('get-intrinsic');

var $SyntaxError = require('es-errors/syntax');
var $TypeError = require('es-errors/type');
var isObject = require('es-object-atoms/isObject');
var $Promise = GetIntrinsic('%Promise%', true);

var Call = require('./Call');
var CompletionRecord = require('./CompletionRecord');
var GetMethod = require('./GetMethod');

var isIteratorRecord = require('../helpers/records/iterator-record');

var callBound = require('call-bound');

var $then = callBound('Promise.prototype.then', true);

// https://262.ecma-international.org/15.0/#sec-asynciteratorclose

module.exports = function AsyncIteratorClose(iteratorRecord, completion) {
	if (!isIteratorRecord(iteratorRecord)) {
		throw new $TypeError('Assertion failed: `iteratorRecord` must be an Iterator Record'); // step 1
	}

	if (!(completion instanceof CompletionRecord)) {
		throw new $TypeError('Assertion failed: completion is not a Completion Record instance'); // step 2
	}

	if (!$then) {
		throw new $SyntaxError('This environment does not support Promises.');
	}

	var iterator = iteratorRecord['[[Iterator]]']; // step 3

	return $then(
		$then(
			$then(
				new $Promise(function (resolve) {
					resolve(GetMethod(iterator, 'return')); // step 4
					// resolve(Call(ret, iterator, [])); // step 6
				}),
				function (returnV) { // step 5.a
					if (typeof returnV === 'undefined') {
						return completion; // step 5.b
					}
					return Call(returnV, iterator); // step 5.c, 5.d.
				}
			),
			null,
			function (e) {
				if (completion.type() === 'throw') {
					completion['?'](); // step 6
				} else {
					throw e; // step 7
				}
			}
		),
		function (innerResult) { // step 8
			if (completion.type() === 'throw') {
				completion['?'](); // step 6
			}
			if (!isObject(innerResult)) {
				throw new $TypeError('`innerResult` must be an Object'); // step 10
			}
			return completion;
		}
	);
};
'use strict';

var $TypeError = require('es-errors/type');
// var $BigInt = GetIntrinsic('%BigInt%', true);
// var $pow = require('math-intrinsics/pow');

// var BinaryAnd = require('./BinaryAnd');
// var BinaryOr = require('./BinaryOr');
// var BinaryXor = require('./BinaryXor');
// var modulo = require('./modulo');

// var zero = $BigInt && $BigInt(0);
// var negOne = $BigInt && $BigInt(-1);
// var two = $BigInt && $BigInt(2);

// https://262.ecma-international.org/11.0/#sec-bigintbitwiseop

module.exports = function BigIntBitwiseOp(op, x, y) {
	if (op !== '&' && op !== '|' && op !== '^') {
		throw new $TypeError('Assertion failed: `op` must be `&`, `|`, or `^`');
	}
	if (typeof x !== 'bigint' || typeof y !== 'bigint') {
		throw new $TypeError('`x` and `y` must be BigInts');
	}

	if (op === '&') {
		return x & y;
	}
	if (op === '|') {
		return x | y;
	}
	return x ^ y;
	/*
	var result = zero;
	var shift = 0;
	while (x !== zero && x !== negOne && y !== zero && y !== negOne) {
		var xDigit = modulo(x, two);
		var yDigit = modulo(y, two);
		if (op === '&') {
			result += $pow(2, shift) * BinaryAnd(xDigit, yDigit);
		} else if (op === '|') {
			result += $pow(2, shift) * BinaryOr(xDigit, yDigit);
		} else if (op === '^') {
			result += $pow(2, shift) * BinaryXor(xDigit, yDigit);
		}
		shift += 1;
		x = (x - xDigit) / two;
		y = (y - yDigit) / two;
	}
	var tmp;
	if (op === '&') {
		tmp = BinaryAnd(modulo(x, two), modulo(y, two));
	} else if (op === '|') {
		tmp = BinaryAnd(modulo(x, two), modulo(y, two));
	} else {
		tmp = BinaryXor(modulo(x, two), modulo(y, two));
	}
	if (tmp !== 0) {
		result -= $pow(2, shift);
	}
	return result;
	*/
};
'use strict';

var $TypeError = require('es-errors/type');

// https://262.ecma-international.org/11.0/#sec-binaryand

module.exports = function BinaryAnd(x, y) {
	if ((x !== 0 && x !== 1) || (y !== 0 && y !== 1)) {
		throw new $TypeError('Assertion failed: `x` and `y` must be either 0 or 1');
	}
	return x & y;
};
'use strict';

var $TypeError = require('es-errors/type');

// https://262.ecma-international.org/11.0/#sec-binaryor

module.exports = function BinaryOr(x, y) {
	if ((x !== 0 && x !== 1) || (y !== 0 && y !== 1)) {
		throw new $TypeError('Assertion failed: `x` and `y` must be either 0 or 1');
	}
	return x | y;
};
'use strict';

var $TypeError = require('es-errors/type');

// https://262.ecma-international.org/11.0/#sec-binaryxor

module.exports = function BinaryXor(x, y) {
	if ((x !== 0 && x !== 1) || (y !== 0 && y !== 1)) {
		throw new $TypeError('Assertion failed: `x` and `y` must be either 0 or 1');
	}
	return x ^ y;
};
'use strict';

var $TypeError = require('es-errors/type');

var IsArray = require('./IsArray');

var isByteValue = require('../helpers/isByteValue');

// https://262.ecma-international.org/12.0/#sec-bytelistbitwiseop

module.exports = function ByteListBitwiseOp(op, xBytes, yBytes) {
	if (op !== '&' && op !== '^' && op !== '|') {
		throw new $TypeError('Assertion failed: `op` must be `&`, `^`, or `|`');
	}
	if (!IsArray(xBytes) || !IsArray(yBytes) || xBytes.length !== yBytes.length) {
		throw new $TypeError('Assertion failed: `xBytes` and `yBytes` must be same-length sequences of byte values (an integer 0-255, inclusive)');
	}

	var result = [];

	for (var i = 0; i < xBytes.length; i += 1) {
		var xByte = xBytes[i];
		var yByte = yBytes[i];
		if (!isByteValue(xByte) || !isByteValue(yByte)) {
			throw new $TypeError('Assertion failed: `xBytes` and `yBytes` must be same-length sequences of byte values (an integer 0-255, inclusive)');
		}
		var resultByte;
		if (op === '&') {
			resultByte = xByte & yByte;
		} else if (op === '^') {
			resultByte = xByte ^ yByte;
		} else {
			resultByte = xByte | yByte;
		}
		result[result.length] = resultByte;
	}

	return result;
};
'use strict';

var $TypeError = require('es-errors/type');

var IsArray = require('./IsArray');

var isByteValue = require('../helpers/isByteValue');

// https://262.ecma-international.org/12.0/#sec-bytelistequal

module.exports = function ByteListEqual(xBytes, yBytes) {
	if (!IsArray(xBytes) || !IsArray(yBytes)) {
		throw new $TypeError('Assertion failed: `xBytes` and `yBytes` must be sequences of byte values (an integer 0-255, inclusive)');
	}

	if (xBytes.length !== yBytes.length) {
		return false;
	}

	for (var i = 0; i < xBytes.length; i += 1) {
		var xByte = xBytes[i];
		var yByte = yBytes[i];
		if (!isByteValue(xByte) || !isByteValue(yByte)) {
			throw new $TypeError('Assertion failed: `xBytes` and `yBytes` must be sequences of byte values (an integer 0-255, inclusive)');
		}
		if (xByte !== yByte) {
			return false;
		}
	}
	return true;
};
'use strict';

var GetIntrinsic = require('get-intrinsic');
var callBound = require('call-bound');

var $TypeError = require('es-errors/type');

var IsArray = require('./IsArray');

var $apply = GetIntrinsic('%Reflect.apply%', true) || callBound('Function.prototype.apply');

// https://262.ecma-international.org/6.0/#sec-call

module.exports = function Call(F, V) {
	var argumentsList = arguments.length > 2 ? arguments[2] : [];
	if (!IsArray(argumentsList)) {
		throw new $TypeError('Assertion failed: optional `argumentsList`, if provided, must be a List');
	}
	return $apply(F, V, argumentsList);
};
'use strict';

var isObject = require('es-object-atoms/isObject');

var KeyForSymbol = require('./KeyForSymbol');

// https://262.ecma-international.org/14.0/#sec-canbeheldweakly

module.exports = function CanBeHeldWeakly(v) {
	if (isObject(v)) {
		return true; // step 1
	}
	if (typeof v === 'symbol' && typeof KeyForSymbol(v) === 'undefined') {
		return true; // step 2
	}
	return false; // step 3
};
'use strict';

var $TypeError = require('es-errors/type');

var callBound = require('call-bound');
var hasOwn = require('hasown');

var $charCodeAt = callBound('String.prototype.charCodeAt');
var $toUpperCase = callBound('String.prototype.toUpperCase');

var isRegExpRecord = require('../helpers/records/regexp-record');
var caseFolding = require('../helpers/caseFolding.json');

// https://262.ecma-international.org/14.0/#sec-runtime-semantics-canonicalize-ch

module.exports = function Canonicalize(rer, ch) {
	if (!isRegExpRecord(rer)) {
		throw new $TypeError('Assertion failed: `rer` must be a RegExp Record');
	}

	if (typeof ch !== 'string') {
		throw new $TypeError('Assertion failed: `ch` must be a character');
	}

	if (rer['[[Unicode]]'] && rer['[[IgnoreCase]]']) { // step 1
		if (hasOwn(caseFolding.C, ch)) {
			return caseFolding.C[ch];
		}
		if (hasOwn(caseFolding.S, ch)) {
			return caseFolding.S[ch];
		}
		return ch; // step 1.b
	}

	if (!rer['[[IgnoreCase]]']) {
		return ch; // step 2
	}

	var u = $toUpperCase(ch); // step 5

	if (u.length !== 1) {
		return ch; // step 7
	}

	var cu = u; // step 8

	if ($charCodeAt(ch, 0) >= 128 && $charCodeAt(cu, 0) < 128) {
		return ch; // step 9
	}

	return cu; // step 10
};
'use strict';

var $TypeError = require('es-errors/type');

var SameValue = require('./SameValue');
var ToNumber = require('./ToNumber');
var ToString = require('./ToString');

// https://262.ecma-international.org/6.0/#sec-canonicalnumericindexstring

module.exports = function CanonicalNumericIndexString(argument) {
	if (typeof argument !== 'string') {
		throw new $TypeError('Assertion failed: `argument` must be a String');
	}
	if (argument === '-0') { return -0; }
	var n = ToNumber(argument);
	if (SameValue(ToString(n), argument)) { return n; }
	return void 0;
};
'use strict';

var $TypeError = require('es-errors/type');

var AllCharacters = require('./AllCharacters');

var CharSet = require('../helpers/CharSet').CharSet;
var isRegExpRecord = require('../helpers/records/regexp-record');

// https://262.ecma-international.org/15.0/#sec-charactercomplement

module.exports = function CharacterComplement(rer, S) {
	if (!isRegExpRecord(rer)) {
		throw new $TypeError('Assertion failed: `rer` must be a RegExp Record');
	}

	if (!(S instanceof CharSet)) {
		throw new $TypeError('Assertion failed: S must be a CharSet');
	}

	var A = AllCharacters(rer); // step 1

	// 2. Return the CharSet containing the CharSetElements of A which are not also CharSetElements of S.
	return new CharSet(
		function (x) { return !S.test(x) && A.test(x); },
		function (emit) {
			A.yield(function (x) {
				if (!S.test(x)) {
					emit(x);
				}
			});
		}
	);
};
'use strict';

var GetIntrinsic = require('get-intrinsic');
var callBound = require('call-bound');

var $fromCharCode = GetIntrinsic('%String.fromCharCode%');
var $TypeError = require('es-errors/type');
var $charCodeAt = callBound('String.prototype.charCodeAt');

var CharSet = require('../helpers/CharSet').CharSet;

module.exports = function CharacterRange(A, B) {
	var a;
	var b;

	if (A instanceof CharSet || B instanceof CharSet) {
		if (!(A instanceof CharSet) || !(B instanceof CharSet)) {
			throw new $TypeError('Assertion failed: CharSets A and B are not both CharSets');
		}

		A.yield(function (c) {
			if (typeof a !== 'undefined') {
				throw new $TypeError('Assertion failed: CharSet A has more than one character');
			}
			a = c;
		});
		B.yield(function (c) {
			if (typeof b !== 'undefined') {
				throw new $TypeError('Assertion failed: CharSet B has more than one character');
			}
			b = c;
		});
	} else {
		if (A.length !== 1 || B.length !== 1) {
			throw new $TypeError('Assertion failed: CharSets A and B contain exactly one character');
		}
		a = A[0];
		b = B[0];
	}

	var i = $charCodeAt(a, 0);
	var j = $charCodeAt(b, 0);

	if (!(i <= j)) {
		throw new $TypeError('Assertion failed: i is not <= j');
	}

	var arr = [];
	for (var k = i; k <= j; k += 1) {
		arr[arr.length] = $fromCharCode(k);
	}
	return arr;
};
'use strict';

var $TypeError = require('es-errors/type');
var max = require('math-intrinsics/max');
var min = require('math-intrinsics/min');

// https://262.ecma-international.org/12.0/#clamping

module.exports = function clamp(x, lower, upper) {
	if (typeof x !== 'number' || typeof lower !== 'number' || typeof upper !== 'number' || !(lower <= upper)) {
		throw new $TypeError('Assertion failed: all three arguments must be MVs, and `lower` must be `<= upper`');
	}
	return min(max(lower, x), upper);
};
'use strict';

var SLOT = require('internal-slot');
var keptObjects = [];

// https://262.ecma-international.org/12.0/#sec-clear-kept-objects

module.exports = function ClearKeptObjects() {
	keptObjects.length = 0;
};

SLOT.set(module.exports, '[[es-abstract internal: KeptAlive]]', keptObjects);
'use strict';

var $TypeError = require('es-errors/type');

var GetPrototypeFromConstructor = require('./GetPrototypeFromConstructor');
var IsConstructor = require('./IsConstructor');
var IsDetachedBuffer = require('./IsDetachedBuffer');
var OrdinarySetPrototypeOf = require('./OrdinarySetPrototypeOf');

var isInteger = require('math-intrinsics/isInteger');
var isArrayBuffer = require('is-array-buffer');
var arrayBufferSlice = require('arraybuffer.prototype.slice');

// https://262.ecma-international.org/12.0/#sec-clonearraybuffer

module.exports = function CloneArrayBuffer(srcBuffer, srcByteOffset, srcLength, cloneConstructor) {
	if (!isArrayBuffer(srcBuffer)) {
		throw new $TypeError('Assertion failed: `srcBuffer` must be an ArrayBuffer instance');
	}
	if (!isInteger(srcByteOffset) || srcByteOffset < 0) {
		throw new $TypeError('Assertion failed: `srcByteOffset` must be a non-negative integer');
	}
	if (!isInteger(srcLength) || srcLength < 0) {
		throw new $TypeError('Assertion failed: `srcLength` must be a non-negative integer');
	}
	if (!IsConstructor(cloneConstructor)) {
		throw new $TypeError('Assertion failed: `cloneConstructor` must be a constructor');
	}

	// 3. Let targetBuffer be ? AllocateArrayBuffer(cloneConstructor, srcLength).
	var proto = GetPrototypeFromConstructor(cloneConstructor, '%ArrayBufferPrototype%'); // step 3, kinda

	if (IsDetachedBuffer(srcBuffer)) {
		throw new $TypeError('`srcBuffer` must not be a detached ArrayBuffer'); // step 4
	}

	/*
    5. Let srcBlock be srcBuffer.[[ArrayBufferData]].
    6. Let targetBlock be targetBuffer.[[ArrayBufferData]].
    7. Perform CopyDataBlockBytes(targetBlock, 0, srcBlock, srcByteOffset, srcLength).
    */
	var targetBuffer = arrayBufferSlice(srcBuffer, srcByteOffset, srcByteOffset + srcLength); // steps 5-7
	OrdinarySetPrototypeOf(targetBuffer, proto); // step 3

	return targetBuffer; // step 8
};
'use strict';

var $TypeError = require('es-errors/type');
var callBound = require('call-bound');
var isLeadingSurrogate = require('../helpers/isLeadingSurrogate');
var isTrailingSurrogate = require('../helpers/isTrailingSurrogate');

var UTF16SurrogatePairToCodePoint = require('./UTF16SurrogatePairToCodePoint');

var $charAt = callBound('String.prototype.charAt');
var $charCodeAt = callBound('String.prototype.charCodeAt');

// https://262.ecma-international.org/12.0/#sec-codepointat

module.exports = function CodePointAt(string, position) {
	if (typeof string !== 'string') {
		throw new $TypeError('Assertion failed: `string` must be a String');
	}
	var size = string.length;
	if (position < 0 || position >= size) {
		throw new $TypeError('Assertion failed: `position` must be >= 0, and < the length of `string`');
	}
	var first = $charCodeAt(string, position);
	var cp = $charAt(string, position);
	var firstIsLeading = isLeadingSurrogate(first);
	var firstIsTrailing = isTrailingSurrogate(first);
	if (!firstIsLeading && !firstIsTrailing) {
		return {
			'[[CodePoint]]': cp,
			'[[CodeUnitCount]]': 1,
			'[[IsUnpairedSurrogate]]': false
		};
	}
	if (firstIsTrailing || (position + 1 === size)) {
		return {
			'[[CodePoint]]': cp,
			'[[CodeUnitCount]]': 1,
			'[[IsUnpairedSurrogate]]': true
		};
	}
	var second = $charCodeAt(string, position + 1);
	if (!isTrailingSurrogate(second)) {
		return {
			'[[CodePoint]]': cp,
			'[[CodeUnitCount]]': 1,
			'[[IsUnpairedSurrogate]]': true
		};
	}

	return {
		'[[CodePoint]]': UTF16SurrogatePairToCodePoint(first, second),
		'[[CodeUnitCount]]': 2,
		'[[IsUnpairedSurrogate]]': false
	};
};
'use strict';

var $TypeError = require('es-errors/type');

var UTF16EncodeCodePoint = require('./UTF16EncodeCodePoint');
var IsArray = require('./IsArray');

var forEach = require('../helpers/forEach');
var isCodePoint = require('../helpers/isCodePoint');

// https://262.ecma-international.org/12.0/#sec-codepointstostring

module.exports = function CodePointsToString(text) {
	if (!IsArray(text)) {
		throw new $TypeError('Assertion failed: `text` must be a sequence of Unicode Code Points');
	}
	var result = '';
	forEach(text, function (cp) {
		if (!isCodePoint(cp)) {
			throw new $TypeError('Assertion failed: `text` must be a sequence of Unicode Code Points');
		}
		result += UTF16EncodeCodePoint(cp);
	});
	return result;
};
'use strict';

var $TypeError = require('es-errors/type');

var Call = require('./Call');
var IsLessThan = require('./IsLessThan');
var ToNumber = require('./ToNumber');
var ToString = require('./ToString');

var isNaN = require('math-intrinsics/isNaN');

// https://262.ecma-international.org/14.0/#sec-comparearrayelements

module.exports = function CompareArrayElements(x, y, compareFn) {
	if (typeof compareFn !== 'function' && typeof compareFn !== 'undefined') {
		throw new $TypeError('Assertion failed: `compareFn` must be a function or undefined');
	}

	if (typeof x === 'undefined' && typeof y === 'undefined') {
		return 0; // step 1
	}

	if (typeof x === 'undefined') {
		return 1; // step 2
	}

	if (typeof y === 'undefined') {
		return -1; // step 3
	}

	if (typeof compareFn !== 'undefined') { // step 4
		var v = ToNumber(Call(compareFn, void undefined, [x, y])); // step 4.a
		if (isNaN(v)) {
			return 0; // step 4.b
		}
		return v; // step 4.c
	}

	var xString = ToString(x); // step 5
	var yString = ToString(y); // step 6
	var xSmaller = IsLessThan(xString, yString, true); // step 7
	if (xSmaller) {
		return -1; // step 8
	}
	var ySmaller = IsLessThan(yString, xString, true); // step 9
	if (ySmaller) {
		return 1; // step 10
	}
	return 0; // step 11
};
'use strict';

var $TypeError = require('es-errors/type');

var Call = require('./Call');
var SameValue = require('./SameValue');
var ToNumber = require('./ToNumber');

var isNaN = require('math-intrinsics/isNaN');

// https://262.ecma-international.org/14.0/#sec-comparetypedarrayelements

module.exports = function CompareTypedArrayElements(x, y, compareFn) {
	if ((typeof x !== 'number' && typeof x !== 'bigint') || typeof x !== typeof y) {
		throw new $TypeError('Assertion failed: `x` and `y` must be either a BigInt or a Number, and both must be the same type');
	}
	if (typeof compareFn !== 'function' && typeof compareFn !== 'undefined') {
		throw new $TypeError('Assertion failed: `compareFn` must be a function or undefined');
	}

	if (typeof compareFn !== 'undefined') { // step 2
		var v = ToNumber(Call(compareFn, void undefined, [x, y])); // step 2.a
		if (isNaN(v)) {
			return 0; // step 2.b
		}
		return v; // step 2.c
	}

	var xNaN = isNaN(x);
	var yNaN = isNaN(y);
	if (xNaN && yNaN) {
		return 0; // step 3
	}

	if (xNaN) {
		return 1; // step 4
	}

	if (yNaN) {
		return -1; // step 5
	}

	if (x < y) {
		return -1; // step 6
	}

	if (x > y) {
		return 1; // step 7
	}

	if (SameValue(x, -0) && SameValue(y, 0)) {
		return -1; // step 8
	}

	if (SameValue(x, 0) && SameValue(y, -0)) {
		return 1; // step 9
	}

	return 0; // step 10
};
'use strict';

var $TypeError = require('es-errors/type');

var hasOwn = require('hasown');

var IsDataDescriptor = require('./IsDataDescriptor');
var IsGenericDescriptor = require('./IsGenericDescriptor');

var isPropertyDescriptor = require('../helpers/records/property-descriptor');

// https://262.ecma-international.org/6.0/#sec-completepropertydescriptor

module.exports = function CompletePropertyDescriptor(Desc) {
	if (!isPropertyDescriptor(Desc)) {
		throw new $TypeError('Assertion failed: `Desc` must be a Property Descriptor');
	}

	/* eslint no-param-reassign: 0 */

	if (IsGenericDescriptor(Desc) || IsDataDescriptor(Desc)) {
		if (!hasOwn(Desc, '[[Value]]')) {
			Desc['[[Value]]'] = void 0;
		}
		if (!hasOwn(Desc, '[[Writable]]')) {
			Desc['[[Writable]]'] = false;
		}
	} else {
		if (!hasOwn(Desc, '[[Get]]')) {
			Desc['[[Get]]'] = void 0;
		}
		if (!hasOwn(Desc, '[[Set]]')) {
			Desc['[[Set]]'] = void 0;
		}
	}
	if (!hasOwn(Desc, '[[Enumerable]]')) {
		Desc['[[Enumerable]]'] = false;
	}
	if (!hasOwn(Desc, '[[Configurable]]')) {
		Desc['[[Configurable]]'] = false;
	}
	return Desc;
};
'use strict';

var $SyntaxError = require('es-errors/syntax');

var SLOT = require('internal-slot');

// https://262.ecma-international.org/7.0/#sec-completion-record-specification-type

var CompletionRecord = function CompletionRecord(type, value) {
	if (!(this instanceof CompletionRecord)) {
		return new CompletionRecord(type, value);
	}
	if (type !== 'normal' && type !== 'break' && type !== 'continue' && type !== 'return' && type !== 'throw') {
		throw new $SyntaxError('Assertion failed: `type` must be one of "normal", "break", "continue", "return", or "throw"');
	}
	SLOT.set(this, '[[Type]]', type);
	SLOT.set(this, '[[Value]]', value);
	// [[Target]] slot?
};

CompletionRecord.prototype.type = function Type() {
	return SLOT.get(this, '[[Type]]');
};

CompletionRecord.prototype.value = function Value() {
	return SLOT.get(this, '[[Value]]');
};

CompletionRecord.prototype['?'] = function ReturnIfAbrupt() {
	var type = SLOT.get(this, '[[Type]]');
	var value = SLOT.get(this, '[[Value]]');

	if (type === 'throw') {
		throw value;
	}
	return value;
};

CompletionRecord.prototype['!'] = function assert() {
	var type = SLOT.get(this, '[[Type]]');

	if (type !== 'normal') {
		throw new $SyntaxError('Assertion failed: Completion Record is not of type "normal"');
	}
	return SLOT.get(this, '[[Value]]');
};

module.exports = CompletionRecord;
'use strict';

var $TypeError = require('es-errors/type');
var isObject = require('es-object-atoms/isObject');
var callBound = require('call-bound');
var OwnPropertyKeys = require('own-keys');

var forEach = require('../helpers/forEach');
var every = require('../helpers/every');
var some = require('../helpers/some');

var $isEnumerable = callBound('Object.prototype.propertyIsEnumerable');

var CreateDataPropertyOrThrow = require('./CreateDataPropertyOrThrow');
var Get = require('./Get');
var IsArray = require('./IsArray');
var isPropertyKey = require('../helpers/isPropertyKey');
var SameValue = require('./SameValue');
var ToNumber = require('./ToNumber');
var ToObject = require('./ToObject');

var isInteger = require('math-intrinsics/isInteger');

// https://262.ecma-international.org/12.0/#sec-copydataproperties

module.exports = function CopyDataProperties(target, source, excludedItems) {
	if (!isObject(target)) {
		throw new $TypeError('Assertion failed: "target" must be an Object');
	}

	if (!IsArray(excludedItems) || !every(excludedItems, isPropertyKey)) {
		throw new $TypeError('Assertion failed: "excludedItems" must be a List of Property Keys');
	}

	if (typeof source === 'undefined' || source === null) {
		return target;
	}

	var from = ToObject(source);

	var keys = OwnPropertyKeys(from);
	forEach(keys, function (nextKey) {
		var excluded = some(excludedItems, function (e) {
			return SameValue(e, nextKey) === true;
		});
		/*
		var excluded = false;

		forEach(excludedItems, function (e) {
			if (SameValue(e, nextKey) === true) {
				excluded = true;
			}
		});
		*/

		var enumerable = $isEnumerable(from, nextKey) || (
		// this is to handle string keys being non-enumerable in older engines
			typeof source === 'string'
			&& nextKey >= 0
			&& isInteger(ToNumber(nextKey))
		);
		if (excluded === false && enumerable) {
			var propValue = Get(from, nextKey);
			CreateDataPropertyOrThrow(target, nextKey, propValue);
		}
	});

	return target;
};
'use strict';

var GetIntrinsic = require('get-intrinsic');

var $SyntaxError = require('es-errors/syntax');
var $TypeError = require('es-errors/type');
var isObject = require('es-object-atoms/isObject');
var $Promise = GetIntrinsic('%Promise%', true);

var AsyncFromSyncIteratorContinuation = require('./AsyncFromSyncIteratorContinuation');
var Call = require('./Call');
var CreateIterResultObject = require('./CreateIterResultObject');
var Get = require('./Get');
var GetMethod = require('./GetMethod');
var IteratorNext = require('./IteratorNext');
var OrdinaryObjectCreate = require('./OrdinaryObjectCreate');

var isIteratorRecord = require('../helpers/records/iterator-record');

var SLOT = require('internal-slot');

var $AsyncFromSyncIteratorPrototype = GetIntrinsic('%AsyncFromSyncIteratorPrototype%', true) || {
	next: function next(value) {
		if (!$Promise) {
			throw new $SyntaxError('This environment does not support Promises.');
		}

		var O = this; // step 1

		SLOT.assert(O, '[[SyncIteratorRecord]]'); // step 2

		var argsLength = arguments.length;

		return new $Promise(function (resolve) { // step 3
			var syncIteratorRecord = SLOT.get(O, '[[SyncIteratorRecord]]'); // step 4
			var result;
			if (argsLength > 0) {
				result = IteratorNext(syncIteratorRecord, value); // step 5.a
			} else { // step 6
				result = IteratorNext(syncIteratorRecord);// step 6.a
			}
			resolve(AsyncFromSyncIteratorContinuation(result)); // step 8
		});
	},
	'return': function () {
		if (!$Promise) {
			throw new $SyntaxError('This environment does not support Promises.');
		}

		var O = this; // step 1

		SLOT.assert(O, '[[SyncIteratorRecord]]'); // step 2

		var valueIsPresent = arguments.length > 0;
		var value = valueIsPresent ? arguments[0] : void undefined;

		return new $Promise(function (resolve, reject) { // step 3
			var syncIterator = SLOT.get(O, '[[SyncIteratorRecord]]')['[[Iterator]]']; // step 4
			var iteratorReturn = GetMethod(syncIterator, 'return'); // step 5

			if (typeof iteratorReturn === 'undefined') { // step 7
				var iterResult = CreateIterResultObject(value, true); // step 7.a
				Call(resolve, undefined, [iterResult]); // step 7.b
				return;
			}
			var result;
			if (valueIsPresent) { // step 8
				result = Call(iteratorReturn, syncIterator, [value]); // step 8.a
			} else { // step 9
				result = Call(iteratorReturn, syncIterator); // step 9.a
			}
			if (!isObject(result)) { // step 11
				Call(reject, undefined, [new $TypeError('Iterator `return` method returned a non-object value.')]); // step 11.a
				return;
			}

			resolve(AsyncFromSyncIteratorContinuation(result)); // step 12
		});
	},
	'throw': function () {
		if (!$Promise) {
			throw new $SyntaxError('This environment does not support Promises.');
		}

		var O = this; // step 1

		SLOT.assert(O, '[[SyncIteratorRecord]]'); // step 2

		var valueIsPresent = arguments.length > 0;
		var value = valueIsPresent ? arguments[0] : void undefined;

		return new $Promise(function (resolve, reject) { // step 3
			var syncIterator = SLOT.get(O, '[[SyncIteratorRecord]]')['[[Iterator]]']; // step 4

			var throwMethod = GetMethod(syncIterator, 'throw'); // step 5

			if (typeof throwMethod === 'undefined') { // step 7
				Call(reject, undefined, [value]); // step 7.a
				return;
			}

			var result;
			if (valueIsPresent) { // step 8
				result = Call(throwMethod, syncIterator, [value]); // step 8.a
			} else { // step 9
				result = Call(throwMethod, syncIterator); // step 9.a
			}
			if (!isObject(result)) { // step 11
				Call(reject, undefined, [new $TypeError('Iterator `throw` method returned a non-object value.')]); // step 11.a
				return;
			}

			resolve(AsyncFromSyncIteratorContinuation(result/* , promiseCapability */)); // step 12
		});
	}
};

// https://262.ecma-international.org/15.0/#sec-createasyncfromsynciterator

module.exports = function CreateAsyncFromSyncIterator(syncIteratorRecord) {
	if (!isIteratorRecord(syncIteratorRecord)) {
		throw new $TypeError('Assertion failed: `syncIteratorRecord` must be an Iterator Record');
	}

	// var asyncIterator = OrdinaryObjectCreate(%AsyncFromSyncIteratorPrototype%, « [[SyncIteratorRecord]] »); // step 1
	var asyncIterator = OrdinaryObjectCreate($AsyncFromSyncIteratorPrototype);

	SLOT.set(asyncIterator, '[[SyncIteratorRecord]]', syncIteratorRecord); // step 2

	var nextMethod = Get(asyncIterator, 'next'); // step 3

	return { // steps 3-4
		'[[Iterator]]': asyncIterator,
		'[[NextMethod]]': nextMethod,
		'[[Done]]': false
	};
};
'use strict';

var $TypeError = require('es-errors/type');
var isObject = require('es-object-atoms/isObject');

var isPropertyKey = require('../helpers/isPropertyKey');
var OrdinaryDefineOwnProperty = require('./OrdinaryDefineOwnProperty');

// https://262.ecma-international.org/6.0/#sec-createdataproperty

module.exports = function CreateDataProperty(O, P, V) {
	if (!isObject(O)) {
		throw new $TypeError('Assertion failed: Type(O) is not Object');
	}
	if (!isPropertyKey(P)) {
		throw new $TypeError('Assertion failed: P is not a Property Key');
	}
	var newDesc = {
		'[[Configurable]]': true,
		'[[Enumerable]]': true,
		'[[Value]]': V,
		'[[Writable]]': true
	};
	return OrdinaryDefineOwnProperty(O, P, newDesc);
};
'use strict';

var $TypeError = require('es-errors/type');
var isObject = require('es-object-atoms/isObject');

var CreateDataProperty = require('./CreateDataProperty');

var isPropertyKey = require('../helpers/isPropertyKey');

// // https://262.ecma-international.org/14.0/#sec-createdatapropertyorthrow

module.exports = function CreateDataPropertyOrThrow(O, P, V) {
	if (!isObject(O)) {
		throw new $TypeError('Assertion failed: Type(O) is not Object');
	}
	if (!isPropertyKey(P)) {
		throw new $TypeError('Assertion failed: P is not a Property Key');
	}
	var success = CreateDataProperty(O, P, V);
	if (!success) {
		throw new $TypeError('unable to create data property');
	}
};
'use strict';

var $TypeError = require('es-errors/type');

var callBound = require('call-bound');

var $replace = callBound('String.prototype.replace');

var RequireObjectCoercible = require('./RequireObjectCoercible');
var ToString = require('./ToString');

// https://262.ecma-international.org/6.0/#sec-createhtml

module.exports = function CreateHTML(string, tag, attribute, value) {
	if (typeof tag !== 'string' || typeof attribute !== 'string') {
		throw new $TypeError('Assertion failed: `tag` and `attribute` must be strings');
	}
	var str = RequireObjectCoercible(string);
	var S = ToString(str);
	var p1 = '<' + tag;
	if (attribute !== '') {
		var V = ToString(value);
		var escapedV = $replace(V, /\x22/g, '&quot;');
		p1 += '\x20' + attribute + '\x3D\x22' + escapedV + '\x22';
	}
	return p1 + '>' + S + '</' + tag + '>';
};
'use strict';

var $TypeError = require('es-errors/type');

// https://262.ecma-international.org/6.0/#sec-createiterresultobject

module.exports = function CreateIterResultObject(value, done) {
	if (typeof done !== 'boolean') {
		throw new $TypeError('Assertion failed: Type(done) is not Boolean');
	}
	return {
		value: value,
		done: done
	};
};
'use strict';

var callBound = require('call-bound');

var $TypeError = require('es-errors/type');
var isObject = require('es-object-atoms/isObject');
var $indexOf = callBound('Array.prototype.indexOf', true) || callBound('String.prototype.indexOf');

var Get = require('./Get');
var IsArray = require('./IsArray');
var LengthOfArrayLike = require('./LengthOfArrayLike');
var ToString = require('./ToString');
var Type = require('./Type');

var defaultElementTypes = ['Undefined', 'Null', 'Boolean', 'String', 'Symbol', 'Number', 'BigInt', 'Object'];

// https://262.ecma-international.org/11.0/#sec-createlistfromarraylike

module.exports = function CreateListFromArrayLike(obj) {
	var elementTypes = arguments.length > 1
		? arguments[1]
		: defaultElementTypes;

	if (!isObject(obj)) {
		throw new $TypeError('Assertion failed: `obj` must be an Object');
	}
	if (!IsArray(elementTypes)) {
		throw new $TypeError('Assertion failed: `elementTypes`, if provided, must be an array');
	}
	var len = LengthOfArrayLike(obj);
	var list = [];
	var index = 0;
	while (index < len) {
		var indexName = ToString(index);
		var next = Get(obj, indexName);
		var nextType = Type(next);
		if ($indexOf(elementTypes, nextType) < 0) {
			throw new $TypeError('item type ' + nextType + ' is not a valid elementType');
		}
		list[list.length] = next;
		index += 1;
	}
	return list;
};
'use strict';

var $TypeError = require('es-errors/type');
var isObject = require('es-object-atoms/isObject');

var DefinePropertyOrThrow = require('./DefinePropertyOrThrow');

var isPropertyKey = require('../helpers/isPropertyKey');

// https://262.ecma-international.org/13.0/#sec-createnonenumerabledatapropertyorthrow

module.exports = function CreateNonEnumerableDataPropertyOrThrow(O, P, V) {
	if (!isObject(O)) {
		throw new $TypeError('Assertion failed: Type(O) is not Object');
	}

	if (!isPropertyKey(P)) {
		throw new $TypeError('Assertion failed: P is not a Property Key');
	}

	var newDesc = {
		'[[Configurable]]': true,
		'[[Enumerable]]': false,
		'[[Value]]': V,
		'[[Writable]]': true
	};
	return DefinePropertyOrThrow(O, P, newDesc);
};
'use strict';

var GetIntrinsic = require('get-intrinsic');
var hasSymbols = require('has-symbols')();

var $TypeError = require('es-errors/type');
var isObject = require('es-object-atoms/isObject');
var IteratorPrototype = GetIntrinsic('%IteratorPrototype%', true);

var AdvanceStringIndex = require('./AdvanceStringIndex');
var CreateIterResultObject = require('./CreateIterResultObject');
var DefineMethodProperty = require('./DefineMethodProperty');
var Get = require('./Get');
var OrdinaryObjectCreate = require('./OrdinaryObjectCreate');
var RegExpExec = require('./RegExpExec');
var Set = require('./Set');
var ToLength = require('./ToLength');
var ToString = require('./ToString');

var SLOT = require('internal-slot');
var setToStringTag = require('es-set-tostringtag');

var RegExpStringIterator = function RegExpStringIterator(R, S, global, fullUnicode) {
	if (typeof S !== 'string') {
		throw new $TypeError('`S` must be a string');
	}
	if (typeof global !== 'boolean') {
		throw new $TypeError('`global` must be a boolean');
	}
	if (typeof fullUnicode !== 'boolean') {
		throw new $TypeError('`fullUnicode` must be a boolean');
	}
	SLOT.set(this, '[[IteratingRegExp]]', R);
	SLOT.set(this, '[[IteratedString]]', S);
	SLOT.set(this, '[[Global]]', global);
	SLOT.set(this, '[[Unicode]]', fullUnicode);
	SLOT.set(this, '[[Done]]', false);
};

if (IteratorPrototype) {
	RegExpStringIterator.prototype = OrdinaryObjectCreate(IteratorPrototype);
}

var RegExpStringIteratorNext = function next() {
	var O = this; // eslint-disable-line no-invalid-this
	if (!isObject(O)) {
		throw new $TypeError('receiver must be an object');
	}
	if (
		!(O instanceof RegExpStringIterator)
		|| !SLOT.has(O, '[[IteratingRegExp]]')
		|| !SLOT.has(O, '[[IteratedString]]')
		|| !SLOT.has(O, '[[Global]]')
		|| !SLOT.has(O, '[[Unicode]]')
		|| !SLOT.has(O, '[[Done]]')
	) {
		throw new $TypeError('"this" value must be a RegExpStringIterator instance');
	}
	if (SLOT.get(O, '[[Done]]')) {
		return CreateIterResultObject(undefined, true);
	}
	var R = SLOT.get(O, '[[IteratingRegExp]]');
	var S = SLOT.get(O, '[[IteratedString]]');
	var global = SLOT.get(O, '[[Global]]');
	var fullUnicode = SLOT.get(O, '[[Unicode]]');
	var match = RegExpExec(R, S);
	if (match === null) {
		SLOT.set(O, '[[Done]]', true);
		return CreateIterResultObject(undefined, true);
	}
	if (global) {
		var matchStr = ToString(Get(match, '0'));
		if (matchStr === '') {
			var thisIndex = ToLength(Get(R, 'lastIndex'));
			var nextIndex = AdvanceStringIndex(S, thisIndex, fullUnicode);
			Set(R, 'lastIndex', nextIndex, true);
		}
		return CreateIterResultObject(match, false);
	}
	SLOT.set(O, '[[Done]]', true);
	return CreateIterResultObject(match, false);
};
DefineMethodProperty(RegExpStringIterator.prototype, 'next', RegExpStringIteratorNext, false);

if (hasSymbols) {
	setToStringTag(RegExpStringIterator.prototype, 'RegExp String Iterator');

	if (Symbol.iterator && typeof RegExpStringIterator.prototype[Symbol.iterator] !== 'function') {
		var iteratorFn = function SymbolIterator() {
			return this;
		};
		DefineMethodProperty(RegExpStringIterator.prototype, Symbol.iterator, iteratorFn, false);
	}
}

// https://262.ecma-international.org/15.0/#sec-createregexpstringiterator

module.exports = function CreateRegExpStringIterator(R, S, global, fullUnicode) {
	// assert R.global === global && R.unicode === fullUnicode?
	return new RegExpStringIterator(R, S, global, fullUnicode);
};
'use strict';

var $EvalError = require('es-errors/eval');

var DayWithinYear = require('./DayWithinYear');
var InLeapYear = require('./InLeapYear');
var MonthFromTime = require('./MonthFromTime');

// https://262.ecma-international.org/5.1/#sec-15.9.1.5

module.exports = function DateFromTime(t) {
	var m = MonthFromTime(t);
	var d = DayWithinYear(t);
	if (m === 0) {
		return d + 1;
	}
	if (m === 1) {
		return d - 30;
	}
	var leap = InLeapYear(t);
	if (m === 2) {
		return d - 58 - leap;
	}
	if (m === 3) {
		return d - 89 - leap;
	}
	if (m === 4) {
		return d - 119 - leap;
	}
	if (m === 5) {
		return d - 150 - leap;
	}
	if (m === 6) {
		return d - 180 - leap;
	}
	if (m === 7) {
		return d - 211 - leap;
	}
	if (m === 8) {
		return d - 242 - leap;
	}
	if (m === 9) {
		return d - 272 - leap;
	}
	if (m === 10) {
		return d - 303 - leap;
	}
	if (m === 11) {
		return d - 333 - leap;
	}
	throw new $EvalError('Assertion failed: MonthFromTime returned an impossible value: ' + m);
};
'use strict';

var $TypeError = require('es-errors/type');

var weekdays = ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'];
var months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];

var $isNaN = require('math-intrinsics/isNaN');
var padTimeComponent = require('../helpers/padTimeComponent');

var DateFromTime = require('./DateFromTime');
var MonthFromTime = require('./MonthFromTime');
var WeekDay = require('./WeekDay');
var YearFromTime = require('./YearFromTime');

// https://262.ecma-international.org/9.0/#sec-datestring

module.exports = function DateString(tv) {
	if (typeof tv !== 'number' || $isNaN(tv)) {
		throw new $TypeError('Assertion failed: `tv` must be a non-NaN Number');
	}
	var weekday = weekdays[WeekDay(tv)];
	var month = months[MonthFromTime(tv)];
	var day = padTimeComponent(DateFromTime(tv));
	var year = padTimeComponent(YearFromTime(tv), 4);
	return weekday + '\x20' + month + '\x20' + day + '\x20' + year;
};
'use strict';

var floor = require('./floor');

// https://262.ecma-international.org/5.1/#sec-15.9.1.3

module.exports = function DayFromYear(y) {
	return (365 * (y - 1970)) + floor((y - 1969) / 4) - floor((y - 1901) / 100) + floor((y - 1601) / 400);
};

'use strict';

var floor = require('./floor');

var msPerDay = require('../helpers/timeConstants').msPerDay;

// https://262.ecma-international.org/5.1/#sec-15.9.1.2

module.exports = function Day(t) {
	return floor(t / msPerDay);
};
'use strict';

var modulo = require('./modulo');

// https://262.ecma-international.org/5.1/#sec-15.9.1.3

module.exports = function DaysInYear(y) {
	if (modulo(y, 4) !== 0) {
		return 365;
	}
	if (modulo(y, 100) !== 0) {
		return 366;
	}
	if (modulo(y, 400) !== 0) {
		return 365;
	}
	return 366;
};
'use strict';

var Day = require('./Day');
var DayFromYear = require('./DayFromYear');
var YearFromTime = require('./YearFromTime');

// https://262.ecma-international.org/5.1/#sec-15.9.1.4

module.exports = function DayWithinYear(t) {
	return Day(t) - DayFromYear(YearFromTime(t));
};
'use strict';

var $TypeError = require('es-errors/type');
var isObject = require('es-object-atoms/isObject');

var DefinePropertyOrThrow = require('./DefinePropertyOrThrow');
var IsExtensible = require('./IsExtensible');

var isPropertyKey = require('../helpers/isPropertyKey');

// https://262.ecma-international.org/13.0/#sec-definemethodproperty

module.exports = function DefineMethodProperty(homeObject, key, closure, enumerable) {
	if (!isObject(homeObject)) {
		throw new $TypeError('Assertion failed: `homeObject` is not an Object');
	}
	if (!isPropertyKey(key)) {
		throw new $TypeError('Assertion failed: `key` is not a Property Key or a Private Name');
	}
	if (typeof closure !== 'function') {
		throw new $TypeError('Assertion failed: `closure` is not a function');
	}
	if (typeof enumerable !== 'boolean') {
		throw new $TypeError('Assertion failed: `enumerable` is not a Boolean');
	}

	// 1. Assert: homeObject is an ordinary, extensible object with no non-configurable properties.
	if (!IsExtensible(homeObject)) {
		throw new $TypeError('Assertion failed: `homeObject` is not an ordinary, extensible object, with no non-configurable properties');
	}

	// 2. If key is a Private Name, then
	//  a. Return PrivateElement { [[Key]]: key, [[Kind]]: method, [[Value]]: closure }.
	// 3. Else,
	var desc = { // step 3.a
		'[[Value]]': closure,
		'[[Writable]]': true,
		'[[Enumerable]]': enumerable,
		'[[Configurable]]': true
	};
	DefinePropertyOrThrow(homeObject, key, desc); // step 3.b
};
'use strict';

var $TypeError = require('es-errors/type');
var isObject = require('es-object-atoms/isObject');

var isPropertyDescriptor = require('../helpers/records/property-descriptor');
var DefineOwnProperty = require('../helpers/DefineOwnProperty');

var FromPropertyDescriptor = require('./FromPropertyDescriptor');
var IsDataDescriptor = require('./IsDataDescriptor');
var isPropertyKey = require('../helpers/isPropertyKey');
var SameValue = require('./SameValue');
var ToPropertyDescriptor = require('./ToPropertyDescriptor');

// https://262.ecma-international.org/6.0/#sec-definepropertyorthrow

module.exports = function DefinePropertyOrThrow(O, P, desc) {
	if (!isObject(O)) {
		throw new $TypeError('Assertion failed: Type(O) is not Object');
	}

	if (!isPropertyKey(P)) {
		throw new $TypeError('Assertion failed: P is not a Property Key');
	}

	var Desc = isPropertyDescriptor(desc) ? desc : ToPropertyDescriptor(desc);
	if (!isPropertyDescriptor(Desc)) {
		throw new $TypeError('Assertion failed: Desc is not a valid Property Descriptor');
	}

	return DefineOwnProperty(
		IsDataDescriptor,
		SameValue,
		FromPropertyDescriptor,
		O,
		P,
		Desc
	);
};
'use strict';

var $TypeError = require('es-errors/type');
var isObject = require('es-object-atoms/isObject');

var isPropertyKey = require('../helpers/isPropertyKey');

// https://262.ecma-international.org/6.0/#sec-deletepropertyorthrow

module.exports = function DeletePropertyOrThrow(O, P) {
	if (!isObject(O)) {
		throw new $TypeError('Assertion failed: Type(O) is not Object');
	}

	if (!isPropertyKey(P)) {
		throw new $TypeError('Assertion failed: P is not a Property Key');
	}

	// eslint-disable-next-line no-param-reassign
	var success = delete O[P];
	if (!success) {
		throw new $TypeError('Attempt to delete property failed.');
	}
	return success;
};
'use strict';

var $SyntaxError = require('es-errors/syntax');
var $TypeError = require('es-errors/type');

var IsDetachedBuffer = require('./IsDetachedBuffer');

var isArrayBuffer = require('is-array-buffer');
var isSharedArrayBuffer = require('is-shared-array-buffer');

var MessageChannel;
try {
	// eslint-disable-next-line global-require
	MessageChannel = require('worker_threads').MessageChannel;
} catch (e) { /**/ }

// https://262.ecma-international.org/9.0/#sec-detacharraybuffer

/* globals postMessage */

module.exports = function DetachArrayBuffer(arrayBuffer) {
	if (!isArrayBuffer(arrayBuffer) || isSharedArrayBuffer(arrayBuffer)) {
		throw new $TypeError('Assertion failed: `arrayBuffer` must be an Object with an [[ArrayBufferData]] internal slot, and not a Shared Array Buffer');
	}

	// commented out since there's no way to set or access this key
	// var key = arguments.length > 1 ? arguments[1] : void undefined;

	// if (!SameValue(arrayBuffer[[ArrayBufferDetachKey]], key)) {
	// 	throw new $TypeError('Assertion failed: `key` must be the value of the [[ArrayBufferDetachKey]] internal slot of `arrayBuffer`');
	// }

	if (!IsDetachedBuffer(arrayBuffer)) { // node v21.0.0+ throws when you structuredClone a detached buffer
		if (typeof structuredClone === 'function') {
			structuredClone(arrayBuffer, { transfer: [arrayBuffer] });
		} else if (typeof postMessage === 'function') {
			postMessage('', '/', [arrayBuffer]); // TODO: see if this might trigger listeners
		} else if (MessageChannel) {
			(new MessageChannel()).port1.postMessage(null, [arrayBuffer]);
		} else {
			throw new $SyntaxError('DetachArrayBuffer is not supported in this environment');
		}
	}

	return null;
};
'use strict';

var $TypeError = require('es-errors/type');
var isObject = require('es-object-atoms/isObject');
var objectKeys = require('object-keys');
var safePushApply = require('safe-push-apply');
var callBound = require('call-bound');

var $isEnumerable = callBound('Object.prototype.propertyIsEnumerable');

var forEach = require('../helpers/forEach');

// https://262.ecma-international.org/14.0/#sec-enumerableownproperties

module.exports = function EnumerableOwnProperties(O, kind) {
	if (!isObject(O)) {
		throw new $TypeError('Assertion failed: Type(O) is not Object');
	}

	var keys = objectKeys(O);
	if (kind === 'key') {
		return keys;
	}
	if (kind === 'value' || kind === 'key+value') {
		var results = [];
		forEach(keys, function (key) {
			if ($isEnumerable(O, key)) {
				safePushApply(results, [
					kind === 'value' ? O[key] : [key, O[key]]
				]);
			}
		});
		return results;
	}
	throw new $TypeError('Assertion failed: "kind" is not "key", "value", or "key+value": ' + kind);
};
'use strict';

var $TypeError = require('es-errors/type');
var isInteger = require('math-intrinsics/isInteger');
var isObject = require('es-object-atoms/isObject');

var Call = require('./Call');
var Get = require('./Get');
var ToBoolean = require('./ToBoolean');
var IsCallable = require('./IsCallable');
var ToString = require('./ToString');

// https://262.ecma-international.org/15.0/#sec-findviapredicate

module.exports = function FindViaPredicate(O, len, direction, predicate, thisArg) {
	if (!isObject(O)) {
		throw new $TypeError('Assertion failed: Type(O) is not Object');
	}
	if (!isInteger(len) || len < 0) {
		throw new $TypeError('Assertion failed: len must be a non-negative integer');
	}
	if (direction !== 'ascending' && direction !== 'descending' && direction !== 'DESCENDING' && direction !== 'ASCENDING') {
		throw new $TypeError('Assertion failed: direction must be ~ASCENDING~ or ~DESCENDING~');
	}

	if (!IsCallable(predicate)) {
		throw new $TypeError('predicate must be callable'); // step 1
	}

	for ( // steps 2-4
		var k = direction === 'ascending' || direction === 'ASCENDING' ? 0 : len - 1;
		direction === 'ascending' || direction === 'ASCENDING' ? k < len : k >= 0;
		k += 1
	) {
		var Pk = ToString(k); // step 4.a
		var kValue = Get(O, Pk); // step 4.c
		var testResult = Call(predicate, thisArg, [kValue, k, O]); // step 4.d
		if (ToBoolean(testResult)) {
			return { '[[Index]]': k, '[[Value]]': kValue }; // step 4.e
		}
	}
	return { '[[Index]]': -1, '[[Value]]': void undefined }; // step 5
};
'use strict';

var $TypeError = require('es-errors/type');

var MAX_SAFE_INTEGER = require('math-intrinsics/constants/maxSafeInteger');

var Call = require('./Call');
var CreateDataPropertyOrThrow = require('./CreateDataPropertyOrThrow');
var Get = require('./Get');
var HasProperty = require('./HasProperty');
var IsArray = require('./IsArray');
var LengthOfArrayLike = require('./LengthOfArrayLike');
var ToString = require('./ToString');

// https://262.ecma-international.org/11.0/#sec-flattenintoarray

module.exports = function FlattenIntoArray(target, source, sourceLen, start, depth) {
	var mapperFunction;
	if (arguments.length > 5) {
		mapperFunction = arguments[5];
	}

	var targetIndex = start;
	var sourceIndex = 0;
	while (sourceIndex < sourceLen) {
		var P = ToString(sourceIndex);
		var exists = HasProperty(source, P);
		if (exists === true) {
			var element = Get(source, P);
			if (typeof mapperFunction !== 'undefined') {
				if (arguments.length <= 6) {
					throw new $TypeError('Assertion failed: thisArg is required when mapperFunction is provided');
				}
				element = Call(mapperFunction, arguments[6], [element, sourceIndex, source]);
			}
			var shouldFlatten = false;
			if (depth > 0) {
				shouldFlatten = IsArray(element);
			}
			if (shouldFlatten) {
				var elementLen = LengthOfArrayLike(element);
				targetIndex = FlattenIntoArray(target, element, elementLen, targetIndex, depth - 1);
			} else {
				if (targetIndex >= MAX_SAFE_INTEGER) {
					throw new $TypeError('index too large');
				}
				CreateDataPropertyOrThrow(target, ToString(targetIndex), element);
				targetIndex += 1;
			}
		}
		sourceIndex += 1;
	}

	return targetIndex;
};
'use strict';

// var modulo = require('./modulo');
var $floor = require('math-intrinsics/floor');

// http://262.ecma-international.org/11.0/#eqn-floor

module.exports = function floor(x) {
	// return x - modulo(x, 1);
	if (typeof x === 'bigint') {
		return x;
	}
	return $floor(x);
};
'use strict';

var $TypeError = require('es-errors/type');

var isPropertyDescriptor = require('../helpers/records/property-descriptor');
var fromPropertyDescriptor = require('../helpers/fromPropertyDescriptor');

// https://262.ecma-international.org/6.0/#sec-frompropertydescriptor

module.exports = function FromPropertyDescriptor(Desc) {
	if (typeof Desc !== 'undefined' && !isPropertyDescriptor(Desc)) {
		throw new $TypeError('Assertion failed: `Desc` must be a Property Descriptor');
	}

	return fromPropertyDescriptor(Desc);
};
'use strict';

var isObject = require('es-object-atoms/isObject');

var Get = require('./Get');
var ToIndex = require('./ToIndex');

// https://262.ecma-international.org/15.0/#sec-getarraybuffermaxbytelengthoption

module.exports = function GetArrayBufferMaxByteLengthOption(options) {
	if (!isObject(options)) {
		return 'EMPTY'; // step 1
	}

	var maxByteLength = Get(options, 'maxByteLength'); // step 2

	if (typeof maxByteLength === 'undefined') {
		return 'EMPTY'; // step 3
	}

	return ToIndex(maxByteLength); // step 4
};
'use strict';

var getGlobal = require('globalthis/polyfill');

// https://262.ecma-international.org/6.0/#sec-getglobalobject

module.exports = function GetGlobalObject() {
	return getGlobal();
};
'use strict';

var $TypeError = require('es-errors/type');
var isObject = require('es-object-atoms/isObject');

var Call = require('./Call');
var Get = require('./Get');
var IsCallable = require('./IsCallable');

// https://262.ecma-international.org/15.0/#sec-getiteratorfrommethod

module.exports = function GetIteratorFromMethod(obj, method) {
	if (!IsCallable(method)) {
		throw new $TypeError('method must be a function');
	}

	var iterator = Call(method, obj); // step 1
	if (!isObject(iterator)) {
		throw new $TypeError('iterator must return an object'); // step 2
	}

	var nextMethod = Get(iterator, 'next'); // step 3
	return { // steps 4-5
		'[[Iterator]]': iterator,
		'[[NextMethod]]': nextMethod,
		'[[Done]]': false
	};
};
'use strict';

var GetIntrinsic = require('get-intrinsic');

var $TypeError = require('es-errors/type');
var $asyncIterator = GetIntrinsic('%Symbol.asyncIterator%', true);

var inspect = require('object-inspect');
var hasSymbols = require('has-symbols')();

var AdvanceStringIndex = require('./AdvanceStringIndex');
var CreateAsyncFromSyncIterator = require('./CreateAsyncFromSyncIterator');
var GetIteratorFromMethod = require('./GetIteratorFromMethod');
var GetMethod = require('./GetMethod');

var ES = {
	AdvanceStringIndex: AdvanceStringIndex,
	GetMethod: GetMethod
};

var getIteratorMethod = require('../helpers/getIteratorMethod');

// https://262.ecma-international.org/14.0/#sec-getiterator

module.exports = function GetIterator(obj, kind) {
	if (kind !== 'SYNC' && kind !== 'ASYNC') {
		throw new $TypeError("Assertion failed: `kind` must be one of 'sync' or 'async', got " + inspect(kind));
	}

	var method;
	if (kind === 'ASYNC') { // step 1
		if (hasSymbols && $asyncIterator) {
			method = GetMethod(obj, $asyncIterator); // step 1.a
		}
	}
	if (typeof method === 'undefined') { // step 1.b
		// var syncMethod = GetMethod(obj, $iterator); // step 1.b.i
		var syncMethod = getIteratorMethod(ES, obj);
		if (kind === 'ASYNC') {
			if (typeof syncMethod === 'undefined') {
				throw new $TypeError('iterator method is `undefined`'); // step 1.b.ii
			}
			var syncIteratorRecord = GetIteratorFromMethod(obj, syncMethod); // step 1.b.iii
			return CreateAsyncFromSyncIterator(syncIteratorRecord); // step 1.b.iv
		}
		method = syncMethod; // step 2, kind of
	}

	if (typeof method === 'undefined') {
		throw new $TypeError('iterator method is `undefined`'); // step 3
	}
	return GetIteratorFromMethod(obj, method); // step 4
};
'use strict';

var $TypeError = require('es-errors/type');

var inspect = require('object-inspect');

var isPropertyKey = require('../helpers/isPropertyKey');

var isObject = require('es-object-atoms/isObject');

// https://262.ecma-international.org/6.0/#sec-get-o-p

module.exports = function Get(O, P) {
	// 7.3.1.1
	if (!isObject(O)) {
		throw new $TypeError('Assertion failed: Type(O) is not Object');
	}
	// 7.3.1.2
	if (!isPropertyKey(P)) {
		throw new $TypeError('Assertion failed: P is not a Property Key, got ' + inspect(P));
	}
	// 7.3.1.3
	return O[P];
};
'use strict';

var $TypeError = require('es-errors/type');

var isMatchRecord = require('../helpers/records/match-record');

// https://262.ecma-international.org/13.0/#sec-getmatchindexpair

module.exports = function GetMatchIndexPair(S, match) {
	if (typeof S !== 'string') {
		throw new $TypeError('Assertion failed: `S` must be a String');
	}
	if (!isMatchRecord(match)) {
		throw new $TypeError('Assertion failed: `match` must be a Match Record');
	}

	if (!(match['[[StartIndex]]'] <= S.length)) {
		throw new $TypeError('`match` [[StartIndex]] must be a non-negative integer <= the length of S');
	}
	if (!(match['[[EndIndex]]'] <= S.length)) {
		throw new $TypeError('`match` [[EndIndex]] must be an integer between [[StartIndex]] and the length of S, inclusive');
	}
	return [match['[[StartIndex]]'], match['[[EndIndex]]']];
};
'use strict';

var $TypeError = require('es-errors/type');

var substring = require('./substring');

var isMatchRecord = require('../helpers/records/match-record');

// https://262.ecma-international.org/13.0/#sec-getmatchstring

module.exports = function GetMatchString(S, match) {
	if (typeof S !== 'string') {
		throw new $TypeError('Assertion failed: `S` must be a String');
	}
	if (!isMatchRecord(match)) {
		throw new $TypeError('Assertion failed: `match` must be a Match Record');
	}

	if (!(match['[[StartIndex]]'] <= S.length)) {
		throw new $TypeError('`match` [[StartIndex]] must be a non-negative integer <= the length of S');
	}
	if (!(match['[[EndIndex]]'] <= S.length)) {
		throw new $TypeError('`match` [[EndIndex]] must be an integer between [[StartIndex]] and the length of S, inclusive');
	}
	return substring(S, match['[[StartIndex]]'], match['[[EndIndex]]']);
};
'use strict';

var $TypeError = require('es-errors/type');

var GetV = require('./GetV');
var IsCallable = require('./IsCallable');
var isPropertyKey = require('../helpers/isPropertyKey');

var inspect = require('object-inspect');

// https://262.ecma-international.org/6.0/#sec-getmethod

module.exports = function GetMethod(O, P) {
	// 7.3.9.1
	if (!isPropertyKey(P)) {
		throw new $TypeError('Assertion failed: P is not a Property Key');
	}

	// 7.3.9.2
	var func = GetV(O, P);

	// 7.3.9.4
	if (func == null) {
		return void 0;
	}

	// 7.3.9.5
	if (!IsCallable(func)) {
		throw new $TypeError(inspect(P) + ' is not a function: ' + inspect(func));
	}

	// 7.3.9.6
	return func;
};
'use strict';

var $TypeError = require('es-errors/type');

var GetUTCEpochNanoseconds = require('./GetUTCEpochNanoseconds');

var isInteger = require('math-intrinsics/isInteger');

// https://262.ecma-international.org/14.0/#sec-getnamedtimezoneepochnanoseconds

// eslint-disable-next-line max-params
module.exports = function GetNamedTimeZoneEpochNanoseconds(
	timeZoneIdentifier,
	year,
	month,
	day,
	hour,
	minute,
	second,
	millisecond,
	microsecond,
	nanosecond
) {
	if (typeof timeZoneIdentifier !== 'string') {
		throw new $TypeError('Assertion failed: `timeZoneIdentifier` must be a string');
	}
	if (!isInteger(year)) {
		throw new $TypeError('Assertion failed: `year` must be an integral number');
	}
	if (!isInteger(month) || month < 1 || month > 12) {
		throw new $TypeError('Assertion failed: `month` must be an integral number between 1 and 12, inclusive');
	}
	if (!isInteger(day) || day < 1 || day > 31) {
		throw new $TypeError('Assertion failed: `day` must be an integral number between 1 and 31, inclusive');
	}
	if (!isInteger(hour) || hour < 0 || hour > 23) {
		throw new $TypeError('Assertion failed: `hour` must be an integral number between 0 and 23, inclusive');
	}
	if (!isInteger(minute) || minute < 0 || minute > 59) {
		throw new $TypeError('Assertion failed: `minute` must be an integral number between 0 and 59, inclusive');
	}
	if (!isInteger(second) || second < 0 || second > 999) {
		throw new $TypeError('Assertion failed: `second` must be an integral number between 0 and 999, inclusive');
	}
	if (!isInteger(millisecond) || millisecond < 0 || millisecond > 999) {
		throw new $TypeError('Assertion failed: `millisecond` must be an integral number between 0 and 999, inclusive');
	}
	if (!isInteger(microsecond) || microsecond < 0 || microsecond > 999) {
		throw new $TypeError('Assertion failed: `microsecond` must be an integral number between 0 and 999, inclusive');
	}
	if (!isInteger(nanosecond) || nanosecond < 0 || nanosecond > 999) {
		throw new $TypeError('Assertion failed: `nanosecond` must be an integral number between 0 and 999, inclusive');
	}

	if (timeZoneIdentifier !== 'UTC') {
		throw new $TypeError('Assertion failed: only UTC time zone is supported'); // step 1
	}

	var epochNanoseconds = GetUTCEpochNanoseconds(
		year,
		month,
		day,
		hour,
		minute,
		second,
		millisecond,
		microsecond,
		nanosecond
	); // step 2

	return [epochNanoseconds]; // step 3
};
'use strict';

var GetIntrinsic = require('get-intrinsic');

var hasSymbols = require('has-symbols')();

var $TypeError = require('es-errors/type');
var isObject = require('es-object-atoms/isObject');

var $gOPN = GetIntrinsic('%Object.getOwnPropertyNames%', true);
var $gOPS = hasSymbols && GetIntrinsic('%Object.getOwnPropertySymbols%', true);
var keys = require('object-keys');

// https://262.ecma-international.org/6.0/#sec-getownpropertykeys

module.exports = function GetOwnPropertyKeys(O, Type) {
	if (!isObject(O)) {
		throw new $TypeError('Assertion failed: Type(O) is not Object');
	}
	if (Type === 'Symbol') {
		return $gOPS ? $gOPS(O) : [];
	}
	if (Type === 'String') {
		if (!$gOPN) {
			return keys(O);
		}
		return $gOPN(O);
	}
	throw new $TypeError('Assertion failed: `Type` must be `"String"` or `"Symbol"`');
};
'use strict';

var $TypeError = require('es-errors/type');

var Get = require('./Get');
var IsCallable = require('./IsCallable');
var IsConstructor = require('./IsConstructor');

// https://262.ecma-international.org/12.0/#sec-getpromiseresolve

module.exports = function GetPromiseResolve(promiseConstructor) {
	if (!IsConstructor(promiseConstructor)) {
		throw new $TypeError('Assertion failed: `promiseConstructor` must be a constructor');
	}
	var promiseResolve = Get(promiseConstructor, 'resolve');
	if (IsCallable(promiseResolve) === false) {
		throw new $TypeError('`resolve` method is not callable');
	}
	return promiseResolve;
};
'use strict';

var GetIntrinsic = require('get-intrinsic');

var $Function = GetIntrinsic('%Function%');
var $TypeError = require('es-errors/type');
var $SyntaxError = require('es-errors/syntax');

var Get = require('./Get');
var IsConstructor = require('./IsConstructor');

var isObject = require('es-object-atoms/isObject');

// https://262.ecma-international.org/6.0/#sec-getprototypefromconstructor

module.exports = function GetPrototypeFromConstructor(constructor, intrinsicDefaultProto) {
	var intrinsic = GetIntrinsic(intrinsicDefaultProto); // throws if not a valid intrinsic
	if (!isObject(intrinsic)) {
		throw new $TypeError('intrinsicDefaultProto must be an object');
	}
	if (!IsConstructor(constructor)) {
		throw new $TypeError('Assertion failed: `constructor` must be a constructor');
	}
	var proto = Get(constructor, 'prototype');
	if (!isObject(proto)) {
		if (!(constructor instanceof $Function)) {
			// ignore other realms, for now
			throw new $SyntaxError('cross-realm constructors not currently supported');
		}
		proto = intrinsic;
	}
	return proto;
};
'use strict';

var callBound = require('call-bound');
var $TypeError = require('es-errors/type');
var isInteger = require('math-intrinsics/isInteger');

var StringToCodePoints = require('./StringToCodePoints');

var $indexOf = callBound('String.prototype.indexOf');

// https://262.ecma-international.org/13.0/#sec-getstringindex

module.exports = function GetStringIndex(S, e) {
	if (typeof S !== 'string') {
		throw new $TypeError('Assertion failed: `S` must be a String');
	}
	if (!isInteger(e) || e < 0) {
		throw new $TypeError('Assertion failed: `e` must be a non-negative integer');
	}

	if (S === '') {
		return 0;
	}
	var codepoints = StringToCodePoints(S);
	var eUTF = e >= codepoints.length ? S.length : $indexOf(S, codepoints[e]);
	return eUTF;
};
'use strict';

var $TypeError = require('es-errors/type');
var inspect = require('object-inspect');
var isInteger = require('math-intrinsics/isInteger');
var isObject = require('es-object-atoms/isObject');
var regexTester = require('safe-regex-test');

var Get = require('./Get');
var IsArray = require('./IsArray');
var min = require('./min');
var StringIndexOf = require('./StringIndexOf');
var StringToNumber = require('./StringToNumber');
var substring = require('./substring');
var ToString = require('./ToString');

var every = require('../helpers/every');
var isPrefixOf = require('../helpers/isPrefixOf');
var isStringOrUndefined = require('../helpers/isStringOrUndefined');

var startsWithDollarDigit = regexTester(/^\$[0-9]/);
var startsWithDollarTwoDigit = regexTester(/^\$[0-9][0-9]/);

// http://www.ecma-international.org/ecma-262/15.0/#sec-getsubstitution

// eslint-disable-next-line max-statements, max-params, max-lines-per-function
module.exports = function GetSubstitution(matched, str, position, captures, namedCaptures, replacementTemplate) {
	if (typeof matched !== 'string') {
		throw new $TypeError('Assertion failed: `matched` must be a String');
	}

	if (typeof str !== 'string') {
		throw new $TypeError('Assertion failed: `str` must be a String');
	}

	if (!isInteger(position) || position < 0) {
		throw new $TypeError('Assertion failed: `position` must be a nonnegative integer, got ' + inspect(position));
	}

	if (!IsArray(captures) || !every(captures, isStringOrUndefined)) {
		throw new $TypeError('Assertion failed: `captures` must be a possibly-empty List of Strings or `undefined`, got ' + inspect(captures));
	}

	if (typeof namedCaptures !== 'undefined' && !isObject(namedCaptures)) {
		throw new $TypeError('Assertion failed: `namedCaptures` must be `undefined` or an Object');
	}

	if (typeof replacementTemplate !== 'string') {
		throw new $TypeError('Assertion failed: `replacementTemplate` must be a String');
	}

	var stringLength = str.length; // step 1

	if (position > stringLength) {
		throw new $TypeError('Assertion failed: position > stringLength, got ' + inspect(position)); // step 2
	}

	var templateRemainder = replacementTemplate; // step 3

	var result = ''; // step 4

	while (templateRemainder !== '') { // step 5
		// 5.a NOTE: The following steps isolate ref (a prefix of templateRemainder), determine refReplacement (its replacement), and then append that replacement to result.

		var ref, refReplacement, capture;
		if (isPrefixOf('$$', templateRemainder)) { // step 5.b
			ref = '$$'; // step 5.b.i
			refReplacement = '$'; // step 5.b.ii
		} else if (isPrefixOf('$`', templateRemainder)) { // step 5.c
			ref = '$`'; // step 5.c.i
			refReplacement = substring(str, 0, position); // step 5.c.ii
		} else if (isPrefixOf('$&', templateRemainder)) { // step 5.d
			ref = '$&'; // step 5.d.i
			refReplacement = matched; // step 5.d.ii
		} else if (isPrefixOf('$\'', templateRemainder)) { // step 5.e
			ref = '$\''; // step 5.e.i
			var matchLength = matched.length; // step 5.e.ii
			var tailPos = position + matchLength; // step 5.e.iii
			refReplacement = substring(str, min(tailPos, stringLength)); // step 5.e.iv
			// 5.e.v NOTE: tailPos can exceed stringLength only if this abstract operation was invoked by a call to the intrinsic @@replace method of %RegExp.prototype% on an object whose "exec" property is not the intrinsic %RegExp.prototype.exec%.
		} else if (startsWithDollarDigit(templateRemainder)) { // step 5.f
			var digitCount = startsWithDollarTwoDigit(templateRemainder) ? 2 : 1; // step 5.f.i

			var digits = substring(templateRemainder, 1, 1 + digitCount); // step 5.f.ii

			var index = StringToNumber(digits); // step 5.f.iii

			if (index < 0 || index > 99) {
				throw new $TypeError('Assertion failed: `index` must be >= 0 and <= 99'); // step 5.f.iv
			}

			var captureLen = captures.length; // step 5.f.v

			if (index > captureLen && digitCount === 2) { // step 5.f.vi
				//  1. NOTE: When a two-digit replacement pattern specifies an index exceeding the count of capturing groups, it is treated as a one-digit replacement pattern followed by a literal digit.

				digitCount = 1; // step 5.f.vi.2

				digits = substring(digits, 0, 1); // step 5.f.vi.3

				index = StringToNumber(digits); // step 5.f.vi.4
			}

			ref = substring(templateRemainder, 0, 1 + digitCount); // step 5.f.vii

			if (1 <= index && index <= captureLen) { // step 5.f.viii
				capture = captures[index - 1]; // step 5.f.viii.1

				if (typeof capture === 'undefined') { // step 5.f.viii.2
					refReplacement = ''; // step 5.f.viii.2.a
				} else { // step 5.f.viii.3
					refReplacement = capture; // step 5.f.viii.3.a
				}
			} else { // step 5.f.ix
				refReplacement = ref; // step 5.f.ix.1
			}
		} else if (isPrefixOf('$<', templateRemainder)) { // step 5.g
			var gtPos = StringIndexOf(templateRemainder, '>', 0); // step 5.g.i
			if (!(gtPos > -1) || typeof namedCaptures === 'undefined') { // step 5.g.ii
				ref = '$<'; // step 5.g.ii.1
				refReplacement = ref; // step 5.g.ii.2
			} else { // step 5.g.iii
				ref = substring(templateRemainder, 0, gtPos + 1); // step 5.g.iii.1
				var groupName = substring(templateRemainder, 2, gtPos); // step 5.g.iii.2
				if (!isObject(namedCaptures)) {
					throw new $TypeError('Assertion failed: Type(namedCaptures) is not Object'); // step 5.g.iii.3
				}
				capture = Get(namedCaptures, groupName); // step 5.g.iii.4
				if (typeof capture === 'undefined') { // step 5.g.iii.5
					refReplacement = ''; // step 5.g.iii.5.a
				} else { // step 5.g.iii.6
					refReplacement = ToString(capture); // step 5.g.iii.6.a
				}
			}
		} else { // step 5.h
			ref = substring(templateRemainder, 0, 1); // step 5.h.i
			refReplacement = ref; // step 5.h.ii
		}

		var refLength = ref.length; // step 5.i

		templateRemainder = substring(templateRemainder, refLength); // step 5.j

		result += refReplacement; // step 5.k
	}

	return result; // step 6
};
'use strict';

var GetIntrinsic = require('get-intrinsic');

var MakeDay = require('./MakeDay');
var MakeTime = require('./MakeTime');
var MakeDate = require('./MakeDate');

var isInteger = require('math-intrinsics/isInteger');

var $BigInt = GetIntrinsic('%BigInt%', true);
var $SyntaxError = GetIntrinsic('%SyntaxError%');
var $TypeError = GetIntrinsic('%TypeError%');

// https://tc39.es/ecma262/#sec-getutcepochnanoseconds

// eslint-disable-next-line max-params
module.exports = function GetUTCEpochNanoseconds(
	year,
	month,
	day,
	hour,
	minute,
	second,
	millisecond,
	microsecond,
	nanosecond
) {
	if (!isInteger(year)) {
		throw new $TypeError('Assertion failed: `year` must be an integral Number');
	}
	if (!isInteger(month) || month < 1 || month > 12) {
		throw new $TypeError('Assertion failed: `month` must be an integral Number between 1 and 12, inclusive');
	}
	if (!isInteger(day) || day < 1 || day > 31) {
		throw new $TypeError('Assertion failed: `day` must be an integral Number between 1 and 31, inclusive');
	}
	if (!isInteger(hour) || hour < 0 || hour > 23) {
		throw new $TypeError('Assertion failed: `hour` must be an integral Number between 0 and 23, inclusive');
	}
	if (!isInteger(minute) || minute < 0 || minute > 59) {
		throw new $TypeError('Assertion failed: `minute` must be an integral Number between 0 and 59, inclusive');
	}
	if (!isInteger(second) || second < 0 || second > 59) {
		throw new $TypeError('Assertion failed: `second` must be an integral Number between 0 and 59, inclusive');
	}
	if (!isInteger(millisecond) || millisecond < 0 || millisecond > 999) {
		throw new $TypeError('Assertion failed: `millisecond` must be an integral Number between 0 and 999, inclusive');
	}
	if (!isInteger(microsecond) || microsecond < 0 || microsecond > 999) {
		throw new $TypeError('Assertion failed: `microsecond` must be an integral Number between 0 and 999, inclusive');
	}
	if (!isInteger(nanosecond) || nanosecond < 0 || nanosecond > 999) {
		throw new $TypeError('Assertion failed: `nanosecond` must be an integral Number between 0 and 999, inclusive');
	}

	var date = MakeDay(year, month - 1, day); // step 1
	var time = MakeTime(hour, minute, second, millisecond); // step 2
	var ms = MakeDate(date, time); // step 3
	if (!isInteger(ms)) {
		throw new $TypeError('Assertion failed: `ms` from MakeDate is not an integral Number'); // step 4
	}

	if (!$BigInt) {
		throw new $SyntaxError('BigInts are not supported in this environment');
	}
	return $BigInt((ms * 1e6) + (microsecond * 1e3) + nanosecond); // step 5
};
'use strict';

var GetIntrinsic = require('get-intrinsic');

var $SyntaxError = require('es-errors/syntax');
var $TypeError = require('es-errors/type');
var callBound = require('call-bound');
var isInteger = require('math-intrinsics/isInteger');
var $Uint8Array = GetIntrinsic('%Uint8Array%', true);

var $slice = callBound('Array.prototype.slice');

var IsDetachedBuffer = require('./IsDetachedBuffer');
var RawBytesToNumeric = require('./RawBytesToNumeric');

var isArrayBuffer = require('is-array-buffer');
var isSharedArrayBuffer = require('is-shared-array-buffer');
var safeConcat = require('safe-array-concat');

var tableTAO = require('./tables/typed-array-objects');

var defaultEndianness = require('../helpers/defaultEndianness');

// https://262.ecma-international.org/15.0/#sec-getvaluefrombuffer

module.exports = function GetValueFromBuffer(arrayBuffer, byteIndex, type, isTypedArray, order) {
	var isSAB = isSharedArrayBuffer(arrayBuffer);
	if (!isArrayBuffer(arrayBuffer) && !isSAB) {
		throw new $TypeError('Assertion failed: `arrayBuffer` must be an ArrayBuffer or a SharedArrayBuffer');
	}

	if (!isInteger(byteIndex)) {
		throw new $TypeError('Assertion failed: `byteIndex` must be an integer');
	}

	if (typeof type !== 'string' || typeof tableTAO.size['$' + type] !== 'number') {
		throw new $TypeError('Assertion failed: `type` must be one of ' + tableTAO.choices);
	}

	if (typeof isTypedArray !== 'boolean') {
		throw new $TypeError('Assertion failed: `isTypedArray` must be a boolean');
	}

	if (order !== 'SEQ-CST' && order !== 'UNORDERED') {
		throw new $TypeError('Assertion failed: `order` must be either `SEQ-CST` or `UNORDERED`');
	}

	if (arguments.length > 5 && typeof arguments[5] !== 'boolean') {
		throw new $TypeError('Assertion failed: `isLittleEndian` must be a boolean, if present');
	}

	if (IsDetachedBuffer(arrayBuffer)) {
		throw new $TypeError('Assertion failed: `arrayBuffer` is detached'); // step 1
	}

	// 2. Assert: There are sufficient bytes in arrayBuffer starting at byteIndex to represent a value of type.

	if (byteIndex < 0) {
		throw new $TypeError('Assertion failed: `byteIndex` must be non-negative'); // step 3
	}

	// 4. Let block be arrayBuffer.[[ArrayBufferData]].

	var elementSize = tableTAO.size['$' + type]; // step 5
	if (!elementSize) {
		throw new $TypeError('Assertion failed: `type` must be one of ' + tableTAO.choices);
	}

	var rawValue;
	if (isSAB) { // step 6
		/*
		a. Let execution be the [[CandidateExecution]] field of the surrounding agent's Agent Record.
		b. Let eventList be the [[EventList]] field of the element in execution.[[EventLists]] whose [[AgentSignifier]] is AgentSignifier().
		c. If isTypedArray is true and type is "Int8", "Uint8", "Int16", "Uint16", "Int32", or "Uint32", let noTear be true; otherwise let noTear be false.
		d. Let rawValue be a List of length elementSize of nondeterministically chosen byte values.
		e. NOTE: In implementations, rawValue is the result of a non-atomic or atomic read instruction on the underlying hardware. The nondeterminism is a semantic prescription of the memory model to describe observable behaviour of hardware with weak consistency.
		f. Let readEvent be ReadSharedMemory{ [[Order]]: order, [[NoTear]]: noTear, [[Block]]: block, [[ByteIndex]]: byteIndex, [[ElementSize]]: elementSize }.
		g. Append readEvent to eventList.
		h. Append Chosen Value Record { [[Event]]: readEvent, [[ChosenValue]]: rawValue } to execution.[[ChosenValues]].
		*/
		throw new $SyntaxError('SharedArrayBuffer is not supported by this implementation');
	} else {
		// 7. Let rawValue be a List of elementSize containing, in order, the elementSize sequence of bytes starting with block[byteIndex].
		rawValue = $slice(new $Uint8Array(arrayBuffer, byteIndex), 0, elementSize); // step 6
	}

	// 8. If isLittleEndian is not present, set isLittleEndian to either true or false. The choice is implementation dependent and should be the alternative that is most efficient for the implementation. An implementation must use the same value each time this step is executed and the same value must be used for the corresponding step in the SetValueInBuffer abstract operation.
	var isLittleEndian = arguments.length > 5 ? arguments[5] : defaultEndianness === 'little'; // step 8

	var bytes = isLittleEndian
		? $slice(safeConcat([0, 0, 0, 0, 0, 0, 0, 0], rawValue), -elementSize)
		: $slice(safeConcat(rawValue, [0, 0, 0, 0, 0, 0, 0, 0]), 0, elementSize);

	return RawBytesToNumeric(type, bytes, isLittleEndian);
};
'use strict';

var $TypeError = require('es-errors/type');

var IsFixedLengthArrayBuffer = require('./IsFixedLengthArrayBuffer');
var IsViewOutOfBounds = require('./IsViewOutOfBounds');

var isDataViewWithBufferWitnessRecord = require('../helpers/records/data-view-with-buffer-witness-record');

var dataViewBuffer = require('data-view-buffer');
var dataViewByteLength = require('data-view-byte-length');
var dataViewByteOffset = require('data-view-byte-offset');

// https://262.ecma-international.org/15.0/#sec-getviewbytelength

module.exports = function GetViewByteLength(viewRecord) {
	if (!isDataViewWithBufferWitnessRecord(viewRecord)) {
		throw new $TypeError('Assertion failed: `viewRecord` must be a DataView with Buffer Witness Record');
	}

	if (IsViewOutOfBounds(viewRecord)) {
		throw new $TypeError('Assertion failed: `viewRecord` is out of bounds'); // step 1
	}

	var view = viewRecord['[[Object]]']; // step 2

	var isFixed = IsFixedLengthArrayBuffer(dataViewBuffer(view));

	var viewByteLength = isFixed ? dataViewByteLength(view) : 'AUTO'; // view.[[ByteLength]]
	if (viewByteLength !== 'AUTO') {
		return viewByteLength; // step 3
	}

	if (isFixed) {
		throw new $TypeError('Assertion failed: DataView’s ArrayBuffer is not fixed length'); // step 4
	}

	var byteOffset = dataViewByteOffset(view); // step 5

	var byteLength = viewRecord['[[CachedBufferByteLength]]']; // step 6

	if (byteLength === 'DETACHED') {
		throw new $TypeError('Assertion failed: DataView’s ArrayBuffer is detached'); // step 7
	}

	return byteLength - byteOffset; // step 8
};
'use strict';

var $TypeError = require('es-errors/type');

var inspect = require('object-inspect');

var isPropertyKey = require('../helpers/isPropertyKey');
// var ToObject = require('./ToObject');

// https://262.ecma-international.org/6.0/#sec-getv

module.exports = function GetV(V, P) {
	// 7.3.2.1
	if (!isPropertyKey(P)) {
		throw new $TypeError('Assertion failed: P is not a Property Key, got ' + inspect(P));
	}

	// 7.3.2.2-3
	// var O = ToObject(V);

	// 7.3.2.4
	return V[P];
};
'use strict';

var $TypeError = require('es-errors/type');
var isNegativeZero = require('math-intrinsics/isNegativeZero');
var MAX_SAFE_INTEGER = require('math-intrinsics/constants/maxSafeInteger');

var AddValueToKeyedGroup = require('./AddValueToKeyedGroup');
var Call = require('./Call');
var GetIterator = require('./GetIterator');
var IsCallable = require('./IsCallable');
var IteratorClose = require('./IteratorClose');
var IteratorStep = require('./IteratorStep');
var IteratorValue = require('./IteratorValue');
var RequireObjectCoercible = require('./RequireObjectCoercible');
var ThrowCompletion = require('./ThrowCompletion');
var ToPropertyKey = require('./ToPropertyKey');

// https://262.ecma-international.org/15.0/#sec-groupby

module.exports = function GroupBy(items, callbackfn, keyCoercion) {
	if (keyCoercion !== 'PROPERTY' && keyCoercion !== 'ZERO') {
		throw new $TypeError('Assertion failed: `keyCoercion` must be `"PROPERTY"` or `"ZERO"`');
	}

	RequireObjectCoercible(items); // step 1

	if (!IsCallable(callbackfn)) {
		throw new $TypeError('callbackfn must be callable'); // step 2
	}

	var groups = []; // step 3

	var iteratorRecord = GetIterator(items, 'SYNC'); // step 4

	var k = 0; // step 5

	// eslint-disable-next-line no-constant-condition
	while (true) { // step 6
		if (k >= MAX_SAFE_INTEGER) { // step 6.a
			var error = ThrowCompletion(new $TypeError('k must be less than 2 ** 53 - 1')); // step 6.a.i
			return void IteratorClose(iteratorRecord, error); // step 6.a.ii
		}
		var next = IteratorStep(iteratorRecord); // step 6.b
		if (!next) { // step 6.c
			return groups; // step 6.c.i
		}

		var value = IteratorValue(next); // step 6.dv

		var key;
		try {
			key = Call(callbackfn, undefined, [value, k]); // step 6.e
		} catch (e) {
			return void IteratorClose(iteratorRecord, ThrowCompletion(e)); // step 6.f
		}

		if (keyCoercion === 'PROPERTY') { // step 6.g
			try {
				key = ToPropertyKey(key); // step 6.g.i
			} catch (e) {
				return void IteratorClose(iteratorRecord, ThrowCompletion(e)); // step 6.g.ii
			}
		} else { // step 6.h
			if (keyCoercion !== 'ZERO') {
				throw new $TypeError('Assertion failed: keyCoercion must be ~PROPERTY~ or ~ZERO~'); // step 6.h.i
			}
			if (isNegativeZero(key)) {
				key = +0; // step 6.h.ii
			}
		}

		AddValueToKeyedGroup(groups, key, value); // step 6.i

		k += 1; // step 6.j
	}
};
'use strict';

var $TypeError = require('es-errors/type');

var isRegExpRecord = require('../helpers/records/regexp-record');

// https://262.ecma-international.org/15.0/#sec-runtime-semantics-haseitherunicodeflag-abstract-operation

module.exports = function HasEitherUnicodeFlag(rer) {
	if (!isRegExpRecord(rer)) {
		throw new $TypeError('Assertion failed: `rer` must be a RegExp Record');
	}

	if (rer['[[Unicode]]'] || rer['[[UnicodeSets]]']) { // step 1
		return true; // step 1.a
	}
	return false; // step 2
};
'use strict';

var $TypeError = require('es-errors/type');

var hasOwn = require('hasown');
var isObject = require('es-object-atoms/isObject');

var isPropertyKey = require('../helpers/isPropertyKey');

// https://262.ecma-international.org/6.0/#sec-hasownproperty

module.exports = function HasOwnProperty(O, P) {
	if (!isObject(O)) {
		throw new $TypeError('Assertion failed: `O` must be an Object');
	}
	if (!isPropertyKey(P)) {
		throw new $TypeError('Assertion failed: `P` must be a Property Key');
	}
	return hasOwn(O, P);
};
'use strict';

var $TypeError = require('es-errors/type');
var isObject = require('es-object-atoms/isObject');

var isPropertyKey = require('../helpers/isPropertyKey');

// https://262.ecma-international.org/6.0/#sec-hasproperty

module.exports = function HasProperty(O, P) {
	if (!isObject(O)) {
		throw new $TypeError('Assertion failed: `O` must be an Object');
	}
	if (!isPropertyKey(P)) {
		throw new $TypeError('Assertion failed: `P` must be a Property Key');
	}
	return P in O;
};
'use strict';

var floor = require('./floor');
var modulo = require('./modulo');

var timeConstants = require('../helpers/timeConstants');
var msPerHour = timeConstants.msPerHour;
var HoursPerDay = timeConstants.HoursPerDay;

// https://262.ecma-international.org/5.1/#sec-15.9.1.10

module.exports = function HourFromTime(t) {
	return modulo(floor(t / msPerHour), HoursPerDay);
};
'use strict';

var $EvalError = require('es-errors/eval');

var DaysInYear = require('./DaysInYear');
var YearFromTime = require('./YearFromTime');

// https://262.ecma-international.org/5.1/#sec-15.9.1.3

module.exports = function InLeapYear(t) {
	var days = DaysInYear(YearFromTime(t));
	if (days === 365) {
		return 0;
	}
	if (days === 366) {
		return 1;
	}
	throw new $EvalError('Assertion failed: there are not 365 or 366 days in a year, got: ' + days);
};
'use strict';

var $TypeError = require('es-errors/type');
var isObject = require('es-object-atoms/isObject');

var CreateNonEnumerableDataPropertyOrThrow = require('./CreateNonEnumerableDataPropertyOrThrow');
var Get = require('./Get');
var HasProperty = require('./HasProperty');

// https://262.ecma-international.org/13.0/#sec-installerrorcause

module.exports = function InstallErrorCause(O, options) {
	if (!isObject(O)) {
		throw new $TypeError('Assertion failed: Type(O) is not Object');
	}

	if (isObject(options) && HasProperty(options, 'cause')) {
		var cause = Get(options, 'cause');
		CreateNonEnumerableDataPropertyOrThrow(O, 'cause', cause);
	}
};
'use strict';

var GetIntrinsic = require('get-intrinsic');

var $TypeError = require('es-errors/type');
var isObject = require('es-object-atoms/isObject');

var $hasInstance = GetIntrinsic('%Symbol.hasInstance%', true);

var Call = require('./Call');
var GetMethod = require('./GetMethod');
var IsCallable = require('./IsCallable');
var OrdinaryHasInstance = require('./OrdinaryHasInstance');
var ToBoolean = require('./ToBoolean');

// https://262.ecma-international.org/6.0/#sec-instanceofoperator

module.exports = function InstanceofOperator(O, C) {
	if (!isObject(O)) {
		throw new $TypeError('Assertion failed: Type(O) is not Object');
	}
	var instOfHandler = $hasInstance ? GetMethod(C, $hasInstance) : void 0;
	if (typeof instOfHandler !== 'undefined') {
		return ToBoolean(Call(instOfHandler, C, [O]));
	}
	if (!IsCallable(C)) {
		throw new $TypeError('`C` is not Callable');
	}
	return OrdinaryHasInstance(C, O);
};
'use strict';

var $TypeError = require('es-errors/type');
var isObject = require('es-object-atoms/isObject');

var Call = require('./Call');
var CreateDataProperty = require('./CreateDataProperty');
var EnumerableOwnProperties = require('./EnumerableOwnProperties');
var Get = require('./Get');
var IsArray = require('./IsArray');
var LengthOfArrayLike = require('./LengthOfArrayLike');
var ToString = require('./ToString');

var forEach = require('../helpers/forEach');

// https://262.ecma-international.org/14.0/#sec-internalizejsonproperty

// note: `reviver` was implicitly closed-over until ES2020, where it becomes a third argument

module.exports = function InternalizeJSONProperty(holder, name, reviver) {
	if (!isObject(holder)) {
		throw new $TypeError('Assertion failed: `holder` is not an Object');
	}
	if (typeof name !== 'string') {
		throw new $TypeError('Assertion failed: `name` is not a String');
	}
	if (typeof reviver !== 'function') {
		throw new $TypeError('Assertion failed: `reviver` is not a Function');
	}

	var val = Get(holder, name); // step 1

	if (isObject(val)) { // step 2
		var isArray = IsArray(val); // step 2.a
		if (isArray) { // step 2.b
			var I = 0; // step 2.b.i

			var len = LengthOfArrayLike(val); // step 2.b.ii

			while (I < len) { // step 2.b.iii
				var newElement = InternalizeJSONProperty(val, ToString(I), reviver); // step 2.b.iv.1

				if (typeof newElement === 'undefined') { // step 2.b.iii.2
					delete val[ToString(I)]; // step 2.b.iii.2.a
				} else { // step 2.b.iii.3
					CreateDataProperty(val, ToString(I), newElement); // step 2.b.iii.3.a
				}

				I += 1; // step 2.b.iii.4
			}
		} else { // step 2.c
			var keys = EnumerableOwnProperties(val, 'key'); // step 2.c.i

			forEach(keys, function (P) { // step 2.c.ii
				// eslint-disable-next-line no-shadow
				var newElement = InternalizeJSONProperty(val, P, reviver); // step 2.c.ii.1

				if (typeof newElement === 'undefined') { // step 2.c.ii.2
					delete val[P]; // step 2.c.ii.2.a
				} else { // step 2.c.ii.3
					CreateDataProperty(val, P, newElement); // step 2.c.ii.3.a
				}
			});
		}
	}

	return Call(reviver, holder, [name, val]); // step 3
};
'use strict';

var $TypeError = require('es-errors/type');

var Call = require('./Call');
var IsArray = require('./IsArray');
var GetV = require('./GetV');
var isPropertyKey = require('../helpers/isPropertyKey');

// https://262.ecma-international.org/6.0/#sec-invoke

module.exports = function Invoke(O, P) {
	if (!isPropertyKey(P)) {
		throw new $TypeError('Assertion failed: P must be a Property Key');
	}
	var argumentsList = arguments.length > 2 ? arguments[2] : [];
	if (!IsArray(argumentsList)) {
		throw new $TypeError('Assertion failed: optional `argumentsList`, if provided, must be a List');
	}
	var func = GetV(O, P);
	return Call(func, O, argumentsList);
};
'use strict';

var $TypeError = require('es-errors/type');

var hasOwn = require('hasown');

var isPropertyDescriptor = require('../helpers/records/property-descriptor');

// https://262.ecma-international.org/5.1/#sec-8.10.1

module.exports = function IsAccessorDescriptor(Desc) {
	if (typeof Desc === 'undefined') {
		return false;
	}

	if (!isPropertyDescriptor(Desc)) {
		throw new $TypeError('Assertion failed: `Desc` must be a Property Descriptor');
	}

	if (!hasOwn(Desc, '[[Get]]') && !hasOwn(Desc, '[[Set]]')) {
		return false;
	}

	return true;
};
'use strict';

var $TypeError = require('es-errors/type');

var IsTypedArrayOutOfBounds = require('./IsTypedArrayOutOfBounds');
var IsViewOutOfBounds = require('./IsViewOutOfBounds');
var MakeDataViewWithBufferWitnessRecord = require('./MakeDataViewWithBufferWitnessRecord');
var MakeTypedArrayWithBufferWitnessRecord = require('./MakeTypedArrayWithBufferWitnessRecord');

var isDataView = require('is-data-view');
var isTypedArray = require('is-typed-array');

// https://262.ecma-international.org/15.0/#sec-isarraybufferviewoutofbounds

module.exports = function IsArrayBufferViewOutOfBounds(O) {
	var isDV = isDataView(O);
	if (!isTypedArray(O) && !isDV) {
		throw new $TypeError('Assertion failed: `O` must be a TypedArray or DataView');
	}

	if (isDV) { // step 1
		var viewRecord = MakeDataViewWithBufferWitnessRecord(O, 'SEQ-CST'); // step 1.a

		return IsViewOutOfBounds(viewRecord); // step 1.b
	}

	var taRecord = MakeTypedArrayWithBufferWitnessRecord(O, 'SEQ-CST'); // step 2

	return IsTypedArrayOutOfBounds(taRecord); // step 3
};
'use strict';

// https://262.ecma-international.org/6.0/#sec-isarray
module.exports = require('../helpers/IsArray');
'use strict';

// https://262.ecma-international.org/15.0/#sec-isbigintelementtype

module.exports = function IsBigIntElementType(type) {
	return type === 'BIGUINT64' || type === 'BIGINT64';
};
'use strict';

// http://262.ecma-international.org/5.1/#sec-9.11

module.exports = require('is-callable');
'use strict';

var ValidateAndApplyPropertyDescriptor = require('./ValidateAndApplyPropertyDescriptor');

// https://262.ecma-international.org/13.0/#sec-iscompatiblepropertydescriptor

module.exports = function IsCompatiblePropertyDescriptor(Extensible, Desc, Current) {
	return ValidateAndApplyPropertyDescriptor(undefined, '', Extensible, Desc, Current);
};
'use strict';

var GetIntrinsic = require('get-intrinsic');

var $isConcatSpreadable = GetIntrinsic('%Symbol.isConcatSpreadable%', true);

var Get = require('./Get');
var IsArray = require('./IsArray');
var ToBoolean = require('./ToBoolean');

var isObject = require('es-object-atoms/isObject');

// https://262.ecma-international.org/6.0/#sec-isconcatspreadable

module.exports = function IsConcatSpreadable(O) {
	if (!isObject(O)) {
		return false;
	}
	if ($isConcatSpreadable) {
		var spreadable = Get(O, $isConcatSpreadable);
		if (typeof spreadable !== 'undefined') {
			return ToBoolean(spreadable);
		}
	}
	return IsArray(O);
};
'use strict';

var GetIntrinsic = require('../GetIntrinsic.js');

var $construct = GetIntrinsic('%Reflect.construct%', true);

var DefinePropertyOrThrow = require('./DefinePropertyOrThrow');
try {
	DefinePropertyOrThrow({}, '', { '[[Get]]': function () {} });
} catch (e) {
	// Accessor properties aren't supported
	DefinePropertyOrThrow = null;
}

// https://262.ecma-international.org/6.0/#sec-isconstructor

if (DefinePropertyOrThrow && $construct) {
	var isConstructorMarker = {};
	var badArrayLike = {};
	DefinePropertyOrThrow(badArrayLike, 'length', {
		'[[Get]]': function () {
			throw isConstructorMarker;
		},
		'[[Enumerable]]': true
	});

	module.exports = function IsConstructor(argument) {
		try {
			// `Reflect.construct` invokes `IsConstructor(target)` before `Get(args, 'length')`:
			$construct(argument, badArrayLike);
		} catch (err) {
			return err === isConstructorMarker;
		}
	};
} else {
	module.exports = function IsConstructor(argument) {
		// unfortunately there's no way to truly check this without try/catch `new argument` in old environments
		return typeof argument === 'function' && !!argument.prototype;
	};
}
'use strict';

var $TypeError = require('es-errors/type');

var hasOwn = require('hasown');

var isPropertyDescriptor = require('../helpers/records/property-descriptor');

// https://262.ecma-international.org/5.1/#sec-8.10.2

module.exports = function IsDataDescriptor(Desc) {
	if (typeof Desc === 'undefined') {
		return false;
	}

	if (!isPropertyDescriptor(Desc)) {
		throw new $TypeError('Assertion failed: `Desc` must be a Property Descriptor');
	}

	if (!hasOwn(Desc, '[[Value]]') && !hasOwn(Desc, '[[Writable]]')) {
		return false;
	}

	return true;
};
'use strict';

var $TypeError = require('es-errors/type');

var $byteLength = require('array-buffer-byte-length');
var availableTypedArrays = require('available-typed-arrays')();
var callBound = require('call-bound');
var isArrayBuffer = require('is-array-buffer');
var isSharedArrayBuffer = require('is-shared-array-buffer');

var $sabByteLength = callBound('SharedArrayBuffer.prototype.byteLength', true);

// https://262.ecma-international.org/8.0/#sec-isdetachedbuffer

module.exports = function IsDetachedBuffer(arrayBuffer) {
	var isSAB = isSharedArrayBuffer(arrayBuffer);
	if (!isArrayBuffer(arrayBuffer) && !isSAB) {
		throw new $TypeError('Assertion failed: `arrayBuffer` must be an Object with an [[ArrayBufferData]] internal slot');
	}
	if ((isSAB ? $sabByteLength : $byteLength)(arrayBuffer) === 0) {
		try {
			new global[availableTypedArrays[0]](arrayBuffer); // eslint-disable-line no-new
		} catch (error) {
			return !!error && error.name === 'TypeError';
		}
	}
	return false;
};
'use strict';

var GetIntrinsic = require('get-intrinsic');

var $preventExtensions = GetIntrinsic('%Object.preventExtensions%', true);
var $isExtensible = GetIntrinsic('%Object.isExtensible%', true);

var isPrimitive = require('../helpers/isPrimitive');

// https://262.ecma-international.org/6.0/#sec-isextensible-o

module.exports = $preventExtensions
	? function IsExtensible(obj) {
		return !isPrimitive(obj) && $isExtensible(obj);
	}
	: function IsExtensible(obj) {
		return !isPrimitive(obj);
	};
'use strict';

var $TypeError = require('es-errors/type');

var callBound = require('call-bound');

var $arrayBufferResizable = callBound('%ArrayBuffer.prototype.resizable%', true);
var $sharedArrayGrowable = callBound('%SharedArrayBuffer.prototype.growable%', true);

var isArrayBuffer = require('is-array-buffer');
var isSharedArrayBuffer = require('is-shared-array-buffer');

// https://262.ecma-international.org/15.0/#sec-isfixedlengtharraybuffer

module.exports = function IsFixedLengthArrayBuffer(arrayBuffer) {
	var isAB = isArrayBuffer(arrayBuffer);
	var isSAB = isSharedArrayBuffer(arrayBuffer);
	if (!isAB && !isSAB) {
		throw new $TypeError('Assertion failed: `arrayBuffer` must be an ArrayBuffer or SharedArrayBuffer');
	}

	if (isAB && $arrayBufferResizable) {
		return !$arrayBufferResizable(arrayBuffer); // step 1
	}
	if (isSAB && $sharedArrayGrowable) {
		return !$sharedArrayGrowable(arrayBuffer); // step 1
	}
	return true; // step 2
};
'use strict';

var $TypeError = require('es-errors/type');

var IsAccessorDescriptor = require('./IsAccessorDescriptor');
var IsDataDescriptor = require('./IsDataDescriptor');

var isPropertyDescriptor = require('../helpers/records/property-descriptor');

// https://262.ecma-international.org/6.0/#sec-isgenericdescriptor

module.exports = function IsGenericDescriptor(Desc) {
	if (typeof Desc === 'undefined') {
		return false;
	}

	if (!isPropertyDescriptor(Desc)) {
		throw new $TypeError('Assertion failed: `Desc` must be a Property Descriptor');
	}

	if (!IsAccessorDescriptor(Desc) && !IsDataDescriptor(Desc)) {
		return true;
	}

	return false;
};
'use strict';

var truncate = require('./truncate');

var $isFinite = require('math-intrinsics/isFinite');

// https://262.ecma-international.org/14.0/#sec-isintegralnumber

module.exports = function IsIntegralNumber(argument) {
	if (typeof argument !== 'number' || !$isFinite(argument)) {
		return false;
	}
	return truncate(argument) === argument;
};
'use strict';

var GetIntrinsic = require('get-intrinsic');

var $Number = GetIntrinsic('%Number%');
var $TypeError = require('es-errors/type');
var min = require('math-intrinsics/min');
var $isNaN = require('math-intrinsics/isNaN');

var $charCodeAt = require('call-bound')('String.prototype.charCodeAt');

var StringToBigInt = require('./StringToBigInt');
var ToNumeric = require('./ToNumeric');
var ToPrimitive = require('./ToPrimitive');

var BigIntLessThan = require('./BigInt/lessThan');
var NumberLessThan = require('./Number/lessThan');

// https://262.ecma-international.org/14.0/#sec-islessthan

// eslint-disable-next-line max-statements, max-lines-per-function
module.exports = function IsLessThan(x, y, LeftFirst) {
	if (typeof LeftFirst !== 'boolean') {
		throw new $TypeError('Assertion failed: LeftFirst argument must be a Boolean');
	}
	var px;
	var py;
	if (LeftFirst) {
		px = ToPrimitive(x, $Number);
		py = ToPrimitive(y, $Number);
	} else {
		py = ToPrimitive(y, $Number);
		px = ToPrimitive(x, $Number);
	}

	if (typeof px === 'string' && typeof py === 'string') { // step 3
		// a. Let lx be the length of px.
		// b. Let ly be the length of py.
		// c. For each integer i starting with 0 such that i < min(lx, ly), in ascending order, do
		// i. Let cx be the integer that is the numeric value of the code unit at index i within px.
		// ii. Let cy be the integer that is the numeric value of the code unit at index i within py.
		// iii. If cx < cy, return true.
		// iv. If cx > cy, return false.
		// d. If lx < ly, return true. Otherwise, return false.

		var lx = px.length; // step 3.a
		var ly = py.length; // step 3.b
		for (var i = 0; i < min(lx, ly); i++) { // step 3.c
			var cx = $charCodeAt(px, i); // step 3.c.i
			var cy = $charCodeAt(py, i); // step 3.c.ii
			if (cx < cy) {
				return true; // step 3.c.iii
			}
			if (cx > cy) {
				return false; // step 3.c.iv
			}
		}
		return lx < ly; // step 3.d
	}

	var nx;
	var ny;
	if (typeof px === 'bigint' && typeof py === 'string') {
		ny = StringToBigInt(py);
		if (typeof ny === 'undefined') {
			return void undefined;
		}
		return BigIntLessThan(px, ny);
	}
	if (typeof px === 'string' && typeof py === 'bigint') {
		nx = StringToBigInt(px);
		if (typeof nx === 'undefined') {
			return void undefined;
		}
		return BigIntLessThan(nx, py);
	}

	nx = ToNumeric(px);
	ny = ToNumeric(py);

	if (typeof nx === typeof ny) {
		return typeof nx === 'number' ? NumberLessThan(nx, ny) : BigIntLessThan(nx, ny);
	}

	if ($isNaN(nx) || $isNaN(ny)) {
		return void undefined;
	}

	if (nx === -Infinity || ny === Infinity) {
		return true;
	}
	if (nx === Infinity || ny === -Infinity) {
		return false;
	}

	return nx < ny; // by now, these are both finite, and the same type
};
'use strict';

var isFinite = require('math-intrinsics/isFinite');
var isObject = require('es-object-atoms/isObject');

var IsStrictlyEqual = require('./IsStrictlyEqual');
var StringToBigInt = require('./StringToBigInt');
var ToNumber = require('./ToNumber');
var ToPrimitive = require('./ToPrimitive');

var isSameType = require('../helpers/isSameType');

// https://262.ecma-international.org/13.0/#sec-islooselyequal

module.exports = function IsLooselyEqual(x, y) {
	if (isSameType(x, y)) {
		return IsStrictlyEqual(x, y);
	}
	if (x == null && y == null) {
		return true;
	}
	if (typeof x === 'number' && typeof y === 'string') {
		return IsLooselyEqual(x, ToNumber(y));
	}
	if (typeof x === 'string' && typeof y === 'number') {
		return IsLooselyEqual(ToNumber(x), y);
	}
	if (typeof x === 'bigint' && typeof y === 'string') {
		var n = StringToBigInt(y);
		if (typeof n === 'undefined') {
			return false;
		}
		return IsLooselyEqual(x, n);
	}
	if (typeof x === 'string' && typeof y === 'bigint') {
		return IsLooselyEqual(y, x);
	}
	if (typeof x === 'boolean') {
		return IsLooselyEqual(ToNumber(x), y);
	}
	if (typeof y === 'boolean') {
		return IsLooselyEqual(x, ToNumber(y));
	}
	if ((typeof x === 'string' || typeof x === 'number' || typeof x === 'symbol' || typeof x === 'bigint') && isObject(y)) {
		return IsLooselyEqual(x, ToPrimitive(y));
	}
	if (isObject(x) && (typeof y === 'string' || typeof y === 'number' || typeof y === 'symbol' || typeof y === 'bigint')) {
		return IsLooselyEqual(ToPrimitive(x), y);
	}
	if ((typeof x === 'bigint' && typeof y === 'number') || (typeof x === 'number' && typeof y === 'bigint')) {
		if (!isFinite(x) || !isFinite(y)) {
			return false;
		}
		// eslint-disable-next-line eqeqeq
		return x == y; // shortcut for step 13.b.
	}
	return false;
};
'use strict';

var IsUnclampedIntegerElementType = require('./IsUnclampedIntegerElementType');
var IsBigIntElementType = require('./IsBigIntElementType');

// https://262.ecma-international.org/15.0/#sec-isnotearconfiguration

module.exports = function IsNoTearConfiguration(type, order) {
	if (IsUnclampedIntegerElementType(type)) {
		return true;
	}
	if (IsBigIntElementType(type) && order !== 'INIT' && order !== 'UNORDERED') {
		return true;
	}
	return false;
};
'use strict';

var callBound = require('call-bound');

var $PromiseThen = callBound('Promise.prototype.then', true);

var isObject = require('es-object-atoms/isObject');

// https://262.ecma-international.org/6.0/#sec-ispromise

module.exports = function IsPromise(x) {
	if (!isObject(x)) {
		return false;
	}
	if (!$PromiseThen) { // Promises are not supported
		return false;
	}
	try {
		$PromiseThen(x); // throws if not a promise
	} catch (e) {
		return false;
	}
	return true;
};
'use strict';

var isPropertyKey = require('../helpers/isPropertyKey');

// https://262.ecma-international.org/6.0/#sec-ispropertykey

module.exports = function IsPropertyKey(argument) {
	return isPropertyKey(argument);
};
'use strict';

var GetIntrinsic = require('get-intrinsic');

var $match = GetIntrinsic('%Symbol.match%', true);

var hasRegExpMatcher = require('is-regex');
var isObject = require('es-object-atoms/isObject');

var ToBoolean = require('./ToBoolean');

// https://262.ecma-international.org/6.0/#sec-isregexp

module.exports = function IsRegExp(argument) {
	if (!isObject(argument)) {
		return false;
	}
	if ($match) {
		var isRegExp = argument[$match];
		if (typeof isRegExp !== 'undefined') {
			return ToBoolean(isRegExp);
		}
	}
	return hasRegExpMatcher(argument);
};
'use strict';

var $TypeError = require('es-errors/type');
var isObject = require('es-object-atoms/isObject');

var isSharedArrayBuffer = require('is-shared-array-buffer');

// https://262.ecma-international.org/8.0/#sec-issharedarraybuffer

module.exports = function IsSharedArrayBuffer(obj) {
	if (!isObject(obj)) {
		throw new $TypeError('Assertion failed: Type(O) is not Object');
	}

	return isSharedArrayBuffer(obj);
};
'use strict';

var SameValueNonNumber = require('./SameValueNonNumber');
var Type = require('./Type');
var NumberEqual = require('./Number/equal');

// https://262.ecma-international.org/14.0/#sec-isstrictlyequal

module.exports = function IsStrictlyEqual(x, y) {
	if (Type(x) !== Type(y)) {
		return false;
	}
	return typeof x === 'number' ? NumberEqual(x, y) : SameValueNonNumber(x, y);
};
'use strict';

var CodePointAt = require('./CodePointAt');

var $TypeError = require('es-errors/type');

// https://262.ecma-international.org/14.0/#sec-isstringwellformedunicode

module.exports = function IsStringWellFormedUnicode(string) {
	if (typeof string !== 'string') {
		throw new $TypeError('Assertion failed: `string` must be a String');
	}
	var len = string.length; // step 1
	var k = 0; // step 2
	while (k < len) { // step 3
		var cp = CodePointAt(string, k); // step 3.a
		if (cp['[[IsUnpairedSurrogate]]']) {
			return false; // step 3.b
		}
		k += cp['[[CodeUnitCount]]']; // step 3.c
	}
	return true; // step 4
};
'use strict';

var $TypeError = require('es-errors/type');

var regexTester = require('safe-regex-test');

// https://tc39.es/ecma262/#sec-istimezoneoffsetstring

// implementation taken from https://github.com/tc39/proposal-temporal/blob/21ee5b13f0672990c807475ba094092d19dd6dc5/polyfill/lib/ecmascript.mjs#L2140

var OFFSET = /^([+\u2212-])([01][0-9]|2[0-3])(?::?([0-5][0-9])(?::?([0-5][0-9])(?:[.,](\d{1,9}))?)?)?$/;

var testOffset = regexTester(OFFSET);

module.exports = function IsTimeZoneOffsetString(offsetString) {
	if (typeof offsetString !== 'string') {
		throw new $TypeError('Assertion failed: `offsetString` must be a String');
	}
	return testOffset(offsetString);
};
'use strict';

var $TypeError = require('es-errors/type');

var IsDetachedBuffer = require('./IsDetachedBuffer');
var IsFixedLengthArrayBuffer = require('./IsFixedLengthArrayBuffer');
var TypedArrayElementSize = require('./TypedArrayElementSize');

var isTypedArrayWithBufferWitnessRecord = require('../helpers/records/typed-array-with-buffer-witness-record');

var typedArrayBuffer = require('typed-array-buffer');
var typedArrayByteOffset = require('typed-array-byte-offset');
var typedArrayLength = require('typed-array-length');

// https://262.ecma-international.org/15.0/#sec-istypedarrayoutofbounds

module.exports = function IsTypedArrayOutOfBounds(taRecord) {
	if (!isTypedArrayWithBufferWitnessRecord(taRecord)) {
		throw new $TypeError('Assertion failed: `taRecord` must be a TypedArray With Buffer Witness Record');
	}

	var O = taRecord['[[Object]]']; // step 1

	var bufferByteLength = taRecord['[[CachedBufferByteLength]]']; // step 2

	if (IsDetachedBuffer(typedArrayBuffer(O)) && bufferByteLength !== 'DETACHED') {
		throw new $TypeError('Assertion failed: typed array is detached only if the byte length is ~DETACHED~'); // step 3
	}

	if (bufferByteLength === 'DETACHED') {
		return true; // step 4
	}

	var byteOffsetStart = typedArrayByteOffset(O); // step 5

	var isFixed = IsFixedLengthArrayBuffer(typedArrayBuffer(O));

	var byteOffsetEnd;
	var length = isFixed ? typedArrayLength(O) : 'AUTO';
	// TODO: probably use package for array length
	// seems to apply when TA is backed by a resizable/growable AB
	if (length === 'AUTO') { // step 6
		byteOffsetEnd = bufferByteLength; // step 6.a
	} else {
		var elementSize = TypedArrayElementSize(O); // step 7.a

		byteOffsetEnd = byteOffsetStart + (length * elementSize); // step 7.b
	}

	if (byteOffsetStart > bufferByteLength || byteOffsetEnd > bufferByteLength) {
		return true; // step 8
	}

	// 9. NOTE: 0-length TypedArrays are not considered out-of-bounds.

	return false; // step 10
};
'use strict';

// https://262.ecma-international.org/15.0/#sec-isunclampedintegerelementtype

module.exports = function IsUnclampedIntegerElementType(type) {
	return type === 'INT8'
		|| type === 'UINT8'
		|| type === 'INT16'
		|| type === 'UINT16'
		|| type === 'INT32'
		|| type === 'UINT32';
};
'use strict';

// https://262.ecma-international.org/15.0/#sec-isunsignedelementtype

module.exports = function IsUnsignedElementType(type) {
	return type === 'UINT8'
		|| type === 'UINT8C'
		|| type === 'UINT16'
		|| type === 'UINT32'
		|| type === 'BIGUINT64';
};
'use strict';

var $TypeError = require('es-errors/type');

var IsDetachedBuffer = require('./IsDetachedBuffer');
var IsTypedArrayOutOfBounds = require('./IsTypedArrayOutOfBounds');
var MakeTypedArrayWithBufferWitnessRecord = require('./MakeTypedArrayWithBufferWitnessRecord');
var TypedArrayLength = require('./TypedArrayLength');

var isInteger = require('math-intrinsics/isInteger');
var isNegativeZero = require('math-intrinsics/isNegativeZero');

var isTypedArray = require('is-typed-array');
var typedArrayBuffer = require('typed-array-buffer');

// https://262.ecma-international.org/15.0/#sec-isvalidintegerindex

module.exports = function IsValidIntegerIndex(O, index) {
	if (!isTypedArray(O)) {
		throw new $TypeError('Assertion failed: `O` is not a TypedArray object');
	}
	if (typeof index !== 'number') {
		throw new $TypeError('Assertion failed: `index` is not a Number');
	}

	var buffer = typedArrayBuffer(O);

	if (IsDetachedBuffer(buffer)) { return false; } // step 1

	if (!isInteger(index)) { return false; } // step 2

	if (isNegativeZero(index)) { return false; } // step 3

	var taRecord = MakeTypedArrayWithBufferWitnessRecord(O, 'UNORDERED'); // step 4
	if (IsTypedArrayOutOfBounds(taRecord)) {
		return false; // step 6
	}
	var length = TypedArrayLength(taRecord); // step 7

	if (index < 0 || index >= length) { return false; } // step 8

	return true; // step 9
};
'use strict';

var $TypeError = require('es-errors/type');

var IsDetachedBuffer = require('./IsDetachedBuffer');
var IsFixedLengthArrayBuffer = require('./IsFixedLengthArrayBuffer');

var isDataViewWithBufferWitnessRecord = require('../helpers/records/data-view-with-buffer-witness-record');

var dataViewBuffer = require('data-view-buffer');
var dataViewByteLength = require('data-view-byte-length');
var dataViewByteOffset = require('data-view-byte-offset');

// https://262.ecma-international.org/15.0/#sec-isviewoutofbounds

module.exports = function IsViewOutOfBounds(viewRecord) {
	if (!isDataViewWithBufferWitnessRecord(viewRecord)) {
		throw new $TypeError('Assertion failed: `viewRecord` must be a DataView With Buffer Witness Record');
	}

	var view = viewRecord['[[Object]]']; // step 1

	var bufferByteLength = viewRecord['[[CachedBufferByteLength]]']; // step 2

	if (IsDetachedBuffer(dataViewBuffer(view)) !== (bufferByteLength === 'DETACHED')) {
		// step 3
		throw new $TypeError('Assertion failed: `IsDetachedBuffer(dataViewBuffer(view))` must be true if and only if `bufferByteLength === ~DETACHED~');
	}

	if (bufferByteLength === 'DETACHED') {
		return true; // step 4
	}

	var byteOffsetStart = dataViewByteOffset(view); // step 5

	var isFixed = IsFixedLengthArrayBuffer(dataViewBuffer(view));

	var viewByteLength = isFixed ? dataViewByteLength(view) : 'AUTO'; // view.[[ByteLength]]
	var byteOffsetEnd = viewByteLength === 'AUTO' ? bufferByteLength : byteOffsetStart + viewByteLength; // steps 6 - 7

	if (byteOffsetStart > bufferByteLength || byteOffsetEnd > bufferByteLength) {
		return true; // step 8
	}

	// 9. NOTE: 0-length DataViews are not considered out-of-bounds.

	return false; // step 10
};
'use strict';

var $TypeError = require('es-errors/type');
var callBound = require('call-bound');
var isInteger = require('math-intrinsics/isInteger');

var $indexOf = callBound('String.prototype.indexOf');

var IsArray = require('./IsArray');
var WordCharacters = require('./WordCharacters');

var every = require('../helpers/every');
var isRegExpRecord = require('../helpers/records/regexp-record');

var isChar = function isChar(c) {
	return typeof c === 'string';
};

// https://262.ecma-international.org/14.0/#sec-runtime-semantics-iswordchar-abstract-operation

module.exports = function IsWordChar(rer, Input, e) {
	if (!isRegExpRecord(rer)) {
		throw new $TypeError('Assertion failed: `rer` must be a RegExp Record');
	}
	if (!IsArray(Input) || !every(Input, isChar)) {
		throw new $TypeError('Assertion failed: `Input` must be a List of characters');
	}

	if (!isInteger(e)) {
		throw new $TypeError('Assertion failed: `e` must be an integer');
	}

	var InputLength = Input.length; // step 1

	if (e === -1 || e === InputLength) {
		return false; // step 2
	}

	var c = Input[e]; // step 3

	return $indexOf(WordCharacters(rer), c) > -1; // steps 4-5
};
'use strict';

var $TypeError = require('es-errors/type');
var isObject = require('es-object-atoms/isObject');

var Call = require('./Call');
var CompletionRecord = require('./CompletionRecord');
var GetMethod = require('./GetMethod');
var IsCallable = require('./IsCallable');

var isIteratorRecord = require('../helpers/records/iterator-record');

// https://262.ecma-international.org/15.0/#sec-iteratorclose

module.exports = function IteratorClose(iteratorRecord, completion) {
	if (!isIteratorRecord(iteratorRecord)) {
		throw new $TypeError('Assertion failed: `iteratorRecord` must be an Iterator Record'); // step 1
	}
	if (!isObject(iteratorRecord['[[Iterator]]'])) {
		throw new $TypeError('Assertion failed: iteratorRecord.[[Iterator]] must be an Object'); // step 1
	}

	if (!IsCallable(completion) && !(completion instanceof CompletionRecord)) { // step 2
		throw new $TypeError('Assertion failed: completion is not a thunk representing a Completion Record, nor a Completion Record instance');
	}
	var completionThunk = completion instanceof CompletionRecord ? function () { return completion['?'](); } : completion;

	var iterator = iteratorRecord['[[Iterator]]']; // step 3

	var iteratorReturn;
	try {
		iteratorReturn = GetMethod(iterator, 'return'); // step 4
	} catch (e) {
		completionThunk(); // throws if `completion` is a throw completion // step 6
		completionThunk = null; // ensure it's not called twice.
		throw e; // step 7
	}
	if (typeof iteratorReturn === 'undefined') {
		return completionThunk(); // step 5.a - 5.b
	}

	var innerResult;
	try {
		innerResult = Call(iteratorReturn, iterator, []);
	} catch (e) {
		// if we hit here, then "e" is the innerResult completion that needs re-throwing

		completionThunk(); // throws if `completion` is a throw completion // step 6
		completionThunk = null; // ensure it's not called twice.

		// if not, then return the innerResult completion
		throw e; // step 7
	}
	var completionRecord = completionThunk(); // if innerResult worked, then throw if the completion does
	completionThunk = null; // ensure it's not called twice.

	if (!isObject(innerResult)) {
		throw new $TypeError('iterator .return must return an object');
	}

	return completionRecord;
};
'use strict';

var $TypeError = require('es-errors/type');
var isObject = require('es-object-atoms/isObject');

var Get = require('./Get');
var ToBoolean = require('./ToBoolean');

// https://262.ecma-international.org/6.0/#sec-iteratorcomplete

module.exports = function IteratorComplete(iterResult) {
	if (!isObject(iterResult)) {
		throw new $TypeError('Assertion failed: Type(iterResult) is not Object');
	}
	return ToBoolean(Get(iterResult, 'done'));
};
'use strict';

var $TypeError = require('es-errors/type');
var isObject = require('es-object-atoms/isObject');

var Call = require('./Call');

var isIteratorRecord = require('../helpers/records/iterator-record');

// https://262.ecma-international.org/15.0/#sec-iteratornext

module.exports = function IteratorNext(iteratorRecord) {
	if (!isIteratorRecord(iteratorRecord)) {
		throw new $TypeError('Assertion failed: `iteratorRecord` must be an Iterator Record'); // step 1
	}

	var result;
	if (arguments.length < 2) { // step 1
		result = Call(iteratorRecord['[[NextMethod]]'], iteratorRecord['[[Iterator]]']); // step 1.a
	} else { // step 2
		result = Call(iteratorRecord['[[NextMethod]]'], iteratorRecord['[[Iterator]]'], [arguments[1]]); // step 2.a
	}

	if (!isObject(result)) {
		throw new $TypeError('iterator next must return an object'); // step 3
	}
	return result; // step 4
};
'use strict';

var $TypeError = require('es-errors/type');

var IteratorComplete = require('./IteratorComplete');
var IteratorNext = require('./IteratorNext');

var isIteratorRecord = require('../helpers/records/iterator-record');

// https://262.ecma-international.org/15.0/#sec-iteratorstep

module.exports = function IteratorStep(iteratorRecord) {
	if (!isIteratorRecord(iteratorRecord)) {
		throw new $TypeError('Assertion failed: `iteratorRecord` must be an Iterator Record'); // step 1
	}

	var result = IteratorNext(iteratorRecord); // step 1
	var done = IteratorComplete(result); // step 2
	return done === true ? false : result; // steps 3-4
};

'use strict';

var $TypeError = require('es-errors/type');

var Get = require('./Get');
var IteratorComplete = require('./IteratorComplete');
var IteratorNext = require('./IteratorNext');

var isIteratorRecord = require('../helpers/records/iterator-record');

// https://262.ecma-international.org/15.0/#sec-iteratorstepvalue

module.exports = function IteratorStepValue(iteratorRecord) {
	if (!isIteratorRecord(iteratorRecord)) {
		throw new $TypeError('Assertion failed: `iteratorRecord` must be an Iterator Record');
	}
	/* eslint no-param-reassign: 0 */

	var result;
	try {
		result = IteratorNext(iteratorRecord); // step 1
	} catch (e) { // step 2
		iteratorRecord['[[Done]]'] = true; // step 2.a
		throw e; // step 2.b
	}

	var done;
	try {
		done = IteratorComplete(result); // step 4
	} catch (e) { // step 5
		iteratorRecord['[[Done]]'] = true; // step 5.a
		throw e; // step 5.b
	}

	if (done) { // step 7
		iteratorRecord['[[Done]]'] = true; // step 7.a
		return 'DONE'; // step 7.b
	}

	var value;
	try {
		value = Get(result, 'value'); // step 8
	} catch (e) { // step 9
		iteratorRecord['[[Done]]'] = true; // step 9.a
		throw e; // step 10
	}

	return value; // step 10
};
'use strict';

var $TypeError = require('es-errors/type');

var IteratorStep = require('./IteratorStep');
var IteratorValue = require('./IteratorValue');

var isIteratorRecord = require('../helpers/records/iterator-record');

// https://262.ecma-international.org/15.0/#sec-iteratortolist

module.exports = function IteratorToList(iteratorRecord) {
	if (!isIteratorRecord(iteratorRecord)) {
		throw new $TypeError('Assertion failed: `iteratorRecord` must be an Iterator Record'); // step 1
	}

	var values = []; // step 1
	var next = true; // step 2
	while (next) { // step 3
		next = IteratorStep(iteratorRecord); // step 3.a
		if (next) {
			var nextValue = IteratorValue(next); // step 3.b.i
			values[values.length] = nextValue; // step 3.b.ii
		}
	}
	return values; // step 4
};
'use strict';

var $TypeError = require('es-errors/type');
var isObject = require('es-object-atoms/isObject');

var Get = require('./Get');

// https://262.ecma-international.org/6.0/#sec-iteratorvalue

module.exports = function IteratorValue(iterResult) {
	if (!isObject(iterResult)) {
		throw new $TypeError('Assertion failed: Type(iterResult) is not Object');
	}
	return Get(iterResult, 'value');
};

'use strict';

var $TypeError = require('es-errors/type');

var callBound = require('call-bound');

var $keyFor = callBound('Symbol.keyFor', true);

// https://262.ecma-international.org/14.0/#sec-keyforsymbol

module.exports = function KeyForSymbol(sym) {
	if (typeof sym !== 'symbol') {
		throw new $TypeError('Assertion failed: `sym` must be a Symbol');
	}
	return $keyFor(sym);
};
'use strict';

var $TypeError = require('es-errors/type');
var isObject = require('es-object-atoms/isObject');

var Get = require('./Get');
var ToLength = require('./ToLength');

// https://262.ecma-international.org/11.0/#sec-lengthofarraylike

module.exports = function LengthOfArrayLike(obj) {
	if (!isObject(obj)) {
		throw new $TypeError('Assertion failed: `obj` must be an Object');
	}
	return ToLength(Get(obj, 'length'));
};

// TODO: use this all over
'use strict';

var $TypeError = require('es-errors/type');

var ArrayBufferByteLength = require('./ArrayBufferByteLength');
var IsDetachedBuffer = require('./IsDetachedBuffer');

var dataViewBuffer = require('data-view-buffer');
var isDataView = require('is-data-view');

// https://262.ecma-international.org/15.0/#sec-makedataviewwithbufferwitnessrecord

module.exports = function MakeDataViewWithBufferWitnessRecord(obj, order) {
	if (!isDataView(obj)) {
		throw new $TypeError('MakeDataViewWithBufferWitnessRecord called with non-DataView');
	}
	if (order !== 'SEQ-CST' && order !== 'UNORDERED') {
		throw new $TypeError('Assertion failed: `order` must be ~SEQ-CST~ or ~UNORDERED~');
	}

	var buffer = dataViewBuffer(obj); // step 1

	var byteLength = IsDetachedBuffer(buffer) ? 'DETACHED' : ArrayBufferByteLength(buffer, order); // steps 2 - 3

	return { '[[Object]]': obj, '[[CachedBufferByteLength]]': byteLength }; // step 4
};
'use strict';

var $isFinite = require('math-intrinsics/isFinite');

var msPerDay = require('../helpers/timeConstants').msPerDay;

// https://262.ecma-international.org/5.1/#sec-15.9.1.13

module.exports = function MakeDate(day, time) {
	if (!$isFinite(day) || !$isFinite(time)) {
		return NaN;
	}
	return (day * msPerDay) + time;
};
'use strict';

var GetIntrinsic = require('get-intrinsic');

var $DateUTC = GetIntrinsic('%Date.UTC%');

var $isFinite = require('math-intrinsics/isFinite');

var DateFromTime = require('./DateFromTime');
var Day = require('./Day');
var floor = require('./floor');
var modulo = require('./modulo');
var MonthFromTime = require('./MonthFromTime');
var ToIntegerOrInfinity = require('./ToIntegerOrInfinity');
var YearFromTime = require('./YearFromTime');

// https://262.ecma-international.org/5.1/#sec-15.9.1.12

module.exports = function MakeDay(year, month, date) {
	if (!$isFinite(year) || !$isFinite(month) || !$isFinite(date)) {
		return NaN;
	}
	var y = ToIntegerOrInfinity(year);
	var m = ToIntegerOrInfinity(month);
	var dt = ToIntegerOrInfinity(date);
	var ym = y + floor(m / 12);
	if (!$isFinite(ym)) {
		return NaN;
	}
	var mn = modulo(m, 12);
	var t = $DateUTC(ym, mn, 1);
	if (YearFromTime(t) !== ym || MonthFromTime(t) !== mn || DateFromTime(t) !== 1) {
		return NaN;
	}
	return Day(t) + dt - 1;
};
'use strict';

var $TypeError = require('es-errors/type');

var ToIntegerOrInfinity = require('./ToIntegerOrInfinity');

var isNaN = require('math-intrinsics/isNaN');

// https://262.ecma-international.org/15.0/#sec-makefullyear

module.exports = function MakeFullYear(year) {
	if (typeof year !== 'number') {
		throw new $TypeError('Assertion failed: `year` must be a Number');
	}

	if (isNaN(year)) {
		return NaN; // step 1
	}

	var truncated = ToIntegerOrInfinity(year); // step 2
	if (0 <= truncated && truncated <= 99) {
		return 1900 + truncated; // step 3
	}

	return truncated; // step 4
};
'use strict';

var $TypeError = require('es-errors/type');

var ArrayCreate = require('./ArrayCreate');
var CreateDataPropertyOrThrow = require('./CreateDataPropertyOrThrow');
var GetMatchIndexPair = require('./GetMatchIndexPair');
var IsArray = require('./IsArray');
var OrdinaryObjectCreate = require('./OrdinaryObjectCreate');
var ToString = require('./ToString');

var every = require('../helpers/every');
var isMatchRecord = require('../helpers/records/match-record');

var isStringOrUndefined = function isStringOrUndefined(s) {
	return typeof s === 'undefined' || typeof s === 'string';
};

var isMatchRecordOrUndefined = function isMatchRecordOrUndefined(m) {
	return typeof m === 'undefined' || isMatchRecord(m);
};

var MAX_ARRAY_LENGTH = require('math-intrinsics/constants/maxArrayLength');

// https://262.ecma-international.org/13.0/#sec-getmatchindexpair

module.exports = function MakeMatchIndicesIndexPairArray(S, indices, groupNames, hasGroups) {
	if (typeof S !== 'string') {
		throw new $TypeError('Assertion failed: `S` must be a String');
	}
	if (!IsArray(indices) || !every(indices, isMatchRecordOrUndefined)) {
		throw new $TypeError('Assertion failed: `indices` must be a List of either Match Records or `undefined`');
	}
	if (!IsArray(groupNames) || !every(groupNames, isStringOrUndefined)) {
		throw new $TypeError('Assertion failed: `groupNames` must be a List of either Strings or `undefined`');
	}
	if (typeof hasGroups !== 'boolean') {
		throw new $TypeError('Assertion failed: `hasGroups` must be a Boolean');
	}

	var n = indices.length; // step 1
	if (!(n < MAX_ARRAY_LENGTH)) {
		throw new $TypeError('Assertion failed: `indices` length must be less than the max array size, 2**32 - 1');
	}
	if (groupNames.length !== n - 1) {
		throw new $TypeError('Assertion failed: `groupNames` must have exactly one fewer item than `indices`');
	}

	var A = ArrayCreate(n); // step 5
	var groups = hasGroups ? OrdinaryObjectCreate(null) : void undefined; // step 6-7
	CreateDataPropertyOrThrow(A, 'groups', groups); // step 8

	for (var i = 0; i < n; i += 1) { // step 9
		var matchIndices = indices[i]; // step 9.a
		// eslint-disable-next-line no-negated-condition
		var matchIndexPair = typeof matchIndices !== 'undefined' ? GetMatchIndexPair(S, matchIndices) : void undefined; // step 9.b-9.c
		CreateDataPropertyOrThrow(A, ToString(i), matchIndexPair); // step 9.d
		if (i > 0 && typeof groupNames[i - 1] !== 'undefined') { // step 9.e
			if (!groups) {
				throw new $TypeError('if `hasGroups` is `false`, `groupNames` can only contain `undefined` values');
			}
			CreateDataPropertyOrThrow(groups, groupNames[i - 1], matchIndexPair); // step 9.e.i
		}
	}
	return A; // step 10
};
'use strict';

var $isFinite = require('math-intrinsics/isFinite');
var timeConstants = require('../helpers/timeConstants');
var msPerSecond = timeConstants.msPerSecond;
var msPerMinute = timeConstants.msPerMinute;
var msPerHour = timeConstants.msPerHour;

var ToIntegerOrInfinity = require('./ToIntegerOrInfinity');

// https://262.ecma-international.org/12.0/#sec-maketime

module.exports = function MakeTime(hour, min, sec, ms) {
	if (!$isFinite(hour) || !$isFinite(min) || !$isFinite(sec) || !$isFinite(ms)) {
		return NaN;
	}
	var h = ToIntegerOrInfinity(hour);
	var m = ToIntegerOrInfinity(min);
	var s = ToIntegerOrInfinity(sec);
	var milli = ToIntegerOrInfinity(ms);
	var t = (h * msPerHour) + (m * msPerMinute) + (s * msPerSecond) + milli;
	return t;
};
'use strict';

var $TypeError = require('es-errors/type');

var ArrayBufferByteLength = require('./ArrayBufferByteLength');
var IsDetachedBuffer = require('./IsDetachedBuffer');

var isTypedArray = require('is-typed-array');
var typedArrayBuffer = require('typed-array-buffer');

// https://262.ecma-international.org/15.0/#sec-maketypedarraywithbufferwitnessrecord

module.exports = function MakeTypedArrayWithBufferWitnessRecord(obj, order) {
	if (!isTypedArray(obj)) {
		throw new $TypeError('Assertion failed: `obj` must be a Typed Array');
	}
	if (order !== 'SEQ-CST' && order !== 'UNORDERED') {
		throw new $TypeError('Assertion failed: `order` must be ~SEQ-CST~ or ~UNORDERED~');
	}

	var buffer = typedArrayBuffer(obj); // step 1

	var byteLength = IsDetachedBuffer(buffer) ? 'DETACHED' : ArrayBufferByteLength(buffer, order); // steps 2 - 3

	return { '[[Object]]': obj, '[[CachedBufferByteLength]]': byteLength }; // step 4
};
'use strict';

// https://262.ecma-international.org/6.0/#sec-algorithm-conventions

module.exports = require('math-intrinsics/max');
'use strict';

var floor = require('./floor');
var modulo = require('./modulo');

var timeConstants = require('../helpers/timeConstants');
var msPerMinute = timeConstants.msPerMinute;
var MinutesPerHour = timeConstants.MinutesPerHour;

// https://262.ecma-international.org/5.1/#sec-15.9.1.10

module.exports = function MinFromTime(t) {
	return modulo(floor(t / msPerMinute), MinutesPerHour);
};
'use strict';

// https://262.ecma-international.org/6.0/#sec-algorithm-conventions

module.exports = require('math-intrinsics/min');
'use strict';

var mod = require('../helpers/mod');

// https://262.ecma-international.org/5.1/#sec-5.2

module.exports = function modulo(x, y) {
	return mod(x, y);
};
'use strict';

var $RangeError = require('es-errors/range');

var DayWithinYear = require('./DayWithinYear');
var InLeapYear = require('./InLeapYear');

// https://262.ecma-international.org/5.1/#sec-15.9.1.4

module.exports = function MonthFromTime(t) {
	var day = DayWithinYear(t);
	if (0 <= day && day < 31) {
		return 0;
	}
	var leap = InLeapYear(t);
	if (31 <= day && day < (59 + leap)) {
		return 1;
	}
	if ((59 + leap) <= day && day < (90 + leap)) {
		return 2;
	}
	if ((90 + leap) <= day && day < (120 + leap)) {
		return 3;
	}
	if ((120 + leap) <= day && day < (151 + leap)) {
		return 4;
	}
	if ((151 + leap) <= day && day < (181 + leap)) {
		return 5;
	}
	if ((181 + leap) <= day && day < (212 + leap)) {
		return 6;
	}
	if ((212 + leap) <= day && day < (243 + leap)) {
		return 7;
	}
	if ((243 + leap) <= day && day < (273 + leap)) {
		return 8;
	}
	if ((273 + leap) <= day && day < (304 + leap)) {
		return 9;
	}
	if ((304 + leap) <= day && day < (334 + leap)) {
		return 10;
	}
	if ((334 + leap) <= day && day < (365 + leap)) {
		return 11;
	}

	throw new $RangeError('Assertion failed: `day` is out of range');
};
'use strict';

var modulo = require('./modulo');

var msPerSecond = require('../helpers/timeConstants').msPerSecond;

// https://262.ecma-international.org/5.1/#sec-15.9.1.10

module.exports = function msFromTime(t) {
	return modulo(t, msPerSecond);
};
'use strict';

var $TypeError = require('es-errors/type');

var IsCallable = require('./IsCallable');
var IsConstructor = require('./IsConstructor');

// https://262.ecma-international.org/6.0/#sec-newpromisecapability

module.exports = function NewPromiseCapability(C) {
	if (!IsConstructor(C)) {
		throw new $TypeError('C must be a constructor'); // step 1
	}

	var resolvingFunctions = { '[[Resolve]]': void undefined, '[[Reject]]': void undefined }; // step 3

	var promise = new C(function (resolve, reject) { // steps 4-5
		if (typeof resolvingFunctions['[[Resolve]]'] !== 'undefined' || typeof resolvingFunctions['[[Reject]]'] !== 'undefined') {
			throw new $TypeError('executor has already been called'); // step 4.a, 4.b
		}
		resolvingFunctions['[[Resolve]]'] = resolve; // step 4.c
		resolvingFunctions['[[Reject]]'] = reject; // step 4.d
	}); // step 4-6

	if (!IsCallable(resolvingFunctions['[[Resolve]]']) || !IsCallable(resolvingFunctions['[[Reject]]'])) {
		throw new $TypeError('executor must provide valid resolve and reject functions'); // steps 7-8
	}

	return {
		'[[Promise]]': promise,
		'[[Resolve]]': resolvingFunctions['[[Resolve]]'],
		'[[Reject]]': resolvingFunctions['[[Reject]]']
	}; // step 9
};
'use strict';

var CompletionRecord = require('./CompletionRecord');

// https://262.ecma-international.org/6.0/#sec-normalcompletion

module.exports = function NormalCompletion(value) {
	return new CompletionRecord('normal', value);
};
'use strict';

var $TypeError = require('es-errors/type');

var ToInt32 = require('./ToInt32');
var ToUint32 = require('./ToUint32');

// https://262.ecma-international.org/11.0/#sec-numberbitwiseop

module.exports = function NumberBitwiseOp(op, x, y) {
	if (op !== '&' && op !== '|' && op !== '^') {
		throw new $TypeError('Assertion failed: `op` must be `&`, `|`, or `^`');
	}
	if (typeof x !== 'number' || typeof y !== 'number') {
		throw new $TypeError('Assertion failed: `x` and `y` arguments must be Numbers');
	}
	var lnum = ToInt32(x);
	var rnum = ToUint32(y);
	if (op === '&') {
		return lnum & rnum;
	}
	if (op === '|') {
		return lnum | rnum;
	}
	return lnum ^ rnum;
};
'use strict';

var GetIntrinsic = require('get-intrinsic');

var $BigInt = GetIntrinsic('%BigInt%', true);
var $RangeError = require('es-errors/range');
var $SyntaxError = require('es-errors/syntax');
var $TypeError = require('es-errors/type');

var isInteger = require('math-intrinsics/isInteger');

// https://262.ecma-international.org/12.0/#sec-numbertobigint

module.exports = function NumberToBigInt(number) {
	if (typeof number !== 'number') {
		throw new $TypeError('Assertion failed: `number` must be a String');
	}
	if (!isInteger(number)) {
		throw new $RangeError('The number ' + number + ' cannot be converted to a BigInt because it is not an integer');
	}
	if (!$BigInt) {
		throw new $SyntaxError('BigInts are not supported in this environment');
	}
	return $BigInt(number);
};
'use strict';

var $TypeError = require('es-errors/type');

var hasOwnProperty = require('./HasOwnProperty');
var ToBigInt64 = require('./ToBigInt64');
var ToBigUint64 = require('./ToBigUint64');
var ToInt16 = require('./ToInt16');
var ToInt32 = require('./ToInt32');
var ToInt8 = require('./ToInt8');
var ToUint16 = require('./ToUint16');
var ToUint32 = require('./ToUint32');
var ToUint8 = require('./ToUint8');
var ToUint8Clamp = require('./ToUint8Clamp');

var valueToFloat32Bytes = require('../helpers/valueToFloat32Bytes');
var valueToFloat64Bytes = require('../helpers/valueToFloat64Bytes');
var integerToNBytes = require('../helpers/integerToNBytes');

var tableTAO = require('./tables/typed-array-objects');

// https://262.ecma-international.org/15.0/#table-the-typedarray-constructors
var TypeToAO = {
	__proto__: null,
	$INT8: ToInt8,
	$UINT8: ToUint8,
	$UINT8C: ToUint8Clamp,
	$INT16: ToInt16,
	$UINT16: ToUint16,
	$INT32: ToInt32,
	$UINT32: ToUint32,
	$BIGINT64: ToBigInt64,
	$BIGUINT64: ToBigUint64
};

// https://262.ecma-international.org/15.0/#sec-numerictorawbytes

module.exports = function NumericToRawBytes(type, value, isLittleEndian) {
	if (typeof type !== 'string' || !hasOwnProperty(tableTAO.size, '$' + type)) {
		throw new $TypeError('Assertion failed: `type` must be a TypedArray element type');
	}
	if (typeof value !== 'number' && typeof value !== 'bigint') {
		throw new $TypeError('Assertion failed: `value` must be a Number or a BigInt');
	}
	if (typeof isLittleEndian !== 'boolean') {
		throw new $TypeError('Assertion failed: `isLittleEndian` must be a Boolean');
	}

	if (type === 'FLOAT32') { // step 1
		return valueToFloat32Bytes(value, isLittleEndian);
	} else if (type === 'FLOAT64') { // step 2
		return valueToFloat64Bytes(value, isLittleEndian);
	} // step 3

	var n = tableTAO.size['$' + type]; // step 3.a

	var convOp = TypeToAO['$' + type]; // step 3.b

	var intValue = convOp(value); // step 3.c

	return integerToNBytes(intValue, n, isLittleEndian); // step 3.d, 3.e, 4
};
'use strict';

var DefinePropertyOrThrow = require('./DefinePropertyOrThrow');
var Get = require('./Get');
var OrdinaryGetOwnProperty = require('./OrdinaryGetOwnProperty');
var ToObject = require('./ToObject');
var ToPropertyDescriptor = require('./ToPropertyDescriptor');

var forEach = require('../helpers/forEach');
var OwnPropertyKeys = require('own-keys');

// https://262.ecma-international.org/15.0/#sec-objectdefineproperties

module.exports = function ObjectDefineProperties(O, Properties) {
	var props = ToObject(Properties); // step 1
	var keys = OwnPropertyKeys(props); // step 2
	var descriptors = []; // step 3

	forEach(keys, function (nextKey) { // step 4
		var propDesc = OrdinaryGetOwnProperty(props, nextKey); // ToPropertyDescriptor(getOwnPropertyDescriptor(props, nextKey)); // step 4.a
		if (typeof propDesc !== 'undefined' && propDesc['[[Enumerable]]']) { // step 4.b
			var descObj = Get(props, nextKey); // step 4.b.i
			var desc = ToPropertyDescriptor(descObj); // step 4.b.ii
			descriptors[descriptors.length] = { '[[Key]]': nextKey, '[[Descriptor]]': desc }; // step 4.b.iii
		}
	});

	forEach(descriptors, function (pair) { // step 5
		DefinePropertyOrThrow(O, pair['[[Key]]'], pair['[[Descriptor]]']); // step 5.c
	});

	return O; // step 6
};
'use strict';

var GetIntrinsic = require('get-intrinsic');
var $TypeError = require('es-errors/type');

var GetPrototypeFromConstructor = require('./GetPrototypeFromConstructor');
var IsArray = require('./IsArray');
var OrdinaryObjectCreate = require('./OrdinaryObjectCreate');

// https://262.ecma-international.org/6.0/#sec-ordinarycreatefromconstructor

module.exports = function OrdinaryCreateFromConstructor(constructor, intrinsicDefaultProto) {
	GetIntrinsic(intrinsicDefaultProto); // throws if not a valid intrinsic
	var proto = GetPrototypeFromConstructor(constructor, intrinsicDefaultProto);
	var slots = arguments.length < 3 ? [] : arguments[2];
	if (!IsArray(slots)) {
		throw new $TypeError('Assertion failed: if provided, `internalSlotsList` must be a List');
	}
	return OrdinaryObjectCreate(proto, slots);
};
'use strict';

var $gOPD = require('gopd');
var $SyntaxError = require('es-errors/syntax');
var $TypeError = require('es-errors/type');
var isObject = require('es-object-atoms/isObject');

var isPropertyDescriptor = require('../helpers/records/property-descriptor');

var IsAccessorDescriptor = require('./IsAccessorDescriptor');
var IsExtensible = require('./IsExtensible');
var isPropertyKey = require('../helpers/isPropertyKey');
var ToPropertyDescriptor = require('./ToPropertyDescriptor');
var SameValue = require('./SameValue');
var ValidateAndApplyPropertyDescriptor = require('./ValidateAndApplyPropertyDescriptor');

// https://262.ecma-international.org/6.0/#sec-ordinarydefineownproperty

module.exports = function OrdinaryDefineOwnProperty(O, P, Desc) {
	if (!isObject(O)) {
		throw new $TypeError('Assertion failed: O must be an Object');
	}
	if (!isPropertyKey(P)) {
		throw new $TypeError('Assertion failed: P must be a Property Key');
	}
	if (!isPropertyDescriptor(Desc)) {
		throw new $TypeError('Assertion failed: Desc must be a Property Descriptor');
	}
	if (!$gOPD) {
		// ES3/IE 8 fallback
		if (IsAccessorDescriptor(Desc)) {
			throw new $SyntaxError('This environment does not support accessor property descriptors.');
		}
		var creatingNormalDataProperty = !(P in O)
			&& Desc['[[Writable]]']
			&& Desc['[[Enumerable]]']
			&& Desc['[[Configurable]]']
			&& '[[Value]]' in Desc;
		var settingExistingDataProperty = (P in O)
			&& (!('[[Configurable]]' in Desc) || Desc['[[Configurable]]'])
			&& (!('[[Enumerable]]' in Desc) || Desc['[[Enumerable]]'])
			&& (!('[[Writable]]' in Desc) || Desc['[[Writable]]'])
			&& '[[Value]]' in Desc;
		if (creatingNormalDataProperty || settingExistingDataProperty) {
			O[P] = Desc['[[Value]]']; // eslint-disable-line no-param-reassign
			return SameValue(O[P], Desc['[[Value]]']);
		}
		throw new $SyntaxError('This environment does not support defining non-writable, non-enumerable, or non-configurable properties');
	}
	var desc = $gOPD(O, P);
	var current = desc && ToPropertyDescriptor(desc);
	var extensible = IsExtensible(O);
	return ValidateAndApplyPropertyDescriptor(O, P, extensible, Desc, current);
};
'use strict';

var $gOPD = require('gopd');
var $TypeError = require('es-errors/type');
var isObject = require('es-object-atoms/isObject');
var callBound = require('call-bound');

var $isEnumerable = callBound('Object.prototype.propertyIsEnumerable');

var hasOwn = require('hasown');

var IsArray = require('./IsArray');
var isPropertyKey = require('../helpers/isPropertyKey');
var IsRegExp = require('./IsRegExp');
var ToPropertyDescriptor = require('./ToPropertyDescriptor');

// https://262.ecma-international.org/6.0/#sec-ordinarygetownproperty

module.exports = function OrdinaryGetOwnProperty(O, P) {
	if (!isObject(O)) {
		throw new $TypeError('Assertion failed: O must be an Object');
	}
	if (!isPropertyKey(P)) {
		throw new $TypeError('Assertion failed: P must be a Property Key');
	}
	if (!hasOwn(O, P)) {
		return void 0;
	}
	if (!$gOPD) {
		// ES3 / IE 8 fallback
		var arrayLength = IsArray(O) && P === 'length';
		var regexLastIndex = IsRegExp(O) && P === 'lastIndex';
		return {
			'[[Configurable]]': !(arrayLength || regexLastIndex),
			'[[Enumerable]]': $isEnumerable(O, P),
			'[[Value]]': O[P],
			'[[Writable]]': true
		};
	}
	return ToPropertyDescriptor($gOPD(O, P));
};
'use strict';

var $TypeError = require('es-errors/type');
var isObject = require('es-object-atoms/isObject');

var $getProto = require('get-proto');

// https://262.ecma-international.org/7.0/#sec-ordinarygetprototypeof

module.exports = function OrdinaryGetPrototypeOf(O) {
	if (!isObject(O)) {
		throw new $TypeError('Assertion failed: O must be an Object');
	}
	if (!$getProto) {
		throw new $TypeError('This environment does not support fetching prototypes.');
	}
	return $getProto(O);
};
'use strict';

var $TypeError = require('es-errors/type');
var isObject = require('es-object-atoms/isObject');

var Get = require('./Get');
var IsCallable = require('./IsCallable');

// https://262.ecma-international.org/6.0/#sec-ordinaryhasinstance

module.exports = function OrdinaryHasInstance(C, O) {
	if (!IsCallable(C)) {
		return false;
	}
	if (!isObject(O)) {
		return false;
	}
	var P = Get(C, 'prototype');
	if (!isObject(P)) {
		throw new $TypeError('OrdinaryHasInstance called on an object with an invalid prototype property.');
	}
	return O instanceof C;
};
'use strict';

var $TypeError = require('es-errors/type');
var isObject = require('es-object-atoms/isObject');

var isPropertyKey = require('../helpers/isPropertyKey');

// https://262.ecma-international.org/6.0/#sec-ordinaryhasproperty

module.exports = function OrdinaryHasProperty(O, P) {
	if (!isObject(O)) {
		throw new $TypeError('Assertion failed: Type(O) is not Object');
	}
	if (!isPropertyKey(P)) {
		throw new $TypeError('Assertion failed: P must be a Property Key');
	}
	return P in O;
};
'use strict';

var GetIntrinsic = require('get-intrinsic');

var $ObjectCreate = GetIntrinsic('%Object.create%', true);
var $TypeError = require('es-errors/type');
var $SyntaxError = require('es-errors/syntax');
var isObject = require('es-object-atoms/isObject');

var IsArray = require('./IsArray');

var forEach = require('../helpers/forEach');

var SLOT = require('internal-slot');

var hasProto = require('has-proto')();

// https://262.ecma-international.org/11.0/#sec-objectcreate

module.exports = function OrdinaryObjectCreate(proto) {
	if (proto !== null && !isObject(proto)) {
		throw new $TypeError('Assertion failed: `proto` must be null or an object');
	}
	var additionalInternalSlotsList = arguments.length < 2 ? [] : arguments[1];
	if (!IsArray(additionalInternalSlotsList)) {
		throw new $TypeError('Assertion failed: `additionalInternalSlotsList` must be an Array');
	}

	// var internalSlotsList = ['[[Prototype]]', '[[Extensible]]']; // step 1
	// internalSlotsList.push(...additionalInternalSlotsList); // step 2
	// var O = MakeBasicObject(internalSlotsList); // step 3
	// setProto(O, proto); // step 4
	// return O; // step 5

	var O;
	if (hasProto) {
		O = { __proto__: proto };
	} else if ($ObjectCreate) {
		O = $ObjectCreate(proto);
	} else {
		if (proto === null) {
			throw new $SyntaxError('native Object.create support is required to create null objects');
		}
		var T = function T() {};
		T.prototype = proto;
		O = new T();
	}

	if (additionalInternalSlotsList.length > 0) {
		forEach(additionalInternalSlotsList, function (slot) {
			SLOT.set(O, slot, void undefined);
		});
	}

	return O;
};
'use strict';

var $TypeError = require('es-errors/type');
var $setProto = require('set-proto');
var isObject = require('es-object-atoms/isObject');

var OrdinaryGetPrototypeOf = require('./OrdinaryGetPrototypeOf');

// https://262.ecma-international.org/7.0/#sec-ordinarysetprototypeof

module.exports = function OrdinarySetPrototypeOf(O, V) {
	if (V !== null && !isObject(V)) {
		throw new $TypeError('Assertion failed: V must be Object or Null');
	}
	/*
	var extensible = IsExtensible(O);
	var current = OrdinaryGetPrototypeOf(O);
	if (SameValue(V, current)) {
		return true;
	}
	if (!extensible) {
		return false;
	}
	*/
	try {
		$setProto(O, V);
	} catch (e) {
		return false;
	}
	return OrdinaryGetPrototypeOf(O) === V;
	/*
	var p = V;
	var done = false;
	while (!done) {
		if (p === null) {
			done = true;
		} else if (SameValue(p, O)) {
			return false;
		} else {
			if (wat) {
				done = true;
			} else {
				p = p.[[Prototype]];
			}
		}
	}
	O.[[Prototype]] = V;
	return true;
	*/
};
'use strict';

var $TypeError = require('es-errors/type');
var isObject = require('es-object-atoms/isObject');

var Call = require('./Call');
var Get = require('./Get');
var IsCallable = require('./IsCallable');

var inspect = require('object-inspect');

// https://262.ecma-international.org/8.0/#sec-ordinarytoprimitive

module.exports = function OrdinaryToPrimitive(O, hint) {
	if (!isObject(O)) {
		throw new $TypeError('Assertion failed: Type(O) is not Object');
	}
	if (/* typeof hint !== 'string' || */ hint !== 'string' && hint !== 'number') {
		throw new $TypeError('Assertion failed: `hint` must be "string" or "number"');
	}

	var methodNames = hint === 'string' ? ['toString', 'valueOf'] : ['valueOf', 'toString'];

	for (var i = 0; i < methodNames.length; i += 1) {
		var name = methodNames[i];
		var method = Get(O, name);
		if (IsCallable(method)) {
			var result = Call(method, O);
			if (!isObject(result)) {
				return result;
			}
		}
	}

	throw new $TypeError('No primitive value for ' + inspect(O));
};
'use strict';

var $SyntaxError = require('es-errors/syntax');
var $TypeError = require('es-errors/type');

var substring = require('./substring');

var isInteger = require('math-intrinsics/isInteger');
var isNaN = require('math-intrinsics/isNaN');

// https://262.ecma-international.org/14.0/#sec-parsehexoctet

module.exports = function ParseHexOctet(string, position) {
	if (typeof string !== 'string') {
		throw new $TypeError('Assertion failed: `string` must be a String');
	}
	if (!isInteger(position) || position < 0) {
		throw new $TypeError('Assertion failed: `position` must be a nonnegative integer');
	}

	var len = string.length; // step 1
	if ((position + 2) > len) { // step 2
		var error = new $SyntaxError('requested a position on a string that does not contain 2 characters at that position'); // step 2.a
		return [error]; // step 2.b
	}
	var hexDigits = substring(string, position, position + 2); // step 3

	var n = +('0x' + hexDigits);
	if (isNaN(n)) {
		return [new $SyntaxError('Invalid hexadecimal characters')];
	}
	return n;

	/*
	4. Let _parseResult_ be ParseText(StringToCodePoints(_hexDigits_), |HexDigits[~Sep]|).
    5. If _parseResult_ is not a Parse Node, return _parseResult_.
    6. Let _n_ be the unsigned 8-bit value corresponding with the MV of _parseResult_.
    7. Return _n_.
    */
};
'use strict';

var GetIntrinsic = require('get-intrinsic');
var callBind = require('call-bind');
var $SyntaxError = require('es-errors/syntax');

var $resolve = GetIntrinsic('%Promise.resolve%', true);
var $PromiseResolve = $resolve && callBind($resolve);

// https://262.ecma-international.org/9.0/#sec-promise-resolve

module.exports = function PromiseResolve(C, x) {
	if (!$PromiseResolve) {
		throw new $SyntaxError('This environment does not support Promises.');
	}
	return $PromiseResolve(C, x);
};

'use strict';

var $TypeError = require('es-errors/type');

var callBound = require('call-bound');
var forEach = require('../helpers/forEach');
var isLeadingSurrogate = require('../helpers/isLeadingSurrogate');
var isTrailingSurrogate = require('../helpers/isTrailingSurrogate');

var $charCodeAt = callBound('String.prototype.charCodeAt');
var $strSplit = callBound('String.prototype.split');

var StringToCodePoints = require('./StringToCodePoints');
var UnicodeEscape = require('./UnicodeEscape');
var UTF16EncodeCodePoint = require('./UTF16EncodeCodePoint');

var hasOwn = require('hasown');

// https://262.ecma-international.org/12.0/#sec-quotejsonstring

var escapes = {
	'\u0008': '\\b',
	'\u0009': '\\t',
	'\u000A': '\\n',
	'\u000C': '\\f',
	'\u000D': '\\r',
	'\u0022': '\\"',
	'\u005c': '\\\\'
};

module.exports = function QuoteJSONString(value) {
	if (typeof value !== 'string') {
		throw new $TypeError('Assertion failed: `value` must be a String');
	}
	var product = '"';
	if (value) {
		forEach($strSplit(StringToCodePoints(value), ''), function (C) {
			if (hasOwn(escapes, C)) {
				product += escapes[C];
			} else {
				var cCharCode = $charCodeAt(C, 0);
				if (cCharCode < 0x20 || isLeadingSurrogate(cCharCode) || isTrailingSurrogate(cCharCode)) {
					product += UnicodeEscape(C);
				} else {
					product += UTF16EncodeCodePoint(cCharCode);
				}
			}
		});
	}
	product += '"';
	return product;
};
'use strict';

var GetIntrinsic = require('get-intrinsic');
var callBound = require('call-bound');

var $RangeError = require('es-errors/range');
var $SyntaxError = require('es-errors/syntax');
var $TypeError = require('es-errors/type');
var $BigInt = GetIntrinsic('%BigInt%', true);

var hasOwnProperty = require('./HasOwnProperty');
var IsArray = require('./IsArray');
var IsBigIntElementType = require('./IsBigIntElementType');
var IsUnsignedElementType = require('./IsUnsignedElementType');

var bytesAsFloat32 = require('../helpers/bytesAsFloat32');
var bytesAsFloat64 = require('../helpers/bytesAsFloat64');
var bytesAsInteger = require('../helpers/bytesAsInteger');
var every = require('../helpers/every');
var isByteValue = require('../helpers/isByteValue');

var $reverse = callBound('Array.prototype.reverse');
var $slice = callBound('Array.prototype.slice');

var tableTAO = require('./tables/typed-array-objects');

// https://262.ecma-international.org/15.0/#sec-rawbytestonumeric

module.exports = function RawBytesToNumeric(type, rawBytes, isLittleEndian) {
	if (!hasOwnProperty(tableTAO.size, '$' + type)) {
		throw new $TypeError('Assertion failed: `type` must be a TypedArray element type');
	}
	if (!IsArray(rawBytes) || !every(rawBytes, isByteValue)) {
		throw new $TypeError('Assertion failed: `rawBytes` must be an Array of bytes');
	}
	if (typeof isLittleEndian !== 'boolean') {
		throw new $TypeError('Assertion failed: `isLittleEndian` must be a Boolean');
	}

	var elementSize = tableTAO.size['$' + type]; // step 1

	if (rawBytes.length !== elementSize) {
		// this assertion is not in the spec, but it'd be an editorial error if it were ever violated
		throw new $RangeError('Assertion failed: `rawBytes` must have a length of ' + elementSize + ' for type ' + type);
	}

	var isBigInt = IsBigIntElementType(type);
	if (isBigInt && !$BigInt) {
		throw new $SyntaxError('this environment does not support BigInts');
	}

	// eslint-disable-next-line no-param-reassign
	rawBytes = $slice(rawBytes, 0, elementSize);
	if (!isLittleEndian) {
		$reverse(rawBytes); // step 2
	}

	if (type === 'FLOAT32') { // step 3
		return bytesAsFloat32(rawBytes);
	}

	if (type === 'FLOAT64') { // step 4
		return bytesAsFloat64(rawBytes);
	}

	return bytesAsInteger(rawBytes, elementSize, IsUnsignedElementType(type), isBigInt);
};
'use strict';

var GetIntrinsic = require('get-intrinsic');

var $RegExp = GetIntrinsic('%RegExp%');

// var RegExpAlloc = require('./RegExpAlloc');
// var RegExpInitialize = require('./RegExpInitialize');
var ToString = require('./ToString');

// https://262.ecma-international.org/6.0/#sec-regexpcreate

module.exports = function RegExpCreate(P, F) {
	// var obj = RegExpAlloc($RegExp);
	// return RegExpInitialize(obj, P, F);

	// covers spec mechanics; bypass regex brand checking
	var pattern = typeof P === 'undefined' ? '' : ToString(P);
	var flags = typeof F === 'undefined' ? '' : ToString(F);
	return new $RegExp(pattern, flags);
};
'use strict';

var $TypeError = require('es-errors/type');
var isObject = require('es-object-atoms/isObject');
var regexExec = require('call-bound')('RegExp.prototype.exec');

var Call = require('./Call');
var Get = require('./Get');
var IsCallable = require('./IsCallable');

// https://262.ecma-international.org/6.0/#sec-regexpexec

module.exports = function RegExpExec(R, S) {
	if (!isObject(R)) {
		throw new $TypeError('Assertion failed: `R` must be an Object');
	}
	if (typeof S !== 'string') {
		throw new $TypeError('Assertion failed: `S` must be a String');
	}
	var exec = Get(R, 'exec');
	if (IsCallable(exec)) {
		var result = Call(exec, R, [S]);
		if (result === null || isObject(result)) {
			return result;
		}
		throw new $TypeError('"exec" method must return `null` or an Object');
	}
	return regexExec(R, S);
};
'use strict';

var GetIntrinsic = require('get-intrinsic');
var callBound = require('call-bound');

var $TypeError = require('es-errors/type');
var isObject = require('es-object-atoms/isObject');
var $RegExpPrototype = GetIntrinsic('%RegExp.prototype%');

var SameValue = require('./SameValue');

var $indexOf = callBound('String.prototype.indexOf');

var hasRegExpMatcher = require('is-regex');
var getFlags = require('regexp.prototype.flags');

// https://262.ecma-international.org/13.0/#sec-regexphasflag

module.exports = function RegExpHasFlag(R, codeUnit) {
	if (typeof codeUnit !== 'string' || codeUnit.length !== 1) {
		throw new $TypeError('Assertion failed: `string` must be a code unit - a String of length 1');
	}

	if (!isObject(R)) {
		throw new $TypeError('Assertion failed: Type(R) is not Object');
	}

	if (!hasRegExpMatcher(R)) { // step 2
		if (SameValue(R, $RegExpPrototype)) {
			return void undefined; // step 2.a
		}
		throw new $TypeError('`R` must be a RegExp object'); // step 2.b
	}

	var flags = getFlags(R); // step 3

	return $indexOf(flags, codeUnit) > -1; // steps 4-5
};
'use strict';

module.exports = require('es-object-atoms/RequireObjectCoercible');
'use strict';

var $isNaN = require('math-intrinsics/isNaN');

// http://262.ecma-international.org/5.1/#sec-9.12

module.exports = function SameValue(x, y) {
	if (x === y) { // 0 === -0, but they are not identical.
		if (x === 0) { return 1 / x === 1 / y; }
		return true;
	}
	return $isNaN(x) && $isNaN(y);
};
'use strict';

var $TypeError = require('es-errors/type');

var SameValue = require('./SameValue');
var Type = require('./Type');

// https://262.ecma-international.org/14.0/#sec-samevaluenonnumeric

module.exports = function SameValueNonNumber(x, y) {
	if (typeof x === 'number') {
		throw new $TypeError('Assertion failed: SameValueNonNumber does not accept Number values');
	}
	if (Type(x) !== Type(y)) {
		throw new $TypeError('SameValueNonNumber requires two non-Number values of the same type.');
	}
	return SameValue(x, y);
};
'use strict';

var $isNaN = require('math-intrinsics/isNaN');

// https://262.ecma-international.org/6.0/#sec-samevaluezero

module.exports = function SameValueZero(x, y) {
	return (x === y) || ($isNaN(x) && $isNaN(y));
};
'use strict';

var floor = require('./floor');
var modulo = require('./modulo');

var timeConstants = require('../helpers/timeConstants');
var msPerSecond = timeConstants.msPerSecond;
var SecondsPerMinute = timeConstants.SecondsPerMinute;

// https://262.ecma-international.org/5.1/#sec-15.9.1.10

module.exports = function SecFromTime(t) {
	return modulo(floor(t / msPerSecond), SecondsPerMinute);
};
'use strict';

var $TypeError = require('es-errors/type');
var isInteger = require('math-intrinsics/isInteger');

var DefinePropertyOrThrow = require('./DefinePropertyOrThrow');
var HasOwnProperty = require('./HasOwnProperty');
var IsExtensible = require('./IsExtensible');

// https://262.ecma-international.org/12.0/#sec-setfunctionlength

module.exports = function SetFunctionLength(F, length) {
	if (typeof F !== 'function' || !IsExtensible(F) || HasOwnProperty(F, 'length')) {
		throw new $TypeError('Assertion failed: `F` must be an extensible function and lack an own `length` property');
	}
	if (typeof length !== 'number') {
		throw new $TypeError('Assertion failed: `length` must be a Number');
	}
	if (length !== Infinity && (!isInteger(length) || length < 0)) {
		throw new $TypeError('Assertion failed: `length` must be ∞, or an integer >= 0');
	}
	return DefinePropertyOrThrow(F, 'length', {
		'[[Configurable]]': true,
		'[[Enumerable]]': false,
		'[[Value]]': length,
		'[[Writable]]': false
	});
};
'use strict';

var hasOwn = require('hasown');

var $TypeError = require('es-errors/type');

var getSymbolDescription = require('get-symbol-description');

var DefinePropertyOrThrow = require('./DefinePropertyOrThrow');
var IsExtensible = require('./IsExtensible');

// https://262.ecma-international.org/6.0/#sec-setfunctionname

module.exports = function SetFunctionName(F, name) {
	if (typeof F !== 'function') {
		throw new $TypeError('Assertion failed: `F` must be a function');
	}
	if (!IsExtensible(F) || hasOwn(F, 'name')) {
		throw new $TypeError('Assertion failed: `F` must be extensible, and must not have a `name` own property');
	}
	if (typeof name !== 'symbol' && typeof name !== 'string') {
		throw new $TypeError('Assertion failed: `name` must be a Symbol or a String');
	}
	if (typeof name === 'symbol') {
		var description = getSymbolDescription(name);
		// eslint-disable-next-line no-param-reassign
		name = typeof description === 'undefined' ? '' : '[' + description + ']';
	}
	if (arguments.length > 2) {
		var prefix = arguments[2];
		// eslint-disable-next-line no-param-reassign
		name = prefix + ' ' + name;
	}
	return DefinePropertyOrThrow(F, 'name', {
		'[[Value]]': name,
		'[[Writable]]': false,
		'[[Enumerable]]': false,
		'[[Configurable]]': true
	});
};
'use strict';

var GetIntrinsic = require('get-intrinsic');

var $SyntaxError = require('es-errors/syntax');
var $TypeError = require('es-errors/type');
var isObject = require('es-object-atoms/isObject');
var $gOPD = require('gopd');
var $preventExtensions = GetIntrinsic('%Object.preventExtensions%', true);
var $gOPN = GetIntrinsic('%Object.getOwnPropertyNames%', true);

var forEach = require('../helpers/forEach');

var DefinePropertyOrThrow = require('./DefinePropertyOrThrow');
var IsAccessorDescriptor = require('./IsAccessorDescriptor');
var ToPropertyDescriptor = require('./ToPropertyDescriptor');

// https://262.ecma-international.org/6.0/#sec-setintegritylevel

module.exports = function SetIntegrityLevel(O, level) {
	if (!isObject(O)) {
		throw new $TypeError('Assertion failed: Type(O) is not Object');
	}
	if (level !== 'sealed' && level !== 'frozen') {
		throw new $TypeError('Assertion failed: `level` must be `"sealed"` or `"frozen"`');
	}
	if (!$preventExtensions) {
		throw new $SyntaxError('SetIntegrityLevel requires native `Object.preventExtensions` support');
	}
	var status = $preventExtensions(O);
	if (!status) {
		return false;
	}
	if (!$gOPN) {
		throw new $SyntaxError('SetIntegrityLevel requires native `Object.getOwnPropertyNames` support');
	}
	var theKeys = $gOPN(O);
	if (level === 'sealed') {
		forEach(theKeys, function (k) {
			DefinePropertyOrThrow(O, k, { configurable: false });
		});
	} else if (level === 'frozen') {
		forEach(theKeys, function (k) {
			var currentDesc = $gOPD(O, k);
			if (typeof currentDesc !== 'undefined') {
				var desc;
				if (IsAccessorDescriptor(ToPropertyDescriptor(currentDesc))) {
					desc = { configurable: false };
				} else {
					desc = { configurable: false, writable: false };
				}
				DefinePropertyOrThrow(O, k, desc);
			}
		});
	}
	return true;
};
'use strict';

var $TypeError = require('es-errors/type');
var isObject = require('es-object-atoms/isObject');

var isPropertyKey = require('../helpers/isPropertyKey');
var SameValue = require('./SameValue');

// IE 9 does not throw in strict mode when writability/configurability/extensibility is violated
var noThrowOnStrictViolation = (function () {
	try {
		delete [].length;
		return true;
	} catch (e) {
		return false;
	}
}());

// https://262.ecma-international.org/6.0/#sec-set-o-p-v-throw

module.exports = function Set(O, P, V, Throw) {
	if (!isObject(O)) {
		throw new $TypeError('Assertion failed: `O` must be an Object');
	}
	if (!isPropertyKey(P)) {
		throw new $TypeError('Assertion failed: `P` must be a Property Key');
	}
	if (typeof Throw !== 'boolean') {
		throw new $TypeError('Assertion failed: `Throw` must be a Boolean');
	}
	if (Throw) {
		O[P] = V; // eslint-disable-line no-param-reassign
		if (noThrowOnStrictViolation && !SameValue(O[P], V)) {
			throw new $TypeError('Attempted to assign to readonly property.');
		}
		return true;
	}
	try {
		O[P] = V; // eslint-disable-line no-param-reassign
		return noThrowOnStrictViolation ? SameValue(O[P], V) : true;
	} catch (e) {
		return false;
	}

};
'use strict';

var $RangeError = require('es-errors/range');
var $TypeError = require('es-errors/type');
var isInteger = require('math-intrinsics/isInteger');

var isTypedArray = require('is-typed-array');
var whichTypedArray = require('which-typed-array');

var Get = require('./Get');
var IsTypedArrayOutOfBounds = require('./IsTypedArrayOutOfBounds');
var LengthOfArrayLike = require('./LengthOfArrayLike');
var MakeTypedArrayWithBufferWitnessRecord = require('./MakeTypedArrayWithBufferWitnessRecord');
var ToObject = require('./ToObject');
var ToString = require('./ToString');
var TypedArrayLength = require('./TypedArrayLength');
var TypedArraySetElement = require('./TypedArraySetElement');

// https://262.ecma-international.org/15.0/#sec-settypedarrayfromarraylike

module.exports = function SetTypedArrayFromArrayLike(target, targetOffset, source) {
	var whichTarget = whichTypedArray(target);
	if (!whichTarget) {
		throw new $TypeError('Assertion failed: `target` must be a Typed Array');
	}

	if (targetOffset !== Infinity && (!isInteger(targetOffset) || targetOffset < 0)) {
		throw new $TypeError('Assertion failed: `targetOffset` must be a non-negative integer or +Infinity');
	}

	if (isTypedArray(source)) {
		throw new $TypeError('Assertion failed: `source` must not be a Typed Array');
	}

	var targetRecord = MakeTypedArrayWithBufferWitnessRecord(target, 'SEQ-CST'); // step 1

	if (IsTypedArrayOutOfBounds(targetRecord)) {
		throw new $TypeError('target is out of bounds'); // step 2
	}

	var targetLength = TypedArrayLength(targetRecord); // step 3

	var src = ToObject(source); // step 4

	var srcLength = LengthOfArrayLike(src); // step 5

	if (targetOffset === Infinity) {
		throw new $RangeError('targetOffset must be a finite integer'); // step 6
	}

	if (srcLength + targetOffset > targetLength) {
		throw new $RangeError('targetOffset + srcLength must be <= target.length'); // step 7
	}

	var k = 0; // step 8

	while (k < srcLength) { // step 9
		var Pk = ToString(k); // step 9.a
		var value = Get(src, Pk); // step 9.b
		var targetIndex = targetOffset + k; // step 9.c
		TypedArraySetElement(target, targetIndex, value); // step 9.d
		k += 1; // step 9.e
	}
};
'use strict';

var $RangeError = require('es-errors/range');
var $SyntaxError = require('es-errors/syntax');
var $TypeError = require('es-errors/type');

var CloneArrayBuffer = require('./CloneArrayBuffer');
var GetValueFromBuffer = require('./GetValueFromBuffer');
var IsSharedArrayBuffer = require('./IsSharedArrayBuffer');
var IsTypedArrayOutOfBounds = require('./IsTypedArrayOutOfBounds');
var MakeTypedArrayWithBufferWitnessRecord = require('./MakeTypedArrayWithBufferWitnessRecord');
var SameValue = require('./SameValue');
var SetValueInBuffer = require('./SetValueInBuffer');
var TypedArrayByteLength = require('./TypedArrayByteLength');
var TypedArrayElementSize = require('./TypedArrayElementSize');
var TypedArrayElementType = require('./TypedArrayElementType');
var TypedArrayLength = require('./TypedArrayLength');

var typedArrayBuffer = require('typed-array-buffer');
var typedArrayByteOffset = require('typed-array-byte-offset');
var whichTypedArray = require('which-typed-array');
var GetIntrinsic = require('call-bound');
var isInteger = require('math-intrinsics/isInteger');

var $ArrayBuffer = GetIntrinsic('%ArrayBuffer%', true);

// https://262.ecma-international.org/15.0/#sec-settypedarrayfromtypedarray

module.exports = function SetTypedArrayFromTypedArray(target, targetOffset, source) {
	var whichTarget = whichTypedArray(target);
	if (!whichTarget) {
		throw new $TypeError('Assertion failed: `target` must be a Typed Array');
	}

	if (targetOffset !== Infinity && (!isInteger(targetOffset) || targetOffset < 0)) {
		throw new $TypeError('Assertion failed: `targetOffset` must be a non-negative integer or +Infinity');
	}

	var whichSource = whichTypedArray(source);
	if (!whichSource) {
		throw new $TypeError('Assertion failed: `source` must be a Typed Array');
	}

	var targetBuffer = typedArrayBuffer(target); // step 1

	var targetRecord = MakeTypedArrayWithBufferWitnessRecord(target, 'SEQ-CST'); // step 2

	if (IsTypedArrayOutOfBounds(targetRecord)) {
		throw new $TypeError('target is out of bounds'); // step 3
	}

	var targetLength = TypedArrayLength(targetRecord); // step 4

	var srcBuffer = typedArrayBuffer(source); // step 5

	var srcRecord = MakeTypedArrayWithBufferWitnessRecord(source, 'SEQ-CST'); // step 6

	if (IsTypedArrayOutOfBounds(srcRecord)) {
		throw new $TypeError('target is out of bounds'); // step 7
	}

	var srcLength = TypedArrayLength(srcRecord); // step 8

	var targetType = TypedArrayElementType(target); // step 9

	var targetElementSize = TypedArrayElementSize(target); // step 10

	var targetByteOffset = typedArrayByteOffset(target); // step 11

	var srcType = TypedArrayElementType(source); // step 12

	var srcElementSize = TypedArrayElementSize(source); // step 13

	var srcByteOffset = typedArrayByteOffset(source); // step 14

	if (targetOffset === Infinity) {
		throw new $RangeError('targetOffset must be a non-negative integer or +Infinity'); // step 15
	}

	if (srcLength + targetOffset > targetLength) {
		throw new $RangeError('targetOffset + source.length must not be greater than target.length'); // step 16
	}

	var targetContentType = whichTarget === 'BigInt64Array' || whichTarget === 'BigUint64Array' ? 'BIGINT' : 'NUMBER';
	var sourceContentType = whichSource === 'BigInt64Array' || whichSource === 'BigUint64Array' ? 'BIGINT' : 'NUMBER';
	if (targetContentType !== sourceContentType) {
		throw new $TypeError('source and target must have the same content type'); // step 17
	}

	var sameSharedArrayBuffer = false;
	if (IsSharedArrayBuffer(srcBuffer) && IsSharedArrayBuffer(targetBuffer)) { // step 18
		// a. If srcBuffer.[[ArrayBufferData]] and targetBuffer.[[ArrayBufferData]] are the same Shared Data Block values, let same be true; else let same be false.
		throw new $SyntaxError('SharedArrayBuffer is not supported by this implementation');
	}

	var srcByteIndex;
	if (SameValue(srcBuffer, targetBuffer) || sameSharedArrayBuffer) { // step 19
		var srcByteLength = TypedArrayByteLength(srcRecord); // step 19.a
		srcBuffer = CloneArrayBuffer(srcBuffer, srcByteOffset, srcByteLength, $ArrayBuffer); // step 19.b
		srcByteIndex = 0; // step 19.c
	} else { // step 20
		srcByteIndex = srcByteOffset; // step 20.a
	}

	var targetByteIndex = (targetOffset * targetElementSize) + targetByteOffset; // step 21

	var limit = targetByteIndex + (targetElementSize * srcLength); // step 22

	var value;
	if (srcType === targetType) { // step 23
		// a. NOTE: The transfer must be performed in a manner that preserves the bit-level encoding of the source data.

		while (targetByteIndex < limit) { // step 23.b
			value = GetValueFromBuffer(srcBuffer, srcByteIndex, 'UINT8', true, 'UNORDERED'); // step 23.b.i

			SetValueInBuffer(targetBuffer, targetByteIndex, 'UINT8', value, true, 'UNORDERED'); // step 23.b.ii

			srcByteIndex += 1; // step 23.b.iii

			targetByteIndex += 1; // step 23.b.iv
		}
	} else { // step 24
		while (targetByteIndex < limit) { // step 24.a
			value = GetValueFromBuffer(srcBuffer, srcByteIndex, srcType, true, 'UNORDERED'); // step 24.a.i

			SetValueInBuffer(targetBuffer, targetByteIndex, targetType, value, true, 'UNORDERED'); // step 24.a.ii

			srcByteIndex += srcElementSize; // step 24.a.iii

			targetByteIndex += targetElementSize; // step 24.a.iv
		}
	}
};
'use strict';

var GetIntrinsic = require('get-intrinsic');

var $SyntaxError = require('es-errors/syntax');
var $TypeError = require('es-errors/type');
var isInteger = require('math-intrinsics/isInteger');
var $Uint8Array = GetIntrinsic('%Uint8Array%', true);

var IsBigIntElementType = require('./IsBigIntElementType');
var IsDetachedBuffer = require('./IsDetachedBuffer');
var NumericToRawBytes = require('./NumericToRawBytes');

var isArrayBuffer = require('is-array-buffer');
var isSharedArrayBuffer = require('is-shared-array-buffer');
var hasOwn = require('hasown');

var tableTAO = require('./tables/typed-array-objects');

var defaultEndianness = require('../helpers/defaultEndianness');
var forEach = require('../helpers/forEach');

// https://262.ecma-international.org/15.0/#sec-setvalueinbuffer

/* eslint max-params: 0 */

module.exports = function SetValueInBuffer(arrayBuffer, byteIndex, type, value, isTypedArray, order) {
	var isSAB = isSharedArrayBuffer(arrayBuffer);
	if (!isArrayBuffer(arrayBuffer) && !isSAB) {
		throw new $TypeError('Assertion failed: `arrayBuffer` must be an ArrayBuffer or a SharedArrayBuffer');
	}

	if (!isInteger(byteIndex) || byteIndex < 0) {
		throw new $TypeError('Assertion failed: `byteIndex` must be a non-negative integer');
	}

	if (typeof type !== 'string' || !hasOwn(tableTAO.size, '$' + type)) {
		throw new $TypeError('Assertion failed: `type` must be one of ' + tableTAO.choices);
	}

	if (typeof value !== 'number' && typeof value !== 'bigint') {
		throw new $TypeError('Assertion failed: `value` must be a Number or a BigInt');
	}

	if (typeof isTypedArray !== 'boolean') {
		throw new $TypeError('Assertion failed: `isTypedArray` must be a boolean');
	}
	if (order !== 'SEQ-CST' && order !== 'UNORDERED' && order !== 'INIT') {
		throw new $TypeError('Assertion failed: `order` must be `"SEQ-CST"`, `"UNORDERED"`, or `"INIT"`');
	}

	if (arguments.length > 6 && typeof arguments[6] !== 'boolean') {
		throw new $TypeError('Assertion failed: `isLittleEndian` must be a boolean, if present');
	}

	if (IsDetachedBuffer(arrayBuffer)) {
		throw new $TypeError('Assertion failed: ArrayBuffer is detached'); // step 1
	}

	// 2. Assert: There are sufficient bytes in arrayBuffer starting at byteIndex to represent a value of type.

	if (IsBigIntElementType(type) ? typeof value !== 'bigint' : typeof value !== 'number') { // step 3
		throw new $TypeError('Assertion failed: `value` must be a BigInt if type is ~BIGINT64~ or ~BIGUINT64~, otherwise a Number');
	}

	// 4. Let block be arrayBuffer’s [[ArrayBufferData]] internal slot.

	var elementSize = tableTAO.size['$' + type]; // step 5

	// 6. If isLittleEndian is not present, set isLittleEndian to either true or false. The choice is implementation dependent and should be the alternative that is most efficient for the implementation. An implementation must use the same value each time this step is executed and the same value must be used for the corresponding step in the GetValueFromBuffer abstract operation.
	var isLittleEndian = arguments.length > 6 ? arguments[6] : defaultEndianness === 'little'; // step 6

	var rawBytes = NumericToRawBytes(type, value, isLittleEndian); // step 7

	if (isSAB) { // step 8
		/*
			Let execution be the [[CandidateExecution]] field of the surrounding agent's Agent Record.
			Let eventList be the [[EventList]] field of the element in execution.[[EventsRecords]] whose [[AgentSignifier]] is AgentSignifier().
			If isTypedArray is true and IsNoTearConfiguration(type, order) is true, let noTear be true; otherwise let noTear be false.
			Append WriteSharedMemory { [[Order]]: order, [[NoTear]]: noTear, [[Block]]: block, [[ByteIndex]]: byteIndex, [[ElementSize]]: elementSize, [[Payload]]: rawBytes } to eventList.
		*/
		throw new $SyntaxError('SharedArrayBuffer is not supported by this implementation');
	} else {
		// 9. Store the individual bytes of rawBytes into block, in order, starting at block[byteIndex].
		var arr = new $Uint8Array(arrayBuffer, byteIndex, elementSize);
		forEach(rawBytes, function (rawByte, i) {
			arr[i] = rawByte;
		});
	}

	// 10. Return NormalCompletion(undefined).
};
'use strict';

var $TypeError = require('es-errors/type');
var callBound = require('call-bound');
var isInteger = require('math-intrinsics/isInteger');
var isObject = require('es-object-atoms/isObject');

var Get = require('./Get');
var HasProperty = require('./HasProperty');
var ToString = require('./ToString');

var isAbstractClosure = require('../helpers/isAbstractClosure');

var $sort = callBound('Array.prototype.sort');

// https://262.ecma-international.org/14.0/#sec-sortindexedproperties

module.exports = function SortIndexedProperties(obj, len, SortCompare, holes) {
	if (!isObject(obj)) {
		throw new $TypeError('Assertion failed: Type(obj) is not Object');
	}
	if (!isInteger(len) || len < 0) {
		throw new $TypeError('Assertion failed: `len` must be an integer >= 0');
	}
	if (!isAbstractClosure(SortCompare) || SortCompare.length !== 2) {
		throw new $TypeError('Assertion failed: `SortCompare` must be an abstract closure taking 2 arguments');
	}
	if (holes !== 'skip-holes' && holes !== 'read-through-holes') {
		throw new $TypeError('Assertion failed: `holes` must be either ~skip-holes~ or ~read-through-holes~');
	}

	var items = []; // step 1

	var k = 0; // step 2

	while (k < len) { // step 3
		var Pk = ToString(k);
		var kRead = holes === 'skip-holes' ? HasProperty(obj, Pk) : true; // step 3.b - 3.c
		if (kRead) { // step 3.d
			var kValue = Get(obj, Pk);
			items[items.length] = kValue;
		}
		k += 1; // step 3.e
	}

	$sort(items, SortCompare); // step 4

	return items; // step 5
};
'use strict';

var GetIntrinsic = require('get-intrinsic');

var $species = GetIntrinsic('%Symbol.species%', true);
var $TypeError = require('es-errors/type');
var isObject = require('es-object-atoms/isObject');

var IsConstructor = require('./IsConstructor');

// https://262.ecma-international.org/6.0/#sec-speciesconstructor

module.exports = function SpeciesConstructor(O, defaultConstructor) {
	if (!isObject(O)) {
		throw new $TypeError('Assertion failed: Type(O) is not Object');
	}
	var C = O.constructor;
	if (typeof C === 'undefined') {
		return defaultConstructor;
	}
	if (!isObject(C)) {
		throw new $TypeError('O.constructor is not an Object');
	}
	var S = $species ? C[$species] : void 0;
	if (S == null) {
		return defaultConstructor;
	}
	if (IsConstructor(S)) {
		return S;
	}
	throw new $TypeError('no constructor found');
};
'use strict';

var GetIntrinsic = require('get-intrinsic');

var $Object = require('es-object-atoms');
var $StringPrototype = GetIntrinsic('%String.prototype%');
var $SyntaxError = require('es-errors/syntax');
var $TypeError = require('es-errors/type');
var setProto = require('set-proto');

var DefinePropertyOrThrow = require('./DefinePropertyOrThrow');

// https://262.ecma-international.org/6.0/#sec-stringcreate

module.exports = function StringCreate(value, prototype) {
	if (typeof value !== 'string') {
		throw new $TypeError('Assertion failed: `S` must be a String');
	}

	var S = $Object(value);
	if (prototype !== $StringPrototype) {
		if (setProto) {
			setProto(S, prototype);
		} else {
			throw new $SyntaxError('StringCreate: a `proto` argument that is not `String.prototype` is not supported in an environment that does not support setting the [[Prototype]]');
		}
	}

	var length = value.length;
	DefinePropertyOrThrow(S, 'length', {
		'[[Configurable]]': false,
		'[[Enumerable]]': false,
		'[[Value]]': length,
		'[[Writable]]': false
	});

	return S;
};
'use strict';

var $TypeError = require('es-errors/type');
var isNegativeZero = require('math-intrinsics/isNegativeZero');
var isObject = require('es-object-atoms/isObject');

var callBound = require('call-bound');
var $charAt = callBound('String.prototype.charAt');
var $stringToString = callBound('String.prototype.toString');

var CanonicalNumericIndexString = require('./CanonicalNumericIndexString');

var isPropertyKey = require('../helpers/isPropertyKey');
var isInteger = require('math-intrinsics/isInteger');

// https://262.ecma-international.org/12.0/#sec-stringgetownproperty

module.exports = function StringGetOwnProperty(S, P) {
	var str;
	if (isObject(S)) {
		try {
			str = $stringToString(S);
		} catch (e) { /**/ }
	}
	if (typeof str !== 'string') {
		throw new $TypeError('Assertion failed: `S` must be a boxed string object');
	}
	if (!isPropertyKey(P)) {
		throw new $TypeError('Assertion failed: P is not a Property Key');
	}
	if (typeof P !== 'string') {
		return void undefined;
	}
	var index = CanonicalNumericIndexString(P);
	var len = str.length;
	if (typeof index === 'undefined' || !isInteger(index) || isNegativeZero(index) || index < 0 || len <= index) {
		return void undefined;
	}
	var resultStr = $charAt(S, index);
	return {
		'[[Configurable]]': false,
		'[[Enumerable]]': true,
		'[[Value]]': resultStr,
		'[[Writable]]': false
	};
};
'use strict';

var callBound = require('call-bound');

var $TypeError = require('es-errors/type');
var isInteger = require('math-intrinsics/isInteger');

var $slice = callBound('String.prototype.slice');

// https://262.ecma-international.org/12.0/#sec-stringindexof

module.exports = function StringIndexOf(string, searchValue, fromIndex) {
	if (typeof string !== 'string') {
		throw new $TypeError('Assertion failed: `string` must be a String');
	}
	if (typeof searchValue !== 'string') {
		throw new $TypeError('Assertion failed: `searchValue` must be a String');
	}
	if (!isInteger(fromIndex) || fromIndex < 0) {
		throw new $TypeError('Assertion failed: `fromIndex` must be a non-negative integer');
	}

	var len = string.length;
	if (searchValue === '' && fromIndex <= len) {
		return fromIndex;
	}

	var searchLen = searchValue.length;
	for (var i = fromIndex; i <= (len - searchLen); i += 1) {
		var candidate = $slice(string, i, i + searchLen);
		if (candidate === searchValue) {
			return i;
		}
	}
	return -1;
};
'use strict';

var $TypeError = require('es-errors/type');

var StringPad = require('./StringPad');
var ToLength = require('./ToLength');
var ToString = require('./ToString');

// https://262.ecma-international.org/15.0/#sec-stringpaddingbuiltinsimpl

module.exports = function StringPaddingBuiltinsImpl(O, maxLength, fillString, placement) {
	if (placement !== 'start' && placement !== 'end' && placement !== 'START' && placement !== 'END') {
		throw new $TypeError('Assertion failed: `placement` must be ~START~ or ~END~');
	}

	var S = ToString(O); // step 1

	var intMaxLength = ToLength(maxLength); // step 2

	var stringLength = S.length; // step 3

	if (intMaxLength <= stringLength) { return S; } // step 4

	var filler = typeof fillString === 'undefined' ? ' ' : ToString(fillString); // steps 5-6

	return StringPad(S, intMaxLength, filler, placement); // step 7
};
'use strict';

var $TypeError = require('es-errors/type');
var callBound = require('call-bound');
var isInteger = require('math-intrinsics/isInteger');

var $strSlice = callBound('String.prototype.slice');

// https://262.ecma-international.org/15.0/#sec-stringpad

module.exports = function StringPad(S, maxLength, fillString, placement) {
	if (typeof S !== 'string') {
		throw new $TypeError('Assertion failed: `S` must be a String');
	}
	if (!isInteger(maxLength) || maxLength < 0) {
		throw new $TypeError('Assertion failed: `maxLength` must be a non-negative integer');
	}
	if (typeof fillString !== 'string') {
		throw new $TypeError('Assertion failed: `fillString` must be a String');
	}
	if (placement !== 'start' && placement !== 'end' && placement !== 'START' && placement !== 'END') {
		throw new $TypeError('Assertion failed: `placement` must be ~START~ or ~END~');
	}

	var stringLength = S.length; // step 1

	if (maxLength <= stringLength) { return S; } // step 2

	if (fillString === '') { return S; } // step 3

	var fillLen = maxLength - stringLength; // step 4

	// 5. Let _truncatedStringFiller_ be the String value consisting of repeated concatenations of _fillString_ truncated to length _fillLen_.
	var truncatedStringFiller = '';
	while (truncatedStringFiller.length < fillLen) {
		truncatedStringFiller += fillString;
	}
	truncatedStringFiller = $strSlice(truncatedStringFiller, 0, fillLen);

	if (placement === 'start' || placement === 'START') { return truncatedStringFiller + S; } // step 6

	return S + truncatedStringFiller; // step 7
};
'use strict';

var GetIntrinsic = require('get-intrinsic');

var $BigInt = GetIntrinsic('%BigInt%', true);
var $TypeError = require('es-errors/type');
var $SyntaxError = require('es-errors/syntax');

// https://262.ecma-international.org/14.0/#sec-stringtobigint

module.exports = function StringToBigInt(argument) {
	if (typeof argument !== 'string') {
		throw new $TypeError('`argument` must be a string');
	}
	if (!$BigInt) {
		throw new $SyntaxError('BigInts are not supported in this environment');
	}
	try {
		return $BigInt(argument);
	} catch (e) {
		return void undefined;
	}
};
'use strict';

var $TypeError = require('es-errors/type');

var CodePointAt = require('./CodePointAt');

// https://262.ecma-international.org/12.0/#sec-stringtocodepoints

module.exports = function StringToCodePoints(string) {
	if (typeof string !== 'string') {
		throw new $TypeError('Assertion failed: `string` must be a String');
	}
	var codePoints = [];
	var size = string.length;
	var position = 0;
	while (position < size) {
		var cp = CodePointAt(string, position);
		codePoints[codePoints.length] = cp['[[CodePoint]]'];
		position += cp['[[CodeUnitCount]]'];
	}
	return codePoints;
};
'use strict';

var GetIntrinsic = require('get-intrinsic');

var $RegExp = GetIntrinsic('%RegExp%');
var $TypeError = require('es-errors/type');
var $parseInteger = GetIntrinsic('%parseInt%');

var callBound = require('call-bound');
var regexTester = require('safe-regex-test');

var $strSlice = callBound('String.prototype.slice');
var isBinary = regexTester(/^0b[01]+$/i);
var isOctal = regexTester(/^0o[0-7]+$/i);
var isInvalidHexLiteral = regexTester(/^[-+]0x[0-9a-f]+$/i);
var nonWS = ['\u0085', '\u200b', '\ufffe'].join('');
var nonWSregex = new $RegExp('[' + nonWS + ']', 'g');
var hasNonWS = regexTester(nonWSregex);

var $trim = require('string.prototype.trim');

// https://262.ecma-international.org/13.0/#sec-stringtonumber

module.exports = function StringToNumber(argument) {
	if (typeof argument !== 'string') {
		throw new $TypeError('Assertion failed: `argument` is not a String');
	}
	if (isBinary(argument)) {
		return +$parseInteger($strSlice(argument, 2), 2);
	}
	if (isOctal(argument)) {
		return +$parseInteger($strSlice(argument, 2), 8);
	}
	if (hasNonWS(argument) || isInvalidHexLiteral(argument)) {
		return NaN;
	}
	var trimmed = $trim(argument);
	if (trimmed !== argument) {
		return StringToNumber(trimmed);
	}
	return +argument;
};
'use strict';

var $TypeError = require('es-errors/type');
var isInteger = require('math-intrinsics/isInteger');
var callBound = require('call-bound');

var $slice = callBound('String.prototype.slice');

// https://262.ecma-international.org/12.0/#substring
module.exports = function substring(S, inclusiveStart, exclusiveEnd) {
	if (typeof S !== 'string' || !isInteger(inclusiveStart) || (arguments.length > 2 && !isInteger(exclusiveEnd))) {
		throw new $TypeError('`S` must be a String, and `inclusiveStart` and `exclusiveEnd` must be integers');
	}
	return $slice(S, inclusiveStart, arguments.length > 2 ? exclusiveEnd : S.length);
};
'use strict';

var $TypeError = require('es-errors/type');

var callBound = require('call-bound');

var $SymbolToString = callBound('Symbol.prototype.toString', true);

// https://262.ecma-international.org/6.0/#sec-symboldescriptivestring

module.exports = function SymbolDescriptiveString(sym) {
	if (typeof sym !== 'symbol') {
		throw new $TypeError('Assertion failed: `sym` must be a Symbol');
	}
	return $SymbolToString(sym);
};
'use strict';

var callBind = require('call-bind');

var I402 = typeof Intl === 'undefined' ? null : Intl;
var DateTimeFormat = I402 && I402.DateTimeFormat;
var resolvedOptions = DateTimeFormat && callBind(DateTimeFormat.prototype.resolvedOptions);

// https://262.ecma-international.org/15.0/#sec-systemtimezoneidentifier

module.exports = function SystemTimeZoneIdentifier() {
	if (DateTimeFormat && resolvedOptions) {
		return resolvedOptions(new DateTimeFormat()).timeZone; // steps 2 - 3

	}

	return 'UTC'; // step 1
};
'use strict';

var $gOPD = require('gopd');
var $TypeError = require('es-errors/type');

var every = require('../helpers/every');
var OwnPropertyKeys = require('own-keys');
var isObject = require('es-object-atoms/isObject');

var IsDataDescriptor = require('./IsDataDescriptor');
var IsExtensible = require('./IsExtensible');
var ToPropertyDescriptor = require('./ToPropertyDescriptor');

// https://262.ecma-international.org/6.0/#sec-testintegritylevel

module.exports = function TestIntegrityLevel(O, level) {
	if (!isObject(O)) {
		throw new $TypeError('Assertion failed: Type(O) is not Object');
	}
	if (level !== 'sealed' && level !== 'frozen') {
		throw new $TypeError('Assertion failed: `level` must be `"sealed"` or `"frozen"`');
	}
	var status = IsExtensible(O);
	if (status || !$gOPD) {
		return false;
	}
	var theKeys = OwnPropertyKeys(O);
	return theKeys.length === 0 || every(theKeys, function (k) {
		var currentDesc = $gOPD(O, k);
		if (typeof currentDesc !== 'undefined') {
			if (currentDesc.configurable) {
				return false;
			}
			if (level === 'frozen' && IsDataDescriptor(ToPropertyDescriptor(currentDesc)) && currentDesc.writable) {
				return false;
			}
		}
		return true;
	});
};
'use strict';

var callBound = require('call-bound');

var $SyntaxError = require('es-errors/syntax');
var $bigIntValueOf = callBound('BigInt.prototype.valueOf', true);

// https://262.ecma-international.org/15.0/#sec-thisbigintvalue

module.exports = function ThisBigIntValue(value) {
	if (typeof value === 'bigint') {
		return value;
	}

	if (!$bigIntValueOf) {
		throw new $SyntaxError('BigInt is not supported');
	}

	return $bigIntValueOf(value);
};
'use strict';

var $BooleanValueOf = require('call-bound')('Boolean.prototype.valueOf');

// https://262.ecma-international.org/15.0/#sec-properties-of-the-boolean-prototype-object

module.exports = function ThisBooleanValue(value) {
	if (typeof value === 'boolean') {
		return value;
	}

	return $BooleanValueOf(value);
};
'use strict';

var callBound = require('call-bound');

var $NumberValueOf = callBound('Number.prototype.valueOf');

// https://262.ecma-international.org/15.0/#sec-thisnumbervalue

module.exports = function ThisNumberValue(value) {
	if (typeof value === 'number') {
		return value;
	}

	return $NumberValueOf(value);
};
'use strict';

var $StringValueOf = require('call-bound')('String.prototype.valueOf');

// https://262.ecma-international.org/15.0/#sec-properties-of-the-string-prototype-object

module.exports = function ThisStringValue(value) {
	if (typeof value === 'string') {
		return value;
	}

	return $StringValueOf(value);
};
'use strict';

var $SyntaxError = require('es-errors/syntax');
var callBound = require('call-bound');

var $SymbolValueOf = callBound('Symbol.prototype.valueOf', true);

// https://262.ecma-international.org/15.0/#sec-thissymbolvalue

module.exports = function ThisSymbolValue(value) {
	if (typeof value === 'symbol') {
		return value;
	}

	if (!$SymbolValueOf) {
		throw new $SyntaxError('Symbols are not supported; thisSymbolValue requires that `value` be a Symbol or a Symbol object');
	}

	return $SymbolValueOf(value);
};
'use strict';

var CompletionRecord = require('./CompletionRecord');

// https://262.ecma-international.org/9.0/#sec-throwcompletion

module.exports = function ThrowCompletion(argument) {
	return new CompletionRecord('throw', argument);
};
'use strict';

var GetIntrinsic = require('get-intrinsic');

var $Date = GetIntrinsic('%Date%');

var $isFinite = require('math-intrinsics/isFinite');
var abs = require('math-intrinsics/abs');

var ToNumber = require('./ToNumber');

// https://262.ecma-international.org/5.1/#sec-15.9.1.14

module.exports = function TimeClip(time) {
	if (!$isFinite(time) || abs(time) > 8.64e15) {
		return NaN;
	}
	return +new $Date(ToNumber(time));
};

'use strict';

var msPerDay = require('../helpers/timeConstants').msPerDay;

var DayFromYear = require('./DayFromYear');

// https://262.ecma-international.org/5.1/#sec-15.9.1.3

module.exports = function TimeFromYear(y) {
	return msPerDay * DayFromYear(y);
};
'use strict';

var $TypeError = require('es-errors/type');

var $isNaN = require('math-intrinsics/isNaN');

var HourFromTime = require('./HourFromTime');
var MinFromTime = require('./MinFromTime');
var SecFromTime = require('./SecFromTime');
var ToZeroPaddedDecimalString = require('./ToZeroPaddedDecimalString');

// https://262.ecma-international.org/13.0/#sec-timestring

module.exports = function TimeString(tv) {
	if (typeof tv !== 'number' || $isNaN(tv)) {
		throw new $TypeError('Assertion failed: `tv` must be a non-NaN Number');
	}

	var hour = ToZeroPaddedDecimalString(HourFromTime(tv), 2); // step 1

	var minute = ToZeroPaddedDecimalString(MinFromTime(tv), 2); // step 2

	var second = ToZeroPaddedDecimalString(SecFromTime(tv), 2); // step 3

	return hour + ':' + minute + ':' + second + ' GMT'; // step 4
};
'use strict';

var modulo = require('./modulo');

var msPerDay = require('../helpers/timeConstants').msPerDay;

// https://262.ecma-international.org/5.1/#sec-15.9.1.2

module.exports = function TimeWithinDay(t) {
	return modulo(t, msPerDay);
};

'use strict';

var GetIntrinsic = require('get-intrinsic');

var $Date = GetIntrinsic('%Date%');
var $TypeError = require('es-errors/type');
var callBound = require('call-bound');
var isInteger = require('math-intrinsics/isInteger');

var $indexOf = callBound('String.prototype.indexOf');
var $slice = callBound('String.prototype.slice');
var $toTimeString = callBound('Date.prototype.toTimeString');

// https://262.ecma-international.org/14.0/#sec-timezoneestring

module.exports = function TimeZoneString(tv) {
	if (!isInteger(tv)) {
		throw new $TypeError('Assertion failed: `tv` must be an integral Number');
	}

	// 1. Let localTimeZone be DefaultTimeZone().
	// 2. If IsTimeZoneOffsetString(localTimeZone) is true, then
	//   a. Let offsetNs be ParseTimeZoneOffsetString(localTimeZone).
	// 3. Else,
	//   a. Let offsetNs be GetNamedTimeZoneOffsetNanoseconds(localTimeZone, ℤ(ℝ(tv) × 106)).
	// 4. Let offset be 𝔽(truncate(offsetNs / 106)).
	// 5. If offset is +0𝔽 or offset > +0𝔽, then
	//   a. Let offsetSign be "+".
	//   b. Let absOffset be offset.
	// 6. Else,
	//   a. Let offsetSign be "-".
	//   b. Let absOffset be -offset.
	// 7. Let offsetMin be ToZeroPaddedDecimalString(ℝ(MinFromTime(absOffset)), 2).
	// 8. Let offsetHour be ToZeroPaddedDecimalString(ℝ(HourFromTime(absOffset)), 2).
	// 9. Let tzName be an implementation-defined string that is either the empty String or the string-concatenation of the code unit 0x0020 (SPACE), the code unit 0x0028 (LEFT PARENTHESIS), an implementation-defined timezone name, and the code unit 0x0029 (RIGHT PARENTHESIS).
	// 10. Return the string-concatenation of offsetSign, offsetHour, offsetMin, and tzName.

	// hack until DefaultTimeZone, IsTimeZoneOffsetString, ParseTimeZoneOffsetString, GetNamedTimeZoneOffsetNanoseconds, and "implementation-defined string" are available
	var ts = $toTimeString(new $Date(tv));
	return $slice(ts, $indexOf(ts, '(') + 1, $indexOf(ts, ')'));
};
'use strict';

var GetIntrinsic = require('get-intrinsic');

var $BigInt = GetIntrinsic('%BigInt%', true);
var $pow = require('math-intrinsics/pow');

var ToBigInt = require('./ToBigInt');
var BigIntRemainder = require('./BigInt/remainder');

var modBigInt = require('../helpers/modBigInt');

// BigInt(2**63), but node v10.4-v10.8 have a bug where you can't `BigInt(x)` anything larger than MAX_SAFE_INTEGER
var twoSixtyThree = $BigInt && (BigInt($pow(2, 32)) * BigInt($pow(2, 31)));

// BigInt(2**64), but node v10.4-v10.8 have a bug where you can't `BigInt(x)` anything larger than MAX_SAFE_INTEGER
var twoSixtyFour = $BigInt && (BigInt($pow(2, 32)) * BigInt($pow(2, 32)));

// https://262.ecma-international.org/11.0/#sec-tobigint64

module.exports = function ToBigInt64(argument) {
	var n = ToBigInt(argument);
	var int64bit = modBigInt(BigIntRemainder, n, twoSixtyFour);
	return int64bit >= twoSixtyThree ? int64bit - twoSixtyFour : int64bit;
};
'use strict';

var GetIntrinsic = require('get-intrinsic');

var $BigInt = GetIntrinsic('%BigInt%', true);
var $Number = GetIntrinsic('%Number%');
var $TypeError = require('es-errors/type');
var $SyntaxError = require('es-errors/syntax');

var StringToBigInt = require('./StringToBigInt');
var ToPrimitive = require('./ToPrimitive');

// https://262.ecma-international.org/13.0/#sec-tobigint

module.exports = function ToBigInt(argument) {
	if (!$BigInt) {
		throw new $SyntaxError('BigInts are not supported in this environment');
	}

	var prim = ToPrimitive(argument, $Number);

	if (prim == null) {
		throw new $TypeError('Cannot convert null or undefined to a BigInt');
	}

	if (typeof prim === 'boolean') {
		return prim ? $BigInt(1) : $BigInt(0);
	}

	if (typeof prim === 'number') {
		throw new $TypeError('Cannot convert a Number value to a BigInt');
	}

	if (typeof prim === 'string') {
		var n = StringToBigInt(prim);
		if (typeof n === 'undefined') {
			throw new $TypeError('Failed to parse String to BigInt');
		}
		return n;
	}

	if (typeof prim === 'symbol') {
		throw new $TypeError('Cannot convert a Symbol value to a BigInt');
	}

	if (typeof prim !== 'bigint') {
		throw new $SyntaxError('Assertion failed: unknown primitive type');
	}

	return prim;
};
'use strict';

var GetIntrinsic = require('get-intrinsic');

var $BigInt = GetIntrinsic('%BigInt%', true);

var $pow = require('math-intrinsics/pow');

var ToBigInt = require('./ToBigInt');
var BigIntRemainder = require('./BigInt/remainder');

var modBigInt = require('../helpers/modBigInt');

// BigInt(2**64), but node v10.4-v10.8 have a bug where you can't `BigInt(x)` anything larger than MAX_SAFE_INTEGER
var twoSixtyFour = $BigInt && (BigInt($pow(2, 32)) * BigInt($pow(2, 32)));

// https://262.ecma-international.org/11.0/#sec-tobiguint64

module.exports = function ToBigUint64(argument) {
	var n = ToBigInt(argument);
	var int64bit = modBigInt(BigIntRemainder, n, twoSixtyFour);
	return int64bit;
};
'use strict';

// http://262.ecma-international.org/5.1/#sec-9.2

module.exports = function ToBoolean(value) { return !!value; };
'use strict';

var GetIntrinsic = require('get-intrinsic');

var $TypeError = require('es-errors/type');
var $Date = GetIntrinsic('%Date%');
var $String = GetIntrinsic('%String%');

var $isNaN = require('math-intrinsics/isNaN');

// https://262.ecma-international.org/6.0/#sec-todatestring

module.exports = function ToDateString(tv) {
	if (typeof tv !== 'number') {
		throw new $TypeError('Assertion failed: `tv` must be a Number');
	}
	if ($isNaN(tv)) {
		return 'Invalid Date';
	}
	return $String(new $Date(tv));
};
'use strict';

var $RangeError = require('es-errors/range');

var ToIntegerOrInfinity = require('./ToIntegerOrInfinity');

var MAX_SAFE_INTEGER = require('math-intrinsics/constants/maxSafeInteger');

// https://262.ecma-international.org/15.0/#sec-toindex

module.exports = function ToIndex(value) {
	if (typeof value === 'undefined') {
		return 0;
	}
	var integer = ToIntegerOrInfinity(value);
	if (integer < 0 || integer >= MAX_SAFE_INTEGER) {
		throw new $RangeError('index must be >= 0 and < 2 ** 53 - 1');
	}
	return integer;
};
'use strict';

var modulo = require('./modulo');
var ToNumber = require('./ToNumber');
var truncate = require('./truncate');

var isFinite = require('math-intrinsics/isFinite');

// https://262.ecma-international.org/14.0/#sec-toint16

var two16 = 0x10000; // Math.pow(2, 16);

module.exports = function ToInt16(argument) {
	var number = ToNumber(argument);
	if (!isFinite(number) || number === 0) {
		return 0;
	}
	var int = truncate(number);
	var int16bit = modulo(int, two16);
	return int16bit >= 0x8000 ? int16bit - two16 : int16bit;
};
'use strict';

var modulo = require('./modulo');
var ToNumber = require('./ToNumber');
var truncate = require('./truncate');

var isFinite = require('math-intrinsics/isFinite');

// https://262.ecma-international.org/14.0/#sec-toint32

var two31 = 0x80000000; // Math.pow(2, 31);
var two32 = 0x100000000; // Math.pow(2, 32);

module.exports = function ToInt32(argument) {
	var number = ToNumber(argument);
	if (!isFinite(number) || number === 0) {
		return 0;
	}
	var int = truncate(number);
	var int32bit = modulo(int, two32);
	var result = int32bit >= two31 ? int32bit - two32 : int32bit;
	return result === 0 ? 0 : result; // in the spec, these are math values, so we filter out -0 here
};
'use strict';

var modulo = require('./modulo');
var ToNumber = require('./ToNumber');
var truncate = require('./truncate');

var isFinite = require('math-intrinsics/isFinite');

// https://262.ecma-international.org/14.0/#sec-toint8

module.exports = function ToInt8(argument) {
	var number = ToNumber(argument);
	if (!isFinite(number) || number === 0) {
		return 0;
	}
	var int = truncate(number);
	var int8bit = modulo(int, 0x100);
	return int8bit >= 0x80 ? int8bit - 0x100 : int8bit;
};
'use strict';

var ToNumber = require('./ToNumber');
var truncate = require('./truncate');

var $isNaN = require('math-intrinsics/isNaN');
var $isFinite = require('math-intrinsics/isFinite');

// https://262.ecma-international.org/14.0/#sec-tointegerorinfinity

module.exports = function ToIntegerOrInfinity(value) {
	var number = ToNumber(value);
	if ($isNaN(number) || number === 0) { return 0; }
	if (!$isFinite(number)) { return number; }
	return truncate(number);
};
'use strict';

var MAX_SAFE_INTEGER = require('math-intrinsics/constants/maxSafeInteger');

var ToIntegerOrInfinity = require('./ToIntegerOrInfinity');

// https://262.ecma-international.org/12.0/#sec-tolength

module.exports = function ToLength(argument) {
	var len = ToIntegerOrInfinity(argument);
	if (len <= 0) { return 0; } // includes converting -0 to +0
	if (len > MAX_SAFE_INTEGER) { return MAX_SAFE_INTEGER; }
	return len;
};
'use strict';

var GetIntrinsic = require('get-intrinsic');

var $TypeError = require('es-errors/type');
var $Number = GetIntrinsic('%Number%');
var isPrimitive = require('../helpers/isPrimitive');

var ToPrimitive = require('./ToPrimitive');
var StringToNumber = require('./StringToNumber');

// https://262.ecma-international.org/13.0/#sec-tonumber

module.exports = function ToNumber(argument) {
	var value = isPrimitive(argument) ? argument : ToPrimitive(argument, $Number);
	if (typeof value === 'symbol') {
		throw new $TypeError('Cannot convert a Symbol value to a number');
	}
	if (typeof value === 'bigint') {
		throw new $TypeError('Conversion from \'BigInt\' to \'number\' is not allowed.');
	}
	if (typeof value === 'string') {
		return StringToNumber(value);
	}
	return +value;
};
'use strict';

var GetIntrinsic = require('get-intrinsic');

var $Number = GetIntrinsic('%Number%');

var isPrimitive = require('../helpers/isPrimitive');

var ToPrimitive = require('./ToPrimitive');
var ToNumber = require('./ToNumber');

// https://262.ecma-international.org/11.0/#sec-tonumeric

module.exports = function ToNumeric(argument) {
	var primValue = isPrimitive(argument) ? argument : ToPrimitive(argument, $Number);
	if (typeof primValue === 'bigint') {
		return primValue;
	}
	return ToNumber(primValue);
};
'use strict';

// https://262.ecma-international.org/6.0/#sec-toobject

module.exports = require('es-object-atoms/ToObject');
'use strict';

var toPrimitive = require('es-to-primitive/es2015');

// https://262.ecma-international.org/6.0/#sec-toprimitive

module.exports = function ToPrimitive(input) {
	if (arguments.length > 1) {
		return toPrimitive(input, arguments[1]);
	}
	return toPrimitive(input);
};
'use strict';

var hasOwn = require('hasown');

var $TypeError = require('es-errors/type');
var isObject = require('es-object-atoms/isObject');

var IsCallable = require('./IsCallable');
var ToBoolean = require('./ToBoolean');

// https://262.ecma-international.org/5.1/#sec-8.10.5

module.exports = function ToPropertyDescriptor(Obj) {
	if (!isObject(Obj)) {
		throw new $TypeError('ToPropertyDescriptor requires an object');
	}

	var desc = {};
	if (hasOwn(Obj, 'enumerable')) {
		desc['[[Enumerable]]'] = ToBoolean(Obj.enumerable);
	}
	if (hasOwn(Obj, 'configurable')) {
		desc['[[Configurable]]'] = ToBoolean(Obj.configurable);
	}
	if (hasOwn(Obj, 'value')) {
		desc['[[Value]]'] = Obj.value;
	}
	if (hasOwn(Obj, 'writable')) {
		desc['[[Writable]]'] = ToBoolean(Obj.writable);
	}
	if (hasOwn(Obj, 'get')) {
		var getter = Obj.get;
		if (typeof getter !== 'undefined' && !IsCallable(getter)) {
			throw new $TypeError('getter must be a function');
		}
		desc['[[Get]]'] = getter;
	}
	if (hasOwn(Obj, 'set')) {
		var setter = Obj.set;
		if (typeof setter !== 'undefined' && !IsCallable(setter)) {
			throw new $TypeError('setter must be a function');
		}
		desc['[[Set]]'] = setter;
	}

	if ((hasOwn(desc, '[[Get]]') || hasOwn(desc, '[[Set]]')) && (hasOwn(desc, '[[Value]]') || hasOwn(desc, '[[Writable]]'))) {
		throw new $TypeError('Invalid property descriptor. Cannot both specify accessors and a value or writable attribute');
	}
	return desc;
};
'use strict';

var GetIntrinsic = require('get-intrinsic');

var $String = GetIntrinsic('%String%');

var ToPrimitive = require('./ToPrimitive');
var ToString = require('./ToString');

// https://262.ecma-international.org/6.0/#sec-topropertykey

module.exports = function ToPropertyKey(argument) {
	var key = ToPrimitive(argument, $String);
	return typeof key === 'symbol' ? key : ToString(key);
};
'use strict';

var GetIntrinsic = require('get-intrinsic');

var $String = GetIntrinsic('%String%');
var $TypeError = require('es-errors/type');

// https://262.ecma-international.org/6.0/#sec-tostring

module.exports = function ToString(argument) {
	if (typeof argument === 'symbol') {
		throw new $TypeError('Cannot convert a Symbol value to a string');
	}
	return $String(argument);
};
'use strict';

var modulo = require('./modulo');
var ToNumber = require('./ToNumber');
var truncate = require('./truncate');

var isFinite = require('math-intrinsics/isFinite');

// https://262.ecma-international.org/14.0/#sec-touint16

var two16 = 0x10000; // Math.pow(2, 16)

module.exports = function ToUint16(argument) {
	var number = ToNumber(argument);
	if (!isFinite(number) || number === 0) {
		return 0;
	}
	var int = truncate(number);
	var int16bit = modulo(int, two16);
	return int16bit === 0 ? 0 : int16bit; // in the spec, these are math values, so we filter out -0 here
};
'use strict';

var modulo = require('./modulo');
var ToNumber = require('./ToNumber');
var truncate = require('./truncate');

var isFinite = require('math-intrinsics/isFinite');

// https://262.ecma-international.org/14.0/#sec-touint32

var two32 = 0x100000000; // Math.pow(2, 32);

module.exports = function ToUint32(argument) {
	var number = ToNumber(argument);
	if (!isFinite(number) || number === 0) {
		return 0;
	}
	var int = truncate(number);
	var int32bit = modulo(int, two32);
	return int32bit === 0 ? 0 : int32bit; // in the spec, these are math values, so we filter out -0 here
};
'use strict';

var clamp = require('./clamp');

var ToNumber = require('./ToNumber');
var floor = require('./floor');

var $isNaN = require('math-intrinsics/isNaN');

// https://262.ecma-international.org/15.0/#sec-touint8clamp

module.exports = function ToUint8Clamp(argument) {
	var number = ToNumber(argument); // step 1

	if ($isNaN(number)) { return 0; } // step 2

	var clamped = clamp(number, 0, 255); // step 4

	var f = floor(clamped); // step 5

	if (clamped < (f + 0.5)) { return f; } // step 6

	if (clamped > (f + 0.5)) { return f + 1; } // step 7

	return f % 2 === 0 ? f : f + 1; // step 8
};
'use strict';

var isFinite = require('math-intrinsics/isFinite');

var modulo = require('./modulo');
var ToNumber = require('./ToNumber');
var truncate = require('./truncate');

// https://262.ecma-international.org/14.0/#sec-touint8

module.exports = function ToUint8(argument) {
	var number = ToNumber(argument);
	if (!isFinite(number) || number === 0) {
		return 0;
	}
	var int = truncate(number);
	var int8bit = modulo(int, 0x100);
	return int8bit;
};
'use strict';

var GetIntrinsic = require('get-intrinsic');

var $String = GetIntrinsic('%String%');
var $RangeError = require('es-errors/range');
var isInteger = require('math-intrinsics/isInteger');

var StringPad = require('./StringPad');

// https://262.ecma-international.org/13.0/#sec-tozeropaddeddecimalstring

module.exports = function ToZeroPaddedDecimalString(n, minLength) {
	if (!isInteger(n) || n < 0) {
		throw new $RangeError('Assertion failed: `q` must be a non-negative integer');
	}
	var S = $String(n);
	return StringPad(S, minLength, '0', 'start');
};
'use strict';

var trimStart = require('string.prototype.trimstart');
var trimEnd = require('string.prototype.trimend');

var $TypeError = require('es-errors/type');

var RequireObjectCoercible = require('./RequireObjectCoercible');
var ToString = require('./ToString');

// https://262.ecma-international.org/10.0/#sec-trimstring

module.exports = function TrimString(string, where) {
	var str = RequireObjectCoercible(string);
	var S = ToString(str);
	var T;
	if (where === 'start') {
		T = trimStart(S);
	} else if (where === 'end') {
		T = trimEnd(S);
	} else if (where === 'start+end') {
		T = trimStart(trimEnd(S));
	} else {
		throw new $TypeError('Assertion failed: invalid `where` value; must be "start", "end", or "start+end"');
	}
	return T;
};
'use strict';

var floor = require('./floor');

var $TypeError = require('es-errors/type');

// https://262.ecma-international.org/14.0/#eqn-truncate

module.exports = function truncate(x) {
	if (typeof x !== 'number' && typeof x !== 'bigint') {
		throw new $TypeError('argument must be a Number or a BigInt');
	}
	var result = x < 0 ? -floor(-x) : floor(x);
	return result === 0 ? 0 : result; // in the spec, these are math values, so we filter out -0 here
};
'use strict';

var $TypeError = require('es-errors/type');

var IsFixedLengthArrayBuffer = require('./IsFixedLengthArrayBuffer');
var IsTypedArrayOutOfBounds = require('./IsTypedArrayOutOfBounds');
var TypedArrayElementSize = require('./TypedArrayElementSize');
var TypedArrayLength = require('./TypedArrayLength');

var isTypedArrayWithBufferWitnessRecord = require('../helpers/records/typed-array-with-buffer-witness-record');

var typedArrayByffer = require('typed-array-buffer');
var typedArrayByteLength = require('typed-array-byte-length');

// https://262.ecma-international.org/15.0/#sec-typedarraybytelength

module.exports = function TypedArrayByteLength(taRecord) {
	if (!isTypedArrayWithBufferWitnessRecord(taRecord)) {
		throw new $TypeError('Assertion failed: `taRecord` must be a TypedArray With Buffer Witness Record');
	}

	if (IsTypedArrayOutOfBounds(taRecord)) {
		return 0; // step 1
	}
	var length = TypedArrayLength(taRecord); // step 2

	if (length === 0) {
		return 0; // step 3
	}

	var O = taRecord['[[Object]]']; // step 4

	var isFixed = IsFixedLengthArrayBuffer(typedArrayByffer(O));

	var byteLength = isFixed ? typedArrayByteLength(O) : 'AUTO';
	if (byteLength !== 'AUTO') {
		return byteLength; // step 5
	}

	var elementSize = TypedArrayElementSize(O); // step 6

	return length * elementSize; // step 7
};
'use strict';

var $SyntaxError = require('es-errors/syntax');
var $TypeError = require('es-errors/type');

var IsArray = require('./IsArray');
var IsConstructor = require('./IsConstructor');
var IsTypedArrayOutOfBounds = require('./IsTypedArrayOutOfBounds');
var TypedArrayLength = require('./TypedArrayLength');
var ValidateTypedArray = require('./ValidateTypedArray');

var availableTypedArrays = require('available-typed-arrays')();

// https://262.ecma-international.org/15.0/#typedarraycreatefromconstructor

module.exports = function TypedArrayCreateFromConstructor(constructor, argumentList) {
	if (!IsConstructor(constructor)) {
		throw new $TypeError('Assertion failed: `constructor` must be a constructor');
	}
	if (!IsArray(argumentList)) {
		throw new $TypeError('Assertion failed: `argumentList` must be a List');
	}
	if (availableTypedArrays.length === 0) {
		throw new $SyntaxError('Assertion failed: Typed Arrays are not supported in this environment');
	}

	// var newTypedArray = Construct(constructor, argumentList); // step 1
	var newTypedArray;
	if (argumentList.length === 0) {
		newTypedArray = new constructor();
	} else if (argumentList.length === 1) {
		newTypedArray = new constructor(argumentList[0]);
	} else if (argumentList.length === 2) {
		newTypedArray = new constructor(argumentList[0], argumentList[1]);
	} else {
		newTypedArray = new constructor(argumentList[0], argumentList[1], argumentList[2]);
	}

	var taRecord = ValidateTypedArray(newTypedArray, 'SEQ-CST'); // step 2

	if (argumentList.length === 1 && typeof argumentList[0] === 'number') { // step 3
		if (IsTypedArrayOutOfBounds(taRecord)) {
			throw new $TypeError('new Typed Array is out of bounds'); // step 3.a
		}
		var length = TypedArrayLength(taRecord); // step 3.b
		if (length < argumentList[0]) {
			throw new $TypeError('`argumentList[0]` must be <= `newTypedArray.length`'); // step 3.c
		}
	}

	return newTypedArray; // step 4
};
'use strict';

var $SyntaxError = require('es-errors/syntax');
var $TypeError = require('es-errors/type');

var whichTypedArray = require('which-typed-array');
var availableTypedArrays = require('available-typed-arrays')();

var IsArray = require('./IsArray');
var TypedArrayCreateFromConstructor = require('./TypedArrayCreateFromConstructor');

var getConstructor = require('../helpers/typedArrayConstructors');

// https://262.ecma-international.org/15.0/#sec-typedarray-create-same-type

module.exports = function TypedArrayCreateSameType(exemplar, argumentList) {
	if (availableTypedArrays.length === 0) {
		throw new $SyntaxError('Assertion failed: Typed Arrays are not supported in this environment');
	}

	var kind = whichTypedArray(exemplar);
	if (!kind) {
		throw new $TypeError('Assertion failed: exemplar must be a TypedArray'); // step 1
	}
	if (!IsArray(argumentList)) {
		throw new $TypeError('Assertion failed: `argumentList` must be a List'); // step 1
	}

	var constructor = getConstructor(kind); // step 2
	if (typeof constructor !== 'function') {
		throw new $SyntaxError('Assertion failed: `constructor` of `exemplar` (' + kind + ') must exist. Please report this!');
	}

	return TypedArrayCreateFromConstructor(constructor, argumentList); // steps 3 - 6
};
'use strict';

var $SyntaxError = require('es-errors/syntax');
var $TypeError = require('es-errors/type');
var isInteger = require('math-intrinsics/isInteger');
var whichTypedArray = require('which-typed-array');

// https://262.ecma-international.org/13.0/#sec-typedarrayelementsize

var tableTAO = require('./tables/typed-array-objects');

module.exports = function TypedArrayElementSize(O) {
	var type = whichTypedArray(O);
	if (!type) {
		throw new $TypeError('Assertion failed: `O` must be a TypedArray');
	}
	var size = tableTAO.size['$' + tableTAO.name['$' + type]];
	if (!isInteger(size) || size < 0) {
		throw new $SyntaxError('Assertion failed: Unknown TypedArray type `' + type + '`');
	}

	return size;
};
'use strict';

var $SyntaxError = require('es-errors/syntax');
var $TypeError = require('es-errors/type');

var whichTypedArray = require('which-typed-array');

// https://262.ecma-international.org/13.0/#sec-typedarrayelementtype

var tableTAO = require('./tables/typed-array-objects');

module.exports = function TypedArrayElementType(O) {
	var type = whichTypedArray(O);
	if (!type) {
		throw new $TypeError('Assertion failed: `O` must be a TypedArray');
	}
	var result = tableTAO.name['$' + type];
	if (typeof result !== 'string') {
		throw new $SyntaxError('Assertion failed: Unknown TypedArray type `' + type + '`');
	}

	return result;
};
'use strict';

var $TypeError = require('es-errors/type');

var GetValueFromBuffer = require('./GetValueFromBuffer');
var IsValidIntegerIndex = require('./IsValidIntegerIndex');
var TypedArrayElementSize = require('./TypedArrayElementSize');
var TypedArrayElementType = require('./TypedArrayElementType');

var isTypedArray = require('is-typed-array');
var typedArrayBuffer = require('typed-array-buffer');
var typedArrayByteOffset = require('typed-array-byte-offset');

// https://262.ecma-international.org/15.0/#sec-typedarraygetelement

module.exports = function TypedArrayGetElement(O, index) {
	if (!isTypedArray(O)) {
		throw new $TypeError('Assertion failed: `O` must be a TypedArray instance');
	}
	if (typeof index !== 'number') {
		throw new $TypeError('Assertion failed: `index` must be a Number');
	}

	if (!IsValidIntegerIndex(O, index)) {
		return undefined; // step 1
	}

	var offset = typedArrayByteOffset(O); // step 2

	var elementSize = TypedArrayElementSize(O); // step 3

	var byteIndexInBuffer = (index * elementSize) + offset; // step 4

	var elementType = TypedArrayElementType(O); // step 5

	return GetValueFromBuffer(typedArrayBuffer(O), byteIndexInBuffer, elementType, true, 'UNORDERED'); // step 6
};
'use strict';

var $TypeError = require('es-errors/type');

var floor = require('./floor');
var IsFixedLengthArrayBuffer = require('./IsFixedLengthArrayBuffer');
var IsTypedArrayOutOfBounds = require('./IsTypedArrayOutOfBounds');
var TypedArrayElementSize = require('./TypedArrayElementSize');

var isTypedArrayWithBufferWitnessRecord = require('../helpers/records/typed-array-with-buffer-witness-record');

var typedArrayBuffer = require('typed-array-buffer');
var typedArrayByteOffset = require('typed-array-byte-offset');
var typedArrayLength = require('typed-array-length');

// https://www.ecma-international.org/ecma-262/15.0/#sec-typedarraylength

module.exports = function TypedArrayLength(taRecord) {
	if (!isTypedArrayWithBufferWitnessRecord(taRecord)) {
		throw new $TypeError('Assertion failed: `taRecord` must be a TypedArray With Buffer Witness Record');
	}

	if (IsTypedArrayOutOfBounds(taRecord)) {
		throw new $TypeError('Assertion failed: `taRecord` is out of bounds'); // step 1
	}

	var O = taRecord['[[Object]]']; // step 2

	var isFixed = IsFixedLengthArrayBuffer(typedArrayBuffer(O));

	var length = isFixed ? typedArrayLength(O) : 'AUTO';
	if (length !== 'AUTO') {
		return length; // step 3
	}

	if (isFixed) {
		throw new $TypeError('Assertion failed: array buffer is not fixed length'); // step 4
	}

	var byteOffset = typedArrayByteOffset(O); // step 5

	var elementSize = TypedArrayElementSize(O); // step 6

	var byteLength = taRecord['[[CachedBufferByteLength]]']; // step 7

	if (byteLength === 'DETACHED') {
		throw new $TypeError('Assertion failed: typed array is detached'); // step 8
	}

	return floor((byteLength - byteOffset) / elementSize); // step 9
};
'use strict';

var $TypeError = require('es-errors/type');

var IsValidIntegerIndex = require('./IsValidIntegerIndex');
var SetValueInBuffer = require('./SetValueInBuffer');
var ToBigInt = require('./ToBigInt');
var ToNumber = require('./ToNumber');
var TypedArrayElementSize = require('./TypedArrayElementSize');
var TypedArrayElementType = require('./TypedArrayElementType');

var typedArrayBuffer = require('typed-array-buffer');
var typedArrayByteOffset = require('typed-array-byte-offset');
var whichTypedArray = require('which-typed-array');

// http://www.ecma-international.org/ecma-262/15.0/#sec-typedarraysetelement

module.exports = function TypedArraySetElement(O, index, value) {
	var which = whichTypedArray(O);
	if (!which) {
		throw new $TypeError('Assertion failed: `O` must be a Typed Array');
	}
	if (typeof index !== 'number') {
		throw new $TypeError('Assertion failed: `index` must be a Number');
	}

	var contentType = which === 'BigInt64Array' || which === 'BigUint64Array' ? 'BIGINT' : 'NUMBER';

	var numValue = contentType === 'BIGINT' ? ToBigInt(value) : ToNumber(value); // steps 1 - 2

	if (IsValidIntegerIndex(O, index)) { // step 3
		var offset = typedArrayByteOffset(O); // step 3.a

		var elementSize = TypedArrayElementSize(O); // step 3.b

		var byteIndexInBuffer = (index * elementSize) + offset; // step 3.c

		var elementType = TypedArrayElementType(O); // step 3.d

		SetValueInBuffer(typedArrayBuffer(O), byteIndexInBuffer, elementType, numValue, true, 'UNORDERED'); // step 3.e
	}
};
'use strict';

var $SyntaxError = require('es-errors/syntax');
var $TypeError = require('es-errors/type');

var whichTypedArray = require('which-typed-array');
var availableTypedArrays = require('available-typed-arrays')();

var IsArray = require('./IsArray');
var SpeciesConstructor = require('./SpeciesConstructor');
var TypedArrayCreateFromConstructor = require('./TypedArrayCreateFromConstructor');

var getConstructor = require('../helpers/typedArrayConstructors');

// https://262.ecma-international.org/15.0/#typedarray-species-create

module.exports = function TypedArraySpeciesCreate(exemplar, argumentList) {
	if (availableTypedArrays.length === 0) {
		throw new $SyntaxError('Assertion failed: Typed Arrays are not supported in this environment');
	}

	var kind = whichTypedArray(exemplar);
	if (!kind) {
		throw new $TypeError('Assertion failed: exemplar must be a TypedArray'); // step 1
	}
	if (!IsArray(argumentList)) {
		throw new $TypeError('Assertion failed: `argumentList` must be a List'); // step 1
	}

	var defaultConstructor = getConstructor(kind); // step 2
	if (typeof defaultConstructor !== 'function') {
		throw new $SyntaxError('Assertion failed: `constructor` of `exemplar` (' + kind + ') must exist. Please report this!');
	}
	var constructor = SpeciesConstructor(exemplar, defaultConstructor); // step 3

	return TypedArrayCreateFromConstructor(constructor, argumentList); // step 4
};
'use strict';

var ES5Type = require('../5/Type');

// https://262.ecma-international.org/11.0/#sec-ecmascript-data-types-and-values

module.exports = function Type(x) {
	if (typeof x === 'symbol') {
		return 'Symbol';
	}
	if (typeof x === 'bigint') {
		return 'BigInt';
	}
	return ES5Type(x);
};
'use strict';

var $TypeError = require('es-errors/type');

var callBound = require('call-bound');

var $charCodeAt = callBound('String.prototype.charCodeAt');
var $numberToString = callBound('Number.prototype.toString');
var $toLowerCase = callBound('String.prototype.toLowerCase');

var StringPad = require('./StringPad');

// https://262.ecma-international.org/11.0/#sec-unicodeescape

module.exports = function UnicodeEscape(C) {
	if (typeof C !== 'string' || C.length !== 1) {
		throw new $TypeError('Assertion failed: `C` must be a single code unit');
	}
	var n = $charCodeAt(C, 0);
	if (n > 0xFFFF) {
		throw new $TypeError('`Assertion failed: numeric value of `C` must be <= 0xFFFF');
	}

	return '\\u' + StringPad($toLowerCase($numberToString(n, 16)), 4, '0', 'start');
};
'use strict';

var GetIntrinsic = require('get-intrinsic');

var $TypeError = require('es-errors/type');
var $fromCharCode = GetIntrinsic('%String.fromCharCode%');

var floor = require('./floor');
var modulo = require('./modulo');

var isCodePoint = require('../helpers/isCodePoint');

// https://262.ecma-international.org/12.0/#sec-utf16encoding

module.exports = function UTF16EncodeCodePoint(cp) {
	if (!isCodePoint(cp)) {
		throw new $TypeError('Assertion failed: `cp` must be >= 0 and <= 0x10FFFF');
	}
	if (cp <= 65535) {
		return $fromCharCode(cp);
	}
	var cu1 = $fromCharCode(floor((cp - 65536) / 1024) + 0xD800);
	var cu2 = $fromCharCode(modulo(cp - 65536, 1024) + 0xDC00);
	return cu1 + cu2;
};
'use strict';

var GetIntrinsic = require('get-intrinsic');

var $TypeError = require('es-errors/type');
var $fromCharCode = GetIntrinsic('%String.fromCharCode%');

var isLeadingSurrogate = require('../helpers/isLeadingSurrogate');
var isTrailingSurrogate = require('../helpers/isTrailingSurrogate');

// https://262.ecma-international.org/12.0/#sec-utf16decodesurrogatepair

module.exports = function UTF16SurrogatePairToCodePoint(lead, trail) {
	if (!isLeadingSurrogate(lead) || !isTrailingSurrogate(trail)) {
		throw new $TypeError('Assertion failed: `lead` must be a leading surrogate char code, and `trail` must be a trailing surrogate char code');
	}
	// var cp = (lead - 0xD800) * 0x400 + (trail - 0xDC00) + 0x10000;
	return $fromCharCode(lead) + $fromCharCode(trail);
};
'use strict';

var $TypeError = require('es-errors/type');
var isObject = require('es-object-atoms/isObject');

var DefineOwnProperty = require('../helpers/DefineOwnProperty');
var isFullyPopulatedPropertyDescriptor = require('../helpers/isFullyPopulatedPropertyDescriptor');
var isPropertyDescriptor = require('../helpers/records/property-descriptor');

var FromPropertyDescriptor = require('./FromPropertyDescriptor');
var IsAccessorDescriptor = require('./IsAccessorDescriptor');
var IsDataDescriptor = require('./IsDataDescriptor');
var IsGenericDescriptor = require('./IsGenericDescriptor');
var isPropertyKey = require('../helpers/isPropertyKey');
var SameValue = require('./SameValue');

// https://262.ecma-international.org/13.0/#sec-validateandapplypropertydescriptor

// see https://github.com/tc39/ecma262/pull/2468 for ES2022 changes

// eslint-disable-next-line max-lines-per-function, max-statements
module.exports = function ValidateAndApplyPropertyDescriptor(O, P, extensible, Desc, current) {
	if (typeof O !== 'undefined' && !isObject(O)) {
		throw new $TypeError('Assertion failed: O must be undefined or an Object');
	}
	if (!isPropertyKey(P)) {
		throw new $TypeError('Assertion failed: P must be a Property Key');
	}
	if (typeof extensible !== 'boolean') {
		throw new $TypeError('Assertion failed: extensible must be a Boolean');
	}
	if (!isPropertyDescriptor(Desc)) {
		throw new $TypeError('Assertion failed: Desc must be a Property Descriptor');
	}
	if (typeof current !== 'undefined' && !isPropertyDescriptor(current)) {
		throw new $TypeError('Assertion failed: current must be a Property Descriptor, or undefined');
	}

	if (typeof current === 'undefined') { // step 2
		if (!extensible) {
			return false; // step 2.a
		}
		if (typeof O === 'undefined') {
			return true; // step 2.b
		}
		if (IsAccessorDescriptor(Desc)) { // step 2.c
			return DefineOwnProperty(
				IsDataDescriptor,
				SameValue,
				FromPropertyDescriptor,
				O,
				P,
				Desc
			);
		}
		// step 2.d
		return DefineOwnProperty(
			IsDataDescriptor,
			SameValue,
			FromPropertyDescriptor,
			O,
			P,
			{
				'[[Configurable]]': !!Desc['[[Configurable]]'],
				'[[Enumerable]]': !!Desc['[[Enumerable]]'],
				'[[Value]]': Desc['[[Value]]'],
				'[[Writable]]': !!Desc['[[Writable]]']
			}
		);
	}

	// 3. Assert: current is a fully populated Property Descriptor.
	if (
		!isFullyPopulatedPropertyDescriptor(
			{
				IsAccessorDescriptor: IsAccessorDescriptor,
				IsDataDescriptor: IsDataDescriptor
			},
			current
		)
	) {
		throw new $TypeError('`current`, when present, must be a fully populated and valid Property Descriptor');
	}

	// 4. If every field in Desc is absent, return true.
	// this can't really match the assertion that it's a Property Descriptor in our JS implementation

	// 5. If current.[[Configurable]] is false, then
	if (!current['[[Configurable]]']) {
		if ('[[Configurable]]' in Desc && Desc['[[Configurable]]']) {
			// step 5.a
			return false;
		}
		if ('[[Enumerable]]' in Desc && !SameValue(Desc['[[Enumerable]]'], current['[[Enumerable]]'])) {
			// step 5.b
			return false;
		}
		if (!IsGenericDescriptor(Desc) && !SameValue(IsAccessorDescriptor(Desc), IsAccessorDescriptor(current))) {
			// step 5.c
			return false;
		}
		if (IsAccessorDescriptor(current)) { // step 5.d
			if ('[[Get]]' in Desc && !SameValue(Desc['[[Get]]'], current['[[Get]]'])) {
				return false;
			}
			if ('[[Set]]' in Desc && !SameValue(Desc['[[Set]]'], current['[[Set]]'])) {
				return false;
			}
		} else if (!current['[[Writable]]']) { // step 5.e
			if ('[[Writable]]' in Desc && Desc['[[Writable]]']) {
				return false;
			}
			if ('[[Value]]' in Desc && !SameValue(Desc['[[Value]]'], current['[[Value]]'])) {
				return false;
			}
		}
	}

	// 6. If O is not undefined, then
	if (typeof O !== 'undefined') {
		var configurable;
		var enumerable;
		if (IsDataDescriptor(current) && IsAccessorDescriptor(Desc)) { // step 6.a
			configurable = ('[[Configurable]]' in Desc ? Desc : current)['[[Configurable]]'];
			enumerable = ('[[Enumerable]]' in Desc ? Desc : current)['[[Enumerable]]'];
			// Replace the property named P of object O with an accessor property having [[Configurable]] and [[Enumerable]] attributes as described by current and each other attribute set to its default value.
			return DefineOwnProperty(
				IsDataDescriptor,
				SameValue,
				FromPropertyDescriptor,
				O,
				P,
				{
					'[[Configurable]]': !!configurable,
					'[[Enumerable]]': !!enumerable,
					'[[Get]]': ('[[Get]]' in Desc ? Desc : current)['[[Get]]'],
					'[[Set]]': ('[[Set]]' in Desc ? Desc : current)['[[Set]]']
				}
			);
		} else if (IsAccessorDescriptor(current) && IsDataDescriptor(Desc)) {
			configurable = ('[[Configurable]]' in Desc ? Desc : current)['[[Configurable]]'];
			enumerable = ('[[Enumerable]]' in Desc ? Desc : current)['[[Enumerable]]'];
			// i. Replace the property named P of object O with a data property having [[Configurable]] and [[Enumerable]] attributes as described by current and each other attribute set to its default value.
			return DefineOwnProperty(
				IsDataDescriptor,
				SameValue,
				FromPropertyDescriptor,
				O,
				P,
				{
					'[[Configurable]]': !!configurable,
					'[[Enumerable]]': !!enumerable,
					'[[Value]]': ('[[Value]]' in Desc ? Desc : current)['[[Value]]'],
					'[[Writable]]': !!('[[Writable]]' in Desc ? Desc : current)['[[Writable]]']
				}
			);
		}

		// For each field of Desc that is present, set the corresponding attribute of the property named P of object O to the value of the field.
		return DefineOwnProperty(
			IsDataDescriptor,
			SameValue,
			FromPropertyDescriptor,
			O,
			P,
			Desc
		);
	}

	return true; // step 7
};
'use strict';

var $RangeError = require('es-errors/range');
var $TypeError = require('es-errors/type');

var ToIndex = require('./ToIndex');
var TypedArrayElementSize = require('./TypedArrayElementSize');
var TypedArrayLength = require('./TypedArrayLength');

var isTypedArrayWithBufferWitnessRecord = require('../helpers/records/typed-array-with-buffer-witness-record');

var typedArrayByteOffset = require('typed-array-byte-offset');

// https://262.ecma-international.org/15.0/#sec-validateatomicaccess

module.exports = function ValidateAtomicAccess(taRecord, requestIndex) {
	if (!isTypedArrayWithBufferWitnessRecord(taRecord)) {
		throw new $TypeError('Assertion failed: `taRecord` must be a TypedArray With Buffer Witness Record');
	}

	var length = TypedArrayLength(taRecord); // step 1

	var accessIndex = ToIndex(requestIndex); // step 2

	/*
	// this assertion can never be reached
	if (!(accessIndex >= 0)) {
		throw new $TypeError('Assertion failed: accessIndex >= 0'); // step 4
	}
	*/

	if (accessIndex >= length) {
		throw new $RangeError('index out of range'); // step 4
	}

	var typedArray = taRecord['[[Object]]']; // step 5

	var elementSize = TypedArrayElementSize(typedArray); // step 6

	var offset = typedArrayByteOffset(typedArray); // step 7

	return (accessIndex * elementSize) + offset; // step 8
};
'use strict';

var $TypeError = require('es-errors/type');

var ValidateAtomicAccess = require('./ValidateAtomicAccess');
var ValidateIntegerTypedArray = require('./ValidateIntegerTypedArray');

// https://262.ecma-international.org/15.0/#sec-availablenamedtimezoneidentifiers

module.exports = function ValidateAtomicAccessOnIntegerTypedArray(typedArray, requestIndex) {
	var waitable = arguments.length > 2 ? arguments[2] : false; // step 1

	if (typeof waitable !== 'boolean') {
		throw new $TypeError('waitable must be a boolean');
	}

	var taRecord = ValidateIntegerTypedArray(typedArray, waitable); // step 2
	return ValidateAtomicAccess(taRecord, requestIndex); // step 3
};
'use strict';

var $TypeError = require('es-errors/type');

var IsBigIntElementType = require('./IsBigIntElementType');
var IsUnclampedIntegerElementType = require('./IsUnclampedIntegerElementType');
var TypedArrayElementType = require('./TypedArrayElementType');
var ValidateTypedArray = require('./ValidateTypedArray');

// https://262.ecma-international.org/15.0/#sec-validateintegertypedarray

module.exports = function ValidateIntegerTypedArray(typedArray, waitable) {
	if (typeof waitable !== 'boolean') {
		throw new $TypeError('Assertion failed: `waitable` must be a Boolean');
	}

	var taRecord = ValidateTypedArray(typedArray, 'UNORDERED'); // step 1

	// 2. NOTE: Bounds checking is not a synchronizing operation when typedArray's backing buffer is a growable SharedArrayBuffer.

	var type = TypedArrayElementType(typedArray); // step 4.a
	if (waitable) { // step 3
		if (type !== 'INT32' && type !== 'BIGINT64') {
			throw new $TypeError('Assertion failed: `typedArray` must be an Int32Array or BigInt64Array when `waitable` is true'); // step 5.a
		}
	} else if (!IsUnclampedIntegerElementType(type) && !IsBigIntElementType(type)) { // step 4
		throw new $TypeError('Assertion failed: `typedArray` must be an integer TypedArray'); // step 4.b
	}

	return taRecord; // step 5
};
'use strict';

var $TypeError = require('es-errors/type');
var isObject = require('es-object-atoms/isObject');

var IsTypedArrayOutOfBounds = require('./IsTypedArrayOutOfBounds');
var MakeTypedArrayWithBufferWitnessRecord = require('./MakeTypedArrayWithBufferWitnessRecord');

var isTypedArray = require('is-typed-array');

// https://262.ecma-international.org/15.0/#sec-validatetypedarray

module.exports = function ValidateTypedArray(O, order) {
	if (order !== 'SEQ-CST' && order !== 'UNORDERED') {
		throw new $TypeError('Assertion failed: `order` must be ~SEQ-CST~ or ~UNORDERED~');
	}

	if (!isObject(O)) {
		throw new $TypeError('Assertion failed: `O` must be an Object'); // step 1
	}
	if (!isTypedArray(O)) {
		throw new $TypeError('Assertion failed: `O` must be a Typed Array'); // steps 1 - 2
	}

	var taRecord = MakeTypedArrayWithBufferWitnessRecord(O, order); // step 3

	if (IsTypedArrayOutOfBounds(taRecord)) {
		throw new $TypeError('`O` must be in-bounds and backed by a non-detached buffer'); // step 4
	}

	return taRecord; // step 5
};
'use strict';

var callBound = require('call-bound');

var $TypeError = require('es-errors/type');
var $deref = callBound('WeakRef.prototype.deref', true);

var isWeakRef = require('is-weakref');

var AddToKeptObjects = require('./AddToKeptObjects');

// https://262.ecma-international.org/12.0/#sec-weakrefderef

module.exports = function WeakRefDeref(weakRef) {
	if (!isWeakRef(weakRef)) {
		throw new $TypeError('Assertion failed: `weakRef` must be a WeakRef');
	}
	var target = $deref(weakRef);
	if (target) {
		AddToKeptObjects(target);
	}
	return target;
};
'use strict';

var Day = require('./Day');
var modulo = require('./modulo');

// https://262.ecma-international.org/5.1/#sec-15.9.1.6

module.exports = function WeekDay(t) {
	return modulo(Day(t) + 4, 7);
};
'use strict';

var $TypeError = require('es-errors/type');

var callBound = require('call-bound');
var $indexOf = callBound('String.prototype.indexOf');

var Canonicalize = require('./Canonicalize');

var caseFolding = require('../helpers/caseFolding.json');
var forEach = require('../helpers/forEach');
var isRegExpRecord = require('../helpers/records/regexp-record');
var OwnPropertyKeys = require('own-keys');

var basicWordChars = 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789_'; // step 1

// https://262.ecma-international.org/14.0/#sec-runtime-semantics-wordcharacters-abstract-operation

module.exports = function WordCharacters(rer) {
	if (!isRegExpRecord(rer)) {
		throw new $TypeError('Assertion failed: `rer` must be a RegExp Record');
	}

	var extraWordChars = '';
	forEach(OwnPropertyKeys(caseFolding.C), function (c) {
		if (
			$indexOf(basicWordChars, c) === -1 // c not in A
			&& $indexOf(basicWordChars, Canonicalize(rer, c)) > -1 // canonicalized c IS in A
		) {
			extraWordChars += caseFolding.C[c]; // step 3
		}
	});
	forEach(OwnPropertyKeys(caseFolding.S), function (c) {
		if (
			$indexOf(basicWordChars, c) === -1 // c not in A
			&& $indexOf(basicWordChars, Canonicalize(rer, c)) > -1 // canonicalized c IS in A
		) {
			extraWordChars += caseFolding.S[c]; // step 3
		}
	});

	if ((!rer['[[Unicode]]'] || !rer['[[IgnoreCase]]']) && extraWordChars.length > 0) {
		throw new $TypeError('Assertion failed: `extraWordChars` must be empty when `rer.[[IgnoreCase]]` and `rer.[[Unicode]]` are not both true'); // step 3
	}

	return basicWordChars + extraWordChars; // step 4
};
'use strict';

var GetIntrinsic = require('get-intrinsic');

var $Date = GetIntrinsic('%Date%');

var callBound = require('call-bound');

var $getUTCFullYear = callBound('Date.prototype.getUTCFullYear');

// https://262.ecma-international.org/5.1/#sec-15.9.1.3

module.exports = function YearFromTime(t) {
	// largest y such that this.TimeFromYear(y) <= t
	return $getUTCFullYear(new $Date(t));
};
'use strict';

var $abs = require('math-intrinsics/abs');

// https://262.ecma-international.org/11.0/#eqn-abs

module.exports = function abs(x) {
	return typeof x === 'bigint' ? BigInt($abs(Number(x))) : $abs(x);
};
'use strict';

var $TypeError = require('es-errors/type');
var isObject = require('es-object-atoms/isObject');
var inspect = require('object-inspect');

var Call = require('./Call');
var Get = require('./Get');
var GetIterator = require('./GetIterator');
var IsCallable = require('./IsCallable');
var IteratorClose = require('./IteratorClose');
var IteratorStep = require('./IteratorStep');
var IteratorValue = require('./IteratorValue');
var ThrowCompletion = require('./ThrowCompletion');

// https://262.ecma-international.org/15.0/#sec-add-entries-from-iterable

module.exports = function AddEntriesFromIterable(target, iterable, adder) {
	if (!IsCallable(adder)) {
		throw new $TypeError('Assertion failed: `adder` is not callable');
	}
	if (iterable == null) {
		throw new $TypeError('Assertion failed: `iterable` is present, and not nullish');
	}
	var iteratorRecord = GetIterator(iterable, 'SYNC');
	while (true) { // eslint-disable-line no-constant-condition
		var next = IteratorStep(iteratorRecord);
		if (!next) {
			return target;
		}
		var nextItem = IteratorValue(next);
		if (!isObject(nextItem)) {
			var error = ThrowCompletion(new $TypeError('iterator next must return an Object, got ' + inspect(nextItem)));
			return IteratorClose(iteratorRecord, error);
		}
		try {
			var k = Get(nextItem, '0');
			var v = Get(nextItem, '1');
			Call(adder, target, [k, v]);
		} catch (e) {
			return IteratorClose(iteratorRecord, ThrowCompletion(e));
		}
	}
};
'use strict';

var SLOT = require('internal-slot');

var $TypeError = require('es-errors/type');
var isObject = require('es-object-atoms/isObject');

var ClearKeptObjects = require('./ClearKeptObjects');

// https://262.ecma-international.org/12.0/#sec-addtokeptobjects

module.exports = function AddToKeptObjects(object) {
	if (!isObject(object)) {
		throw new $TypeError('Assertion failed: `object` must be an Object');
	}
	var arr = SLOT.get(ClearKeptObjects, '[[es-abstract internal: KeptAlive]]');
	arr[arr.length] = object;
};
'use strict';

var $TypeError = require('es-errors/type');

var SameValue = require('./SameValue');

var IsArray = require('../helpers/IsArray');
var every = require('../helpers/every');
var forEach = require('../helpers/forEach');

var hasOwn = require('hasown');

var isKeyedGroup = function (group) {
	return hasOwn(group, '[[Key]]')
        && hasOwn(group, '[[Elements]]')
        && IsArray(group['[[Elements]]']);
};

// https://262.ecma-international.org/15.0/#sec-add-value-to-keyed-group

module.exports = function AddValueToKeyedGroup(groups, key, value) {
	if (!IsArray(groups) || (groups.length > 0 && !every(groups, isKeyedGroup))) {
		throw new $TypeError('Assertion failed: `groups` must be a List of Records with [[Key]] and [[Elements]]');
	}

	var matched = 0;
	forEach(groups, function (g) { // step 1
		if (SameValue(g['[[Key]]'], key)) { // step 2
			matched += 1;
			if (matched > 1) {
				throw new $TypeError('Assertion failed: Exactly one element of groups meets this criterion'); // step 2.a
			}

			var arr = g['[[Elements]]'];
			arr[arr.length] = value; // step 2.b
		}
	});

	if (matched === 0) {
		var group = { '[[Key]]': key, '[[Elements]]': [value] }; // step 2

		// eslint-disable-next-line no-param-reassign
		groups[groups.length] = group; // step 3
	}
};
'use strict';

var CodePointAt = require('./CodePointAt');

var $TypeError = require('es-errors/type');
var isInteger = require('math-intrinsics/isInteger');
var MAX_SAFE_INTEGER = require('math-intrinsics/constants/maxSafeInteger');

// https://262.ecma-international.org/12.0/#sec-advancestringindex

module.exports = function AdvanceStringIndex(S, index, unicode) {
	if (typeof S !== 'string') {
		throw new $TypeError('Assertion failed: `S` must be a String');
	}
	if (!isInteger(index) || index < 0 || index > MAX_SAFE_INTEGER) {
		throw new $TypeError('Assertion failed: `length` must be an integer >= 0 and <= 2**53');
	}
	if (typeof unicode !== 'boolean') {
		throw new $TypeError('Assertion failed: `unicode` must be a Boolean');
	}
	if (!unicode) {
		return index + 1;
	}
	var length = S.length;
	if ((index + 1) >= length) {
		return index + 1;
	}
	var cp = CodePointAt(S, index);
	return index + cp['[[CodeUnitCount]]'];
};
'use strict';

var $TypeError = require('es-errors/type');

var HasEitherUnicodeFlag = require('./HasEitherUnicodeFlag');

var isRegExpRecord = require('../helpers/records/regexp-record');

var CharSet = require('../helpers/CharSet');

// https://262.ecma-international.org/15.0/#sec-allcharacters

module.exports = function AllCharacters(rer) {
	if (!isRegExpRecord(rer)) {
		throw new $TypeError('Assertion failed: `rer` must be a RegExp Record');
	}

	if (rer['[[UnicodeSets]]'] && rer['[[IgnoreCase]]']) { // step 1
		//   1. Return the CharSet containing all Unicode code points _c_ that do not have a <a href="https://www.unicode.org/reports/tr44/#Simple_Case_Folding">Simple Case Folding</a> mapping (that is, scf(_c_)=_c_).
		return CharSet.getNonSimpleCaseFoldingCodePoints(); // step 1.a
	} else if (HasEitherUnicodeFlag(rer)) { // step 2
		//   1. Return the CharSet containing all code point values.
		return CharSet.getCodePoints(); // step 3.a
	// eslint-disable-next-line no-else-return
	} else { // step 3
		//   1. Return the CharSet containing all code unit values.
		return CharSet.getCodeUnits(); // step 3.a
	}
};
'use strict';

var $TypeError = require('es-errors/type');

var HasOwnProperty = require('./HasOwnProperty');
var SameType = require('./SameType');
var ToNumeric = require('./ToNumeric');
var ToPrimitive = require('./ToPrimitive');
var ToString = require('./ToString');

var NumberAdd = require('./Number/add');
var NumberBitwiseAND = require('./Number/bitwiseAND');
var NumberBitwiseOR = require('./Number/bitwiseOR');
var NumberBitwiseXOR = require('./Number/bitwiseXOR');
var NumberDivide = require('./Number/divide');
var NumberExponentiate = require('./Number/exponentiate');
var NumberLeftShift = require('./Number/leftShift');
var NumberMultiply = require('./Number/multiply');
var NumberRemainder = require('./Number/remainder');
var NumberSignedRightShift = require('./Number/signedRightShift');
var NumberSubtract = require('./Number/subtract');
var NumberUnsignedRightShift = require('./Number/unsignedRightShift');
var BigIntAdd = require('./BigInt/add');
var BigIntBitwiseAND = require('./BigInt/bitwiseAND');
var BigIntBitwiseOR = require('./BigInt/bitwiseOR');
var BigIntBitwiseXOR = require('./BigInt/bitwiseXOR');
var BigIntDivide = require('./BigInt/divide');
var BigIntExponentiate = require('./BigInt/exponentiate');
var BigIntLeftShift = require('./BigInt/leftShift');
var BigIntMultiply = require('./BigInt/multiply');
var BigIntRemainder = require('./BigInt/remainder');
var BigIntSignedRightShift = require('./BigInt/signedRightShift');
var BigIntSubtract = require('./BigInt/subtract');
var BigIntUnsignedRightShift = require('./BigInt/unsignedRightShift');

// https://262.ecma-international.org/16.0/#step-applystringornumericbinaryoperator-operations-table
var table = {
	'**': [NumberExponentiate, BigIntExponentiate],
	'*': [NumberMultiply, BigIntMultiply],
	'/': [NumberDivide, BigIntDivide],
	'%': [NumberRemainder, BigIntRemainder],
	'+': [NumberAdd, BigIntAdd],
	'-': [NumberSubtract, BigIntSubtract],
	'<<': [NumberLeftShift, BigIntLeftShift],
	'>>': [NumberSignedRightShift, BigIntSignedRightShift],
	'>>>': [NumberUnsignedRightShift, BigIntUnsignedRightShift],
	'&': [NumberBitwiseAND, BigIntBitwiseAND],
	'^': [NumberBitwiseXOR, BigIntBitwiseXOR],
	'|': [NumberBitwiseOR, BigIntBitwiseOR]
};

// https://262.ecma-international.org/16.0/#sec-applystringornumericbinaryoperator

module.exports = function ApplyStringOrNumericBinaryOperator(lval, opText, rval) {
	if (typeof opText !== 'string' || !HasOwnProperty(table, opText)) {
		throw new $TypeError('Assertion failed: `opText` must be a valid operation string');
	}
	if (opText === '+') {
		var lprim = ToPrimitive(lval);
		var rprim = ToPrimitive(rval);
		if (typeof lprim === 'string' || typeof rprim === 'string') {
			var lstr = ToString(lprim);
			var rstr = ToString(rprim);
			return lstr + rstr;
		}
		/* eslint no-param-reassign: 1 */
		lval = lprim;
		rval = rprim;
	}
	var lnum = ToNumeric(lval);
	var rnum = ToNumeric(rval);
	if (!SameType(lnum, rnum)) {
		throw new $TypeError('types of ' + lnum + ' and ' + rnum + ' differ');
	}
	var Operation = table[opText][typeof lnum === 'bigint' ? 1 : 0];
	return Operation(lnum, rnum);
};
'use strict';

var $TypeError = require('es-errors/type');

// https://262.ecma-international.org/15.0/#sec-arraybufferbytelength

var IsDetachedBuffer = require('./IsDetachedBuffer');

var isArrayBuffer = require('is-array-buffer');
var isSharedArrayBuffer = require('is-shared-array-buffer');
var arrayBufferByteLength = require('array-buffer-byte-length');

var callBound = require('call-bound');
var $sabByteLength = callBound('SharedArrayBuffer.prototype.byteLength', true);

var isGrowable = false; // TODO: support this

module.exports = function ArrayBufferByteLength(arrayBuffer, order) {
	var isSAB = isSharedArrayBuffer(arrayBuffer);
	if (!isArrayBuffer(arrayBuffer) && !isSAB) {
		throw new $TypeError('Assertion failed: `arrayBuffer` must be an ArrayBuffer or a SharedArrayBuffer');
	}
	if (order !== 'SEQ-CST' && order !== 'UNORDERED') {
		throw new $TypeError('Assertion failed: `order` must be ~SEQ-CST~ or ~UNORDERED~');
	}

	// 1. If IsSharedArrayBuffer(arrayBuffer) is true and arrayBuffer has an [[ArrayBufferByteLengthData]] internal slot, then
	// TODO: see if IsFixedLengthArrayBuffer can be used here in the spec instead
	if (isSAB && isGrowable) { // step 1
		// a. Let bufferByteLengthBlock be arrayBuffer.[[ArrayBufferByteLengthData]].
		// b. Let rawLength be GetRawBytesFromSharedBlock(bufferByteLengthBlock, 0, BIGUINT64, true, order).
		// c. Let isLittleEndian be the value of the [[LittleEndian]] field of the surrounding agent's Agent Record.
		// d. Return ℝ(RawBytesToNumeric(BIGUINT64, rawLength, isLittleEndian)).
	}

	if (IsDetachedBuffer(arrayBuffer)) {
		throw new $TypeError('Assertion failed: `arrayBuffer` must not be detached'); // step 2
	}

	return isSAB ? $sabByteLength(arrayBuffer) : arrayBufferByteLength(arrayBuffer);
};
'use strict';

var GetIntrinsic = require('get-intrinsic');

var min = require('math-intrinsics/min');
var $TypeError = require('es-errors/type');
var $ArrayBuffer = GetIntrinsic('%ArrayBuffer%', true);
var $Uint8Array = GetIntrinsic('%Uint8Array%', true);

var callBound = require('call-bound');

var byteLength = require('array-buffer-byte-length');
var $maxByteLength = callBound('%ArrayBuffer.prototype.maxByteLength%', true);
var copy = function copyAB(src, start, end) {
	var that = new $Uint8Array(src);
	if (typeof end === 'undefined') {
		end = that.length; // eslint-disable-line no-param-reassign
	}
	var result = new $ArrayBuffer(end - start);
	var resultArray = new $Uint8Array(result);
	for (var i = 0; i < resultArray.length; i++) {
		resultArray[i] = that[i + start];
	}
	return result;
};
var $abSlice = callBound('%ArrayBuffer.prototype.slice%', true)
	|| function slice(ab, a, b) { // in node < 0.11, slice is an own nonconfigurable property
		return ab.slice ? ab.slice(a, b) : copy(ab, a, b); // node 0.8 lacks `slice`
	};

var DetachArrayBuffer = require('./DetachArrayBuffer');
var IsDetachedBuffer = require('./IsDetachedBuffer');
var IsFixedLengthArrayBuffer = require('./IsFixedLengthArrayBuffer');
var ToIndex = require('./ToIndex');

var isArrayBuffer = require('is-array-buffer');
var isSharedArrayBuffer = require('is-shared-array-buffer');

// https://262.ecma-international.org/15.0/#sec-arraybuffercopyanddetach

module.exports = function ArrayBufferCopyAndDetach(arrayBuffer, newLength, preserveResizability) {
	if (preserveResizability !== 'PRESERVE-RESIZABILITY' && preserveResizability !== 'FIXED-LENGTH') {
		throw new $TypeError('`preserveResizability` must be ~PRESERVE-RESIZABILITY~ or ~FIXED-LENGTH~');
	}

	if (!isArrayBuffer(arrayBuffer) || isSharedArrayBuffer(arrayBuffer)) {
		throw new $TypeError('`arrayBuffer` must be a non-shared ArrayBuffer'); // steps 1 - 2
	}

	var abByteLength;

	var newByteLength;
	if (typeof newLength === 'undefined') { // step 3
		newByteLength = byteLength(arrayBuffer); // step 3.a
		abByteLength = newByteLength;
	} else { // step 4
		newByteLength = ToIndex(newLength); // step 4.a
	}

	if (IsDetachedBuffer(arrayBuffer)) {
		throw new $TypeError('`arrayBuffer` must not be detached'); // step 5
	}

	var newMaxByteLength;
	if (preserveResizability === 'PRESERVE-RESIZABILITY' && !IsFixedLengthArrayBuffer(arrayBuffer)) { // step 6
		newMaxByteLength = $maxByteLength(arrayBuffer); // step 6.a
	} else { // step 7
		newMaxByteLength = 'EMPTY'; // step 7.a
	}

	// commented out since there's no way to set or access this key

	// 8. If arrayBuffer.[[ArrayBufferDetachKey]] is not undefined, throw a TypeError exception.

	// 9. Let newBuffer be ? AllocateArrayBuffer(%ArrayBuffer%, newByteLength, newMaxByteLength).
	var newBuffer = newMaxByteLength === 'EMPTY' ? new $ArrayBuffer(newByteLength) : new $ArrayBuffer(newByteLength, { maxByteLength: newMaxByteLength });

	if (typeof abByteLength !== 'number') {
		abByteLength = byteLength(arrayBuffer);
	}
	var copyLength = min(newByteLength, abByteLength); // step 10
	if (newByteLength > copyLength || newMaxByteLength !== 'EMPTY') {
		var taNew = new $Uint8Array(newBuffer);
		var taOld = new $Uint8Array(arrayBuffer);
		for (var i = 0; i < copyLength; i++) {
			taNew[i] = taOld[i];
		}
	} else {
		newBuffer = $abSlice(arrayBuffer, 0, copyLength); // ? optimization for when the new buffer will not be larger than the old one
	}
	/*
	11. Let fromBlock be arrayBuffer.[[ArrayBufferData]].
	12. Let toBlock be newBuffer.[[ArrayBufferData]].
	13. Perform CopyDataBlockBytes(toBlock, 0, fromBlock, 0, copyLength).
	14. NOTE: Neither creation of the new Data Block nor copying from the old Data Block are observable. Implementations may implement this method as a zero-copy move or a realloc.
	*/

	DetachArrayBuffer(arrayBuffer); // step 15

	return newBuffer; // step 16
};
'use strict';

var GetIntrinsic = require('get-intrinsic');

var $ArrayPrototype = GetIntrinsic('%Array.prototype%');
var $RangeError = require('es-errors/range');
var $SyntaxError = require('es-errors/syntax');
var $TypeError = require('es-errors/type');
var isInteger = require('math-intrinsics/isInteger');
var MAX_ARRAY_LENGTH = require('math-intrinsics/constants/maxArrayLength');
var $setProto = require('set-proto');

// https://262.ecma-international.org/12.0/#sec-arraycreate

module.exports = function ArrayCreate(length) {
	if (!isInteger(length) || length < 0) {
		throw new $TypeError('Assertion failed: `length` must be an integer Number >= 0');
	}
	if (length > MAX_ARRAY_LENGTH) {
		throw new $RangeError('length is greater than (2**32 - 1)');
	}
	var proto = arguments.length > 1 ? arguments[1] : $ArrayPrototype;
	var A = []; // steps 3, 5
	if (proto !== $ArrayPrototype) { // step 4
		if (!$setProto) {
			throw new $SyntaxError('ArrayCreate: a `proto` argument that is not `Array.prototype` is not supported in an environment that does not support setting the [[Prototype]]');
		}
		$setProto(A, proto);
	}
	if (length !== 0) { // bypasses the need for step 6
		A.length = length;
	}
	/* step 6, the above as a shortcut for the below
	OrdinaryDefineOwnProperty(A, 'length', {
		'[[Configurable]]': false,
		'[[Enumerable]]': false,
		'[[Value]]': length,
		'[[Writable]]': true
	});
	*/
	return A;
};
'use strict';

var $RangeError = require('es-errors/range');
var $TypeError = require('es-errors/type');

var assign = require('object.assign');

var isPropertyDescriptor = require('../helpers/records/property-descriptor');

var IsArray = require('./IsArray');
var IsDataDescriptor = require('./IsDataDescriptor');
var OrdinaryDefineOwnProperty = require('./OrdinaryDefineOwnProperty');
var OrdinaryGetOwnProperty = require('./OrdinaryGetOwnProperty');
var ToNumber = require('./ToNumber');
var ToString = require('./ToString');
var ToUint32 = require('./ToUint32');

// https://262.ecma-international.org/6.0/#sec-arraysetlength

// eslint-disable-next-line max-statements, max-lines-per-function
module.exports = function ArraySetLength(A, Desc) {
	if (!IsArray(A)) {
		throw new $TypeError('Assertion failed: A must be an Array');
	}
	if (!isPropertyDescriptor(Desc)) {
		throw new $TypeError('Assertion failed: Desc must be a Property Descriptor');
	}
	if (!('[[Value]]' in Desc)) {
		return OrdinaryDefineOwnProperty(A, 'length', Desc);
	}
	var newLenDesc = assign({}, Desc);
	var newLen = ToUint32(Desc['[[Value]]']);
	var numberLen = ToNumber(Desc['[[Value]]']);
	if (newLen !== numberLen) {
		throw new $RangeError('Invalid array length');
	}
	newLenDesc['[[Value]]'] = newLen;
	var oldLenDesc = OrdinaryGetOwnProperty(A, 'length');
	if (!IsDataDescriptor(oldLenDesc)) {
		throw new $TypeError('Assertion failed: an array had a non-data descriptor on `length`');
	}
	var oldLen = oldLenDesc['[[Value]]'];
	if (newLen >= oldLen) {
		return OrdinaryDefineOwnProperty(A, 'length', newLenDesc);
	}
	if (!oldLenDesc['[[Writable]]']) {
		return false;
	}
	var newWritable;
	if (!('[[Writable]]' in newLenDesc) || newLenDesc['[[Writable]]']) {
		newWritable = true;
	} else {
		newWritable = false;
		newLenDesc['[[Writable]]'] = true;
	}
	var succeeded = OrdinaryDefineOwnProperty(A, 'length', newLenDesc);
	if (!succeeded) {
		return false;
	}
	while (newLen < oldLen) {
		oldLen -= 1;
		// eslint-disable-next-line no-param-reassign
		var deleteSucceeded = delete A[ToString(oldLen)];
		if (!deleteSucceeded) {
			newLenDesc['[[Value]]'] = oldLen + 1;
			if (!newWritable) {
				newLenDesc['[[Writable]]'] = false;
				OrdinaryDefineOwnProperty(A, 'length', newLenDesc);
				return false;
			}
		}
	}
	if (!newWritable) {
		return OrdinaryDefineOwnProperty(A, 'length', { '[[Writable]]': false });
	}
	return true;
};
'use strict';

var GetIntrinsic = require('get-intrinsic');

var $species = GetIntrinsic('%Symbol.species%', true);
var $TypeError = require('es-errors/type');
var isInteger = require('math-intrinsics/isInteger');
var isObject = require('es-object-atoms/isObject');

var ArrayCreate = require('./ArrayCreate');
var Get = require('./Get');
var IsArray = require('./IsArray');
var IsConstructor = require('./IsConstructor');

// https://262.ecma-international.org/12.0/#sec-arrayspeciescreate

module.exports = function ArraySpeciesCreate(originalArray, length) {
	if (!isInteger(length) || length < 0) {
		throw new $TypeError('Assertion failed: length must be an integer >= 0');
	}

	var isArray = IsArray(originalArray);
	if (!isArray) {
		return ArrayCreate(length);
	}

	var C = Get(originalArray, 'constructor');
	// TODO: figure out how to make a cross-realm normal Array, a same-realm Array
	// if (IsConstructor(C)) {
	// 	if C is another realm's Array, C = undefined
	// 	Object.getPrototypeOf(Object.getPrototypeOf(Object.getPrototypeOf(Array))) === null ?
	// }
	if ($species && isObject(C)) {
		C = Get(C, $species);
		if (C === null) {
			C = void 0;
		}
	}

	if (typeof C === 'undefined') {
		return ArrayCreate(length);
	}
	if (!IsConstructor(C)) {
		throw new $TypeError('C must be a constructor');
	}
	return new C(length); // Construct(C, length);
};

'use strict';

var GetIntrinsic = require('get-intrinsic');

var $SyntaxError = require('es-errors/syntax');
var $TypeError = require('es-errors/type');
var isObject = require('es-object-atoms/isObject');
var $Promise = GetIntrinsic('%Promise%', true);

var callBound = require('call-bound');

var CreateIteratorResultObject = require('./CreateIteratorResultObject');
var IteratorComplete = require('./IteratorComplete');
var IteratorValue = require('./IteratorValue');
var PromiseResolve = require('./PromiseResolve');

var $then = callBound('Promise.prototype.then', true);

// https://262.ecma-international.org/16.0/#sec-asyncfromsynciteratorcontinuation

module.exports = function AsyncFromSyncIteratorContinuation(result) {
	if (!isObject(result)) {
		throw new $TypeError('Assertion failed: Type(O) is not Object');
	}

	if (arguments.length > 1) {
		throw new $SyntaxError('although AsyncFromSyncIteratorContinuation should take a second argument, it is not used in this implementation');
	}

	if (!$Promise) {
		throw new $SyntaxError('This environment does not support Promises.');
	}

	return new $Promise(function (resolve) {
		var done = IteratorComplete(result); // step 2
		var value = IteratorValue(result); // step 4
		var valueWrapper = PromiseResolve($Promise, value); // step 6

		// eslint-disable-next-line no-shadow
		var onFulfilled = function (value) { // steps 8-9
			return CreateIteratorResultObject(value, done); // step 8.a
		};
		resolve($then(valueWrapper, onFulfilled)); // step 11
	}); // step 12
};
'use strict';

var GetIntrinsic = require('get-intrinsic');

var $SyntaxError = require('es-errors/syntax');
var $TypeError = require('es-errors/type');
var isObject = require('es-object-atoms/isObject');
var $Promise = GetIntrinsic('%Promise%', true);

var Call = require('./Call');
var CompletionRecord = require('./CompletionRecord');
var GetMethod = require('./GetMethod');

var isIteratorRecord = require('../helpers/records/iterator-record');

var callBound = require('call-bound');

var $then = callBound('Promise.prototype.then', true);

// https://262.ecma-international.org/15.0/#sec-asynciteratorclose

module.exports = function AsyncIteratorClose(iteratorRecord, completion) {
	if (!isIteratorRecord(iteratorRecord)) {
		throw new $TypeError('Assertion failed: `iteratorRecord` must be an Iterator Record'); // step 1
	}

	if (!(completion instanceof CompletionRecord)) {
		throw new $TypeError('Assertion failed: completion is not a Completion Record instance'); // step 2
	}

	if (!$then) {
		throw new $SyntaxError('This environment does not support Promises.');
	}

	var iterator = iteratorRecord['[[Iterator]]']; // step 3

	return $then(
		$then(
			$then(
				new $Promise(function (resolve) {
					resolve(GetMethod(iterator, 'return')); // step 4
					// resolve(Call(ret, iterator, [])); // step 6
				}),
				function (returnV) { // step 5.a
					if (typeof returnV === 'undefined') {
						return completion; // step 5.b
					}
					return Call(returnV, iterator); // step 5.c, 5.d.
				}
			),
			null,
			function (e) {
				if (completion.type() === 'throw') {
					completion['?'](); // step 6
				} else {
					throw e; // step 7
				}
			}
		),
		function (innerResult) { // step 8
			if (completion.type() === 'throw') {
				completion['?'](); // step 6
			}
			if (!isObject(innerResult)) {
				throw new $TypeError('`innerResult` must be an Object'); // step 10
			}
			return completion;
		}
	);
};
'use strict';

var $TypeError = require('es-errors/type');
// var $BigInt = GetIntrinsic('%BigInt%', true);
// var $pow = require('math-intrinsics/pow');

// var BinaryAnd = require('./BinaryAnd');
// var BinaryOr = require('./BinaryOr');
// var BinaryXor = require('./BinaryXor');
// var modulo = require('./modulo');

// var zero = $BigInt && $BigInt(0);
// var negOne = $BigInt && $BigInt(-1);
// var two = $BigInt && $BigInt(2);

// https://262.ecma-international.org/11.0/#sec-bigintbitwiseop

module.exports = function BigIntBitwiseOp(op, x, y) {
	if (op !== '&' && op !== '|' && op !== '^') {
		throw new $TypeError('Assertion failed: `op` must be `&`, `|`, or `^`');
	}
	if (typeof x !== 'bigint' || typeof y !== 'bigint') {
		throw new $TypeError('`x` and `y` must be BigInts');
	}

	if (op === '&') {
		return x & y;
	}
	if (op === '|') {
		return x | y;
	}
	return x ^ y;
	/*
	var result = zero;
	var shift = 0;
	while (x !== zero && x !== negOne && y !== zero && y !== negOne) {
		var xDigit = modulo(x, two);
		var yDigit = modulo(y, two);
		if (op === '&') {
			result += $pow(2, shift) * BinaryAnd(xDigit, yDigit);
		} else if (op === '|') {
			result += $pow(2, shift) * BinaryOr(xDigit, yDigit);
		} else if (op === '^') {
			result += $pow(2, shift) * BinaryXor(xDigit, yDigit);
		}
		shift += 1;
		x = (x - xDigit) / two;
		y = (y - yDigit) / two;
	}
	var tmp;
	if (op === '&') {
		tmp = BinaryAnd(modulo(x, two), modulo(y, two));
	} else if (op === '|') {
		tmp = BinaryAnd(modulo(x, two), modulo(y, two));
	} else {
		tmp = BinaryXor(modulo(x, two), modulo(y, two));
	}
	if (tmp !== 0) {
		result -= $pow(2, shift);
	}
	return result;
	*/
};
'use strict';

var $TypeError = require('es-errors/type');

// https://262.ecma-international.org/11.0/#sec-binaryand

module.exports = function BinaryAnd(x, y) {
	if ((x !== 0 && x !== 1) || (y !== 0 && y !== 1)) {
		throw new $TypeError('Assertion failed: `x` and `y` must be either 0 or 1');
	}
	return x & y;
};
'use strict';

var $TypeError = require('es-errors/type');

// https://262.ecma-international.org/11.0/#sec-binaryor

module.exports = function BinaryOr(x, y) {
	if ((x !== 0 && x !== 1) || (y !== 0 && y !== 1)) {
		throw new $TypeError('Assertion failed: `x` and `y` must be either 0 or 1');
	}
	return x | y;
};
'use strict';

var $TypeError = require('es-errors/type');

// https://262.ecma-international.org/11.0/#sec-binaryxor

module.exports = function BinaryXor(x, y) {
	if ((x !== 0 && x !== 1) || (y !== 0 && y !== 1)) {
		throw new $TypeError('Assertion failed: `x` and `y` must be either 0 or 1');
	}
	return x ^ y;
};
'use strict';

var $TypeError = require('es-errors/type');

var IsArray = require('./IsArray');

var isByteValue = require('../helpers/isByteValue');

// https://262.ecma-international.org/12.0/#sec-bytelistbitwiseop

module.exports = function ByteListBitwiseOp(op, xBytes, yBytes) {
	if (op !== '&' && op !== '^' && op !== '|') {
		throw new $TypeError('Assertion failed: `op` must be `&`, `^`, or `|`');
	}
	if (!IsArray(xBytes) || !IsArray(yBytes) || xBytes.length !== yBytes.length) {
		throw new $TypeError('Assertion failed: `xBytes` and `yBytes` must be same-length sequences of byte values (an integer 0-255, inclusive)');
	}

	var result = [];

	for (var i = 0; i < xBytes.length; i += 1) {
		var xByte = xBytes[i];
		var yByte = yBytes[i];
		if (!isByteValue(xByte) || !isByteValue(yByte)) {
			throw new $TypeError('Assertion failed: `xBytes` and `yBytes` must be same-length sequences of byte values (an integer 0-255, inclusive)');
		}
		var resultByte;
		if (op === '&') {
			resultByte = xByte & yByte;
		} else if (op === '^') {
			resultByte = xByte ^ yByte;
		} else {
			resultByte = xByte | yByte;
		}
		result[result.length] = resultByte;
	}

	return result;
};
'use strict';

var $TypeError = require('es-errors/type');

var IsArray = require('./IsArray');

var isByteValue = require('../helpers/isByteValue');

// https://262.ecma-international.org/12.0/#sec-bytelistequal

module.exports = function ByteListEqual(xBytes, yBytes) {
	if (!IsArray(xBytes) || !IsArray(yBytes)) {
		throw new $TypeError('Assertion failed: `xBytes` and `yBytes` must be sequences of byte values (an integer 0-255, inclusive)');
	}

	if (xBytes.length !== yBytes.length) {
		return false;
	}

	for (var i = 0; i < xBytes.length; i += 1) {
		var xByte = xBytes[i];
		var yByte = yBytes[i];
		if (!isByteValue(xByte) || !isByteValue(yByte)) {
			throw new $TypeError('Assertion failed: `xBytes` and `yBytes` must be sequences of byte values (an integer 0-255, inclusive)');
		}
		if (xByte !== yByte) {
			return false;
		}
	}
	return true;
};
'use strict';

var GetIntrinsic = require('get-intrinsic');
var callBound = require('call-bound');

var $TypeError = require('es-errors/type');

var IsArray = require('./IsArray');

var $apply = GetIntrinsic('%Reflect.apply%', true) || callBound('Function.prototype.apply');

// https://262.ecma-international.org/6.0/#sec-call

module.exports = function Call(F, V) {
	var argumentsList = arguments.length > 2 ? arguments[2] : [];
	if (!IsArray(argumentsList)) {
		throw new $TypeError('Assertion failed: optional `argumentsList`, if provided, must be a List');
	}
	return $apply(F, V, argumentsList);
};
'use strict';

var isObject = require('es-object-atoms/isObject');

var KeyForSymbol = require('./KeyForSymbol');

// https://262.ecma-international.org/14.0/#sec-canbeheldweakly

module.exports = function CanBeHeldWeakly(v) {
	if (isObject(v)) {
		return true; // step 1
	}
	if (typeof v === 'symbol' && typeof KeyForSymbol(v) === 'undefined') {
		return true; // step 2
	}
	return false; // step 3
};
'use strict';

var $TypeError = require('es-errors/type');

var callBound = require('call-bound');
var hasOwn = require('hasown');

var $charCodeAt = callBound('String.prototype.charCodeAt');
var $toUpperCase = callBound('String.prototype.toUpperCase');

var isRegExpRecord = require('../helpers/records/regexp-record');
var caseFolding = require('../helpers/caseFolding.json');

// https://262.ecma-international.org/14.0/#sec-runtime-semantics-canonicalize-ch

module.exports = function Canonicalize(rer, ch) {
	if (!isRegExpRecord(rer)) {
		throw new $TypeError('Assertion failed: `rer` must be a RegExp Record');
	}

	if (typeof ch !== 'string') {
		throw new $TypeError('Assertion failed: `ch` must be a character');
	}

	if (rer['[[Unicode]]'] && rer['[[IgnoreCase]]']) { // step 1
		if (hasOwn(caseFolding.C, ch)) {
			return caseFolding.C[ch];
		}
		if (hasOwn(caseFolding.S, ch)) {
			return caseFolding.S[ch];
		}
		return ch; // step 1.b
	}

	if (!rer['[[IgnoreCase]]']) {
		return ch; // step 2
	}

	var u = $toUpperCase(ch); // step 5

	if (u.length !== 1) {
		return ch; // step 7
	}

	var cu = u; // step 8

	if ($charCodeAt(ch, 0) >= 128 && $charCodeAt(cu, 0) < 128) {
		return ch; // step 9
	}

	return cu; // step 10
};
'use strict';

// https://262.ecma-international.org/16.0/#sec-canonicalizekeyedcollectionkey

module.exports = function CanonicalizeKeyedCollectionKey(key) {
	return key === 0 ? +0 : key;
};
'use strict';

var $TypeError = require('es-errors/type');

var SameValue = require('./SameValue');
var ToNumber = require('./ToNumber');
var ToString = require('./ToString');

// https://262.ecma-international.org/6.0/#sec-canonicalnumericindexstring

module.exports = function CanonicalNumericIndexString(argument) {
	if (typeof argument !== 'string') {
		throw new $TypeError('Assertion failed: `argument` must be a String');
	}
	if (argument === '-0') { return -0; }
	var n = ToNumber(argument);
	if (SameValue(ToString(n), argument)) { return n; }
	return void 0;
};
'use strict';

var $TypeError = require('es-errors/type');

var AllCharacters = require('./AllCharacters');

var CharSet = require('../helpers/CharSet').CharSet;
var isRegExpRecord = require('../helpers/records/regexp-record');

// https://262.ecma-international.org/15.0/#sec-charactercomplement

module.exports = function CharacterComplement(rer, S) {
	if (!isRegExpRecord(rer)) {
		throw new $TypeError('Assertion failed: `rer` must be a RegExp Record');
	}

	if (!(S instanceof CharSet)) {
		throw new $TypeError('Assertion failed: S must be a CharSet');
	}

	var A = AllCharacters(rer); // step 1

	// 2. Return the CharSet containing the CharSetElements of A which are not also CharSetElements of S.
	return new CharSet(
		function (x) { return !S.test(x) && A.test(x); },
		function (emit) {
			A.yield(function (x) {
				if (!S.test(x)) {
					emit(x);
				}
			});
		}
	);
};
'use strict';

var GetIntrinsic = require('get-intrinsic');
var callBound = require('call-bound');

var $fromCharCode = GetIntrinsic('%String.fromCharCode%');
var $TypeError = require('es-errors/type');
var $charCodeAt = callBound('String.prototype.charCodeAt');

var CharSet = require('../helpers/CharSet').CharSet;

// https://262.ecma-international.org/16.0/#sec-runtime-semantics-characterrange-abstract-operation

module.exports = function CharacterRange(A, B) {
	if (!(A instanceof CharSet) || !(B instanceof CharSet)) {
		throw new $TypeError('Assertion failed: CharSets A and B are not both CharSets');
	}

	var a;
	A.yield(function (c) {
		if (typeof a !== 'undefined') {
			throw new $TypeError('Assertion failed: CharSet A has more than one character');
		}
		a = c;
	});

	var b;
	B.yield(function (c) {
		if (typeof b !== 'undefined') {
			throw new $TypeError('Assertion failed: CharSet B has more than one character');
		}
		b = c;
	});

	var i = $charCodeAt(a, 0);
	var j = $charCodeAt(b, 0);

	if (!(i <= j)) {
		throw new $TypeError('Assertion failed: i is not <= j');
	}

	var arr = [];
	for (var k = i; k <= j; k += 1) {
		arr[arr.length] = $fromCharCode(k);
	}
	return arr;
};
'use strict';

var $TypeError = require('es-errors/type');
var max = require('math-intrinsics/max');
var min = require('math-intrinsics/min');

// https://262.ecma-international.org/12.0/#clamping

module.exports = function clamp(x, lower, upper) {
	if (typeof x !== 'number' || typeof lower !== 'number' || typeof upper !== 'number' || !(lower <= upper)) {
		throw new $TypeError('Assertion failed: all three arguments must be MVs, and `lower` must be `<= upper`');
	}
	return min(max(lower, x), upper);
};
'use strict';

var SLOT = require('internal-slot');
var keptObjects = [];

// https://262.ecma-international.org/12.0/#sec-clear-kept-objects

module.exports = function ClearKeptObjects() {
	keptObjects.length = 0;
};

SLOT.set(module.exports, '[[es-abstract internal: KeptAlive]]', keptObjects);
'use strict';

var $TypeError = require('es-errors/type');

var GetPrototypeFromConstructor = require('./GetPrototypeFromConstructor');
var IsConstructor = require('./IsConstructor');
var IsDetachedBuffer = require('./IsDetachedBuffer');
var OrdinarySetPrototypeOf = require('./OrdinarySetPrototypeOf');

var isInteger = require('math-intrinsics/isInteger');
var isArrayBuffer = require('is-array-buffer');
var arrayBufferSlice = require('arraybuffer.prototype.slice');

// https://262.ecma-international.org/12.0/#sec-clonearraybuffer

module.exports = function CloneArrayBuffer(srcBuffer, srcByteOffset, srcLength, cloneConstructor) {
	if (!isArrayBuffer(srcBuffer)) {
		throw new $TypeError('Assertion failed: `srcBuffer` must be an ArrayBuffer instance');
	}
	if (!isInteger(srcByteOffset) || srcByteOffset < 0) {
		throw new $TypeError('Assertion failed: `srcByteOffset` must be a non-negative integer');
	}
	if (!isInteger(srcLength) || srcLength < 0) {
		throw new $TypeError('Assertion failed: `srcLength` must be a non-negative integer');
	}
	if (!IsConstructor(cloneConstructor)) {
		throw new $TypeError('Assertion failed: `cloneConstructor` must be a constructor');
	}

	// 3. Let targetBuffer be ? AllocateArrayBuffer(cloneConstructor, srcLength).
	var proto = GetPrototypeFromConstructor(cloneConstructor, '%ArrayBufferPrototype%'); // step 3, kinda

	if (IsDetachedBuffer(srcBuffer)) {
		throw new $TypeError('`srcBuffer` must not be a detached ArrayBuffer'); // step 4
	}

	/*
    5. Let srcBlock be srcBuffer.[[ArrayBufferData]].
    6. Let targetBlock be targetBuffer.[[ArrayBufferData]].
    7. Perform CopyDataBlockBytes(targetBlock, 0, srcBlock, srcByteOffset, srcLength).
    */
	var targetBuffer = arrayBufferSlice(srcBuffer, srcByteOffset, srcByteOffset + srcLength); // steps 5-7
	OrdinarySetPrototypeOf(targetBuffer, proto); // step 3

	return targetBuffer; // step 8
};
'use strict';

var $TypeError = require('es-errors/type');
var callBound = require('call-bound');
var isLeadingSurrogate = require('../helpers/isLeadingSurrogate');
var isTrailingSurrogate = require('../helpers/isTrailingSurrogate');

var UTF16SurrogatePairToCodePoint = require('./UTF16SurrogatePairToCodePoint');

var $charAt = callBound('String.prototype.charAt');
var $charCodeAt = callBound('String.prototype.charCodeAt');

// https://262.ecma-international.org/12.0/#sec-codepointat

module.exports = function CodePointAt(string, position) {
	if (typeof string !== 'string') {
		throw new $TypeError('Assertion failed: `string` must be a String');
	}
	var size = string.length;
	if (position < 0 || position >= size) {
		throw new $TypeError('Assertion failed: `position` must be >= 0, and < the length of `string`');
	}
	var first = $charCodeAt(string, position);
	var cp = $charAt(string, position);
	var firstIsLeading = isLeadingSurrogate(first);
	var firstIsTrailing = isTrailingSurrogate(first);
	if (!firstIsLeading && !firstIsTrailing) {
		return {
			'[[CodePoint]]': cp,
			'[[CodeUnitCount]]': 1,
			'[[IsUnpairedSurrogate]]': false
		};
	}
	if (firstIsTrailing || (position + 1 === size)) {
		return {
			'[[CodePoint]]': cp,
			'[[CodeUnitCount]]': 1,
			'[[IsUnpairedSurrogate]]': true
		};
	}
	var second = $charCodeAt(string, position + 1);
	if (!isTrailingSurrogate(second)) {
		return {
			'[[CodePoint]]': cp,
			'[[CodeUnitCount]]': 1,
			'[[IsUnpairedSurrogate]]': true
		};
	}

	return {
		'[[CodePoint]]': UTF16SurrogatePairToCodePoint(first, second),
		'[[CodeUnitCount]]': 2,
		'[[IsUnpairedSurrogate]]': false
	};
};
'use strict';

var $TypeError = require('es-errors/type');

var UTF16EncodeCodePoint = require('./UTF16EncodeCodePoint');
var IsArray = require('./IsArray');

var forEach = require('../helpers/forEach');
var isCodePoint = require('../helpers/isCodePoint');

// https://262.ecma-international.org/12.0/#sec-codepointstostring

module.exports = function CodePointsToString(text) {
	if (!IsArray(text)) {
		throw new $TypeError('Assertion failed: `text` must be a sequence of Unicode Code Points');
	}
	var result = '';
	forEach(text, function (cp) {
		if (!isCodePoint(cp)) {
			throw new $TypeError('Assertion failed: `text` must be a sequence of Unicode Code Points');
		}
		result += UTF16EncodeCodePoint(cp);
	});
	return result;
};
'use strict';

var $TypeError = require('es-errors/type');

var Call = require('./Call');
var IsLessThan = require('./IsLessThan');
var ToNumber = require('./ToNumber');
var ToString = require('./ToString');

var isNaN = require('math-intrinsics/isNaN');

// https://262.ecma-international.org/14.0/#sec-comparearrayelements

module.exports = function CompareArrayElements(x, y, compareFn) {
	if (typeof compareFn !== 'function' && typeof compareFn !== 'undefined') {
		throw new $TypeError('Assertion failed: `compareFn` must be a function or undefined');
	}

	if (typeof x === 'undefined' && typeof y === 'undefined') {
		return 0; // step 1
	}

	if (typeof x === 'undefined') {
		return 1; // step 2
	}

	if (typeof y === 'undefined') {
		return -1; // step 3
	}

	if (typeof compareFn !== 'undefined') { // step 4
		var v = ToNumber(Call(compareFn, void undefined, [x, y])); // step 4.a
		if (isNaN(v)) {
			return 0; // step 4.b
		}
		return v; // step 4.c
	}

	var xString = ToString(x); // step 5
	var yString = ToString(y); // step 6
	var xSmaller = IsLessThan(xString, yString, true); // step 7
	if (xSmaller) {
		return -1; // step 8
	}
	var ySmaller = IsLessThan(yString, xString, true); // step 9
	if (ySmaller) {
		return 1; // step 10
	}
	return 0; // step 11
};
'use strict';

var $TypeError = require('es-errors/type');

var Call = require('./Call');
var SameValue = require('./SameValue');
var ToNumber = require('./ToNumber');

var isNaN = require('math-intrinsics/isNaN');

// https://262.ecma-international.org/14.0/#sec-comparetypedarrayelements

module.exports = function CompareTypedArrayElements(x, y, compareFn) {
	if ((typeof x !== 'number' && typeof x !== 'bigint') || typeof x !== typeof y) {
		throw new $TypeError('Assertion failed: `x` and `y` must be either a BigInt or a Number, and both must be the same type');
	}
	if (typeof compareFn !== 'function' && typeof compareFn !== 'undefined') {
		throw new $TypeError('Assertion failed: `compareFn` must be a function or undefined');
	}

	if (typeof compareFn !== 'undefined') { // step 2
		var v = ToNumber(Call(compareFn, void undefined, [x, y])); // step 2.a
		if (isNaN(v)) {
			return 0; // step 2.b
		}
		return v; // step 2.c
	}

	var xNaN = isNaN(x);
	var yNaN = isNaN(y);
	if (xNaN && yNaN) {
		return 0; // step 3
	}

	if (xNaN) {
		return 1; // step 4
	}

	if (yNaN) {
		return -1; // step 5
	}

	if (x < y) {
		return -1; // step 6
	}

	if (x > y) {
		return 1; // step 7
	}

	if (SameValue(x, -0) && SameValue(y, 0)) {
		return -1; // step 8
	}

	if (SameValue(x, 0) && SameValue(y, -0)) {
		return 1; // step 9
	}

	return 0; // step 10
};
'use strict';

var $TypeError = require('es-errors/type');

var hasOwn = require('hasown');

var IsDataDescriptor = require('./IsDataDescriptor');
var IsGenericDescriptor = require('./IsGenericDescriptor');

var isPropertyDescriptor = require('../helpers/records/property-descriptor');

// https://262.ecma-international.org/6.0/#sec-completepropertydescriptor

module.exports = function CompletePropertyDescriptor(Desc) {
	if (!isPropertyDescriptor(Desc)) {
		throw new $TypeError('Assertion failed: `Desc` must be a Property Descriptor');
	}

	/* eslint no-param-reassign: 0 */

	if (IsGenericDescriptor(Desc) || IsDataDescriptor(Desc)) {
		if (!hasOwn(Desc, '[[Value]]')) {
			Desc['[[Value]]'] = void 0;
		}
		if (!hasOwn(Desc, '[[Writable]]')) {
			Desc['[[Writable]]'] = false;
		}
	} else {
		if (!hasOwn(Desc, '[[Get]]')) {
			Desc['[[Get]]'] = void 0;
		}
		if (!hasOwn(Desc, '[[Set]]')) {
			Desc['[[Set]]'] = void 0;
		}
	}
	if (!hasOwn(Desc, '[[Enumerable]]')) {
		Desc['[[Enumerable]]'] = false;
	}
	if (!hasOwn(Desc, '[[Configurable]]')) {
		Desc['[[Configurable]]'] = false;
	}
	return Desc;
};
'use strict';

var $SyntaxError = require('es-errors/syntax');

var SLOT = require('internal-slot');

// https://262.ecma-international.org/7.0/#sec-completion-record-specification-type

var CompletionRecord = function CompletionRecord(type, value) {
	if (!(this instanceof CompletionRecord)) {
		return new CompletionRecord(type, value);
	}
	if (type !== 'normal' && type !== 'break' && type !== 'continue' && type !== 'return' && type !== 'throw') {
		throw new $SyntaxError('Assertion failed: `type` must be one of "normal", "break", "continue", "return", or "throw"');
	}
	SLOT.set(this, '[[Type]]', type);
	SLOT.set(this, '[[Value]]', value);
	// [[Target]] slot?
};

CompletionRecord.prototype.type = function Type() {
	return SLOT.get(this, '[[Type]]');
};

CompletionRecord.prototype.value = function Value() {
	return SLOT.get(this, '[[Value]]');
};

CompletionRecord.prototype['?'] = function ReturnIfAbrupt() {
	var type = SLOT.get(this, '[[Type]]');
	var value = SLOT.get(this, '[[Value]]');

	if (type === 'throw') {
		throw value;
	}
	return value;
};

CompletionRecord.prototype['!'] = function assert() {
	var type = SLOT.get(this, '[[Type]]');

	if (type !== 'normal') {
		throw new $SyntaxError('Assertion failed: Completion Record is not of type "normal"');
	}
	return SLOT.get(this, '[[Value]]');
};

module.exports = CompletionRecord;
'use strict';

var $TypeError = require('es-errors/type');
var isObject = require('es-object-atoms/isObject');
var callBound = require('call-bound');
var OwnPropertyKeys = require('own-keys');

var forEach = require('../helpers/forEach');
var every = require('../helpers/every');
var some = require('../helpers/some');

var $isEnumerable = callBound('Object.prototype.propertyIsEnumerable');

var CreateDataPropertyOrThrow = require('./CreateDataPropertyOrThrow');
var Get = require('./Get');
var IsArray = require('./IsArray');
var isPropertyKey = require('../helpers/isPropertyKey');
var SameValue = require('./SameValue');
var ToNumber = require('./ToNumber');
var ToObject = require('./ToObject');

var isInteger = require('math-intrinsics/isInteger');

// https://262.ecma-international.org/12.0/#sec-copydataproperties

module.exports = function CopyDataProperties(target, source, excludedItems) {
	if (!isObject(target)) {
		throw new $TypeError('Assertion failed: "target" must be an Object');
	}

	if (!IsArray(excludedItems) || !every(excludedItems, isPropertyKey)) {
		throw new $TypeError('Assertion failed: "excludedItems" must be a List of Property Keys');
	}

	if (typeof source === 'undefined' || source === null) {
		return target;
	}

	var from = ToObject(source);

	var keys = OwnPropertyKeys(from);
	forEach(keys, function (nextKey) {
		var excluded = some(excludedItems, function (e) {
			return SameValue(e, nextKey) === true;
		});
		/*
		var excluded = false;

		forEach(excludedItems, function (e) {
			if (SameValue(e, nextKey) === true) {
				excluded = true;
			}
		});
		*/

		var enumerable = $isEnumerable(from, nextKey) || (
		// this is to handle string keys being non-enumerable in older engines
			typeof source === 'string'
			&& nextKey >= 0
			&& isInteger(ToNumber(nextKey))
		);
		if (excluded === false && enumerable) {
			var propValue = Get(from, nextKey);
			CreateDataPropertyOrThrow(target, nextKey, propValue);
		}
	});

	return target;
};
'use strict';

var GetIntrinsic = require('get-intrinsic');

var $SyntaxError = require('es-errors/syntax');
var $TypeError = require('es-errors/type');
var isObject = require('es-object-atoms/isObject');
var $Promise = GetIntrinsic('%Promise%', true);

var AsyncFromSyncIteratorContinuation = require('./AsyncFromSyncIteratorContinuation');
var Call = require('./Call');
var CreateIteratorResultObject = require('./CreateIteratorResultObject');
var Get = require('./Get');
var GetMethod = require('./GetMethod');
var IteratorNext = require('./IteratorNext');
var OrdinaryObjectCreate = require('./OrdinaryObjectCreate');

var isIteratorRecord = require('../helpers/records/iterator-record');

var SLOT = require('internal-slot');

var $AsyncFromSyncIteratorPrototype = GetIntrinsic('%AsyncFromSyncIteratorPrototype%', true) || {
	next: function next(value) {
		if (!$Promise) {
			throw new $SyntaxError('This environment does not support Promises.');
		}

		var O = this; // step 1

		SLOT.assert(O, '[[SyncIteratorRecord]]'); // step 2

		var argsLength = arguments.length;

		return new $Promise(function (resolve) { // step 3
			var syncIteratorRecord = SLOT.get(O, '[[SyncIteratorRecord]]'); // step 4
			var result;
			if (argsLength > 0) {
				result = IteratorNext(syncIteratorRecord, value); // step 5.a
			} else { // step 6
				result = IteratorNext(syncIteratorRecord);// step 6.a
			}
			resolve(AsyncFromSyncIteratorContinuation(result)); // step 8
		});
	},
	'return': function () {
		if (!$Promise) {
			throw new $SyntaxError('This environment does not support Promises.');
		}

		var O = this; // step 1

		SLOT.assert(O, '[[SyncIteratorRecord]]'); // step 2

		var valueIsPresent = arguments.length > 0;
		var value = valueIsPresent ? arguments[0] : void undefined;

		return new $Promise(function (resolve, reject) { // step 3
			var syncIterator = SLOT.get(O, '[[SyncIteratorRecord]]')['[[Iterator]]']; // step 4
			var iteratorReturn = GetMethod(syncIterator, 'return'); // step 5

			if (typeof iteratorReturn === 'undefined') { // step 7
				var iterResult = CreateIteratorResultObject(value, true); // step 7.a
				Call(resolve, undefined, [iterResult]); // step 7.b
				return;
			}
			var result;
			if (valueIsPresent) { // step 8
				result = Call(iteratorReturn, syncIterator, [value]); // step 8.a
			} else { // step 9
				result = Call(iteratorReturn, syncIterator); // step 9.a
			}
			if (!isObject(result)) { // step 11
				Call(reject, undefined, [new $TypeError('Iterator `return` method returned a non-object value.')]); // step 11.a
				return;
			}

			resolve(AsyncFromSyncIteratorContinuation(result)); // step 12
		});
	},
	'throw': function () {
		if (!$Promise) {
			throw new $SyntaxError('This environment does not support Promises.');
		}

		var O = this; // step 1

		SLOT.assert(O, '[[SyncIteratorRecord]]'); // step 2

		var valueIsPresent = arguments.length > 0;
		var value = valueIsPresent ? arguments[0] : void undefined;

		return new $Promise(function (resolve, reject) { // step 3
			var syncIterator = SLOT.get(O, '[[SyncIteratorRecord]]')['[[Iterator]]']; // step 4

			var throwMethod = GetMethod(syncIterator, 'throw'); // step 5

			if (typeof throwMethod === 'undefined') { // step 7
				Call(reject, undefined, [value]); // step 7.a
				return;
			}

			var result;
			if (valueIsPresent) { // step 8
				result = Call(throwMethod, syncIterator, [value]); // step 8.a
			} else { // step 9
				result = Call(throwMethod, syncIterator); // step 9.a
			}
			if (!isObject(result)) { // step 11
				Call(reject, undefined, [new $TypeError('Iterator `throw` method returned a non-object value.')]); // step 11.a
				return;
			}

			resolve(AsyncFromSyncIteratorContinuation(result/* , promiseCapability */)); // step 12
		});
	}
};

// https://262.ecma-international.org/16.0/#sec-createasyncfromsynciterator

module.exports = function CreateAsyncFromSyncIterator(syncIteratorRecord) {
	if (!isIteratorRecord(syncIteratorRecord)) {
		throw new $TypeError('Assertion failed: `syncIteratorRecord` must be an Iterator Record');
	}

	// var asyncIterator = OrdinaryObjectCreate(%AsyncFromSyncIteratorPrototype%, « [[SyncIteratorRecord]] »); // step 1
	var asyncIterator = OrdinaryObjectCreate($AsyncFromSyncIteratorPrototype);

	SLOT.set(asyncIterator, '[[SyncIteratorRecord]]', syncIteratorRecord); // step 2

	var nextMethod = Get(asyncIterator, 'next'); // step 3

	return { // steps 3-4
		'[[Iterator]]': asyncIterator,
		'[[NextMethod]]': nextMethod,
		'[[Done]]': false
	};
};
'use strict';

var $TypeError = require('es-errors/type');
var isObject = require('es-object-atoms/isObject');

var isPropertyKey = require('../helpers/isPropertyKey');
var OrdinaryDefineOwnProperty = require('./OrdinaryDefineOwnProperty');

// https://262.ecma-international.org/6.0/#sec-createdataproperty

module.exports = function CreateDataProperty(O, P, V) {
	if (!isObject(O)) {
		throw new $TypeError('Assertion failed: Type(O) is not Object');
	}
	if (!isPropertyKey(P)) {
		throw new $TypeError('Assertion failed: P is not a Property Key');
	}
	var newDesc = {
		'[[Configurable]]': true,
		'[[Enumerable]]': true,
		'[[Value]]': V,
		'[[Writable]]': true
	};
	return OrdinaryDefineOwnProperty(O, P, newDesc);
};
'use strict';

var $TypeError = require('es-errors/type');
var isObject = require('es-object-atoms/isObject');

var CreateDataProperty = require('./CreateDataProperty');

var isPropertyKey = require('../helpers/isPropertyKey');

// // https://262.ecma-international.org/14.0/#sec-createdatapropertyorthrow

module.exports = function CreateDataPropertyOrThrow(O, P, V) {
	if (!isObject(O)) {
		throw new $TypeError('Assertion failed: Type(O) is not Object');
	}
	if (!isPropertyKey(P)) {
		throw new $TypeError('Assertion failed: P is not a Property Key');
	}
	var success = CreateDataProperty(O, P, V);
	if (!success) {
		throw new $TypeError('unable to create data property');
	}
};
'use strict';

var $TypeError = require('es-errors/type');

var callBound = require('call-bound');

var $replace = callBound('String.prototype.replace');

var RequireObjectCoercible = require('./RequireObjectCoercible');
var ToString = require('./ToString');

// https://262.ecma-international.org/6.0/#sec-createhtml

module.exports = function CreateHTML(string, tag, attribute, value) {
	if (typeof tag !== 'string' || typeof attribute !== 'string') {
		throw new $TypeError('Assertion failed: `tag` and `attribute` must be strings');
	}
	var str = RequireObjectCoercible(string);
	var S = ToString(str);
	var p1 = '<' + tag;
	if (attribute !== '') {
		var V = ToString(value);
		var escapedV = $replace(V, /\x22/g, '&quot;');
		p1 += '\x20' + attribute + '\x3D\x22' + escapedV + '\x22';
	}
	return p1 + '>' + S + '</' + tag + '>';
};
'use strict';

var $TypeError = require('es-errors/type');

var GeneratorStart = require('./GeneratorStart');
var IsArray = require('./IsArray');
var IsCallable = require('./IsCallable');
var OrdinaryObjectCreate = require('./OrdinaryObjectCreate');

var every = require('../helpers/every');

var SLOT = require('internal-slot');
var safeConcat = require('safe-array-concat');
var isObject = require('es-object-atoms/isObject');

var isString = function isString(slot) {
	return typeof slot === 'string';
};

// https://262.ecma-international.org/16.0/#sec-createiteratorfromclosure

module.exports = function CreateIteratorFromClosure(closure, generatorBrand, generatorPrototype) {
	if (!IsCallable(closure)) {
		throw new $TypeError('`closure` must be a function');
	}
	if (typeof generatorBrand !== 'string') {
		throw new $TypeError('`generatorBrand` must be a string');
	}
	if (!isObject(generatorPrototype)) {
		throw new $TypeError('`generatorPrototype` must be an object');
	}
	var extraSlots = arguments.length > 3 ? arguments[3] : []; // step 2
	if (arguments.length > 3) {
		if (!IsArray(extraSlots) || !every(extraSlots, isString)) {
			throw new $TypeError('`extraSlots` must be a List of String internal slot names');
		}
	}
	var internalSlotsList = safeConcat(extraSlots, ['[[GeneratorContext]]', '[[GeneratorBrand]]', '[[GeneratorState]]']); // step 3
	var generator = OrdinaryObjectCreate(generatorPrototype, internalSlotsList); // steps 4, 6
	SLOT.set(generator, '[[GeneratorBrand]]', generatorBrand); // step 5
	SLOT.set(generator, '[[GeneratorState]]', 'SUSPENDED-START'); // step 6

	SLOT.assert(closure, '[[Sentinel]]'); // our userland slot
	SLOT.set(generator, '[[Sentinel]]', SLOT.get(closure, '[[Sentinel]]')); // our userland slot
	SLOT.assert(closure, '[[CloseIfAbrupt]]'); // our second userland slot
	SLOT.set(generator, '[[CloseIfAbrupt]]', SLOT.get(closure, '[[CloseIfAbrupt]]')); // our second userland slot

	GeneratorStart(generator, closure); // step 14

	return generator; // step 16
};
'use strict';

var $TypeError = require('es-errors/type');

// https://262.ecma-international.org/16.0/#sec-createiterresultobject

module.exports = function CreateIteratorResultObject(value, done) {
	if (typeof done !== 'boolean') {
		throw new $TypeError('Assertion failed: Type(done) is not Boolean');
	}
	return {
		value: value,
		done: done
	};
};
'use strict';

var $TypeError = require('es-errors/type');
var isObject = require('es-object-atoms/isObject');

var Get = require('./Get');
var LengthOfArrayLike = require('./LengthOfArrayLike');
var ToString = require('./ToString');

var isPropertyKey = require('../helpers/isPropertyKey');

// https://262.ecma-international.org/16.0/#sec-createlistfromarraylike

module.exports = function CreateListFromArrayLike(obj) {
	var validElementTypes = arguments.length > 1
		? arguments[1]
		: 'ALL'; // step 1

	if (validElementTypes !== 'ALL' && validElementTypes !== 'PROPERTY-KEY') {
		throw new $TypeError('Assertion failed: `validElementType` must be ~ALL~ or ~PROPERTY-KEY~');
	}

	if (!isObject(obj)) {
		throw new $TypeError('Assertion failed: `obj` must be an Object'); // step 2
	}

	var len = LengthOfArrayLike(obj); // step 3
	var list = []; // step 4
	var index = 0; // step 5
	while (index < len) { // step 6
		var indexName = ToString(index); // step 6.a
		var next = Get(obj, indexName); // step 6.b
		if (validElementTypes === 'PROPERTY-KEY' && !isPropertyKey(next)) {
			throw new $TypeError('item ' + indexName + ' is not a valid property key'); // step 6.c
		}
		list[list.length] = next; // step 6.d
		index += 1;	 // step 6.e
	}
	return list; // step 7
};
'use strict';

var $TypeError = require('es-errors/type');
var isObject = require('es-object-atoms/isObject');

var DefinePropertyOrThrow = require('./DefinePropertyOrThrow');

var isPropertyKey = require('../helpers/isPropertyKey');

// https://262.ecma-international.org/13.0/#sec-createnonenumerabledatapropertyorthrow

module.exports = function CreateNonEnumerableDataPropertyOrThrow(O, P, V) {
	if (!isObject(O)) {
		throw new $TypeError('Assertion failed: Type(O) is not Object');
	}

	if (!isPropertyKey(P)) {
		throw new $TypeError('Assertion failed: P is not a Property Key');
	}

	var newDesc = {
		'[[Configurable]]': true,
		'[[Enumerable]]': false,
		'[[Value]]': V,
		'[[Writable]]': true
	};
	return DefinePropertyOrThrow(O, P, newDesc);
};
'use strict';

var GetIntrinsic = require('get-intrinsic');
var hasSymbols = require('has-symbols')();

var $TypeError = require('es-errors/type');
var isObject = require('es-object-atoms/isObject');
var IteratorPrototype = GetIntrinsic('%IteratorPrototype%', true);

var AdvanceStringIndex = require('./AdvanceStringIndex');
var CreateIteratorResultObject = require('./CreateIteratorResultObject');
var DefineMethodProperty = require('./DefineMethodProperty');
var Get = require('./Get');
var OrdinaryObjectCreate = require('./OrdinaryObjectCreate');
var RegExpExec = require('./RegExpExec');
var Set = require('./Set');
var ToLength = require('./ToLength');
var ToString = require('./ToString');

var SLOT = require('internal-slot');
var setToStringTag = require('es-set-tostringtag');

var RegExpStringIterator = function RegExpStringIterator(R, S, global, fullUnicode) {
	if (typeof S !== 'string') {
		throw new $TypeError('`S` must be a string');
	}
	if (typeof global !== 'boolean') {
		throw new $TypeError('`global` must be a boolean');
	}
	if (typeof fullUnicode !== 'boolean') {
		throw new $TypeError('`fullUnicode` must be a boolean');
	}
	SLOT.set(this, '[[IteratingRegExp]]', R);
	SLOT.set(this, '[[IteratedString]]', S);
	SLOT.set(this, '[[Global]]', global);
	SLOT.set(this, '[[Unicode]]', fullUnicode);
	SLOT.set(this, '[[Done]]', false);
};

if (IteratorPrototype) {
	RegExpStringIterator.prototype = OrdinaryObjectCreate(IteratorPrototype);
}

var RegExpStringIteratorNext = function next() {
	var O = this; // eslint-disable-line no-invalid-this
	if (!isObject(O)) {
		throw new $TypeError('receiver must be an object');
	}
	if (
		!(O instanceof RegExpStringIterator)
		|| !SLOT.has(O, '[[IteratingRegExp]]')
		|| !SLOT.has(O, '[[IteratedString]]')
		|| !SLOT.has(O, '[[Global]]')
		|| !SLOT.has(O, '[[Unicode]]')
		|| !SLOT.has(O, '[[Done]]')
	) {
		throw new $TypeError('"this" value must be a RegExpStringIterator instance');
	}
	if (SLOT.get(O, '[[Done]]')) {
		return CreateIteratorResultObject(undefined, true);
	}
	var R = SLOT.get(O, '[[IteratingRegExp]]');
	var S = SLOT.get(O, '[[IteratedString]]');
	var global = SLOT.get(O, '[[Global]]');
	var fullUnicode = SLOT.get(O, '[[Unicode]]');
	var match = RegExpExec(R, S);
	if (match === null) {
		SLOT.set(O, '[[Done]]', true);
		return CreateIteratorResultObject(undefined, true);
	}
	if (global) {
		var matchStr = ToString(Get(match, '0'));
		if (matchStr === '') {
			var thisIndex = ToLength(Get(R, 'lastIndex'));
			var nextIndex = AdvanceStringIndex(S, thisIndex, fullUnicode);
			Set(R, 'lastIndex', nextIndex, true);
		}
		return CreateIteratorResultObject(match, false);
	}
	SLOT.set(O, '[[Done]]', true);
	return CreateIteratorResultObject(match, false);
};
DefineMethodProperty(RegExpStringIterator.prototype, 'next', RegExpStringIteratorNext, false);

if (hasSymbols) {
	setToStringTag(RegExpStringIterator.prototype, 'RegExp String Iterator');

	if (Symbol.iterator && typeof RegExpStringIterator.prototype[Symbol.iterator] !== 'function') {
		var iteratorFn = function SymbolIterator() {
			return this;
		};
		DefineMethodProperty(RegExpStringIterator.prototype, Symbol.iterator, iteratorFn, false);
	}
}

// https://262.ecma-international.org/15.0/#sec-createregexpstringiterator

module.exports = function CreateRegExpStringIterator(R, S, global, fullUnicode) {
	// assert R.global === global && R.unicode === fullUnicode?
	return new RegExpStringIterator(R, S, global, fullUnicode);
};
'use strict';

var $EvalError = require('es-errors/eval');

var DayWithinYear = require('./DayWithinYear');
var InLeapYear = require('./InLeapYear');
var MonthFromTime = require('./MonthFromTime');

// https://262.ecma-international.org/5.1/#sec-15.9.1.5

module.exports = function DateFromTime(t) {
	var m = MonthFromTime(t);
	var d = DayWithinYear(t);
	if (m === 0) {
		return d + 1;
	}
	if (m === 1) {
		return d - 30;
	}
	var leap = InLeapYear(t);
	if (m === 2) {
		return d - 58 - leap;
	}
	if (m === 3) {
		return d - 89 - leap;
	}
	if (m === 4) {
		return d - 119 - leap;
	}
	if (m === 5) {
		return d - 150 - leap;
	}
	if (m === 6) {
		return d - 180 - leap;
	}
	if (m === 7) {
		return d - 211 - leap;
	}
	if (m === 8) {
		return d - 242 - leap;
	}
	if (m === 9) {
		return d - 272 - leap;
	}
	if (m === 10) {
		return d - 303 - leap;
	}
	if (m === 11) {
		return d - 333 - leap;
	}
	throw new $EvalError('Assertion failed: MonthFromTime returned an impossible value: ' + m);
};
'use strict';

var $TypeError = require('es-errors/type');

var weekdays = ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'];
var months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];

var $isNaN = require('math-intrinsics/isNaN');
var padTimeComponent = require('../helpers/padTimeComponent');

var DateFromTime = require('./DateFromTime');
var MonthFromTime = require('./MonthFromTime');
var WeekDay = require('./WeekDay');
var YearFromTime = require('./YearFromTime');

// https://262.ecma-international.org/9.0/#sec-datestring

module.exports = function DateString(tv) {
	if (typeof tv !== 'number' || $isNaN(tv)) {
		throw new $TypeError('Assertion failed: `tv` must be a non-NaN Number');
	}
	var weekday = weekdays[WeekDay(tv)];
	var month = months[MonthFromTime(tv)];
	var day = padTimeComponent(DateFromTime(tv));
	var year = padTimeComponent(YearFromTime(tv), 4);
	return weekday + '\x20' + month + '\x20' + day + '\x20' + year;
};
'use strict';

var floor = require('./floor');

// https://262.ecma-international.org/5.1/#sec-15.9.1.3

module.exports = function DayFromYear(y) {
	return (365 * (y - 1970)) + floor((y - 1969) / 4) - floor((y - 1901) / 100) + floor((y - 1601) / 400);
};

'use strict';

var floor = require('./floor');

var msPerDay = require('../helpers/timeConstants').msPerDay;

// https://262.ecma-international.org/5.1/#sec-15.9.1.2

module.exports = function Day(t) {
	return floor(t / msPerDay);
};
'use strict';

var modulo = require('./modulo');

// https://262.ecma-international.org/5.1/#sec-15.9.1.3

module.exports = function DaysInYear(y) {
	if (modulo(y, 4) !== 0) {
		return 365;
	}
	if (modulo(y, 100) !== 0) {
		return 366;
	}
	if (modulo(y, 400) !== 0) {
		return 365;
	}
	return 366;
};
'use strict';

var Day = require('./Day');
var DayFromYear = require('./DayFromYear');
var YearFromTime = require('./YearFromTime');

// https://262.ecma-international.org/5.1/#sec-15.9.1.4

module.exports = function DayWithinYear(t) {
	return Day(t) - DayFromYear(YearFromTime(t));
};
'use strict';

var $TypeError = require('es-errors/type');
var isObject = require('es-object-atoms/isObject');

var DefinePropertyOrThrow = require('./DefinePropertyOrThrow');
var IsExtensible = require('./IsExtensible');

var isPropertyKey = require('../helpers/isPropertyKey');

// https://262.ecma-international.org/13.0/#sec-definemethodproperty

module.exports = function DefineMethodProperty(homeObject, key, closure, enumerable) {
	if (!isObject(homeObject)) {
		throw new $TypeError('Assertion failed: `homeObject` is not an Object');
	}
	if (!isPropertyKey(key)) {
		throw new $TypeError('Assertion failed: `key` is not a Property Key or a Private Name');
	}
	if (typeof closure !== 'function') {
		throw new $TypeError('Assertion failed: `closure` is not a function');
	}
	if (typeof enumerable !== 'boolean') {
		throw new $TypeError('Assertion failed: `enumerable` is not a Boolean');
	}

	// 1. Assert: homeObject is an ordinary, extensible object with no non-configurable properties.
	if (!IsExtensible(homeObject)) {
		throw new $TypeError('Assertion failed: `homeObject` is not an ordinary, extensible object, with no non-configurable properties');
	}

	// 2. If key is a Private Name, then
	//  a. Return PrivateElement { [[Key]]: key, [[Kind]]: method, [[Value]]: closure }.
	// 3. Else,
	var desc = { // step 3.a
		'[[Value]]': closure,
		'[[Writable]]': true,
		'[[Enumerable]]': enumerable,
		'[[Configurable]]': true
	};
	DefinePropertyOrThrow(homeObject, key, desc); // step 3.b
};
'use strict';

var $TypeError = require('es-errors/type');
var isObject = require('es-object-atoms/isObject');

var isPropertyDescriptor = require('../helpers/records/property-descriptor');
var DefineOwnProperty = require('../helpers/DefineOwnProperty');

var FromPropertyDescriptor = require('./FromPropertyDescriptor');
var IsDataDescriptor = require('./IsDataDescriptor');
var isPropertyKey = require('../helpers/isPropertyKey');
var SameValue = require('./SameValue');
var ToPropertyDescriptor = require('./ToPropertyDescriptor');

// https://262.ecma-international.org/6.0/#sec-definepropertyorthrow

module.exports = function DefinePropertyOrThrow(O, P, desc) {
	if (!isObject(O)) {
		throw new $TypeError('Assertion failed: Type(O) is not Object');
	}

	if (!isPropertyKey(P)) {
		throw new $TypeError('Assertion failed: P is not a Property Key');
	}

	var Desc = isPropertyDescriptor(desc) ? desc : ToPropertyDescriptor(desc);
	if (!isPropertyDescriptor(Desc)) {
		throw new $TypeError('Assertion failed: Desc is not a valid Property Descriptor');
	}

	return DefineOwnProperty(
		IsDataDescriptor,
		SameValue,
		FromPropertyDescriptor,
		O,
		P,
		Desc
	);
};
'use strict';

var $TypeError = require('es-errors/type');
var isObject = require('es-object-atoms/isObject');

var isPropertyKey = require('../helpers/isPropertyKey');

// https://262.ecma-international.org/6.0/#sec-deletepropertyorthrow

module.exports = function DeletePropertyOrThrow(O, P) {
	if (!isObject(O)) {
		throw new $TypeError('Assertion failed: Type(O) is not Object');
	}

	if (!isPropertyKey(P)) {
		throw new $TypeError('Assertion failed: P is not a Property Key');
	}

	// eslint-disable-next-line no-param-reassign
	var success = delete O[P];
	if (!success) {
		throw new $TypeError('Attempt to delete property failed.');
	}
	return success;
};
'use strict';

var $SyntaxError = require('es-errors/syntax');
var $TypeError = require('es-errors/type');

var IsDetachedBuffer = require('./IsDetachedBuffer');

var isArrayBuffer = require('is-array-buffer');
var isSharedArrayBuffer = require('is-shared-array-buffer');

var MessageChannel;
try {
	// eslint-disable-next-line global-require
	MessageChannel = require('worker_threads').MessageChannel;
} catch (e) { /**/ }

// https://262.ecma-international.org/9.0/#sec-detacharraybuffer

/* globals postMessage */

module.exports = function DetachArrayBuffer(arrayBuffer) {
	if (!isArrayBuffer(arrayBuffer) || isSharedArrayBuffer(arrayBuffer)) {
		throw new $TypeError('Assertion failed: `arrayBuffer` must be an Object with an [[ArrayBufferData]] internal slot, and not a Shared Array Buffer');
	}

	// commented out since there's no way to set or access this key
	// var key = arguments.length > 1 ? arguments[1] : void undefined;

	// if (!SameValue(arrayBuffer[[ArrayBufferDetachKey]], key)) {
	// 	throw new $TypeError('Assertion failed: `key` must be the value of the [[ArrayBufferDetachKey]] internal slot of `arrayBuffer`');
	// }

	if (!IsDetachedBuffer(arrayBuffer)) { // node v21.0.0+ throws when you structuredClone a detached buffer
		if (typeof structuredClone === 'function') {
			structuredClone(arrayBuffer, { transfer: [arrayBuffer] });
		} else if (typeof postMessage === 'function') {
			postMessage('', '/', [arrayBuffer]); // TODO: see if this might trigger listeners
		} else if (MessageChannel) {
			(new MessageChannel()).port1.postMessage(null, [arrayBuffer]);
		} else {
			throw new $SyntaxError('DetachArrayBuffer is not supported in this environment');
		}
	}

	return null;
};
'use strict';

var NumberToString = require('./Number/toString');
var StringIndexOf = require('./StringIndexOf');
var StringPad = require('./StringPad');
// var StringToCodePoints = require('./StringToCodePoints');
var UnicodeEscape = require('./UnicodeEscape');
var UTF16EncodeCodePoint = require('./UTF16EncodeCodePoint');

var isLeadingSurrogate = require('../helpers/isLeadingSurrogate');
var isTrailingSurrogate = require('../helpers/isTrailingSurrogate');

var $TypeError = require('es-errors/type');

var isCodePoint = require('../helpers/isCodePoint');
var forEach = require('for-each');
var regexTester = require('safe-regex-test');

var isWhiteSpace = regexTester(/^\s$/);
var isLineTerminator = regexTester(/^[\n\r\u2028\u2029]$/);

// var punctuators = "(){}[]|,.?*+-^$=<>/#&!%:;@~'`\"\\"; // step 1
var syntaxCharacter = '^$\\.*+?()[]{}|';

var otherPunctuators = ",-=<>#&!%:;@~'`\""; // step 3
// var toEscape = StringToCodePoints(otherPunctuators); // step 4

var table64 = {
	'\u0009': 't',
	'\u000a': 'n',
	'\u000b': 'v',
	'\u000c': 'f',
	'\u000d': 'r',
	__proto__: null
};

module.exports = function EncodeForRegExpEscape(c) {
	if (!isCodePoint(c)) {
		throw new $TypeError('Assertion failed: `c` must be a valid Unicode code point');
	}

	var encoded = UTF16EncodeCodePoint(c);

	if (StringIndexOf(syntaxCharacter, encoded, 0) > -1 || encoded === '\u002F') { // step 1
		return '\\' + encoded; // step 1.a
	} else if (encoded in table64) { // step 2
		return '\\' + table64[encoded]; // step 2.a
	}

	if (
		StringIndexOf(otherPunctuators, encoded, 0) > -1
		|| isWhiteSpace(encoded)
		|| isLineTerminator(encoded)
		|| isLeadingSurrogate(c)
		|| isTrailingSurrogate(c)
	) { // step 5
		if (c < 0xFF) { // step 5.a
			var hex = NumberToString(c, 16); // step 5.a.i
			return '\\x' + StringPad(hex, 2, '0', 'START'); // step 5.a.ii
		}

		var escaped = ''; // step 5.b

		var codeUnits = encoded; // step 5.c

		forEach(codeUnits, function (cu) { // step 5.d
			escaped += UnicodeEscape(cu); // step 5.d.i
		});

		return escaped; // step 5.e
	}

	return encoded; // step 6
};
'use strict';

var $TypeError = require('es-errors/type');
var isObject = require('es-object-atoms/isObject');
var objectKeys = require('object-keys');
var safePushApply = require('safe-push-apply');
var callBound = require('call-bound');

var $isEnumerable = callBound('Object.prototype.propertyIsEnumerable');

var forEach = require('../helpers/forEach');

// https://262.ecma-international.org/14.0/#sec-enumerableownproperties

module.exports = function EnumerableOwnProperties(O, kind) {
	if (!isObject(O)) {
		throw new $TypeError('Assertion failed: Type(O) is not Object');
	}

	var keys = objectKeys(O);
	if (kind === 'key') {
		return keys;
	}
	if (kind === 'value' || kind === 'key+value') {
		var results = [];
		forEach(keys, function (key) {
			if ($isEnumerable(O, key)) {
				safePushApply(results, [
					kind === 'value' ? O[key] : [key, O[key]]
				]);
			}
		});
		return results;
	}
	throw new $TypeError('Assertion failed: "kind" is not "key", "value", or "key+value": ' + kind);
};
'use strict';

var $TypeError = require('es-errors/type');
var isInteger = require('math-intrinsics/isInteger');
var isObject = require('es-object-atoms/isObject');

var Call = require('./Call');
var Get = require('./Get');
var ToBoolean = require('./ToBoolean');
var IsCallable = require('./IsCallable');
var ToString = require('./ToString');

// https://262.ecma-international.org/15.0/#sec-findviapredicate

module.exports = function FindViaPredicate(O, len, direction, predicate, thisArg) {
	if (!isObject(O)) {
		throw new $TypeError('Assertion failed: Type(O) is not Object');
	}
	if (!isInteger(len) || len < 0) {
		throw new $TypeError('Assertion failed: len must be a non-negative integer');
	}
	if (direction !== 'ascending' && direction !== 'descending' && direction !== 'DESCENDING' && direction !== 'ASCENDING') {
		throw new $TypeError('Assertion failed: direction must be ~ASCENDING~ or ~DESCENDING~');
	}

	if (!IsCallable(predicate)) {
		throw new $TypeError('predicate must be callable'); // step 1
	}

	for ( // steps 2-4
		var k = direction === 'ascending' || direction === 'ASCENDING' ? 0 : len - 1;
		direction === 'ascending' || direction === 'ASCENDING' ? k < len : k >= 0;
		k += 1
	) {
		var Pk = ToString(k); // step 4.a
		var kValue = Get(O, Pk); // step 4.c
		var testResult = Call(predicate, thisArg, [kValue, k, O]); // step 4.d
		if (ToBoolean(testResult)) {
			return { '[[Index]]': k, '[[Value]]': kValue }; // step 4.e
		}
	}
	return { '[[Index]]': -1, '[[Value]]': void undefined }; // step 5
};
'use strict';

var $TypeError = require('es-errors/type');

var MAX_SAFE_INTEGER = require('math-intrinsics/constants/maxSafeInteger');

var Call = require('./Call');
var CreateDataPropertyOrThrow = require('./CreateDataPropertyOrThrow');
var Get = require('./Get');
var HasProperty = require('./HasProperty');
var IsArray = require('./IsArray');
var LengthOfArrayLike = require('./LengthOfArrayLike');
var ToString = require('./ToString');

// https://262.ecma-international.org/11.0/#sec-flattenintoarray

module.exports = function FlattenIntoArray(target, source, sourceLen, start, depth) {
	var mapperFunction;
	if (arguments.length > 5) {
		mapperFunction = arguments[5];
	}

	var targetIndex = start;
	var sourceIndex = 0;
	while (sourceIndex < sourceLen) {
		var P = ToString(sourceIndex);
		var exists = HasProperty(source, P);
		if (exists === true) {
			var element = Get(source, P);
			if (typeof mapperFunction !== 'undefined') {
				if (arguments.length <= 6) {
					throw new $TypeError('Assertion failed: thisArg is required when mapperFunction is provided');
				}
				element = Call(mapperFunction, arguments[6], [element, sourceIndex, source]);
			}
			var shouldFlatten = false;
			if (depth > 0) {
				shouldFlatten = IsArray(element);
			}
			if (shouldFlatten) {
				var elementLen = LengthOfArrayLike(element);
				targetIndex = FlattenIntoArray(target, element, elementLen, targetIndex, depth - 1);
			} else {
				if (targetIndex >= MAX_SAFE_INTEGER) {
					throw new $TypeError('index too large');
				}
				CreateDataPropertyOrThrow(target, ToString(targetIndex), element);
				targetIndex += 1;
			}
		}
		sourceIndex += 1;
	}

	return targetIndex;
};
'use strict';

// var modulo = require('./modulo');
var $floor = require('math-intrinsics/floor');

// http://262.ecma-international.org/11.0/#eqn-floor

module.exports = function floor(x) {
	// return x - modulo(x, 1);
	if (typeof x === 'bigint') {
		return x;
	}
	return $floor(x);
};
'use strict';

var $TypeError = require('es-errors/type');

var isPropertyDescriptor = require('../helpers/records/property-descriptor');
var fromPropertyDescriptor = require('../helpers/fromPropertyDescriptor');

// https://262.ecma-international.org/6.0/#sec-frompropertydescriptor

module.exports = function FromPropertyDescriptor(Desc) {
	if (typeof Desc !== 'undefined' && !isPropertyDescriptor(Desc)) {
		throw new $TypeError('Assertion failed: `Desc` must be a Property Descriptor');
	}

	return fromPropertyDescriptor(Desc);
};
'use strict';

var $TypeError = require('es-errors/type');

var CompletionRecord = require('./CompletionRecord');
var CreateIteratorResultObject = require('./CreateIteratorResultObject');
var GeneratorValidate = require('./GeneratorValidate');
var NormalCompletion = require('./NormalCompletion');

var SLOT = require('internal-slot');

// https://262.ecma-international.org/16.0/#sec-generatorresumeabrupt

module.exports = function GeneratorResumeAbrupt(generator, abruptCompletion, generatorBrand) {
	if (
		!(abruptCompletion instanceof CompletionRecord)
		|| (abruptCompletion.type() !== 'return' && abruptCompletion.type() !== 'throw')
	) {
		throw new $TypeError('Assertion failed: abruptCompletion must be a `return` or `throw` Completion Record');
	}

	var state = GeneratorValidate(generator, generatorBrand); // step 1

	if (state === 'SUSPENDED-START') { // step 2
		SLOT.set(generator, '[[GeneratorState]]', 'COMPLETED'); // step 3.a
		SLOT.set(generator, '[[GeneratorContext]]', null); // step 3.b
		state = 'COMPLETED'; // step 3.c
	}

	var value = abruptCompletion.value();

	if (state === 'COMPLETED') { // step 3
		return CreateIteratorResultObject(value, true); // steps 3.a-b
	}

	if (state !== 'SUSPENDED-YIELD') {
		throw new $TypeError('Assertion failed: generator state is unexpected: ' + state); // step 4
	}
	if (abruptCompletion.type() === 'return') {
		// due to representing `GeneratorContext` as a function, we can't safely re-invoke it, so we can't support sending it a return completion
		return CreateIteratorResultObject(SLOT.get(generator, '[[CloseIfAbrupt]]')(NormalCompletion(abruptCompletion.value())), true);
	}

	var genContext = SLOT.get(generator, '[[GeneratorContext]]'); // step 5

	SLOT.set(generator, '[[GeneratorState]]', 'EXECUTING'); // step 8

	var result = genContext(value); // steps 6-7, 8-11

	return result; // step 12
};
'use strict';

var $TypeError = require('es-errors/type');

var CreateIteratorResultObject = require('./CreateIteratorResultObject');
var GeneratorValidate = require('./GeneratorValidate');

var SLOT = require('internal-slot');

// https://262.ecma-international.org/16.0/#sec-generatorresume

module.exports = function GeneratorResume(generator, value, generatorBrand) {
	var state = GeneratorValidate(generator, generatorBrand); // step 1
	if (state === 'COMPLETED') {
		return CreateIteratorResultObject(void undefined, true); // step 2
	}

	if (state !== 'SUSPENDED-START' && state !== 'SUSPENDED-YIELD') {
		throw new $TypeError('Assertion failed: generator state is unexpected: ' + state); // step 3
	}

	var genContext = SLOT.get(generator, '[[GeneratorContext]]');

	SLOT.set(generator, '[[GeneratorState]]', 'EXECUTING'); // step 7

	var result = genContext(value); // steps 5-6, 8-10

	return result;
};
'use strict';

var $TypeError = require('es-errors/type');

var CreateIteratorResultObject = require('./CreateIteratorResultObject');
var IsCallable = require('./IsCallable');

var SLOT = require('internal-slot');
var isObject = require('es-object-atoms/isObject');

// https://262.ecma-international.org/16.0/#sec-generatorstart

module.exports = function GeneratorStart(generator, closure) {
	SLOT.assert(generator, '[[GeneratorState]]');
	SLOT.assert(generator, '[[GeneratorContext]]');
	SLOT.assert(generator, '[[GeneratorBrand]]');
	SLOT.assert(generator, '[[Sentinel]]'); // our userland slot
	SLOT.assert(generator, '[[CloseIfAbrupt]]'); // our second userland slot

	if (!IsCallable(closure) || closure.length !== 0) {
		throw new $TypeError('`closure` must be a function that takes no arguments');
	}

	var sentinel = SLOT.get(closure, '[[Sentinel]]');
	if (!isObject(sentinel)) {
		throw new $TypeError('`closure.[[Sentinel]]` must be an object');
	}
	SLOT.set(generator, '[[GeneratorContext]]', function () { // steps 2-5
		try {
			var result = closure();
			if (result === sentinel) {
				SLOT.set(generator, '[[GeneratorState]]', 'COMPLETED');
				SLOT.set(generator, '[[GeneratorContext]]', null);
				return CreateIteratorResultObject(void undefined, true);
			}
			SLOT.set(generator, '[[GeneratorState]]', 'SUSPENDED-YIELD');
			return CreateIteratorResultObject(result, false);
		} catch (e) {
			SLOT.set(generator, '[[GeneratorState]]', 'COMPLETED');
			SLOT.set(generator, '[[GeneratorContext]]', null);
			throw e;
		}
	});

	SLOT.set(generator, '[[GeneratorState]]', 'SUSPENDED-START'); // step 6
};
'use strict';

var $TypeError = require('es-errors/type');

var SLOT = require('internal-slot');

// https://262.ecma-international.org/16.0/#sec-generatorvalidate

module.exports = function GeneratorValidate(generator, generatorBrand) {
	SLOT.assert(generator, '[[GeneratorState]]'); // step 1
	SLOT.assert(generator, '[[GeneratorBrand]]'); // step 2

	var brand = SLOT.get(generator, '[[GeneratorBrand]]');
	if (brand !== generatorBrand) {
		throw new $TypeError('Assertion failed: generator brand is unexpected: ' + brand);
	}
	SLOT.assert(generator, '[[GeneratorContext]]'); // step 4
	var state = SLOT.get(generator, '[[GeneratorState]]'); // step 5
	if (state === 'EXECUTING') {
		throw new $TypeError('generator is executing');
	}

	return state; // step 7
};
'use strict';

var isObject = require('es-object-atoms/isObject');

var Get = require('./Get');
var ToIndex = require('./ToIndex');

// https://262.ecma-international.org/15.0/#sec-getarraybuffermaxbytelengthoption

module.exports = function GetArrayBufferMaxByteLengthOption(options) {
	if (!isObject(options)) {
		return 'EMPTY'; // step 1
	}

	var maxByteLength = Get(options, 'maxByteLength'); // step 2

	if (typeof maxByteLength === 'undefined') {
		return 'EMPTY'; // step 3
	}

	return ToIndex(maxByteLength); // step 4
};
'use strict';

var getGlobal = require('globalthis/polyfill');

// https://262.ecma-international.org/6.0/#sec-getglobalobject

module.exports = function GetGlobalObject() {
	return getGlobal();
};
'use strict';

var $TypeError = require('es-errors/type');
var isObject = require('es-object-atoms/isObject');

var Get = require('./Get');

// https://262.ecma-international.org/16.0/#sec-getiteratordirect

module.exports = function GetIteratorDirect(obj) {
	if (!isObject(obj)) {
		throw new $TypeError('Assertion failed: `obj` must be an Object');
	}

	var nextMethod = Get(obj, 'next'); // step 1

	var iteratorRecord = {
		'[[Iterator]]': obj,
		'[[NextMethod]]': nextMethod,
		'[[Done]]': false
	}; // step 2

	return iteratorRecord; // step 3
};
'use strict';

var $TypeError = require('es-errors/type');
var isObject = require('es-object-atoms/isObject');

var AdvanceStringIndex = require('./AdvanceStringIndex');
var Call = require('./Call');
var GetIteratorDirect = require('./GetIteratorDirect');
var GetMethod = require('./GetMethod');
var IsArray = require('./IsArray');

var getIteratorMethod = require('../helpers/getIteratorMethod');

// https://262.ecma-international.org/16.0/#sec-getiteratorflattenable

module.exports = function GetIteratorFlattenable(obj, primitiveHandling) {
	if (primitiveHandling !== 'REJECT-PRIMITIVES' && primitiveHandling !== 'ITERATE-STRING-PRIMITIVES') {
		throw new $TypeError('Assertion failed: `stringHandling` must be "REJECT-PRIMITIVES" or "ITERATE-STRING-PRIMITIVES"');
	}

	if (!isObject(obj)) {
		if (primitiveHandling === 'REJECT-PRIMITIVES' || typeof obj !== 'string') {
			throw new $TypeError('obj must be an Object'); // step 1.a
		}
	}

	// var method = GetMethod(obj, Symbol.iterator); // step 2
	var method = getIteratorMethod(
		{
			AdvanceStringIndex: AdvanceStringIndex,
			GetMethod: GetMethod,
			IsArray: IsArray
		},
		obj
	);

	var iterator;
	if (typeof method === 'undefined') { // step 3
		iterator = obj; // step 3.a
	} else { // step 4
		iterator = Call(method, obj); // step 4.a
	}

	if (!isObject(iterator)) {
		throw new $TypeError('iterator must be an Object'); // step 5
	}
	return GetIteratorDirect(iterator); // step 6
};
'use strict';

var $TypeError = require('es-errors/type');
var isObject = require('es-object-atoms/isObject');

var Call = require('./Call');
var Get = require('./Get');
var IsCallable = require('./IsCallable');

// https://262.ecma-international.org/15.0/#sec-getiteratorfrommethod

module.exports = function GetIteratorFromMethod(obj, method) {
	if (!IsCallable(method)) {
		throw new $TypeError('method must be a function');
	}

	var iterator = Call(method, obj); // step 1
	if (!isObject(iterator)) {
		throw new $TypeError('iterator must return an object'); // step 2
	}

	var nextMethod = Get(iterator, 'next'); // step 3
	return { // steps 4-5
		'[[Iterator]]': iterator,
		'[[NextMethod]]': nextMethod,
		'[[Done]]': false
	};
};
'use strict';

var GetIntrinsic = require('get-intrinsic');

var $TypeError = require('es-errors/type');
var $asyncIterator = GetIntrinsic('%Symbol.asyncIterator%', true);

var inspect = require('object-inspect');
var hasSymbols = require('has-symbols')();

var AdvanceStringIndex = require('./AdvanceStringIndex');
var CreateAsyncFromSyncIterator = require('./CreateAsyncFromSyncIterator');
var GetIteratorFromMethod = require('./GetIteratorFromMethod');
var GetMethod = require('./GetMethod');

var ES = {
	AdvanceStringIndex: AdvanceStringIndex,
	GetMethod: GetMethod
};

var getIteratorMethod = require('../helpers/getIteratorMethod');

// https://262.ecma-international.org/14.0/#sec-getiterator

module.exports = function GetIterator(obj, kind) {
	if (kind !== 'SYNC' && kind !== 'ASYNC') {
		throw new $TypeError("Assertion failed: `kind` must be one of 'sync' or 'async', got " + inspect(kind));
	}

	var method;
	if (kind === 'ASYNC') { // step 1
		if (hasSymbols && $asyncIterator) {
			method = GetMethod(obj, $asyncIterator); // step 1.a
		}
	}
	if (typeof method === 'undefined') { // step 1.b
		// var syncMethod = GetMethod(obj, $iterator); // step 1.b.i
		var syncMethod = getIteratorMethod(ES, obj);
		if (kind === 'ASYNC') {
			if (typeof syncMethod === 'undefined') {
				throw new $TypeError('iterator method is `undefined`'); // step 1.b.ii
			}
			var syncIteratorRecord = GetIteratorFromMethod(obj, syncMethod); // step 1.b.iii
			return CreateAsyncFromSyncIterator(syncIteratorRecord); // step 1.b.iv
		}
		method = syncMethod; // step 2, kind of
	}

	if (typeof method === 'undefined') {
		throw new $TypeError('iterator method is `undefined`'); // step 3
	}
	return GetIteratorFromMethod(obj, method); // step 4
};
'use strict';

var $TypeError = require('es-errors/type');

var inspect = require('object-inspect');

var isPropertyKey = require('../helpers/isPropertyKey');

var isObject = require('es-object-atoms/isObject');

// https://262.ecma-international.org/6.0/#sec-get-o-p

module.exports = function Get(O, P) {
	// 7.3.1.1
	if (!isObject(O)) {
		throw new $TypeError('Assertion failed: Type(O) is not Object');
	}
	// 7.3.1.2
	if (!isPropertyKey(P)) {
		throw new $TypeError('Assertion failed: P is not a Property Key, got ' + inspect(P));
	}
	// 7.3.1.3
	return O[P];
};
'use strict';

var $TypeError = require('es-errors/type');

var isMatchRecord = require('../helpers/records/match-record');

// https://262.ecma-international.org/13.0/#sec-getmatchindexpair

module.exports = function GetMatchIndexPair(S, match) {
	if (typeof S !== 'string') {
		throw new $TypeError('Assertion failed: `S` must be a String');
	}
	if (!isMatchRecord(match)) {
		throw new $TypeError('Assertion failed: `match` must be a Match Record');
	}

	if (!(match['[[StartIndex]]'] <= S.length)) {
		throw new $TypeError('`match` [[StartIndex]] must be a non-negative integer <= the length of S');
	}
	if (!(match['[[EndIndex]]'] <= S.length)) {
		throw new $TypeError('`match` [[EndIndex]] must be an integer between [[StartIndex]] and the length of S, inclusive');
	}
	return [match['[[StartIndex]]'], match['[[EndIndex]]']];
};
'use strict';

var $TypeError = require('es-errors/type');

var substring = require('./substring');

var isMatchRecord = require('../helpers/records/match-record');

// https://262.ecma-international.org/13.0/#sec-getmatchstring

module.exports = function GetMatchString(S, match) {
	if (typeof S !== 'string') {
		throw new $TypeError('Assertion failed: `S` must be a String');
	}
	if (!isMatchRecord(match)) {
		throw new $TypeError('Assertion failed: `match` must be a Match Record');
	}

	if (!(match['[[StartIndex]]'] <= S.length)) {
		throw new $TypeError('`match` [[StartIndex]] must be a non-negative integer <= the length of S');
	}
	if (!(match['[[EndIndex]]'] <= S.length)) {
		throw new $TypeError('`match` [[EndIndex]] must be an integer between [[StartIndex]] and the length of S, inclusive');
	}
	return substring(S, match['[[StartIndex]]'], match['[[EndIndex]]']);
};
'use strict';

var $TypeError = require('es-errors/type');

var GetV = require('./GetV');
var IsCallable = require('./IsCallable');
var isPropertyKey = require('../helpers/isPropertyKey');

var inspect = require('object-inspect');

// https://262.ecma-international.org/6.0/#sec-getmethod

module.exports = function GetMethod(O, P) {
	// 7.3.9.1
	if (!isPropertyKey(P)) {
		throw new $TypeError('Assertion failed: P is not a Property Key');
	}

	// 7.3.9.2
	var func = GetV(O, P);

	// 7.3.9.4
	if (func == null) {
		return void 0;
	}

	// 7.3.9.5
	if (!IsCallable(func)) {
		throw new $TypeError(inspect(P) + ' is not a function: ' + inspect(func));
	}

	// 7.3.9.6
	return func;
};
'use strict';

var $TypeError = require('es-errors/type');

var GetUTCEpochNanoseconds = require('./GetUTCEpochNanoseconds');

var isInteger = require('math-intrinsics/isInteger');

// https://262.ecma-international.org/14.0/#sec-getnamedtimezoneepochnanoseconds

// eslint-disable-next-line max-params
module.exports = function GetNamedTimeZoneEpochNanoseconds(
	timeZoneIdentifier,
	year,
	month,
	day,
	hour,
	minute,
	second,
	millisecond,
	microsecond,
	nanosecond
) {
	if (typeof timeZoneIdentifier !== 'string') {
		throw new $TypeError('Assertion failed: `timeZoneIdentifier` must be a string');
	}
	if (!isInteger(year)) {
		throw new $TypeError('Assertion failed: `year` must be an integral number');
	}
	if (!isInteger(month) || month < 1 || month > 12) {
		throw new $TypeError('Assertion failed: `month` must be an integral number between 1 and 12, inclusive');
	}
	if (!isInteger(day) || day < 1 || day > 31) {
		throw new $TypeError('Assertion failed: `day` must be an integral number between 1 and 31, inclusive');
	}
	if (!isInteger(hour) || hour < 0 || hour > 23) {
		throw new $TypeError('Assertion failed: `hour` must be an integral number between 0 and 23, inclusive');
	}
	if (!isInteger(minute) || minute < 0 || minute > 59) {
		throw new $TypeError('Assertion failed: `minute` must be an integral number between 0 and 59, inclusive');
	}
	if (!isInteger(second) || second < 0 || second > 999) {
		throw new $TypeError('Assertion failed: `second` must be an integral number between 0 and 999, inclusive');
	}
	if (!isInteger(millisecond) || millisecond < 0 || millisecond > 999) {
		throw new $TypeError('Assertion failed: `millisecond` must be an integral number between 0 and 999, inclusive');
	}
	if (!isInteger(microsecond) || microsecond < 0 || microsecond > 999) {
		throw new $TypeError('Assertion failed: `microsecond` must be an integral number between 0 and 999, inclusive');
	}
	if (!isInteger(nanosecond) || nanosecond < 0 || nanosecond > 999) {
		throw new $TypeError('Assertion failed: `nanosecond` must be an integral number between 0 and 999, inclusive');
	}

	if (timeZoneIdentifier !== 'UTC') {
		throw new $TypeError('Assertion failed: only UTC time zone is supported'); // step 1
	}

	var epochNanoseconds = GetUTCEpochNanoseconds(
		year,
		month,
		day,
		hour,
		minute,
		second,
		millisecond,
		microsecond,
		nanosecond
	); // step 2

	return [epochNanoseconds]; // step 3
};
'use strict';

var GetIntrinsic = require('get-intrinsic');

var hasSymbols = require('has-symbols')();

var $TypeError = require('es-errors/type');
var isObject = require('es-object-atoms/isObject');

var $gOPN = GetIntrinsic('%Object.getOwnPropertyNames%', true);
var $gOPS = hasSymbols && GetIntrinsic('%Object.getOwnPropertySymbols%', true);
var keys = require('object-keys');

// https://262.ecma-international.org/6.0/#sec-getownpropertykeys

module.exports = function GetOwnPropertyKeys(O, Type) {
	if (!isObject(O)) {
		throw new $TypeError('Assertion failed: Type(O) is not Object');
	}
	if (Type === 'Symbol') {
		return $gOPS ? $gOPS(O) : [];
	}
	if (Type === 'String') {
		if (!$gOPN) {
			return keys(O);
		}
		return $gOPN(O);
	}
	throw new $TypeError('Assertion failed: `Type` must be `"String"` or `"Symbol"`');
};
'use strict';

var $TypeError = require('es-errors/type');

var Get = require('./Get');
var IsCallable = require('./IsCallable');
var IsConstructor = require('./IsConstructor');

// https://262.ecma-international.org/12.0/#sec-getpromiseresolve

module.exports = function GetPromiseResolve(promiseConstructor) {
	if (!IsConstructor(promiseConstructor)) {
		throw new $TypeError('Assertion failed: `promiseConstructor` must be a constructor');
	}
	var promiseResolve = Get(promiseConstructor, 'resolve');
	if (IsCallable(promiseResolve) === false) {
		throw new $TypeError('`resolve` method is not callable');
	}
	return promiseResolve;
};
'use strict';

var GetIntrinsic = require('get-intrinsic');

var $Function = GetIntrinsic('%Function%');
var $TypeError = require('es-errors/type');
var $SyntaxError = require('es-errors/syntax');

var Get = require('./Get');
var IsConstructor = require('./IsConstructor');

var isObject = require('es-object-atoms/isObject');

// https://262.ecma-international.org/6.0/#sec-getprototypefromconstructor

module.exports = function GetPrototypeFromConstructor(constructor, intrinsicDefaultProto) {
	var intrinsic = GetIntrinsic(intrinsicDefaultProto); // throws if not a valid intrinsic
	if (!isObject(intrinsic)) {
		throw new $TypeError('intrinsicDefaultProto must be an object');
	}
	if (!IsConstructor(constructor)) {
		throw new $TypeError('Assertion failed: `constructor` must be a constructor');
	}
	var proto = Get(constructor, 'prototype');
	if (!isObject(proto)) {
		if (!(constructor instanceof $Function)) {
			// ignore other realms, for now
			throw new $SyntaxError('cross-realm constructors not currently supported');
		}
		proto = intrinsic;
	}
	return proto;
};
'use strict';

var $RangeError = require('es-errors/range');
var $TypeError = require('es-errors/type');

var Get = require('./Get');
var IsCallable = require('./IsCallable');
var ToIntegerOrInfinity = require('./ToIntegerOrInfinity');
var ToNumber = require('./ToNumber');

var isNaN = require('..//helpers/isNaN');
var isObject = require('es-object-atoms/isObject');

var callBind = require('call-bind');
var isSet = require('is-set');
var stopIterationIterator = require('stop-iteration-iterator');

// https://262.ecma-international.org/16.0/#sec-getsetrecord

module.exports = function GetSetRecord(obj) {
	if (!isObject(obj)) {
		throw new $TypeError('obj is not an Object'); // step 1
	}

	var rawSize = Get(obj, 'size'); // step 2

	var numSize = ToNumber(rawSize); // step 3

	//  4. NOTE: If rawSize is undefined, then numSize will be NaN.
	if (isNaN(numSize)) {
		throw new $TypeError('`size` is not a non-NaN Number'); // step 5
	}

	var intSize = ToIntegerOrInfinity(numSize); // step 6

	if (intSize < 0) {
		throw new $RangeError('set size must be non-negative'); // step 7
	}

	var has = Get(obj, 'has'); // step 8

	if (!IsCallable(has)) {
		throw new $TypeError('has is not a function'); // step 9
	}

	var keys = Get(obj, 'keys'); // step 10
	if (!IsCallable(keys)) {
		throw new $TypeError('keys is not a function'); // step 11
	}
	/* globals StopIteration: false */
	if (isSet(obj) && typeof StopIteration === 'object') {
		var boundKeys = callBind(keys);
		keys = function keys() { // eslint-disable-line no-shadow
			return stopIterationIterator(boundKeys(this)); // eslint-disable-line no-invalid-this
		};
	}

	return {
		'[[SetObject]]': obj,
		'[[Size]]': intSize,
		'[[Has]]': has,
		'[[Keys]]': keys
	}; // step 12
};
'use strict';

var callBound = require('call-bound');
var $TypeError = require('es-errors/type');
var isInteger = require('math-intrinsics/isInteger');

var StringToCodePoints = require('./StringToCodePoints');

var $indexOf = callBound('String.prototype.indexOf');

// https://262.ecma-international.org/13.0/#sec-getstringindex

module.exports = function GetStringIndex(S, e) {
	if (typeof S !== 'string') {
		throw new $TypeError('Assertion failed: `S` must be a String');
	}
	if (!isInteger(e) || e < 0) {
		throw new $TypeError('Assertion failed: `e` must be a non-negative integer');
	}

	if (S === '') {
		return 0;
	}
	var codepoints = StringToCodePoints(S);
	var eUTF = e >= codepoints.length ? S.length : $indexOf(S, codepoints[e]);
	return eUTF;
};
'use strict';

var $TypeError = require('es-errors/type');
var inspect = require('object-inspect');
var isInteger = require('math-intrinsics/isInteger');
var isObject = require('es-object-atoms/isObject');
var regexTester = require('safe-regex-test');

var Get = require('./Get');
var IsArray = require('./IsArray');
var min = require('./min');
var StringIndexOf = require('./StringIndexOf');
var StringToNumber = require('./StringToNumber');
var substring = require('./substring');
var ToString = require('./ToString');

var every = require('../helpers/every');
var isPrefixOf = require('../helpers/isPrefixOf');
var isStringOrUndefined = require('../helpers/isStringOrUndefined');

var startsWithDollarDigit = regexTester(/^\$[0-9]/);
var startsWithDollarTwoDigit = regexTester(/^\$[0-9][0-9]/);

// http://www.ecma-international.org/ecma-262/15.0/#sec-getsubstitution

// eslint-disable-next-line max-statements, max-params, max-lines-per-function
module.exports = function GetSubstitution(matched, str, position, captures, namedCaptures, replacementTemplate) {
	if (typeof matched !== 'string') {
		throw new $TypeError('Assertion failed: `matched` must be a String');
	}

	if (typeof str !== 'string') {
		throw new $TypeError('Assertion failed: `str` must be a String');
	}

	if (!isInteger(position) || position < 0) {
		throw new $TypeError('Assertion failed: `position` must be a nonnegative integer, got ' + inspect(position));
	}

	if (!IsArray(captures) || !every(captures, isStringOrUndefined)) {
		throw new $TypeError('Assertion failed: `captures` must be a possibly-empty List of Strings or `undefined`, got ' + inspect(captures));
	}

	if (typeof namedCaptures !== 'undefined' && !isObject(namedCaptures)) {
		throw new $TypeError('Assertion failed: `namedCaptures` must be `undefined` or an Object');
	}

	if (typeof replacementTemplate !== 'string') {
		throw new $TypeError('Assertion failed: `replacementTemplate` must be a String');
	}

	var stringLength = str.length; // step 1

	if (position > stringLength) {
		throw new $TypeError('Assertion failed: position > stringLength, got ' + inspect(position)); // step 2
	}

	var templateRemainder = replacementTemplate; // step 3

	var result = ''; // step 4

	while (templateRemainder !== '') { // step 5
		// 5.a NOTE: The following steps isolate ref (a prefix of templateRemainder), determine refReplacement (its replacement), and then append that replacement to result.

		var ref, refReplacement, capture;
		if (isPrefixOf('$$', templateRemainder)) { // step 5.b
			ref = '$$'; // step 5.b.i
			refReplacement = '$'; // step 5.b.ii
		} else if (isPrefixOf('$`', templateRemainder)) { // step 5.c
			ref = '$`'; // step 5.c.i
			refReplacement = substring(str, 0, position); // step 5.c.ii
		} else if (isPrefixOf('$&', templateRemainder)) { // step 5.d
			ref = '$&'; // step 5.d.i
			refReplacement = matched; // step 5.d.ii
		} else if (isPrefixOf('$\'', templateRemainder)) { // step 5.e
			ref = '$\''; // step 5.e.i
			var matchLength = matched.length; // step 5.e.ii
			var tailPos = position + matchLength; // step 5.e.iii
			refReplacement = substring(str, min(tailPos, stringLength)); // step 5.e.iv
			// 5.e.v NOTE: tailPos can exceed stringLength only if this abstract operation was invoked by a call to the intrinsic @@replace method of %RegExp.prototype% on an object whose "exec" property is not the intrinsic %RegExp.prototype.exec%.
		} else if (startsWithDollarDigit(templateRemainder)) { // step 5.f
			var digitCount = startsWithDollarTwoDigit(templateRemainder) ? 2 : 1; // step 5.f.i

			var digits = substring(templateRemainder, 1, 1 + digitCount); // step 5.f.ii

			var index = StringToNumber(digits); // step 5.f.iii

			if (index < 0 || index > 99) {
				throw new $TypeError('Assertion failed: `index` must be >= 0 and <= 99'); // step 5.f.iv
			}

			var captureLen = captures.length; // step 5.f.v

			if (index > captureLen && digitCount === 2) { // step 5.f.vi
				//  1. NOTE: When a two-digit replacement pattern specifies an index exceeding the count of capturing groups, it is treated as a one-digit replacement pattern followed by a literal digit.

				digitCount = 1; // step 5.f.vi.2

				digits = substring(digits, 0, 1); // step 5.f.vi.3

				index = StringToNumber(digits); // step 5.f.vi.4
			}

			ref = substring(templateRemainder, 0, 1 + digitCount); // step 5.f.vii

			if (1 <= index && index <= captureLen) { // step 5.f.viii
				capture = captures[index - 1]; // step 5.f.viii.1

				if (typeof capture === 'undefined') { // step 5.f.viii.2
					refReplacement = ''; // step 5.f.viii.2.a
				} else { // step 5.f.viii.3
					refReplacement = capture; // step 5.f.viii.3.a
				}
			} else { // step 5.f.ix
				refReplacement = ref; // step 5.f.ix.1
			}
		} else if (isPrefixOf('$<', templateRemainder)) { // step 5.g
			var gtPos = StringIndexOf(templateRemainder, '>', 0); // step 5.g.i
			if (!(gtPos > -1) || typeof namedCaptures === 'undefined') { // step 5.g.ii
				ref = '$<'; // step 5.g.ii.1
				refReplacement = ref; // step 5.g.ii.2
			} else { // step 5.g.iii
				ref = substring(templateRemainder, 0, gtPos + 1); // step 5.g.iii.1
				var groupName = substring(templateRemainder, 2, gtPos); // step 5.g.iii.2
				if (!isObject(namedCaptures)) {
					throw new $TypeError('Assertion failed: Type(namedCaptures) is not Object'); // step 5.g.iii.3
				}
				capture = Get(namedCaptures, groupName); // step 5.g.iii.4
				if (typeof capture === 'undefined') { // step 5.g.iii.5
					refReplacement = ''; // step 5.g.iii.5.a
				} else { // step 5.g.iii.6
					refReplacement = ToString(capture); // step 5.g.iii.6.a
				}
			}
		} else { // step 5.h
			ref = substring(templateRemainder, 0, 1); // step 5.h.i
			refReplacement = ref; // step 5.h.ii
		}

		var refLength = ref.length; // step 5.i

		templateRemainder = substring(templateRemainder, refLength); // step 5.j

		result += refReplacement; // step 5.k
	}

	return result; // step 6
};
'use strict';

var GetIntrinsic = require('get-intrinsic');

var MakeDay = require('./MakeDay');
var MakeTime = require('./MakeTime');
var MakeDate = require('./MakeDate');

var isInteger = require('math-intrinsics/isInteger');

var $BigInt = GetIntrinsic('%BigInt%', true);
var $SyntaxError = GetIntrinsic('%SyntaxError%');
var $TypeError = GetIntrinsic('%TypeError%');

// https://tc39.es/ecma262/#sec-getutcepochnanoseconds

// eslint-disable-next-line max-params
module.exports = function GetUTCEpochNanoseconds(
	year,
	month,
	day,
	hour,
	minute,
	second,
	millisecond,
	microsecond,
	nanosecond
) {
	if (!isInteger(year)) {
		throw new $TypeError('Assertion failed: `year` must be an integral Number');
	}
	if (!isInteger(month) || month < 1 || month > 12) {
		throw new $TypeError('Assertion failed: `month` must be an integral Number between 1 and 12, inclusive');
	}
	if (!isInteger(day) || day < 1 || day > 31) {
		throw new $TypeError('Assertion failed: `day` must be an integral Number between 1 and 31, inclusive');
	}
	if (!isInteger(hour) || hour < 0 || hour > 23) {
		throw new $TypeError('Assertion failed: `hour` must be an integral Number between 0 and 23, inclusive');
	}
	if (!isInteger(minute) || minute < 0 || minute > 59) {
		throw new $TypeError('Assertion failed: `minute` must be an integral Number between 0 and 59, inclusive');
	}
	if (!isInteger(second) || second < 0 || second > 59) {
		throw new $TypeError('Assertion failed: `second` must be an integral Number between 0 and 59, inclusive');
	}
	if (!isInteger(millisecond) || millisecond < 0 || millisecond > 999) {
		throw new $TypeError('Assertion failed: `millisecond` must be an integral Number between 0 and 999, inclusive');
	}
	if (!isInteger(microsecond) || microsecond < 0 || microsecond > 999) {
		throw new $TypeError('Assertion failed: `microsecond` must be an integral Number between 0 and 999, inclusive');
	}
	if (!isInteger(nanosecond) || nanosecond < 0 || nanosecond > 999) {
		throw new $TypeError('Assertion failed: `nanosecond` must be an integral Number between 0 and 999, inclusive');
	}

	var date = MakeDay(year, month - 1, day); // step 1
	var time = MakeTime(hour, minute, second, millisecond); // step 2
	var ms = MakeDate(date, time); // step 3
	if (!isInteger(ms)) {
		throw new $TypeError('Assertion failed: `ms` from MakeDate is not an integral Number'); // step 4
	}

	if (!$BigInt) {
		throw new $SyntaxError('BigInts are not supported in this environment');
	}
	return $BigInt((ms * 1e6) + (microsecond * 1e3) + nanosecond); // step 5
};
'use strict';

var GetIntrinsic = require('get-intrinsic');

var $SyntaxError = require('es-errors/syntax');
var $TypeError = require('es-errors/type');
var callBound = require('call-bound');
var isInteger = require('math-intrinsics/isInteger');
var $Uint8Array = GetIntrinsic('%Uint8Array%', true);

var $slice = callBound('Array.prototype.slice');

var IsDetachedBuffer = require('./IsDetachedBuffer');
var RawBytesToNumeric = require('./RawBytesToNumeric');

var isArrayBuffer = require('is-array-buffer');
var isSharedArrayBuffer = require('is-shared-array-buffer');
var safeConcat = require('safe-array-concat');

var tableTAO = require('./tables/typed-array-objects');

var defaultEndianness = require('../helpers/defaultEndianness');

// https://262.ecma-international.org/15.0/#sec-getvaluefrombuffer

module.exports = function GetValueFromBuffer(arrayBuffer, byteIndex, type, isTypedArray, order) {
	var isSAB = isSharedArrayBuffer(arrayBuffer);
	if (!isArrayBuffer(arrayBuffer) && !isSAB) {
		throw new $TypeError('Assertion failed: `arrayBuffer` must be an ArrayBuffer or a SharedArrayBuffer');
	}

	if (!isInteger(byteIndex)) {
		throw new $TypeError('Assertion failed: `byteIndex` must be an integer');
	}

	if (typeof type !== 'string' || typeof tableTAO.size['$' + type] !== 'number') {
		throw new $TypeError('Assertion failed: `type` must be one of ' + tableTAO.choices);
	}

	if (typeof isTypedArray !== 'boolean') {
		throw new $TypeError('Assertion failed: `isTypedArray` must be a boolean');
	}

	if (order !== 'SEQ-CST' && order !== 'UNORDERED') {
		throw new $TypeError('Assertion failed: `order` must be either `SEQ-CST` or `UNORDERED`');
	}

	if (arguments.length > 5 && typeof arguments[5] !== 'boolean') {
		throw new $TypeError('Assertion failed: `isLittleEndian` must be a boolean, if present');
	}

	if (IsDetachedBuffer(arrayBuffer)) {
		throw new $TypeError('Assertion failed: `arrayBuffer` is detached'); // step 1
	}

	// 2. Assert: There are sufficient bytes in arrayBuffer starting at byteIndex to represent a value of type.

	if (byteIndex < 0) {
		throw new $TypeError('Assertion failed: `byteIndex` must be non-negative'); // step 3
	}

	// 4. Let block be arrayBuffer.[[ArrayBufferData]].

	var elementSize = tableTAO.size['$' + type]; // step 5
	if (!elementSize) {
		throw new $TypeError('Assertion failed: `type` must be one of ' + tableTAO.choices);
	}

	var rawValue;
	if (isSAB) { // step 6
		/*
		a. Let execution be the [[CandidateExecution]] field of the surrounding agent's Agent Record.
		b. Let eventList be the [[EventList]] field of the element in execution.[[EventLists]] whose [[AgentSignifier]] is AgentSignifier().
		c. If isTypedArray is true and type is "Int8", "Uint8", "Int16", "Uint16", "Int32", or "Uint32", let noTear be true; otherwise let noTear be false.
		d. Let rawValue be a List of length elementSize of nondeterministically chosen byte values.
		e. NOTE: In implementations, rawValue is the result of a non-atomic or atomic read instruction on the underlying hardware. The nondeterminism is a semantic prescription of the memory model to describe observable behaviour of hardware with weak consistency.
		f. Let readEvent be ReadSharedMemory{ [[Order]]: order, [[NoTear]]: noTear, [[Block]]: block, [[ByteIndex]]: byteIndex, [[ElementSize]]: elementSize }.
		g. Append readEvent to eventList.
		h. Append Chosen Value Record { [[Event]]: readEvent, [[ChosenValue]]: rawValue } to execution.[[ChosenValues]].
		*/
		throw new $SyntaxError('SharedArrayBuffer is not supported by this implementation');
	} else {
		// 7. Let rawValue be a List of elementSize containing, in order, the elementSize sequence of bytes starting with block[byteIndex].
		rawValue = $slice(new $Uint8Array(arrayBuffer, byteIndex), 0, elementSize); // step 6
	}

	// 8. If isLittleEndian is not present, set isLittleEndian to either true or false. The choice is implementation dependent and should be the alternative that is most efficient for the implementation. An implementation must use the same value each time this step is executed and the same value must be used for the corresponding step in the SetValueInBuffer abstract operation.
	var isLittleEndian = arguments.length > 5 ? arguments[5] : defaultEndianness === 'little'; // step 8

	var bytes = isLittleEndian
		? $slice(safeConcat([0, 0, 0, 0, 0, 0, 0, 0], rawValue), -elementSize)
		: $slice(safeConcat(rawValue, [0, 0, 0, 0, 0, 0, 0, 0]), 0, elementSize);

	return RawBytesToNumeric(type, bytes, isLittleEndian);
};
'use strict';

var $TypeError = require('es-errors/type');

var IsFixedLengthArrayBuffer = require('./IsFixedLengthArrayBuffer');
var IsViewOutOfBounds = require('./IsViewOutOfBounds');

var isDataViewWithBufferWitnessRecord = require('../helpers/records/data-view-with-buffer-witness-record');

var dataViewBuffer = require('data-view-buffer');
var dataViewByteLength = require('data-view-byte-length');
var dataViewByteOffset = require('data-view-byte-offset');

// https://262.ecma-international.org/15.0/#sec-getviewbytelength

module.exports = function GetViewByteLength(viewRecord) {
	if (!isDataViewWithBufferWitnessRecord(viewRecord)) {
		throw new $TypeError('Assertion failed: `viewRecord` must be a DataView with Buffer Witness Record');
	}

	if (IsViewOutOfBounds(viewRecord)) {
		throw new $TypeError('Assertion failed: `viewRecord` is out of bounds'); // step 1
	}

	var view = viewRecord['[[Object]]']; // step 2

	var isFixed = IsFixedLengthArrayBuffer(dataViewBuffer(view));

	var viewByteLength = isFixed ? dataViewByteLength(view) : 'AUTO'; // view.[[ByteLength]]
	if (viewByteLength !== 'AUTO') {
		return viewByteLength; // step 3
	}

	if (isFixed) {
		throw new $TypeError('Assertion failed: DataView’s ArrayBuffer is not fixed length'); // step 4
	}

	var byteOffset = dataViewByteOffset(view); // step 5

	var byteLength = viewRecord['[[CachedBufferByteLength]]']; // step 6

	if (byteLength === 'DETACHED') {
		throw new $TypeError('Assertion failed: DataView’s ArrayBuffer is detached'); // step 7
	}

	return byteLength - byteOffset; // step 8
};
'use strict';

var $TypeError = require('es-errors/type');

var inspect = require('object-inspect');

var isPropertyKey = require('../helpers/isPropertyKey');
// var ToObject = require('./ToObject');

// https://262.ecma-international.org/6.0/#sec-getv

module.exports = function GetV(V, P) {
	// 7.3.2.1
	if (!isPropertyKey(P)) {
		throw new $TypeError('Assertion failed: P is not a Property Key, got ' + inspect(P));
	}

	// 7.3.2.2-3
	// var O = ToObject(V);

	// 7.3.2.4
	return V[P];
};
'use strict';

var $TypeError = require('es-errors/type');

var AddValueToKeyedGroup = require('./AddValueToKeyedGroup');
var Call = require('./Call');
var CanonicalizeKeyedCollectionKey = require('./CanonicalizeKeyedCollectionKey');
var GetIterator = require('./GetIterator');
var IfAbruptCloseIterator = require('./IfAbruptCloseIterator');
var IsCallable = require('./IsCallable');
var IteratorClose = require('./IteratorClose');
var IteratorStep = require('./IteratorStep');
var IteratorValue = require('./IteratorValue');
var RequireObjectCoercible = require('./RequireObjectCoercible');
var ThrowCompletion = require('./ThrowCompletion');
var ToPropertyKey = require('./ToPropertyKey');

var maxSafeInteger = require('../helpers/maxSafeInteger');

// https://262.ecma-international.org/16.0/#sec-groupby

module.exports = function GroupBy(items, callbackfn, keyCoercion) {
	if (keyCoercion !== 'PROPERTY' && keyCoercion !== 'COLLECTION') {
		throw new $TypeError('Assertion failed: `keyCoercion` must be `"PROPERTY"` or `"COLLECTION"`');
	}

	RequireObjectCoercible(items); // step 1

	if (!IsCallable(callbackfn)) {
		throw new $TypeError('callbackfn must be callable'); // step 2
	}

	var groups = []; // step 3

	var iteratorRecord = GetIterator(items, 'SYNC'); // step 4

	var k = 0; // step 5

	// eslint-disable-next-line no-constant-condition
	while (true) { // step 6
		if (k >= maxSafeInteger) { // step 6.a
			var error = ThrowCompletion(new $TypeError('k must be less than 2 ** 53 - 1')); // step 6.a.i
			return IteratorClose(iteratorRecord, error); // step 6.a.ii
		}
		var next = IteratorStep(iteratorRecord); // step 6.b
		if (!next) { // step 6.c
			return groups; // step 6.c.i
		}

		var value = IteratorValue(next); // step 6.dv

		var key;
		try {
			key = Call(callbackfn, undefined, [value, k]); // step 6.e
		} catch (e) {
			IfAbruptCloseIterator(ThrowCompletion(e), iteratorRecord); // step 6.f
		}

		if (keyCoercion === 'PROPERTY') { // step 6.g
			try {
				key = ToPropertyKey(key); // step 6.g.i
			} catch (e) {
				IfAbruptCloseIterator(ThrowCompletion(e), iteratorRecord); // step 6.g.ii
			}
		} else { // step 6.h
			if (keyCoercion !== 'COLLECTION') {
				throw new $TypeError('keyCoercion must be ~PROPERTY~ or ~COLLECTION~'); // step 6.h.i
			}
			key = CanonicalizeKeyedCollectionKey(key); // step 6.h.ii
		}

		AddValueToKeyedGroup(groups, key, value); // step 6.i

		k += 1; // step 6.j
	}
};
'use strict';

var $TypeError = require('es-errors/type');

var isRegExpRecord = require('../helpers/records/regexp-record');

// https://262.ecma-international.org/15.0/#sec-runtime-semantics-haseitherunicodeflag-abstract-operation

module.exports = function HasEitherUnicodeFlag(rer) {
	if (!isRegExpRecord(rer)) {
		throw new $TypeError('Assertion failed: `rer` must be a RegExp Record');
	}

	if (rer['[[Unicode]]'] || rer['[[UnicodeSets]]']) { // step 1
		return true; // step 1.a
	}
	return false; // step 2
};
'use strict';

var $TypeError = require('es-errors/type');

var hasOwn = require('hasown');
var isObject = require('es-object-atoms/isObject');

var isPropertyKey = require('../helpers/isPropertyKey');

// https://262.ecma-international.org/6.0/#sec-hasownproperty

module.exports = function HasOwnProperty(O, P) {
	if (!isObject(O)) {
		throw new $TypeError('Assertion failed: `O` must be an Object');
	}
	if (!isPropertyKey(P)) {
		throw new $TypeError('Assertion failed: `P` must be a Property Key');
	}
	return hasOwn(O, P);
};
'use strict';

var $TypeError = require('es-errors/type');
var isObject = require('es-object-atoms/isObject');

var isPropertyKey = require('../helpers/isPropertyKey');

// https://262.ecma-international.org/6.0/#sec-hasproperty

module.exports = function HasProperty(O, P) {
	if (!isObject(O)) {
		throw new $TypeError('Assertion failed: `O` must be an Object');
	}
	if (!isPropertyKey(P)) {
		throw new $TypeError('Assertion failed: `P` must be a Property Key');
	}
	return P in O;
};
'use strict';

var floor = require('./floor');
var modulo = require('./modulo');

var timeConstants = require('../helpers/timeConstants');
var msPerHour = timeConstants.msPerHour;
var HoursPerDay = timeConstants.HoursPerDay;

// https://262.ecma-international.org/5.1/#sec-15.9.1.10

module.exports = function HourFromTime(t) {
	return modulo(floor(t / msPerHour), HoursPerDay);
};
'use strict';

var $TypeError = require('es-errors/type');

var CompletionRecord = require('./CompletionRecord');
var IteratorClose = require('./IteratorClose');

// https://262.ecma-international.org/16.0/#sec-ifabruptcloseiterator

module.exports = function IfAbruptCloseIterator(value, iteratorRecord) {
	if (!(value instanceof CompletionRecord)) {
		throw new $TypeError('Assertion failed: `value` must be a Completion Record'); // step 1
	}
	if (value.type() === 'throw') {
		return IteratorClose(iteratorRecord, value); // step 2
	}

	return value['!'](); // step
};
'use strict';

var $EvalError = require('es-errors/eval');

var DaysInYear = require('./DaysInYear');
var YearFromTime = require('./YearFromTime');

// https://262.ecma-international.org/5.1/#sec-15.9.1.3

module.exports = function InLeapYear(t) {
	var days = DaysInYear(YearFromTime(t));
	if (days === 365) {
		return 0;
	}
	if (days === 366) {
		return 1;
	}
	throw new $EvalError('Assertion failed: there are not 365 or 366 days in a year, got: ' + days);
};
'use strict';

var $TypeError = require('es-errors/type');
var isObject = require('es-object-atoms/isObject');

var CreateNonEnumerableDataPropertyOrThrow = require('./CreateNonEnumerableDataPropertyOrThrow');
var Get = require('./Get');
var HasProperty = require('./HasProperty');

// https://262.ecma-international.org/13.0/#sec-installerrorcause

module.exports = function InstallErrorCause(O, options) {
	if (!isObject(O)) {
		throw new $TypeError('Assertion failed: Type(O) is not Object');
	}

	if (isObject(options) && HasProperty(options, 'cause')) {
		var cause = Get(options, 'cause');
		CreateNonEnumerableDataPropertyOrThrow(O, 'cause', cause);
	}
};
'use strict';

var GetIntrinsic = require('get-intrinsic');

var $TypeError = require('es-errors/type');
var isObject = require('es-object-atoms/isObject');

var $hasInstance = GetIntrinsic('%Symbol.hasInstance%', true);

var Call = require('./Call');
var GetMethod = require('./GetMethod');
var IsCallable = require('./IsCallable');
var OrdinaryHasInstance = require('./OrdinaryHasInstance');
var ToBoolean = require('./ToBoolean');

// https://262.ecma-international.org/6.0/#sec-instanceofoperator

module.exports = function InstanceofOperator(O, C) {
	if (!isObject(O)) {
		throw new $TypeError('Assertion failed: Type(O) is not Object');
	}
	var instOfHandler = $hasInstance ? GetMethod(C, $hasInstance) : void 0;
	if (typeof instOfHandler !== 'undefined') {
		return ToBoolean(Call(instOfHandler, C, [O]));
	}
	if (!IsCallable(C)) {
		throw new $TypeError('`C` is not Callable');
	}
	return OrdinaryHasInstance(C, O);
};
'use strict';

var $TypeError = require('es-errors/type');
var isObject = require('es-object-atoms/isObject');

var Call = require('./Call');
var CreateDataProperty = require('./CreateDataProperty');
var EnumerableOwnProperties = require('./EnumerableOwnProperties');
var Get = require('./Get');
var IsArray = require('./IsArray');
var LengthOfArrayLike = require('./LengthOfArrayLike');
var ToString = require('./ToString');

var forEach = require('../helpers/forEach');

// https://262.ecma-international.org/14.0/#sec-internalizejsonproperty

// note: `reviver` was implicitly closed-over until ES2020, where it becomes a third argument

module.exports = function InternalizeJSONProperty(holder, name, reviver) {
	if (!isObject(holder)) {
		throw new $TypeError('Assertion failed: `holder` is not an Object');
	}
	if (typeof name !== 'string') {
		throw new $TypeError('Assertion failed: `name` is not a String');
	}
	if (typeof reviver !== 'function') {
		throw new $TypeError('Assertion failed: `reviver` is not a Function');
	}

	var val = Get(holder, name); // step 1

	if (isObject(val)) { // step 2
		var isArray = IsArray(val); // step 2.a
		if (isArray) { // step 2.b
			var I = 0; // step 2.b.i

			var len = LengthOfArrayLike(val); // step 2.b.ii

			while (I < len) { // step 2.b.iii
				var newElement = InternalizeJSONProperty(val, ToString(I), reviver); // step 2.b.iv.1

				if (typeof newElement === 'undefined') { // step 2.b.iii.2
					delete val[ToString(I)]; // step 2.b.iii.2.a
				} else { // step 2.b.iii.3
					CreateDataProperty(val, ToString(I), newElement); // step 2.b.iii.3.a
				}

				I += 1; // step 2.b.iii.4
			}
		} else { // step 2.c
			var keys = EnumerableOwnProperties(val, 'key'); // step 2.c.i

			forEach(keys, function (P) { // step 2.c.ii
				// eslint-disable-next-line no-shadow
				var newElement = InternalizeJSONProperty(val, P, reviver); // step 2.c.ii.1

				if (typeof newElement === 'undefined') { // step 2.c.ii.2
					delete val[P]; // step 2.c.ii.2.a
				} else { // step 2.c.ii.3
					CreateDataProperty(val, P, newElement); // step 2.c.ii.3.a
				}
			});
		}
	}

	return Call(reviver, holder, [name, val]); // step 3
};
'use strict';

var $TypeError = require('es-errors/type');

var Call = require('./Call');
var IsArray = require('./IsArray');
var GetV = require('./GetV');
var isPropertyKey = require('../helpers/isPropertyKey');

// https://262.ecma-international.org/6.0/#sec-invoke

module.exports = function Invoke(O, P) {
	if (!isPropertyKey(P)) {
		throw new $TypeError('Assertion failed: P must be a Property Key');
	}
	var argumentsList = arguments.length > 2 ? arguments[2] : [];
	if (!IsArray(argumentsList)) {
		throw new $TypeError('Assertion failed: optional `argumentsList`, if provided, must be a List');
	}
	var func = GetV(O, P);
	return Call(func, O, argumentsList);
};
'use strict';

var $TypeError = require('es-errors/type');

var hasOwn = require('hasown');

var isPropertyDescriptor = require('../helpers/records/property-descriptor');

// https://262.ecma-international.org/5.1/#sec-8.10.1

module.exports = function IsAccessorDescriptor(Desc) {
	if (typeof Desc === 'undefined') {
		return false;
	}

	if (!isPropertyDescriptor(Desc)) {
		throw new $TypeError('Assertion failed: `Desc` must be a Property Descriptor');
	}

	if (!hasOwn(Desc, '[[Get]]') && !hasOwn(Desc, '[[Set]]')) {
		return false;
	}

	return true;
};
'use strict';

var $TypeError = require('es-errors/type');

var IsTypedArrayOutOfBounds = require('./IsTypedArrayOutOfBounds');
var IsViewOutOfBounds = require('./IsViewOutOfBounds');
var MakeDataViewWithBufferWitnessRecord = require('./MakeDataViewWithBufferWitnessRecord');
var MakeTypedArrayWithBufferWitnessRecord = require('./MakeTypedArrayWithBufferWitnessRecord');

var isDataView = require('is-data-view');
var isTypedArray = require('is-typed-array');

// https://262.ecma-international.org/15.0/#sec-isarraybufferviewoutofbounds

module.exports = function IsArrayBufferViewOutOfBounds(O) {
	var isDV = isDataView(O);
	if (!isTypedArray(O) && !isDV) {
		throw new $TypeError('Assertion failed: `O` must be a TypedArray or DataView');
	}

	if (isDV) { // step 1
		var viewRecord = MakeDataViewWithBufferWitnessRecord(O, 'SEQ-CST'); // step 1.a

		return IsViewOutOfBounds(viewRecord); // step 1.b
	}

	var taRecord = MakeTypedArrayWithBufferWitnessRecord(O, 'SEQ-CST'); // step 2

	return IsTypedArrayOutOfBounds(taRecord); // step 3
};
'use strict';

// https://262.ecma-international.org/6.0/#sec-isarray
module.exports = require('../helpers/IsArray');
'use strict';

// https://262.ecma-international.org/15.0/#sec-isbigintelementtype

module.exports = function IsBigIntElementType(type) {
	return type === 'BIGUINT64' || type === 'BIGINT64';
};
'use strict';

// http://262.ecma-international.org/5.1/#sec-9.11

module.exports = require('is-callable');
'use strict';

var ValidateAndApplyPropertyDescriptor = require('./ValidateAndApplyPropertyDescriptor');

// https://262.ecma-international.org/13.0/#sec-iscompatiblepropertydescriptor

module.exports = function IsCompatiblePropertyDescriptor(Extensible, Desc, Current) {
	return ValidateAndApplyPropertyDescriptor(undefined, '', Extensible, Desc, Current);
};
'use strict';

var GetIntrinsic = require('get-intrinsic');

var $isConcatSpreadable = GetIntrinsic('%Symbol.isConcatSpreadable%', true);

var Get = require('./Get');
var IsArray = require('./IsArray');
var ToBoolean = require('./ToBoolean');

var isObject = require('es-object-atoms/isObject');

// https://262.ecma-international.org/6.0/#sec-isconcatspreadable

module.exports = function IsConcatSpreadable(O) {
	if (!isObject(O)) {
		return false;
	}
	if ($isConcatSpreadable) {
		var spreadable = Get(O, $isConcatSpreadable);
		if (typeof spreadable !== 'undefined') {
			return ToBoolean(spreadable);
		}
	}
	return IsArray(O);
};
'use strict';

var GetIntrinsic = require('../GetIntrinsic.js');

var $construct = GetIntrinsic('%Reflect.construct%', true);

var DefinePropertyOrThrow = require('./DefinePropertyOrThrow');
try {
	DefinePropertyOrThrow({}, '', { '[[Get]]': function () {} });
} catch (e) {
	// Accessor properties aren't supported
	DefinePropertyOrThrow = null;
}

// https://262.ecma-international.org/6.0/#sec-isconstructor

if (DefinePropertyOrThrow && $construct) {
	var isConstructorMarker = {};
	var badArrayLike = {};
	DefinePropertyOrThrow(badArrayLike, 'length', {
		'[[Get]]': function () {
			throw isConstructorMarker;
		},
		'[[Enumerable]]': true
	});

	module.exports = function IsConstructor(argument) {
		try {
			// `Reflect.construct` invokes `IsConstructor(target)` before `Get(args, 'length')`:
			$construct(argument, badArrayLike);
		} catch (err) {
			return err === isConstructorMarker;
		}
	};
} else {
	module.exports = function IsConstructor(argument) {
		// unfortunately there's no way to truly check this without try/catch `new argument` in old environments
		return typeof argument === 'function' && !!argument.prototype;
	};
}
'use strict';

var $TypeError = require('es-errors/type');

var hasOwn = require('hasown');

var isPropertyDescriptor = require('../helpers/records/property-descriptor');

// https://262.ecma-international.org/5.1/#sec-8.10.2

module.exports = function IsDataDescriptor(Desc) {
	if (typeof Desc === 'undefined') {
		return false;
	}

	if (!isPropertyDescriptor(Desc)) {
		throw new $TypeError('Assertion failed: `Desc` must be a Property Descriptor');
	}

	if (!hasOwn(Desc, '[[Value]]') && !hasOwn(Desc, '[[Writable]]')) {
		return false;
	}

	return true;
};
'use strict';

var $TypeError = require('es-errors/type');

var $byteLength = require('array-buffer-byte-length');
var availableTypedArrays = require('available-typed-arrays')();
var callBound = require('call-bound');
var isArrayBuffer = require('is-array-buffer');
var isSharedArrayBuffer = require('is-shared-array-buffer');

var $sabByteLength = callBound('SharedArrayBuffer.prototype.byteLength', true);

// https://262.ecma-international.org/8.0/#sec-isdetachedbuffer

module.exports = function IsDetachedBuffer(arrayBuffer) {
	var isSAB = isSharedArrayBuffer(arrayBuffer);
	if (!isArrayBuffer(arrayBuffer) && !isSAB) {
		throw new $TypeError('Assertion failed: `arrayBuffer` must be an Object with an [[ArrayBufferData]] internal slot');
	}
	if ((isSAB ? $sabByteLength : $byteLength)(arrayBuffer) === 0) {
		try {
			new global[availableTypedArrays[0]](arrayBuffer); // eslint-disable-line no-new
		} catch (error) {
			return !!error && error.name === 'TypeError';
		}
	}
	return false;
};
'use strict';

var GetIntrinsic = require('get-intrinsic');

var $preventExtensions = GetIntrinsic('%Object.preventExtensions%', true);
var $isExtensible = GetIntrinsic('%Object.isExtensible%', true);

var isPrimitive = require('../helpers/isPrimitive');

// https://262.ecma-international.org/6.0/#sec-isextensible-o

module.exports = $preventExtensions
	? function IsExtensible(obj) {
		return !isPrimitive(obj) && $isExtensible(obj);
	}
	: function IsExtensible(obj) {
		return !isPrimitive(obj);
	};
'use strict';

var $TypeError = require('es-errors/type');

var callBound = require('call-bound');

var $arrayBufferResizable = callBound('%ArrayBuffer.prototype.resizable%', true);
var $sharedArrayGrowable = callBound('%SharedArrayBuffer.prototype.growable%', true);

var isArrayBuffer = require('is-array-buffer');
var isSharedArrayBuffer = require('is-shared-array-buffer');

// https://262.ecma-international.org/15.0/#sec-isfixedlengtharraybuffer

module.exports = function IsFixedLengthArrayBuffer(arrayBuffer) {
	var isAB = isArrayBuffer(arrayBuffer);
	var isSAB = isSharedArrayBuffer(arrayBuffer);
	if (!isAB && !isSAB) {
		throw new $TypeError('Assertion failed: `arrayBuffer` must be an ArrayBuffer or SharedArrayBuffer');
	}

	if (isAB && $arrayBufferResizable) {
		return !$arrayBufferResizable(arrayBuffer); // step 1
	}
	if (isSAB && $sharedArrayGrowable) {
		return !$sharedArrayGrowable(arrayBuffer); // step 1
	}
	return true; // step 2
};
'use strict';

var $TypeError = require('es-errors/type');

var IsAccessorDescriptor = require('./IsAccessorDescriptor');
var IsDataDescriptor = require('./IsDataDescriptor');

var isPropertyDescriptor = require('../helpers/records/property-descriptor');

// https://262.ecma-international.org/6.0/#sec-isgenericdescriptor

module.exports = function IsGenericDescriptor(Desc) {
	if (typeof Desc === 'undefined') {
		return false;
	}

	if (!isPropertyDescriptor(Desc)) {
		throw new $TypeError('Assertion failed: `Desc` must be a Property Descriptor');
	}

	if (!IsAccessorDescriptor(Desc) && !IsDataDescriptor(Desc)) {
		return true;
	}

	return false;
};
'use strict';

var GetIntrinsic = require('get-intrinsic');

var $Number = GetIntrinsic('%Number%');
var $TypeError = require('es-errors/type');
var min = require('math-intrinsics/min');
var $isNaN = require('math-intrinsics/isNaN');

var $charCodeAt = require('call-bound')('String.prototype.charCodeAt');

var StringToBigInt = require('./StringToBigInt');
var ToNumeric = require('./ToNumeric');
var ToPrimitive = require('./ToPrimitive');

var BigIntLessThan = require('./BigInt/lessThan');
var NumberLessThan = require('./Number/lessThan');

// https://262.ecma-international.org/14.0/#sec-islessthan

// eslint-disable-next-line max-statements, max-lines-per-function
module.exports = function IsLessThan(x, y, LeftFirst) {
	if (typeof LeftFirst !== 'boolean') {
		throw new $TypeError('Assertion failed: LeftFirst argument must be a Boolean');
	}
	var px;
	var py;
	if (LeftFirst) {
		px = ToPrimitive(x, $Number);
		py = ToPrimitive(y, $Number);
	} else {
		py = ToPrimitive(y, $Number);
		px = ToPrimitive(x, $Number);
	}

	if (typeof px === 'string' && typeof py === 'string') { // step 3
		// a. Let lx be the length of px.
		// b. Let ly be the length of py.
		// c. For each integer i starting with 0 such that i < min(lx, ly), in ascending order, do
		// i. Let cx be the integer that is the numeric value of the code unit at index i within px.
		// ii. Let cy be the integer that is the numeric value of the code unit at index i within py.
		// iii. If cx < cy, return true.
		// iv. If cx > cy, return false.
		// d. If lx < ly, return true. Otherwise, return false.

		var lx = px.length; // step 3.a
		var ly = py.length; // step 3.b
		for (var i = 0; i < min(lx, ly); i++) { // step 3.c
			var cx = $charCodeAt(px, i); // step 3.c.i
			var cy = $charCodeAt(py, i); // step 3.c.ii
			if (cx < cy) {
				return true; // step 3.c.iii
			}
			if (cx > cy) {
				return false; // step 3.c.iv
			}
		}
		return lx < ly; // step 3.d
	}

	var nx;
	var ny;
	if (typeof px === 'bigint' && typeof py === 'string') {
		ny = StringToBigInt(py);
		if (typeof ny === 'undefined') {
			return void undefined;
		}
		return BigIntLessThan(px, ny);
	}
	if (typeof px === 'string' && typeof py === 'bigint') {
		nx = StringToBigInt(px);
		if (typeof nx === 'undefined') {
			return void undefined;
		}
		return BigIntLessThan(nx, py);
	}

	nx = ToNumeric(px);
	ny = ToNumeric(py);

	if (typeof nx === typeof ny) {
		return typeof nx === 'number' ? NumberLessThan(nx, ny) : BigIntLessThan(nx, ny);
	}

	if ($isNaN(nx) || $isNaN(ny)) {
		return void undefined;
	}

	if (nx === -Infinity || ny === Infinity) {
		return true;
	}
	if (nx === Infinity || ny === -Infinity) {
		return false;
	}

	return nx < ny; // by now, these are both finite, and the same type
};
'use strict';

var isFinite = require('math-intrinsics/isFinite');
var isObject = require('es-object-atoms/isObject');

var IsStrictlyEqual = require('./IsStrictlyEqual');
var StringToBigInt = require('./StringToBigInt');
var ToNumber = require('./ToNumber');
var ToPrimitive = require('./ToPrimitive');

var isSameType = require('../helpers/isSameType');

// https://262.ecma-international.org/13.0/#sec-islooselyequal

module.exports = function IsLooselyEqual(x, y) {
	if (isSameType(x, y)) {
		return IsStrictlyEqual(x, y);
	}
	if (x == null && y == null) {
		return true;
	}
	if (typeof x === 'number' && typeof y === 'string') {
		return IsLooselyEqual(x, ToNumber(y));
	}
	if (typeof x === 'string' && typeof y === 'number') {
		return IsLooselyEqual(ToNumber(x), y);
	}
	if (typeof x === 'bigint' && typeof y === 'string') {
		var n = StringToBigInt(y);
		if (typeof n === 'undefined') {
			return false;
		}
		return IsLooselyEqual(x, n);
	}
	if (typeof x === 'string' && typeof y === 'bigint') {
		return IsLooselyEqual(y, x);
	}
	if (typeof x === 'boolean') {
		return IsLooselyEqual(ToNumber(x), y);
	}
	if (typeof y === 'boolean') {
		return IsLooselyEqual(x, ToNumber(y));
	}
	if ((typeof x === 'string' || typeof x === 'number' || typeof x === 'symbol' || typeof x === 'bigint') && isObject(y)) {
		return IsLooselyEqual(x, ToPrimitive(y));
	}
	if (isObject(x) && (typeof y === 'string' || typeof y === 'number' || typeof y === 'symbol' || typeof y === 'bigint')) {
		return IsLooselyEqual(ToPrimitive(x), y);
	}
	if ((typeof x === 'bigint' && typeof y === 'number') || (typeof x === 'number' && typeof y === 'bigint')) {
		if (!isFinite(x) || !isFinite(y)) {
			return false;
		}
		// eslint-disable-next-line eqeqeq
		return x == y; // shortcut for step 13.b.
	}
	return false;
};
'use strict';

var IsUnclampedIntegerElementType = require('./IsUnclampedIntegerElementType');
var IsBigIntElementType = require('./IsBigIntElementType');

// https://262.ecma-international.org/15.0/#sec-isnotearconfiguration

module.exports = function IsNoTearConfiguration(type, order) {
	if (IsUnclampedIntegerElementType(type)) {
		return true;
	}
	if (IsBigIntElementType(type) && order !== 'INIT' && order !== 'UNORDERED') {
		return true;
	}
	return false;
};
'use strict';

var callBound = require('call-bound');

var $PromiseThen = callBound('Promise.prototype.then', true);

var isObject = require('es-object-atoms/isObject');

// https://262.ecma-international.org/6.0/#sec-ispromise

module.exports = function IsPromise(x) {
	if (!isObject(x)) {
		return false;
	}
	if (!$PromiseThen) { // Promises are not supported
		return false;
	}
	try {
		$PromiseThen(x); // throws if not a promise
	} catch (e) {
		return false;
	}
	return true;
};
'use strict';

var GetIntrinsic = require('get-intrinsic');

var $match = GetIntrinsic('%Symbol.match%', true);

var hasRegExpMatcher = require('is-regex');
var isObject = require('es-object-atoms/isObject');

var ToBoolean = require('./ToBoolean');

// https://262.ecma-international.org/6.0/#sec-isregexp

module.exports = function IsRegExp(argument) {
	if (!isObject(argument)) {
		return false;
	}
	if ($match) {
		var isRegExp = argument[$match];
		if (typeof isRegExp !== 'undefined') {
			return ToBoolean(isRegExp);
		}
	}
	return hasRegExpMatcher(argument);
};
'use strict';

var $TypeError = require('es-errors/type');
var isObject = require('es-object-atoms/isObject');

var isSharedArrayBuffer = require('is-shared-array-buffer');

// https://262.ecma-international.org/8.0/#sec-issharedarraybuffer

module.exports = function IsSharedArrayBuffer(obj) {
	if (!isObject(obj)) {
		throw new $TypeError('Assertion failed: Type(O) is not Object');
	}

	return isSharedArrayBuffer(obj);
};
'use strict';

var SameValueNonNumber = require('./SameValueNonNumber');
var NumberEqual = require('./Number/equal');
var SameType = require('./SameType');

// https://262.ecma-international.org/16.0/#sec-isstrictlyequal

module.exports = function IsStrictlyEqual(x, y) {
	if (!SameType(x, y)) {
		return false;
	}
	return typeof x === 'number' ? NumberEqual(x, y) : SameValueNonNumber(x, y);
};
'use strict';

var CodePointAt = require('./CodePointAt');

var $TypeError = require('es-errors/type');

// https://262.ecma-international.org/14.0/#sec-isstringwellformedunicode

module.exports = function IsStringWellFormedUnicode(string) {
	if (typeof string !== 'string') {
		throw new $TypeError('Assertion failed: `string` must be a String');
	}
	var len = string.length; // step 1
	var k = 0; // step 2
	while (k < len) { // step 3
		var cp = CodePointAt(string, k); // step 3.a
		if (cp['[[IsUnpairedSurrogate]]']) {
			return false; // step 3.b
		}
		k += cp['[[CodeUnitCount]]']; // step 3.c
	}
	return true; // step 4
};
'use strict';

var $TypeError = require('es-errors/type');

var regexTester = require('safe-regex-test');

// https://tc39.es/ecma262/#sec-istimezoneoffsetstring

// implementation taken from https://github.com/tc39/proposal-temporal/blob/21ee5b13f0672990c807475ba094092d19dd6dc5/polyfill/lib/ecmascript.mjs#L2140

var OFFSET = /^([+\u2212-])([01][0-9]|2[0-3])(?::?([0-5][0-9])(?::?([0-5][0-9])(?:[.,](\d{1,9}))?)?)?$/;

var testOffset = regexTester(OFFSET);

module.exports = function IsTimeZoneOffsetString(offsetString) {
	if (typeof offsetString !== 'string') {
		throw new $TypeError('Assertion failed: `offsetString` must be a String');
	}
	return testOffset(offsetString);
};
'use strict';

var $TypeError = require('es-errors/type');

var isTypedArray = require('is-typed-array');
var typedArrayBuffer = require('typed-array-buffer');
var typedArrayLength = require('typed-array-length');

var IsFixedLengthArrayBuffer = require('./IsFixedLengthArrayBuffer');
var IsSharedArrayBuffer = require('./IsSharedArrayBuffer');

// https://262.ecma-international.org/16.0/#sec-istypedarrayfixedlength

module.exports = function IsTypedArrayFixedLength(O) {
	if (!isTypedArray(O)) {
		throw new $TypeError('Assertion failed: `obj` must be a Typed Array');
	}

	// 2. Let buffer be O.[[ViewedArrayBuffer]].
	var buffer = typedArrayBuffer(O); // step 2

	var isFixed = IsFixedLengthArrayBuffer(buffer);

	var length = isFixed ? typedArrayLength(O) : 'AUTO';
	if (length === 'AUTO') {
		return false; // step 1
	}

	if (!isFixed && !IsSharedArrayBuffer(buffer)) {
		return false; // step 3
	}

	return true; // step 4
};
'use strict';

var $TypeError = require('es-errors/type');

var IsDetachedBuffer = require('./IsDetachedBuffer');
var IsFixedLengthArrayBuffer = require('./IsFixedLengthArrayBuffer');
var TypedArrayElementSize = require('./TypedArrayElementSize');

var isTypedArrayWithBufferWitnessRecord = require('../helpers/records/typed-array-with-buffer-witness-record');

var typedArrayBuffer = require('typed-array-buffer');
var typedArrayByteOffset = require('typed-array-byte-offset');
var typedArrayLength = require('typed-array-length');

// https://262.ecma-international.org/15.0/#sec-istypedarrayoutofbounds

module.exports = function IsTypedArrayOutOfBounds(taRecord) {
	if (!isTypedArrayWithBufferWitnessRecord(taRecord)) {
		throw new $TypeError('Assertion failed: `taRecord` must be a TypedArray With Buffer Witness Record');
	}

	var O = taRecord['[[Object]]']; // step 1

	var bufferByteLength = taRecord['[[CachedBufferByteLength]]']; // step 2

	if (IsDetachedBuffer(typedArrayBuffer(O)) && bufferByteLength !== 'DETACHED') {
		throw new $TypeError('Assertion failed: typed array is detached only if the byte length is ~DETACHED~'); // step 3
	}

	if (bufferByteLength === 'DETACHED') {
		return true; // step 4
	}

	var byteOffsetStart = typedArrayByteOffset(O); // step 5

	var isFixed = IsFixedLengthArrayBuffer(typedArrayBuffer(O));

	var byteOffsetEnd;
	var length = isFixed ? typedArrayLength(O) : 'AUTO';
	// TODO: probably use package for array length
	// seems to apply when TA is backed by a resizable/growable AB
	if (length === 'AUTO') { // step 6
		byteOffsetEnd = bufferByteLength; // step 6.a
	} else {
		var elementSize = TypedArrayElementSize(O); // step 7.a

		byteOffsetEnd = byteOffsetStart + (length * elementSize); // step 7.b
	}

	if (byteOffsetStart > bufferByteLength || byteOffsetEnd > bufferByteLength) {
		return true; // step 8
	}

	// 9. NOTE: 0-length TypedArrays are not considered out-of-bounds.

	return false; // step 10
};
'use strict';

// https://262.ecma-international.org/15.0/#sec-isunclampedintegerelementtype

module.exports = function IsUnclampedIntegerElementType(type) {
	return type === 'INT8'
		|| type === 'UINT8'
		|| type === 'INT16'
		|| type === 'UINT16'
		|| type === 'INT32'
		|| type === 'UINT32';
};
'use strict';

// https://262.ecma-international.org/15.0/#sec-isunsignedelementtype

module.exports = function IsUnsignedElementType(type) {
	return type === 'UINT8'
		|| type === 'UINT8C'
		|| type === 'UINT16'
		|| type === 'UINT32'
		|| type === 'BIGUINT64';
};
'use strict';

var $TypeError = require('es-errors/type');

var IsDetachedBuffer = require('./IsDetachedBuffer');
var IsTypedArrayOutOfBounds = require('./IsTypedArrayOutOfBounds');
var MakeTypedArrayWithBufferWitnessRecord = require('./MakeTypedArrayWithBufferWitnessRecord');
var TypedArrayLength = require('./TypedArrayLength');

var isInteger = require('math-intrinsics/isInteger');
var isNegativeZero = require('math-intrinsics/isNegativeZero');

var isTypedArray = require('is-typed-array');
var typedArrayBuffer = require('typed-array-buffer');

// https://262.ecma-international.org/15.0/#sec-isvalidintegerindex

module.exports = function IsValidIntegerIndex(O, index) {
	if (!isTypedArray(O)) {
		throw new $TypeError('Assertion failed: `O` is not a TypedArray object');
	}
	if (typeof index !== 'number') {
		throw new $TypeError('Assertion failed: `index` is not a Number');
	}

	var buffer = typedArrayBuffer(O);

	if (IsDetachedBuffer(buffer)) { return false; } // step 1

	if (!isInteger(index)) { return false; } // step 2

	if (isNegativeZero(index)) { return false; } // step 3

	var taRecord = MakeTypedArrayWithBufferWitnessRecord(O, 'UNORDERED'); // step 4
	if (IsTypedArrayOutOfBounds(taRecord)) {
		return false; // step 6
	}
	var length = TypedArrayLength(taRecord); // step 7

	if (index < 0 || index >= length) { return false; } // step 8

	return true; // step 9
};
'use strict';

var $TypeError = require('es-errors/type');

var IsDetachedBuffer = require('./IsDetachedBuffer');
var IsFixedLengthArrayBuffer = require('./IsFixedLengthArrayBuffer');

var isDataViewWithBufferWitnessRecord = require('../helpers/records/data-view-with-buffer-witness-record');

var dataViewBuffer = require('data-view-buffer');
var dataViewByteLength = require('data-view-byte-length');
var dataViewByteOffset = require('data-view-byte-offset');

// https://262.ecma-international.org/15.0/#sec-isviewoutofbounds

module.exports = function IsViewOutOfBounds(viewRecord) {
	if (!isDataViewWithBufferWitnessRecord(viewRecord)) {
		throw new $TypeError('Assertion failed: `viewRecord` must be a DataView With Buffer Witness Record');
	}

	var view = viewRecord['[[Object]]']; // step 1

	var bufferByteLength = viewRecord['[[CachedBufferByteLength]]']; // step 2

	if (IsDetachedBuffer(dataViewBuffer(view)) !== (bufferByteLength === 'DETACHED')) {
		// step 3
		throw new $TypeError('Assertion failed: `IsDetachedBuffer(dataViewBuffer(view))` must be true if and only if `bufferByteLength === ~DETACHED~');
	}

	if (bufferByteLength === 'DETACHED') {
		return true; // step 4
	}

	var byteOffsetStart = dataViewByteOffset(view); // step 5

	var isFixed = IsFixedLengthArrayBuffer(dataViewBuffer(view));

	var viewByteLength = isFixed ? dataViewByteLength(view) : 'AUTO'; // view.[[ByteLength]]
	var byteOffsetEnd = viewByteLength === 'AUTO' ? bufferByteLength : byteOffsetStart + viewByteLength; // steps 6 - 7

	if (byteOffsetStart > bufferByteLength || byteOffsetEnd > bufferByteLength) {
		return true; // step 8
	}

	// 9. NOTE: 0-length DataViews are not considered out-of-bounds.

	return false; // step 10
};
'use strict';

var $TypeError = require('es-errors/type');
var callBound = require('call-bound');
var isInteger = require('math-intrinsics/isInteger');

var $indexOf = callBound('String.prototype.indexOf');

var IsArray = require('./IsArray');
var WordCharacters = require('./WordCharacters');

var every = require('../helpers/every');
var isRegExpRecord = require('../helpers/records/regexp-record');

var isChar = function isChar(c) {
	return typeof c === 'string';
};

// https://262.ecma-international.org/14.0/#sec-runtime-semantics-iswordchar-abstract-operation

module.exports = function IsWordChar(rer, Input, e) {
	if (!isRegExpRecord(rer)) {
		throw new $TypeError('Assertion failed: `rer` must be a RegExp Record');
	}
	if (!IsArray(Input) || !every(Input, isChar)) {
		throw new $TypeError('Assertion failed: `Input` must be a List of characters');
	}

	if (!isInteger(e)) {
		throw new $TypeError('Assertion failed: `e` must be an integer');
	}

	var InputLength = Input.length; // step 1

	if (e === -1 || e === InputLength) {
		return false; // step 2
	}

	var c = Input[e]; // step 3

	return $indexOf(WordCharacters(rer), c) > -1; // steps 4-5
};
'use strict';

var $TypeError = require('es-errors/type');
var isObject = require('es-object-atoms/isObject');

var Call = require('./Call');
var CompletionRecord = require('./CompletionRecord');
var GetMethod = require('./GetMethod');
var IsCallable = require('./IsCallable');

var isIteratorRecord = require('../helpers/records/iterator-record');

// https://262.ecma-international.org/15.0/#sec-iteratorclose

module.exports = function IteratorClose(iteratorRecord, completion) {
	if (!isIteratorRecord(iteratorRecord)) {
		throw new $TypeError('Assertion failed: `iteratorRecord` must be an Iterator Record'); // step 1
	}
	if (!isObject(iteratorRecord['[[Iterator]]'])) {
		throw new $TypeError('Assertion failed: iteratorRecord.[[Iterator]] must be an Object'); // step 1
	}

	if (!IsCallable(completion) && !(completion instanceof CompletionRecord)) { // step 2
		throw new $TypeError('Assertion failed: completion is not a thunk representing a Completion Record, nor a Completion Record instance');
	}
	var completionThunk = completion instanceof CompletionRecord ? function () { return completion['?'](); } : completion;

	var iterator = iteratorRecord['[[Iterator]]']; // step 3

	var iteratorReturn;
	try {
		iteratorReturn = GetMethod(iterator, 'return'); // step 4
	} catch (e) {
		completionThunk(); // throws if `completion` is a throw completion // step 6
		completionThunk = null; // ensure it's not called twice.
		throw e; // step 7
	}
	if (typeof iteratorReturn === 'undefined') {
		return completionThunk(); // step 5.a - 5.b
	}

	var innerResult;
	try {
		innerResult = Call(iteratorReturn, iterator, []);
	} catch (e) {
		// if we hit here, then "e" is the innerResult completion that needs re-throwing

		completionThunk(); // throws if `completion` is a throw completion // step 6
		completionThunk = null; // ensure it's not called twice.

		// if not, then return the innerResult completion
		throw e; // step 7
	}
	var completionRecord = completionThunk(); // if innerResult worked, then throw if the completion does
	completionThunk = null; // ensure it's not called twice.

	if (!isObject(innerResult)) {
		throw new $TypeError('iterator .return must return an object');
	}

	return completionRecord;
};
'use strict';

var $TypeError = require('es-errors/type');
var isObject = require('es-object-atoms/isObject');

var Get = require('./Get');
var ToBoolean = require('./ToBoolean');

// https://262.ecma-international.org/6.0/#sec-iteratorcomplete

module.exports = function IteratorComplete(iterResult) {
	if (!isObject(iterResult)) {
		throw new $TypeError('Assertion failed: Type(iterResult) is not Object');
	}
	return ToBoolean(Get(iterResult, 'done'));
};
'use strict';

var $TypeError = require('es-errors/type');
var isObject = require('es-object-atoms/isObject');

var Call = require('./Call');

var isIteratorRecord = require('../helpers/records/iterator-record');

// https://262.ecma-international.org/16.0/#sec-iteratornext

module.exports = function IteratorNext(iteratorRecord) {
	if (!isIteratorRecord(iteratorRecord)) {
		throw new $TypeError('Assertion failed: `iteratorRecord` must be an Iterator Record'); // step 1
	}

	var result;
	try {
		if (arguments.length < 2) { // step 1
			result = Call(iteratorRecord['[[NextMethod]]'], iteratorRecord['[[Iterator]]']); // step 1.a
		} else { // step 2
			result = Call(iteratorRecord['[[NextMethod]]'], iteratorRecord['[[Iterator]]'], [arguments[1]]); // step 2.a
		}
	} catch (e) { // step 3
		// eslint-disable-next-line no-param-reassign
		iteratorRecord['[[Done]]'] = true; // step 3.a
		throw e; // step 3.b
	}

	if (!isObject(result)) { // step 5
		// eslint-disable-next-line no-param-reassign
		iteratorRecord['[[Done]]'] = true; // step 5.a
		throw new $TypeError('iterator next must return an object'); // step 5.b
	}
	return result; // step 6
};
'use strict';

var $TypeError = require('es-errors/type');

var IteratorComplete = require('./IteratorComplete');
var IteratorNext = require('./IteratorNext');

var isIteratorRecord = require('../helpers/records/iterator-record');

// https://262.ecma-international.org/16.0/#sec-iteratorstep

module.exports = function IteratorStep(iteratorRecord) {
	if (!isIteratorRecord(iteratorRecord)) {
		throw new $TypeError('Assertion failed: `iteratorRecord` must be an Iterator Record'); // step 1
	}

	var result = IteratorNext(iteratorRecord); // step 1
	try {
		var done = IteratorComplete(result); // step 2
	} catch (e) { // step 3
		// eslint-disable-next-line no-param-reassign
		iteratorRecord['[[Done]]'] = true; // step 3.a
		throw e; // step 3.b

	}

	if (done) { // step 5
		// eslint-disable-next-line no-param-reassign
		iteratorRecord['[[Done]]'] = true; // step 5.a
		return false; // step 5.b. should be `~done~` but `false` is more convenient here.
	}

	return result; // steps 6
};

'use strict';

var $TypeError = require('es-errors/type');

var IteratorStep = require('./IteratorStep');
var IteratorValue = require('./IteratorValue');

var isIteratorRecord = require('../helpers/records/iterator-record');

// https://262.ecma-international.org/16.0/#sec-iteratorstepvalue

module.exports = function IteratorStepValue(iteratorRecord) {
	if (!isIteratorRecord(iteratorRecord)) {
		throw new $TypeError('Assertion failed: `iteratorRecord` must be an Iterator Record');
	}

	var result = IteratorStep(iteratorRecord); // step 1
	if (!result || result === 'DONE') { // step 2
		return result; // step 2.a
	}

	var value;
	try {
		value = IteratorValue(result); // step 3
	} catch (e) { // step 4
		// eslint-disable-next-line no-param-reassign
		iteratorRecord['[[Done]]'] = true; // step 4.a
		throw e; // step 5
	}

	return value; // step 5
};
'use strict';

var $TypeError = require('es-errors/type');

var IteratorStep = require('./IteratorStep');
var IteratorValue = require('./IteratorValue');

var isIteratorRecord = require('../helpers/records/iterator-record');

// https://262.ecma-international.org/15.0/#sec-iteratortolist

module.exports = function IteratorToList(iteratorRecord) {
	if (!isIteratorRecord(iteratorRecord)) {
		throw new $TypeError('Assertion failed: `iteratorRecord` must be an Iterator Record'); // step 1
	}

	var values = []; // step 1
	var next = true; // step 2
	while (next) { // step 3
		next = IteratorStep(iteratorRecord); // step 3.a
		if (next) {
			var nextValue = IteratorValue(next); // step 3.b.i
			values[values.length] = nextValue; // step 3.b.ii
		}
	}
	return values; // step 4
};
'use strict';

var $TypeError = require('es-errors/type');
var isObject = require('es-object-atoms/isObject');

var Get = require('./Get');

// https://262.ecma-international.org/6.0/#sec-iteratorvalue

module.exports = function IteratorValue(iterResult) {
	if (!isObject(iterResult)) {
		throw new $TypeError('Assertion failed: Type(iterResult) is not Object');
	}
	return Get(iterResult, 'value');
};

'use strict';

var $TypeError = require('es-errors/type');

var callBound = require('call-bound');

var $keyFor = callBound('Symbol.keyFor', true);

// https://262.ecma-international.org/14.0/#sec-keyforsymbol

module.exports = function KeyForSymbol(sym) {
	if (typeof sym !== 'symbol') {
		throw new $TypeError('Assertion failed: `sym` must be a Symbol');
	}
	return $keyFor(sym);
};
'use strict';

var $TypeError = require('es-errors/type');
var isObject = require('es-object-atoms/isObject');

var Get = require('./Get');
var ToLength = require('./ToLength');

// https://262.ecma-international.org/11.0/#sec-lengthofarraylike

module.exports = function LengthOfArrayLike(obj) {
	if (!isObject(obj)) {
		throw new $TypeError('Assertion failed: `obj` must be an Object');
	}
	return ToLength(Get(obj, 'length'));
};

// TODO: use this all over
'use strict';

var $TypeError = require('es-errors/type');

var ArrayBufferByteLength = require('./ArrayBufferByteLength');
var IsDetachedBuffer = require('./IsDetachedBuffer');

var dataViewBuffer = require('data-view-buffer');
var isDataView = require('is-data-view');

// https://262.ecma-international.org/15.0/#sec-makedataviewwithbufferwitnessrecord

module.exports = function MakeDataViewWithBufferWitnessRecord(obj, order) {
	if (!isDataView(obj)) {
		throw new $TypeError('MakeDataViewWithBufferWitnessRecord called with non-DataView');
	}
	if (order !== 'SEQ-CST' && order !== 'UNORDERED') {
		throw new $TypeError('Assertion failed: `order` must be ~SEQ-CST~ or ~UNORDERED~');
	}

	var buffer = dataViewBuffer(obj); // step 1

	var byteLength = IsDetachedBuffer(buffer) ? 'DETACHED' : ArrayBufferByteLength(buffer, order); // steps 2 - 3

	return { '[[Object]]': obj, '[[CachedBufferByteLength]]': byteLength }; // step 4
};
'use strict';

var $isFinite = require('math-intrinsics/isFinite');

var msPerDay = require('../helpers/timeConstants').msPerDay;

// https://262.ecma-international.org/5.1/#sec-15.9.1.13

module.exports = function MakeDate(day, time) {
	if (!$isFinite(day) || !$isFinite(time)) {
		return NaN;
	}
	return (day * msPerDay) + time;
};
'use strict';

var GetIntrinsic = require('get-intrinsic');

var $DateUTC = GetIntrinsic('%Date.UTC%');

var $isFinite = require('math-intrinsics/isFinite');

var DateFromTime = require('./DateFromTime');
var Day = require('./Day');
var floor = require('./floor');
var modulo = require('./modulo');
var MonthFromTime = require('./MonthFromTime');
var ToIntegerOrInfinity = require('./ToIntegerOrInfinity');
var YearFromTime = require('./YearFromTime');

// https://262.ecma-international.org/5.1/#sec-15.9.1.12

module.exports = function MakeDay(year, month, date) {
	if (!$isFinite(year) || !$isFinite(month) || !$isFinite(date)) {
		return NaN;
	}
	var y = ToIntegerOrInfinity(year);
	var m = ToIntegerOrInfinity(month);
	var dt = ToIntegerOrInfinity(date);
	var ym = y + floor(m / 12);
	if (!$isFinite(ym)) {
		return NaN;
	}
	var mn = modulo(m, 12);
	var t = $DateUTC(ym, mn, 1);
	if (YearFromTime(t) !== ym || MonthFromTime(t) !== mn || DateFromTime(t) !== 1) {
		return NaN;
	}
	return Day(t) + dt - 1;
};
'use strict';

var $TypeError = require('es-errors/type');

var ToIntegerOrInfinity = require('./ToIntegerOrInfinity');

var isNaN = require('math-intrinsics/isNaN');

// https://262.ecma-international.org/15.0/#sec-makefullyear

module.exports = function MakeFullYear(year) {
	if (typeof year !== 'number') {
		throw new $TypeError('Assertion failed: `year` must be a Number');
	}

	if (isNaN(year)) {
		return NaN; // step 1
	}

	var truncated = ToIntegerOrInfinity(year); // step 2
	if (0 <= truncated && truncated <= 99) {
		return 1900 + truncated; // step 3
	}

	return truncated; // step 4
};
'use strict';

var $TypeError = require('es-errors/type');

var ArrayCreate = require('./ArrayCreate');
var CreateDataPropertyOrThrow = require('./CreateDataPropertyOrThrow');
var GetMatchIndexPair = require('./GetMatchIndexPair');
var IsArray = require('./IsArray');
var OrdinaryObjectCreate = require('./OrdinaryObjectCreate');
var ToString = require('./ToString');

var every = require('../helpers/every');
var isMatchRecord = require('../helpers/records/match-record');

var isStringOrUndefined = function isStringOrUndefined(s) {
	return typeof s === 'undefined' || typeof s === 'string';
};

var isMatchRecordOrUndefined = function isMatchRecordOrUndefined(m) {
	return typeof m === 'undefined' || isMatchRecord(m);
};

var MAX_ARRAY_LENGTH = require('math-intrinsics/constants/maxArrayLength');

// https://262.ecma-international.org/13.0/#sec-getmatchindexpair

module.exports = function MakeMatchIndicesIndexPairArray(S, indices, groupNames, hasGroups) {
	if (typeof S !== 'string') {
		throw new $TypeError('Assertion failed: `S` must be a String');
	}
	if (!IsArray(indices) || !every(indices, isMatchRecordOrUndefined)) {
		throw new $TypeError('Assertion failed: `indices` must be a List of either Match Records or `undefined`');
	}
	if (!IsArray(groupNames) || !every(groupNames, isStringOrUndefined)) {
		throw new $TypeError('Assertion failed: `groupNames` must be a List of either Strings or `undefined`');
	}
	if (typeof hasGroups !== 'boolean') {
		throw new $TypeError('Assertion failed: `hasGroups` must be a Boolean');
	}

	var n = indices.length; // step 1
	if (!(n < MAX_ARRAY_LENGTH)) {
		throw new $TypeError('Assertion failed: `indices` length must be less than the max array size, 2**32 - 1');
	}
	if (groupNames.length !== n - 1) {
		throw new $TypeError('Assertion failed: `groupNames` must have exactly one fewer item than `indices`');
	}

	var A = ArrayCreate(n); // step 5
	var groups = hasGroups ? OrdinaryObjectCreate(null) : void undefined; // step 6-7
	CreateDataPropertyOrThrow(A, 'groups', groups); // step 8

	for (var i = 0; i < n; i += 1) { // step 9
		var matchIndices = indices[i]; // step 9.a
		// eslint-disable-next-line no-negated-condition
		var matchIndexPair = typeof matchIndices !== 'undefined' ? GetMatchIndexPair(S, matchIndices) : void undefined; // step 9.b-9.c
		CreateDataPropertyOrThrow(A, ToString(i), matchIndexPair); // step 9.d
		if (i > 0 && typeof groupNames[i - 1] !== 'undefined') { // step 9.e
			if (!groups) {
				throw new $TypeError('if `hasGroups` is `false`, `groupNames` can only contain `undefined` values');
			}
			CreateDataPropertyOrThrow(groups, groupNames[i - 1], matchIndexPair); // step 9.e.i
		}
	}
	return A; // step 10
};
'use strict';

var $isFinite = require('math-intrinsics/isFinite');
var timeConstants = require('../helpers/timeConstants');
var msPerSecond = timeConstants.msPerSecond;
var msPerMinute = timeConstants.msPerMinute;
var msPerHour = timeConstants.msPerHour;

var ToIntegerOrInfinity = require('./ToIntegerOrInfinity');

// https://262.ecma-international.org/12.0/#sec-maketime

module.exports = function MakeTime(hour, min, sec, ms) {
	if (!$isFinite(hour) || !$isFinite(min) || !$isFinite(sec) || !$isFinite(ms)) {
		return NaN;
	}
	var h = ToIntegerOrInfinity(hour);
	var m = ToIntegerOrInfinity(min);
	var s = ToIntegerOrInfinity(sec);
	var milli = ToIntegerOrInfinity(ms);
	var t = (h * msPerHour) + (m * msPerMinute) + (s * msPerSecond) + milli;
	return t;
};
'use strict';

var $TypeError = require('es-errors/type');

var ArrayBufferByteLength = require('./ArrayBufferByteLength');
var IsDetachedBuffer = require('./IsDetachedBuffer');

var isTypedArray = require('is-typed-array');
var typedArrayBuffer = require('typed-array-buffer');

// https://262.ecma-international.org/15.0/#sec-maketypedarraywithbufferwitnessrecord

module.exports = function MakeTypedArrayWithBufferWitnessRecord(obj, order) {
	if (!isTypedArray(obj)) {
		throw new $TypeError('Assertion failed: `obj` must be a Typed Array');
	}
	if (order !== 'SEQ-CST' && order !== 'UNORDERED') {
		throw new $TypeError('Assertion failed: `order` must be ~SEQ-CST~ or ~UNORDERED~');
	}

	var buffer = typedArrayBuffer(obj); // step 1

	var byteLength = IsDetachedBuffer(buffer) ? 'DETACHED' : ArrayBufferByteLength(buffer, order); // steps 2 - 3

	return { '[[Object]]': obj, '[[CachedBufferByteLength]]': byteLength }; // step 4
};
'use strict';

// https://262.ecma-international.org/6.0/#sec-algorithm-conventions

module.exports = require('math-intrinsics/max');
'use strict';

var floor = require('./floor');
var modulo = require('./modulo');

var timeConstants = require('../helpers/timeConstants');
var msPerMinute = timeConstants.msPerMinute;
var MinutesPerHour = timeConstants.MinutesPerHour;

// https://262.ecma-international.org/5.1/#sec-15.9.1.10

module.exports = function MinFromTime(t) {
	return modulo(floor(t / msPerMinute), MinutesPerHour);
};
'use strict';

// https://262.ecma-international.org/6.0/#sec-algorithm-conventions

module.exports = require('math-intrinsics/min');
'use strict';

var mod = require('../helpers/mod');

// https://262.ecma-international.org/5.1/#sec-5.2

module.exports = function modulo(x, y) {
	return mod(x, y);
};
'use strict';

var $RangeError = require('es-errors/range');

var DayWithinYear = require('./DayWithinYear');
var InLeapYear = require('./InLeapYear');

// https://262.ecma-international.org/5.1/#sec-15.9.1.4

module.exports = function MonthFromTime(t) {
	var day = DayWithinYear(t);
	if (0 <= day && day < 31) {
		return 0;
	}
	var leap = InLeapYear(t);
	if (31 <= day && day < (59 + leap)) {
		return 1;
	}
	if ((59 + leap) <= day && day < (90 + leap)) {
		return 2;
	}
	if ((90 + leap) <= day && day < (120 + leap)) {
		return 3;
	}
	if ((120 + leap) <= day && day < (151 + leap)) {
		return 4;
	}
	if ((151 + leap) <= day && day < (181 + leap)) {
		return 5;
	}
	if ((181 + leap) <= day && day < (212 + leap)) {
		return 6;
	}
	if ((212 + leap) <= day && day < (243 + leap)) {
		return 7;
	}
	if ((243 + leap) <= day && day < (273 + leap)) {
		return 8;
	}
	if ((273 + leap) <= day && day < (304 + leap)) {
		return 9;
	}
	if ((304 + leap) <= day && day < (334 + leap)) {
		return 10;
	}
	if ((334 + leap) <= day && day < (365 + leap)) {
		return 11;
	}

	throw new $RangeError('Assertion failed: `day` is out of range');
};
'use strict';

var modulo = require('./modulo');

var msPerSecond = require('../helpers/timeConstants').msPerSecond;

// https://262.ecma-international.org/5.1/#sec-15.9.1.10

module.exports = function msFromTime(t) {
	return modulo(t, msPerSecond);
};
'use strict';

var $TypeError = require('es-errors/type');

var IsCallable = require('./IsCallable');
var IsConstructor = require('./IsConstructor');

// https://262.ecma-international.org/6.0/#sec-newpromisecapability

module.exports = function NewPromiseCapability(C) {
	if (!IsConstructor(C)) {
		throw new $TypeError('C must be a constructor'); // step 1
	}

	var resolvingFunctions = { '[[Resolve]]': void undefined, '[[Reject]]': void undefined }; // step 3

	var promise = new C(function (resolve, reject) { // steps 4-5
		if (typeof resolvingFunctions['[[Resolve]]'] !== 'undefined' || typeof resolvingFunctions['[[Reject]]'] !== 'undefined') {
			throw new $TypeError('executor has already been called'); // step 4.a, 4.b
		}
		resolvingFunctions['[[Resolve]]'] = resolve; // step 4.c
		resolvingFunctions['[[Reject]]'] = reject; // step 4.d
	}); // step 4-6

	if (!IsCallable(resolvingFunctions['[[Resolve]]']) || !IsCallable(resolvingFunctions['[[Reject]]'])) {
		throw new $TypeError('executor must provide valid resolve and reject functions'); // steps 7-8
	}

	return {
		'[[Promise]]': promise,
		'[[Resolve]]': resolvingFunctions['[[Resolve]]'],
		'[[Reject]]': resolvingFunctions['[[Reject]]']
	}; // step 9
};
'use strict';

var CompletionRecord = require('./CompletionRecord');

// https://262.ecma-international.org/6.0/#sec-normalcompletion

module.exports = function NormalCompletion(value) {
	return new CompletionRecord('normal', value);
};
'use strict';

var $TypeError = require('es-errors/type');

var ToInt32 = require('./ToInt32');
var ToUint32 = require('./ToUint32');

// https://262.ecma-international.org/11.0/#sec-numberbitwiseop

module.exports = function NumberBitwiseOp(op, x, y) {
	if (op !== '&' && op !== '|' && op !== '^') {
		throw new $TypeError('Assertion failed: `op` must be `&`, `|`, or `^`');
	}
	if (typeof x !== 'number' || typeof y !== 'number') {
		throw new $TypeError('Assertion failed: `x` and `y` arguments must be Numbers');
	}
	var lnum = ToInt32(x);
	var rnum = ToUint32(y);
	if (op === '&') {
		return lnum & rnum;
	}
	if (op === '|') {
		return lnum | rnum;
	}
	return lnum ^ rnum;
};
'use strict';

var GetIntrinsic = require('get-intrinsic');

var $BigInt = GetIntrinsic('%BigInt%', true);
var $RangeError = require('es-errors/range');
var $SyntaxError = require('es-errors/syntax');
var $TypeError = require('es-errors/type');

var isInteger = require('math-intrinsics/isInteger');

// https://262.ecma-international.org/12.0/#sec-numbertobigint

module.exports = function NumberToBigInt(number) {
	if (typeof number !== 'number') {
		throw new $TypeError('Assertion failed: `number` must be a String');
	}
	if (!isInteger(number)) {
		throw new $RangeError('The number ' + number + ' cannot be converted to a BigInt because it is not an integer');
	}
	if (!$BigInt) {
		throw new $SyntaxError('BigInts are not supported in this environment');
	}
	return $BigInt(number);
};
'use strict';

var $TypeError = require('es-errors/type');

var hasOwnProperty = require('./HasOwnProperty');
var ToBigInt64 = require('./ToBigInt64');
var ToBigUint64 = require('./ToBigUint64');
var ToInt16 = require('./ToInt16');
var ToInt32 = require('./ToInt32');
var ToInt8 = require('./ToInt8');
var ToUint16 = require('./ToUint16');
var ToUint32 = require('./ToUint32');
var ToUint8 = require('./ToUint8');
var ToUint8Clamp = require('./ToUint8Clamp');

var valueToFloat16Bytes = require('../helpers/valueToFloat16Bytes');
var valueToFloat32Bytes = require('../helpers/valueToFloat32Bytes');
var valueToFloat64Bytes = require('../helpers/valueToFloat64Bytes');
var integerToNBytes = require('../helpers/integerToNBytes');

var tableTAO = require('./tables/typed-array-objects');

// https://262.ecma-international.org/15.0/#table-the-typedarray-constructors
var TypeToAO = {
	__proto__: null,
	$INT8: ToInt8,
	$UINT8: ToUint8,
	$UINT8C: ToUint8Clamp,
	$INT16: ToInt16,
	$UINT16: ToUint16,
	$INT32: ToInt32,
	$UINT32: ToUint32,
	$BIGINT64: ToBigInt64,
	$BIGUINT64: ToBigUint64
};

// https://262.ecma-international.org/16.0/#sec-numerictorawbytes

module.exports = function NumericToRawBytes(type, value, isLittleEndian) {
	if (typeof type !== 'string' || !hasOwnProperty(tableTAO.size, '$' + type)) {
		throw new $TypeError('Assertion failed: `type` must be a TypedArray element type');
	}
	if (typeof value !== 'number' && typeof value !== 'bigint') {
		throw new $TypeError('Assertion failed: `value` must be a Number or a BigInt');
	}
	if (typeof isLittleEndian !== 'boolean') {
		throw new $TypeError('Assertion failed: `isLittleEndian` must be a Boolean');
	}

	if (type === 'FLOAT16') { // step 1
		return valueToFloat16Bytes(value, isLittleEndian);
	} else if (type === 'FLOAT32') { // step 2
		return valueToFloat32Bytes(value, isLittleEndian);
	} else if (type === 'FLOAT64') { // step 3
		return valueToFloat64Bytes(value, isLittleEndian);
	} // step 4

	var n = tableTAO.size['$' + type]; // step 4.a

	var convOp = TypeToAO['$' + type]; // step 4.b

	var intValue = convOp(value); // step 4.c

	return integerToNBytes(intValue, n, isLittleEndian); // step 4.d, 4.e, 5
};
'use strict';

var DefinePropertyOrThrow = require('./DefinePropertyOrThrow');
var Get = require('./Get');
var OrdinaryGetOwnProperty = require('./OrdinaryGetOwnProperty');
var ToObject = require('./ToObject');
var ToPropertyDescriptor = require('./ToPropertyDescriptor');

var forEach = require('../helpers/forEach');
var OwnPropertyKeys = require('own-keys');

// https://262.ecma-international.org/15.0/#sec-objectdefineproperties

module.exports = function ObjectDefineProperties(O, Properties) {
	var props = ToObject(Properties); // step 1
	var keys = OwnPropertyKeys(props); // step 2
	var descriptors = []; // step 3

	forEach(keys, function (nextKey) { // step 4
		var propDesc = OrdinaryGetOwnProperty(props, nextKey); // ToPropertyDescriptor(getOwnPropertyDescriptor(props, nextKey)); // step 4.a
		if (typeof propDesc !== 'undefined' && propDesc['[[Enumerable]]']) { // step 4.b
			var descObj = Get(props, nextKey); // step 4.b.i
			var desc = ToPropertyDescriptor(descObj); // step 4.b.ii
			descriptors[descriptors.length] = { '[[Key]]': nextKey, '[[Descriptor]]': desc }; // step 4.b.iii
		}
	});

	forEach(descriptors, function (pair) { // step 5
		DefinePropertyOrThrow(O, pair['[[Key]]'], pair['[[Descriptor]]']); // step 5.c
	});

	return O; // step 6
};
'use strict';

var GetIntrinsic = require('get-intrinsic');
var $TypeError = require('es-errors/type');

var GetPrototypeFromConstructor = require('./GetPrototypeFromConstructor');
var IsArray = require('./IsArray');
var OrdinaryObjectCreate = require('./OrdinaryObjectCreate');

// https://262.ecma-international.org/6.0/#sec-ordinarycreatefromconstructor

module.exports = function OrdinaryCreateFromConstructor(constructor, intrinsicDefaultProto) {
	GetIntrinsic(intrinsicDefaultProto); // throws if not a valid intrinsic
	var proto = GetPrototypeFromConstructor(constructor, intrinsicDefaultProto);
	var slots = arguments.length < 3 ? [] : arguments[2];
	if (!IsArray(slots)) {
		throw new $TypeError('Assertion failed: if provided, `internalSlotsList` must be a List');
	}
	return OrdinaryObjectCreate(proto, slots);
};
'use strict';

var $gOPD = require('gopd');
var $SyntaxError = require('es-errors/syntax');
var $TypeError = require('es-errors/type');
var isObject = require('es-object-atoms/isObject');

var isPropertyDescriptor = require('../helpers/records/property-descriptor');

var IsAccessorDescriptor = require('./IsAccessorDescriptor');
var IsExtensible = require('./IsExtensible');
var isPropertyKey = require('../helpers/isPropertyKey');
var ToPropertyDescriptor = require('./ToPropertyDescriptor');
var SameValue = require('./SameValue');
var ValidateAndApplyPropertyDescriptor = require('./ValidateAndApplyPropertyDescriptor');

// https://262.ecma-international.org/6.0/#sec-ordinarydefineownproperty

module.exports = function OrdinaryDefineOwnProperty(O, P, Desc) {
	if (!isObject(O)) {
		throw new $TypeError('Assertion failed: O must be an Object');
	}
	if (!isPropertyKey(P)) {
		throw new $TypeError('Assertion failed: P must be a Property Key');
	}
	if (!isPropertyDescriptor(Desc)) {
		throw new $TypeError('Assertion failed: Desc must be a Property Descriptor');
	}
	if (!$gOPD) {
		// ES3/IE 8 fallback
		if (IsAccessorDescriptor(Desc)) {
			throw new $SyntaxError('This environment does not support accessor property descriptors.');
		}
		var creatingNormalDataProperty = !(P in O)
			&& Desc['[[Writable]]']
			&& Desc['[[Enumerable]]']
			&& Desc['[[Configurable]]']
			&& '[[Value]]' in Desc;
		var settingExistingDataProperty = (P in O)
			&& (!('[[Configurable]]' in Desc) || Desc['[[Configurable]]'])
			&& (!('[[Enumerable]]' in Desc) || Desc['[[Enumerable]]'])
			&& (!('[[Writable]]' in Desc) || Desc['[[Writable]]'])
			&& '[[Value]]' in Desc;
		if (creatingNormalDataProperty || settingExistingDataProperty) {
			O[P] = Desc['[[Value]]']; // eslint-disable-line no-param-reassign
			return SameValue(O[P], Desc['[[Value]]']);
		}
		throw new $SyntaxError('This environment does not support defining non-writable, non-enumerable, or non-configurable properties');
	}
	var desc = $gOPD(O, P);
	var current = desc && ToPropertyDescriptor(desc);
	var extensible = IsExtensible(O);
	return ValidateAndApplyPropertyDescriptor(O, P, extensible, Desc, current);
};
'use strict';

var $gOPD = require('gopd');
var $TypeError = require('es-errors/type');
var isObject = require('es-object-atoms/isObject');
var callBound = require('call-bound');

var $isEnumerable = callBound('Object.prototype.propertyIsEnumerable');

var hasOwn = require('hasown');

var IsArray = require('./IsArray');
var isPropertyKey = require('../helpers/isPropertyKey');
var IsRegExp = require('./IsRegExp');
var ToPropertyDescriptor = require('./ToPropertyDescriptor');

// https://262.ecma-international.org/6.0/#sec-ordinarygetownproperty

module.exports = function OrdinaryGetOwnProperty(O, P) {
	if (!isObject(O)) {
		throw new $TypeError('Assertion failed: O must be an Object');
	}
	if (!isPropertyKey(P)) {
		throw new $TypeError('Assertion failed: P must be a Property Key');
	}
	if (!hasOwn(O, P)) {
		return void 0;
	}
	if (!$gOPD) {
		// ES3 / IE 8 fallback
		var arrayLength = IsArray(O) && P === 'length';
		var regexLastIndex = IsRegExp(O) && P === 'lastIndex';
		return {
			'[[Configurable]]': !(arrayLength || regexLastIndex),
			'[[Enumerable]]': $isEnumerable(O, P),
			'[[Value]]': O[P],
			'[[Writable]]': true
		};
	}
	return ToPropertyDescriptor($gOPD(O, P));
};
'use strict';

var $TypeError = require('es-errors/type');
var isObject = require('es-object-atoms/isObject');

var $getProto = require('get-proto');

// https://262.ecma-international.org/7.0/#sec-ordinarygetprototypeof

module.exports = function OrdinaryGetPrototypeOf(O) {
	if (!isObject(O)) {
		throw new $TypeError('Assertion failed: O must be an Object');
	}
	if (!$getProto) {
		throw new $TypeError('This environment does not support fetching prototypes.');
	}
	return $getProto(O);
};
'use strict';

var $TypeError = require('es-errors/type');
var isObject = require('es-object-atoms/isObject');

var Get = require('./Get');
var IsCallable = require('./IsCallable');

// https://262.ecma-international.org/6.0/#sec-ordinaryhasinstance

module.exports = function OrdinaryHasInstance(C, O) {
	if (!IsCallable(C)) {
		return false;
	}
	if (!isObject(O)) {
		return false;
	}
	var P = Get(C, 'prototype');
	if (!isObject(P)) {
		throw new $TypeError('OrdinaryHasInstance called on an object with an invalid prototype property.');
	}
	return O instanceof C;
};
'use strict';

var $TypeError = require('es-errors/type');
var isObject = require('es-object-atoms/isObject');

var isPropertyKey = require('../helpers/isPropertyKey');

// https://262.ecma-international.org/6.0/#sec-ordinaryhasproperty

module.exports = function OrdinaryHasProperty(O, P) {
	if (!isObject(O)) {
		throw new $TypeError('Assertion failed: Type(O) is not Object');
	}
	if (!isPropertyKey(P)) {
		throw new $TypeError('Assertion failed: P must be a Property Key');
	}
	return P in O;
};
'use strict';

var GetIntrinsic = require('get-intrinsic');

var $ObjectCreate = GetIntrinsic('%Object.create%', true);
var $TypeError = require('es-errors/type');
var $SyntaxError = require('es-errors/syntax');
var isObject = require('es-object-atoms/isObject');

var IsArray = require('./IsArray');

var forEach = require('../helpers/forEach');

var SLOT = require('internal-slot');

var hasProto = require('has-proto')();

// https://262.ecma-international.org/11.0/#sec-objectcreate

module.exports = function OrdinaryObjectCreate(proto) {
	if (proto !== null && !isObject(proto)) {
		throw new $TypeError('Assertion failed: `proto` must be null or an object');
	}
	var additionalInternalSlotsList = arguments.length < 2 ? [] : arguments[1];
	if (!IsArray(additionalInternalSlotsList)) {
		throw new $TypeError('Assertion failed: `additionalInternalSlotsList` must be an Array');
	}

	// var internalSlotsList = ['[[Prototype]]', '[[Extensible]]']; // step 1
	// internalSlotsList.push(...additionalInternalSlotsList); // step 2
	// var O = MakeBasicObject(internalSlotsList); // step 3
	// setProto(O, proto); // step 4
	// return O; // step 5

	var O;
	if (hasProto) {
		O = { __proto__: proto };
	} else if ($ObjectCreate) {
		O = $ObjectCreate(proto);
	} else {
		if (proto === null) {
			throw new $SyntaxError('native Object.create support is required to create null objects');
		}
		var T = function T() {};
		T.prototype = proto;
		O = new T();
	}

	if (additionalInternalSlotsList.length > 0) {
		forEach(additionalInternalSlotsList, function (slot) {
			SLOT.set(O, slot, void undefined);
		});
	}

	return O;
};
'use strict';

var $TypeError = require('es-errors/type');
var $setProto = require('set-proto');
var isObject = require('es-object-atoms/isObject');

var OrdinaryGetPrototypeOf = require('./OrdinaryGetPrototypeOf');

// https://262.ecma-international.org/7.0/#sec-ordinarysetprototypeof

module.exports = function OrdinarySetPrototypeOf(O, V) {
	if (V !== null && !isObject(V)) {
		throw new $TypeError('Assertion failed: V must be Object or Null');
	}
	/*
	var extensible = IsExtensible(O);
	var current = OrdinaryGetPrototypeOf(O);
	if (SameValue(V, current)) {
		return true;
	}
	if (!extensible) {
		return false;
	}
	*/
	try {
		$setProto(O, V);
	} catch (e) {
		return false;
	}
	return OrdinaryGetPrototypeOf(O) === V;
	/*
	var p = V;
	var done = false;
	while (!done) {
		if (p === null) {
			done = true;
		} else if (SameValue(p, O)) {
			return false;
		} else {
			if (wat) {
				done = true;
			} else {
				p = p.[[Prototype]];
			}
		}
	}
	O.[[Prototype]] = V;
	return true;
	*/
};
'use strict';

var $TypeError = require('es-errors/type');
var isObject = require('es-object-atoms/isObject');

var Call = require('./Call');
var Get = require('./Get');
var IsCallable = require('./IsCallable');

var inspect = require('object-inspect');

// https://262.ecma-international.org/8.0/#sec-ordinarytoprimitive

module.exports = function OrdinaryToPrimitive(O, hint) {
	if (!isObject(O)) {
		throw new $TypeError('Assertion failed: Type(O) is not Object');
	}
	if (/* typeof hint !== 'string' || */ hint !== 'string' && hint !== 'number') {
		throw new $TypeError('Assertion failed: `hint` must be "string" or "number"');
	}

	var methodNames = hint === 'string' ? ['toString', 'valueOf'] : ['valueOf', 'toString'];

	for (var i = 0; i < methodNames.length; i += 1) {
		var name = methodNames[i];
		var method = Get(O, name);
		if (IsCallable(method)) {
			var result = Call(method, O);
			if (!isObject(result)) {
				return result;
			}
		}
	}

	throw new $TypeError('No primitive value for ' + inspect(O));
};
'use strict';

var $SyntaxError = require('es-errors/syntax');
var $TypeError = require('es-errors/type');

var substring = require('./substring');

var isInteger = require('math-intrinsics/isInteger');
var isNaN = require('math-intrinsics/isNaN');

// https://262.ecma-international.org/14.0/#sec-parsehexoctet

module.exports = function ParseHexOctet(string, position) {
	if (typeof string !== 'string') {
		throw new $TypeError('Assertion failed: `string` must be a String');
	}
	if (!isInteger(position) || position < 0) {
		throw new $TypeError('Assertion failed: `position` must be a nonnegative integer');
	}

	var len = string.length; // step 1
	if ((position + 2) > len) { // step 2
		var error = new $SyntaxError('requested a position on a string that does not contain 2 characters at that position'); // step 2.a
		return [error]; // step 2.b
	}
	var hexDigits = substring(string, position, position + 2); // step 3

	var n = +('0x' + hexDigits);
	if (isNaN(n)) {
		return [new $SyntaxError('Invalid hexadecimal characters')];
	}
	return n;

	/*
	4. Let _parseResult_ be ParseText(StringToCodePoints(_hexDigits_), |HexDigits[~Sep]|).
    5. If _parseResult_ is not a Parse Node, return _parseResult_.
    6. Let _n_ be the unsigned 8-bit value corresponding with the MV of _parseResult_.
    7. Return _n_.
    */
};
'use strict';

var GetIntrinsic = require('get-intrinsic');
var callBind = require('call-bind');
var $SyntaxError = require('es-errors/syntax');

var $resolve = GetIntrinsic('%Promise.resolve%', true);
var $PromiseResolve = $resolve && callBind($resolve);

// https://262.ecma-international.org/9.0/#sec-promise-resolve

module.exports = function PromiseResolve(C, x) {
	if (!$PromiseResolve) {
		throw new $SyntaxError('This environment does not support Promises.');
	}
	return $PromiseResolve(C, x);
};

'use strict';

var $TypeError = require('es-errors/type');

var callBound = require('call-bound');
var forEach = require('../helpers/forEach');
var isLeadingSurrogate = require('../helpers/isLeadingSurrogate');
var isTrailingSurrogate = require('../helpers/isTrailingSurrogate');

var $charCodeAt = callBound('String.prototype.charCodeAt');
var $strSplit = callBound('String.prototype.split');

var StringToCodePoints = require('./StringToCodePoints');
var UnicodeEscape = require('./UnicodeEscape');
var UTF16EncodeCodePoint = require('./UTF16EncodeCodePoint');

var hasOwn = require('hasown');

// https://262.ecma-international.org/12.0/#sec-quotejsonstring

var escapes = {
	'\u0008': '\\b',
	'\u0009': '\\t',
	'\u000A': '\\n',
	'\u000C': '\\f',
	'\u000D': '\\r',
	'\u0022': '\\"',
	'\u005c': '\\\\'
};

module.exports = function QuoteJSONString(value) {
	if (typeof value !== 'string') {
		throw new $TypeError('Assertion failed: `value` must be a String');
	}
	var product = '"';
	if (value) {
		forEach($strSplit(StringToCodePoints(value), ''), function (C) {
			if (hasOwn(escapes, C)) {
				product += escapes[C];
			} else {
				var cCharCode = $charCodeAt(C, 0);
				if (cCharCode < 0x20 || isLeadingSurrogate(cCharCode) || isTrailingSurrogate(cCharCode)) {
					product += UnicodeEscape(C);
				} else {
					product += UTF16EncodeCodePoint(cCharCode);
				}
			}
		});
	}
	product += '"';
	return product;
};
'use strict';

var GetIntrinsic = require('get-intrinsic');
var callBound = require('call-bound');

var $RangeError = require('es-errors/range');
var $SyntaxError = require('es-errors/syntax');
var $TypeError = require('es-errors/type');
var $BigInt = GetIntrinsic('%BigInt%', true);

var hasOwnProperty = require('./HasOwnProperty');
var IsArray = require('./IsArray');
var IsBigIntElementType = require('./IsBigIntElementType');
var IsUnsignedElementType = require('./IsUnsignedElementType');

var bytesAsFloat16 = require('../helpers/bytesAsFloat16');
var bytesAsFloat32 = require('../helpers/bytesAsFloat32');
var bytesAsFloat64 = require('../helpers/bytesAsFloat64');
var bytesAsInteger = require('../helpers/bytesAsInteger');
var every = require('../helpers/every');
var isByteValue = require('../helpers/isByteValue');

var $reverse = callBound('Array.prototype.reverse');
var $slice = callBound('Array.prototype.slice');

var tableTAO = require('./tables/typed-array-objects');

// https://262.ecma-international.org/15.0/#sec-rawbytestonumeric

module.exports = function RawBytesToNumeric(type, rawBytes, isLittleEndian) {
	if (!hasOwnProperty(tableTAO.size, '$' + type)) {
		throw new $TypeError('Assertion failed: `type` must be a TypedArray element type');
	}
	if (!IsArray(rawBytes) || !every(rawBytes, isByteValue)) {
		throw new $TypeError('Assertion failed: `rawBytes` must be an Array of bytes');
	}
	if (typeof isLittleEndian !== 'boolean') {
		throw new $TypeError('Assertion failed: `isLittleEndian` must be a Boolean');
	}

	var elementSize = tableTAO.size['$' + type]; // step 1

	if (rawBytes.length !== elementSize) {
		// this assertion is not in the spec, but it'd be an editorial error if it were ever violated
		throw new $RangeError('Assertion failed: `rawBytes` must have a length of ' + elementSize + ' for type ' + type);
	}

	var isBigInt = IsBigIntElementType(type);
	if (isBigInt && !$BigInt) {
		throw new $SyntaxError('this environment does not support BigInts');
	}

	// eslint-disable-next-line no-param-reassign
	rawBytes = $slice(rawBytes, 0, elementSize);
	if (!isLittleEndian) {
		$reverse(rawBytes); // step 2
	}

	if (type === 'FLOAT16') { // step 3
		return bytesAsFloat16(rawBytes);
	}

	if (type === 'FLOAT32') { // step 4
		return bytesAsFloat32(rawBytes);
	}

	if (type === 'FLOAT64') { // step 5
		return bytesAsFloat64(rawBytes);
	}

	return bytesAsInteger(rawBytes, elementSize, IsUnsignedElementType(type), isBigInt);
};
'use strict';

var GetIntrinsic = require('get-intrinsic');

var $RegExp = GetIntrinsic('%RegExp%');

// var RegExpAlloc = require('./RegExpAlloc');
// var RegExpInitialize = require('./RegExpInitialize');
var ToString = require('./ToString');

// https://262.ecma-international.org/6.0/#sec-regexpcreate

module.exports = function RegExpCreate(P, F) {
	// var obj = RegExpAlloc($RegExp);
	// return RegExpInitialize(obj, P, F);

	// covers spec mechanics; bypass regex brand checking
	var pattern = typeof P === 'undefined' ? '' : ToString(P);
	var flags = typeof F === 'undefined' ? '' : ToString(F);
	return new $RegExp(pattern, flags);
};
'use strict';

var $TypeError = require('es-errors/type');
var isObject = require('es-object-atoms/isObject');
var regexExec = require('call-bound')('RegExp.prototype.exec');

var Call = require('./Call');
var Get = require('./Get');
var IsCallable = require('./IsCallable');

// https://262.ecma-international.org/6.0/#sec-regexpexec

module.exports = function RegExpExec(R, S) {
	if (!isObject(R)) {
		throw new $TypeError('Assertion failed: `R` must be an Object');
	}
	if (typeof S !== 'string') {
		throw new $TypeError('Assertion failed: `S` must be a String');
	}
	var exec = Get(R, 'exec');
	if (IsCallable(exec)) {
		var result = Call(exec, R, [S]);
		if (result === null || isObject(result)) {
			return result;
		}
		throw new $TypeError('"exec" method must return `null` or an Object');
	}
	return regexExec(R, S);
};
'use strict';

var GetIntrinsic = require('get-intrinsic');
var callBound = require('call-bound');

var $TypeError = require('es-errors/type');
var isObject = require('es-object-atoms/isObject');
var $RegExpPrototype = GetIntrinsic('%RegExp.prototype%');

var SameValue = require('./SameValue');

var $indexOf = callBound('String.prototype.indexOf');

var hasRegExpMatcher = require('is-regex');
var getFlags = require('regexp.prototype.flags');

// https://262.ecma-international.org/13.0/#sec-regexphasflag

module.exports = function RegExpHasFlag(R, codeUnit) {
	if (typeof codeUnit !== 'string' || codeUnit.length !== 1) {
		throw new $TypeError('Assertion failed: `string` must be a code unit - a String of length 1');
	}

	if (!isObject(R)) {
		throw new $TypeError('Assertion failed: Type(R) is not Object');
	}

	if (!hasRegExpMatcher(R)) { // step 2
		if (SameValue(R, $RegExpPrototype)) {
			return void undefined; // step 2.a
		}
		throw new $TypeError('`R` must be a RegExp object'); // step 2.b
	}

	var flags = getFlags(R); // step 3

	return $indexOf(flags, codeUnit) > -1; // steps 4-5
};
'use strict';

module.exports = require('es-object-atoms/RequireObjectCoercible');
'use strict';

var CompletionRecord = require('./CompletionRecord');

// https://tc39.es/ecma262/#sec-returncompletion

module.exports = function ReturnCompletion(value) {
	return new CompletionRecord('return', value);
};
'use strict';

// https://262.ecma-international.org/16.0/#sec-sametype

module.exports = function SameType(x, y) {
	if (x === y) {
		return true;
	}
	if (
		(x === null && y !== null)
        || (x !== null && y === null)
	) {
		return false;
	}
	return typeof x === typeof y;
};
'use strict';

var $isNaN = require('math-intrinsics/isNaN');

// http://262.ecma-international.org/5.1/#sec-9.12

module.exports = function SameValue(x, y) {
	if (x === y) { // 0 === -0, but they are not identical.
		if (x === 0) { return 1 / x === 1 / y; }
		return true;
	}
	return $isNaN(x) && $isNaN(y);
};
'use strict';

var $TypeError = require('es-errors/type');

var SameValue = require('./SameValue');
var SameType = require('./SameType');

// https://262.ecma-international.org/16.0/#sec-samevaluenonnumeric

module.exports = function SameValueNonNumber(x, y) {
	if (typeof x === 'number') {
		throw new $TypeError('Assertion failed: SameValueNonNumber does not accept Number values');
	}
	if (!SameType(x, y)) {
		throw new $TypeError('SameValueNonNumber requires two non-Number values of the same type.');
	}
	return SameValue(x, y);
};
'use strict';

var $isNaN = require('math-intrinsics/isNaN');

// https://262.ecma-international.org/6.0/#sec-samevaluezero

module.exports = function SameValueZero(x, y) {
	return (x === y) || ($isNaN(x) && $isNaN(y));
};
'use strict';

var floor = require('./floor');
var modulo = require('./modulo');

var timeConstants = require('../helpers/timeConstants');
var msPerSecond = timeConstants.msPerSecond;
var SecondsPerMinute = timeConstants.SecondsPerMinute;

// https://262.ecma-international.org/5.1/#sec-15.9.1.10

module.exports = function SecFromTime(t) {
	return modulo(floor(t / msPerSecond), SecondsPerMinute);
};
'use strict';

var $TypeError = require('es-errors/type');

var CanonicalizeKeyedCollectionKey = require('./CanonicalizeKeyedCollectionKey');
var IsArray = require('./IsArray');
var SameValue = require('./SameValue');

var some = require('../helpers/some');

// https://262.ecma-international.org/16.0/#sec-setdatahas

module.exports = function SetDataHas(setData, value) {
	if (!IsArray(setData) && setData !== 'EMPTY') {
		throw new $TypeError('Assertion failed: `setData` must be a List or ~EMPTY~');
	}

	// if (SetDataIndex(setData, value) === 'NOT-FOUND') { return false; } // step 1
	// return true; // step 2

	var canonValue = CanonicalizeKeyedCollectionKey(value);

	return some(setData, function (e) {
		return SameValue(e, canonValue);
	});
};
'use strict';

var $TypeError = require('es-errors/type');

var CanonicalizeKeyedCollectionKey = require('./CanonicalizeKeyedCollectionKey');
var SameValue = require('./SameValue');

var isArray = require('../helpers/IsArray');

// https://262.ecma-international.org/16.0/#sec-setdataindex

module.exports = function SetDataIndex(setData, value) {
	if (!isArray(setData) && setData !== 'EMPTY') {
		throw new $TypeError('Assertion failed: `setData` must be a List or ~EMPTY~');
	}

	var canonValue = CanonicalizeKeyedCollectionKey(value); // step 1

	var size = setData.length; // step 2

	var index = 0; // step 3

	while (index < size) { // step 4
		var e = setData[index]; // step 4.a
		if (/* e !== ~EMPTY~ && */ SameValue(e, canonValue)) { // step 4.b
			return index; // step 4.b.i
		}
		index += 1; // step 4.c
	}

	return 'NOT-FOUND'; // step 5
};
'use strict';

var $TypeError = require('es-errors/type');

var forEach = require('../helpers/forEach');
var isArray = require('../helpers/IsArray');

// https://262.ecma-international.org/16.0/#sec-setdatasize

// TODO: when spec enums are unforgeable, uncomment ~EMPTY~ check

module.exports = function SetDataSize(setData) {
	if (!isArray(setData) && setData !== 'EMPTY') {
		throw new $TypeError('Assertion failed: `setData` must be a List or ~EMPTY~');
	}

	if (setData === 'EMPTY') {
		return 0;
	}

	var count = 0; // step 1

	forEach(setData, function (e, i) { // step 2
		if (i in setData /* && e !== ~EMPTY~ */) {
			count += 1; // step 2.a
		}
	});

	return count; // step 3
};
'use strict';

var $TypeError = require('es-errors/type');
var isInteger = require('math-intrinsics/isInteger');

var DefinePropertyOrThrow = require('./DefinePropertyOrThrow');
var HasOwnProperty = require('./HasOwnProperty');
var IsExtensible = require('./IsExtensible');

// https://262.ecma-international.org/12.0/#sec-setfunctionlength

module.exports = function SetFunctionLength(F, length) {
	if (typeof F !== 'function' || !IsExtensible(F) || HasOwnProperty(F, 'length')) {
		throw new $TypeError('Assertion failed: `F` must be an extensible function and lack an own `length` property');
	}
	if (typeof length !== 'number') {
		throw new $TypeError('Assertion failed: `length` must be a Number');
	}
	if (length !== Infinity && (!isInteger(length) || length < 0)) {
		throw new $TypeError('Assertion failed: `length` must be ∞, or an integer >= 0');
	}
	return DefinePropertyOrThrow(F, 'length', {
		'[[Configurable]]': true,
		'[[Enumerable]]': false,
		'[[Value]]': length,
		'[[Writable]]': false
	});
};
'use strict';

var hasOwn = require('hasown');

var $TypeError = require('es-errors/type');

var getSymbolDescription = require('get-symbol-description');

var DefinePropertyOrThrow = require('./DefinePropertyOrThrow');
var IsExtensible = require('./IsExtensible');

// https://262.ecma-international.org/6.0/#sec-setfunctionname

module.exports = function SetFunctionName(F, name) {
	if (typeof F !== 'function') {
		throw new $TypeError('Assertion failed: `F` must be a function');
	}
	if (!IsExtensible(F) || hasOwn(F, 'name')) {
		throw new $TypeError('Assertion failed: `F` must be extensible, and must not have a `name` own property');
	}
	if (typeof name !== 'symbol' && typeof name !== 'string') {
		throw new $TypeError('Assertion failed: `name` must be a Symbol or a String');
	}
	if (typeof name === 'symbol') {
		var description = getSymbolDescription(name);
		// eslint-disable-next-line no-param-reassign
		name = typeof description === 'undefined' ? '' : '[' + description + ']';
	}
	if (arguments.length > 2) {
		var prefix = arguments[2];
		// eslint-disable-next-line no-param-reassign
		name = prefix + ' ' + name;
	}
	return DefinePropertyOrThrow(F, 'name', {
		'[[Value]]': name,
		'[[Writable]]': false,
		'[[Enumerable]]': false,
		'[[Configurable]]': true
	});
};
'use strict';

var GetIntrinsic = require('get-intrinsic');

var $SyntaxError = require('es-errors/syntax');
var $TypeError = require('es-errors/type');
var isObject = require('es-object-atoms/isObject');
var $gOPD = require('gopd');
var $preventExtensions = GetIntrinsic('%Object.preventExtensions%', true);
var $gOPN = GetIntrinsic('%Object.getOwnPropertyNames%', true);

var forEach = require('../helpers/forEach');

var DefinePropertyOrThrow = require('./DefinePropertyOrThrow');
var IsAccessorDescriptor = require('./IsAccessorDescriptor');
var ToPropertyDescriptor = require('./ToPropertyDescriptor');

// https://262.ecma-international.org/6.0/#sec-setintegritylevel

module.exports = function SetIntegrityLevel(O, level) {
	if (!isObject(O)) {
		throw new $TypeError('Assertion failed: Type(O) is not Object');
	}
	if (level !== 'sealed' && level !== 'frozen') {
		throw new $TypeError('Assertion failed: `level` must be `"sealed"` or `"frozen"`');
	}
	if (!$preventExtensions) {
		throw new $SyntaxError('SetIntegrityLevel requires native `Object.preventExtensions` support');
	}
	var status = $preventExtensions(O);
	if (!status) {
		return false;
	}
	if (!$gOPN) {
		throw new $SyntaxError('SetIntegrityLevel requires native `Object.getOwnPropertyNames` support');
	}
	var theKeys = $gOPN(O);
	if (level === 'sealed') {
		forEach(theKeys, function (k) {
			DefinePropertyOrThrow(O, k, { configurable: false });
		});
	} else if (level === 'frozen') {
		forEach(theKeys, function (k) {
			var currentDesc = $gOPD(O, k);
			if (typeof currentDesc !== 'undefined') {
				var desc;
				if (IsAccessorDescriptor(ToPropertyDescriptor(currentDesc))) {
					desc = { configurable: false };
				} else {
					desc = { configurable: false, writable: false };
				}
				DefinePropertyOrThrow(O, k, desc);
			}
		});
	}
	return true;
};
'use strict';

var $TypeError = require('es-errors/type');
var isObject = require('es-object-atoms/isObject');

var isPropertyKey = require('../helpers/isPropertyKey');
var SameValue = require('./SameValue');

// IE 9 does not throw in strict mode when writability/configurability/extensibility is violated
var noThrowOnStrictViolation = (function () {
	try {
		delete [].length;
		return true;
	} catch (e) {
		return false;
	}
}());

// https://262.ecma-international.org/6.0/#sec-set-o-p-v-throw

module.exports = function Set(O, P, V, Throw) {
	if (!isObject(O)) {
		throw new $TypeError('Assertion failed: `O` must be an Object');
	}
	if (!isPropertyKey(P)) {
		throw new $TypeError('Assertion failed: `P` must be a Property Key');
	}
	if (typeof Throw !== 'boolean') {
		throw new $TypeError('Assertion failed: `Throw` must be a Boolean');
	}
	if (Throw) {
		O[P] = V; // eslint-disable-line no-param-reassign
		if (noThrowOnStrictViolation && !SameValue(O[P], V)) {
			throw new $TypeError('Attempted to assign to readonly property.');
		}
		return true;
	}
	try {
		O[P] = V; // eslint-disable-line no-param-reassign
		return noThrowOnStrictViolation ? SameValue(O[P], V) : true;
	} catch (e) {
		return false;
	}

};
'use strict';

var $TypeError = require('es-errors/type');
var gOPD = require('gopd');

var isObject = require('../helpers/isObject');
var isPropertyKey = require('../helpers/isPropertyKey');

var CreateDataPropertyOrThrow = require('./CreateDataPropertyOrThrow');
var SameValue = require('./SameValue');
var Set = require('./Set');

// https://262.ecma-international.org/16.0/#sec-SetterThatIgnoresPrototypeProperties

module.exports = function SetterThatIgnoresPrototypeProperties(thisValue, home, p, v) {
	if (!isObject(home)) {
		throw new $TypeError('Assertion failed: `home` must be an object');
	}
	if (!isPropertyKey(p)) {
		throw new $TypeError('Assertion failed: `p` must be a Property Key');
	}

	if (!isObject(thisValue)) { // step 1
		throw new $TypeError('Assertion failed: `thisValue` must be an Object'); // step 1.a
	}

	if (SameValue(thisValue, home)) { // step 2
		throw new $TypeError('Throwing here emulates assignment to a non-writable data property on the `home` object in strict mode code'); // step 2.b
	}

	var desc = gOPD(thisValue, p); // step 3

	if (typeof desc === 'undefined') { // step 4
		CreateDataPropertyOrThrow(thisValue, p, v); // step 4.a
	} else { // step 5
		Set(thisValue, p, v, true); // step 5.a
	}
};
'use strict';

var $RangeError = require('es-errors/range');
var $TypeError = require('es-errors/type');
var isInteger = require('math-intrinsics/isInteger');

var isTypedArray = require('is-typed-array');
var whichTypedArray = require('which-typed-array');

var Get = require('./Get');
var IsTypedArrayOutOfBounds = require('./IsTypedArrayOutOfBounds');
var LengthOfArrayLike = require('./LengthOfArrayLike');
var MakeTypedArrayWithBufferWitnessRecord = require('./MakeTypedArrayWithBufferWitnessRecord');
var ToObject = require('./ToObject');
var ToString = require('./ToString');
var TypedArrayLength = require('./TypedArrayLength');
var TypedArraySetElement = require('./TypedArraySetElement');

// https://262.ecma-international.org/15.0/#sec-settypedarrayfromarraylike

module.exports = function SetTypedArrayFromArrayLike(target, targetOffset, source) {
	var whichTarget = whichTypedArray(target);
	if (!whichTarget) {
		throw new $TypeError('Assertion failed: `target` must be a Typed Array');
	}

	if (targetOffset !== Infinity && (!isInteger(targetOffset) || targetOffset < 0)) {
		throw new $TypeError('Assertion failed: `targetOffset` must be a non-negative integer or +Infinity');
	}

	if (isTypedArray(source)) {
		throw new $TypeError('Assertion failed: `source` must not be a Typed Array');
	}

	var targetRecord = MakeTypedArrayWithBufferWitnessRecord(target, 'SEQ-CST'); // step 1

	if (IsTypedArrayOutOfBounds(targetRecord)) {
		throw new $TypeError('target is out of bounds'); // step 2
	}

	var targetLength = TypedArrayLength(targetRecord); // step 3

	var src = ToObject(source); // step 4

	var srcLength = LengthOfArrayLike(src); // step 5

	if (targetOffset === Infinity) {
		throw new $RangeError('targetOffset must be a finite integer'); // step 6
	}

	if (srcLength + targetOffset > targetLength) {
		throw new $RangeError('targetOffset + srcLength must be <= target.length'); // step 7
	}

	var k = 0; // step 8

	while (k < srcLength) { // step 9
		var Pk = ToString(k); // step 9.a
		var value = Get(src, Pk); // step 9.b
		var targetIndex = targetOffset + k; // step 9.c
		TypedArraySetElement(target, targetIndex, value); // step 9.d
		k += 1; // step 9.e
	}
};
'use strict';

var $RangeError = require('es-errors/range');
var $SyntaxError = require('es-errors/syntax');
var $TypeError = require('es-errors/type');

var CloneArrayBuffer = require('./CloneArrayBuffer');
var GetValueFromBuffer = require('./GetValueFromBuffer');
var IsSharedArrayBuffer = require('./IsSharedArrayBuffer');
var IsTypedArrayOutOfBounds = require('./IsTypedArrayOutOfBounds');
var MakeTypedArrayWithBufferWitnessRecord = require('./MakeTypedArrayWithBufferWitnessRecord');
var SameValue = require('./SameValue');
var SetValueInBuffer = require('./SetValueInBuffer');
var TypedArrayByteLength = require('./TypedArrayByteLength');
var TypedArrayElementSize = require('./TypedArrayElementSize');
var TypedArrayElementType = require('./TypedArrayElementType');
var TypedArrayLength = require('./TypedArrayLength');

var typedArrayBuffer = require('typed-array-buffer');
var typedArrayByteOffset = require('typed-array-byte-offset');
var whichTypedArray = require('which-typed-array');
var GetIntrinsic = require('call-bound');
var isInteger = require('math-intrinsics/isInteger');

var $ArrayBuffer = GetIntrinsic('%ArrayBuffer%', true);

// https://262.ecma-international.org/15.0/#sec-settypedarrayfromtypedarray

module.exports = function SetTypedArrayFromTypedArray(target, targetOffset, source) {
	var whichTarget = whichTypedArray(target);
	if (!whichTarget) {
		throw new $TypeError('Assertion failed: `target` must be a Typed Array');
	}

	if (targetOffset !== Infinity && (!isInteger(targetOffset) || targetOffset < 0)) {
		throw new $TypeError('Assertion failed: `targetOffset` must be a non-negative integer or +Infinity');
	}

	var whichSource = whichTypedArray(source);
	if (!whichSource) {
		throw new $TypeError('Assertion failed: `source` must be a Typed Array');
	}

	var targetBuffer = typedArrayBuffer(target); // step 1

	var targetRecord = MakeTypedArrayWithBufferWitnessRecord(target, 'SEQ-CST'); // step 2

	if (IsTypedArrayOutOfBounds(targetRecord)) {
		throw new $TypeError('target is out of bounds'); // step 3
	}

	var targetLength = TypedArrayLength(targetRecord); // step 4

	var srcBuffer = typedArrayBuffer(source); // step 5

	var srcRecord = MakeTypedArrayWithBufferWitnessRecord(source, 'SEQ-CST'); // step 6

	if (IsTypedArrayOutOfBounds(srcRecord)) {
		throw new $TypeError('target is out of bounds'); // step 7
	}

	var srcLength = TypedArrayLength(srcRecord); // step 8

	var targetType = TypedArrayElementType(target); // step 9

	var targetElementSize = TypedArrayElementSize(target); // step 10

	var targetByteOffset = typedArrayByteOffset(target); // step 11

	var srcType = TypedArrayElementType(source); // step 12

	var srcElementSize = TypedArrayElementSize(source); // step 13

	var srcByteOffset = typedArrayByteOffset(source); // step 14

	if (targetOffset === Infinity) {
		throw new $RangeError('targetOffset must be a non-negative integer or +Infinity'); // step 15
	}

	if (srcLength + targetOffset > targetLength) {
		throw new $RangeError('targetOffset + source.length must not be greater than target.length'); // step 16
	}

	var targetContentType = whichTarget === 'BigInt64Array' || whichTarget === 'BigUint64Array' ? 'BIGINT' : 'NUMBER';
	var sourceContentType = whichSource === 'BigInt64Array' || whichSource === 'BigUint64Array' ? 'BIGINT' : 'NUMBER';
	if (targetContentType !== sourceContentType) {
		throw new $TypeError('source and target must have the same content type'); // step 17
	}

	var sameSharedArrayBuffer = false;
	if (IsSharedArrayBuffer(srcBuffer) && IsSharedArrayBuffer(targetBuffer)) { // step 18
		// a. If srcBuffer.[[ArrayBufferData]] and targetBuffer.[[ArrayBufferData]] are the same Shared Data Block values, let same be true; else let same be false.
		throw new $SyntaxError('SharedArrayBuffer is not supported by this implementation');
	}

	var srcByteIndex;
	if (SameValue(srcBuffer, targetBuffer) || sameSharedArrayBuffer) { // step 19
		var srcByteLength = TypedArrayByteLength(srcRecord); // step 19.a
		srcBuffer = CloneArrayBuffer(srcBuffer, srcByteOffset, srcByteLength, $ArrayBuffer); // step 19.b
		srcByteIndex = 0; // step 19.c
	} else { // step 20
		srcByteIndex = srcByteOffset; // step 20.a
	}

	var targetByteIndex = (targetOffset * targetElementSize) + targetByteOffset; // step 21

	var limit = targetByteIndex + (targetElementSize * srcLength); // step 22

	var value;
	if (srcType === targetType) { // step 23
		// a. NOTE: The transfer must be performed in a manner that preserves the bit-level encoding of the source data.

		while (targetByteIndex < limit) { // step 23.b
			value = GetValueFromBuffer(srcBuffer, srcByteIndex, 'UINT8', true, 'UNORDERED'); // step 23.b.i

			SetValueInBuffer(targetBuffer, targetByteIndex, 'UINT8', value, true, 'UNORDERED'); // step 23.b.ii

			srcByteIndex += 1; // step 23.b.iii

			targetByteIndex += 1; // step 23.b.iv
		}
	} else { // step 24
		while (targetByteIndex < limit) { // step 24.a
			value = GetValueFromBuffer(srcBuffer, srcByteIndex, srcType, true, 'UNORDERED'); // step 24.a.i

			SetValueInBuffer(targetBuffer, targetByteIndex, targetType, value, true, 'UNORDERED'); // step 24.a.ii

			srcByteIndex += srcElementSize; // step 24.a.iii

			targetByteIndex += targetElementSize; // step 24.a.iv
		}
	}
};
'use strict';

var GetIntrinsic = require('get-intrinsic');

var $SyntaxError = require('es-errors/syntax');
var $TypeError = require('es-errors/type');
var isInteger = require('math-intrinsics/isInteger');
var $Uint8Array = GetIntrinsic('%Uint8Array%', true);

var IsBigIntElementType = require('./IsBigIntElementType');
var IsDetachedBuffer = require('./IsDetachedBuffer');
var NumericToRawBytes = require('./NumericToRawBytes');

var isArrayBuffer = require('is-array-buffer');
var isSharedArrayBuffer = require('is-shared-array-buffer');
var hasOwn = require('hasown');

var tableTAO = require('./tables/typed-array-objects');

var defaultEndianness = require('../helpers/defaultEndianness');
var forEach = require('../helpers/forEach');

// https://262.ecma-international.org/15.0/#sec-setvalueinbuffer

/* eslint max-params: 0 */

module.exports = function SetValueInBuffer(arrayBuffer, byteIndex, type, value, isTypedArray, order) {
	var isSAB = isSharedArrayBuffer(arrayBuffer);
	if (!isArrayBuffer(arrayBuffer) && !isSAB) {
		throw new $TypeError('Assertion failed: `arrayBuffer` must be an ArrayBuffer or a SharedArrayBuffer');
	}

	if (!isInteger(byteIndex) || byteIndex < 0) {
		throw new $TypeError('Assertion failed: `byteIndex` must be a non-negative integer');
	}

	if (typeof type !== 'string' || !hasOwn(tableTAO.size, '$' + type)) {
		throw new $TypeError('Assertion failed: `type` must be one of ' + tableTAO.choices);
	}

	if (typeof value !== 'number' && typeof value !== 'bigint') {
		throw new $TypeError('Assertion failed: `value` must be a Number or a BigInt');
	}

	if (typeof isTypedArray !== 'boolean') {
		throw new $TypeError('Assertion failed: `isTypedArray` must be a boolean');
	}
	if (order !== 'SEQ-CST' && order !== 'UNORDERED' && order !== 'INIT') {
		throw new $TypeError('Assertion failed: `order` must be `"SEQ-CST"`, `"UNORDERED"`, or `"INIT"`');
	}

	if (arguments.length > 6 && typeof arguments[6] !== 'boolean') {
		throw new $TypeError('Assertion failed: `isLittleEndian` must be a boolean, if present');
	}

	if (IsDetachedBuffer(arrayBuffer)) {
		throw new $TypeError('Assertion failed: ArrayBuffer is detached'); // step 1
	}

	// 2. Assert: There are sufficient bytes in arrayBuffer starting at byteIndex to represent a value of type.

	if (IsBigIntElementType(type) ? typeof value !== 'bigint' : typeof value !== 'number') { // step 3
		throw new $TypeError('Assertion failed: `value` must be a BigInt if type is ~BIGINT64~ or ~BIGUINT64~, otherwise a Number');
	}

	// 4. Let block be arrayBuffer’s [[ArrayBufferData]] internal slot.

	var elementSize = tableTAO.size['$' + type]; // step 5

	// 6. If isLittleEndian is not present, set isLittleEndian to either true or false. The choice is implementation dependent and should be the alternative that is most efficient for the implementation. An implementation must use the same value each time this step is executed and the same value must be used for the corresponding step in the GetValueFromBuffer abstract operation.
	var isLittleEndian = arguments.length > 6 ? arguments[6] : defaultEndianness === 'little'; // step 6

	var rawBytes = NumericToRawBytes(type, value, isLittleEndian); // step 7

	if (isSAB) { // step 8
		/*
			Let execution be the [[CandidateExecution]] field of the surrounding agent's Agent Record.
			Let eventList be the [[EventList]] field of the element in execution.[[EventsRecords]] whose [[AgentSignifier]] is AgentSignifier().
			If isTypedArray is true and IsNoTearConfiguration(type, order) is true, let noTear be true; otherwise let noTear be false.
			Append WriteSharedMemory { [[Order]]: order, [[NoTear]]: noTear, [[Block]]: block, [[ByteIndex]]: byteIndex, [[ElementSize]]: elementSize, [[Payload]]: rawBytes } to eventList.
		*/
		throw new $SyntaxError('SharedArrayBuffer is not supported by this implementation');
	} else {
		// 9. Store the individual bytes of rawBytes into block, in order, starting at block[byteIndex].
		var arr = new $Uint8Array(arrayBuffer, byteIndex, elementSize);
		forEach(rawBytes, function (rawByte, i) {
			arr[i] = rawByte;
		});
	}

	// 10. Return NormalCompletion(undefined).
};
'use strict';

var $TypeError = require('es-errors/type');
var callBound = require('call-bound');
var isInteger = require('math-intrinsics/isInteger');
var isObject = require('es-object-atoms/isObject');

var Get = require('./Get');
var HasProperty = require('./HasProperty');
var ToString = require('./ToString');

var isAbstractClosure = require('../helpers/isAbstractClosure');

var $sort = callBound('Array.prototype.sort');

// https://262.ecma-international.org/14.0/#sec-sortindexedproperties

module.exports = function SortIndexedProperties(obj, len, SortCompare, holes) {
	if (!isObject(obj)) {
		throw new $TypeError('Assertion failed: Type(obj) is not Object');
	}
	if (!isInteger(len) || len < 0) {
		throw new $TypeError('Assertion failed: `len` must be an integer >= 0');
	}
	if (!isAbstractClosure(SortCompare) || SortCompare.length !== 2) {
		throw new $TypeError('Assertion failed: `SortCompare` must be an abstract closure taking 2 arguments');
	}
	if (holes !== 'skip-holes' && holes !== 'read-through-holes') {
		throw new $TypeError('Assertion failed: `holes` must be either ~skip-holes~ or ~read-through-holes~');
	}

	var items = []; // step 1

	var k = 0; // step 2

	while (k < len) { // step 3
		var Pk = ToString(k);
		var kRead = holes === 'skip-holes' ? HasProperty(obj, Pk) : true; // step 3.b - 3.c
		if (kRead) { // step 3.d
			var kValue = Get(obj, Pk);
			items[items.length] = kValue;
		}
		k += 1; // step 3.e
	}

	$sort(items, SortCompare); // step 4

	return items; // step 5
};
'use strict';

var GetIntrinsic = require('get-intrinsic');

var $species = GetIntrinsic('%Symbol.species%', true);
var $TypeError = require('es-errors/type');
var isObject = require('es-object-atoms/isObject');

var IsConstructor = require('./IsConstructor');

// https://262.ecma-international.org/6.0/#sec-speciesconstructor

module.exports = function SpeciesConstructor(O, defaultConstructor) {
	if (!isObject(O)) {
		throw new $TypeError('Assertion failed: Type(O) is not Object');
	}
	var C = O.constructor;
	if (typeof C === 'undefined') {
		return defaultConstructor;
	}
	if (!isObject(C)) {
		throw new $TypeError('O.constructor is not an Object');
	}
	var S = $species ? C[$species] : void 0;
	if (S == null) {
		return defaultConstructor;
	}
	if (IsConstructor(S)) {
		return S;
	}
	throw new $TypeError('no constructor found');
};
'use strict';

var GetIntrinsic = require('get-intrinsic');

var $Object = require('es-object-atoms');
var $StringPrototype = GetIntrinsic('%String.prototype%');
var $SyntaxError = require('es-errors/syntax');
var $TypeError = require('es-errors/type');
var setProto = require('set-proto');

var DefinePropertyOrThrow = require('./DefinePropertyOrThrow');

// https://262.ecma-international.org/6.0/#sec-stringcreate

module.exports = function StringCreate(value, prototype) {
	if (typeof value !== 'string') {
		throw new $TypeError('Assertion failed: `S` must be a String');
	}

	var S = $Object(value);
	if (prototype !== $StringPrototype) {
		if (setProto) {
			setProto(S, prototype);
		} else {
			throw new $SyntaxError('StringCreate: a `proto` argument that is not `String.prototype` is not supported in an environment that does not support setting the [[Prototype]]');
		}
	}

	var length = value.length;
	DefinePropertyOrThrow(S, 'length', {
		'[[Configurable]]': false,
		'[[Enumerable]]': false,
		'[[Value]]': length,
		'[[Writable]]': false
	});

	return S;
};
'use strict';

var $TypeError = require('es-errors/type');
var isNegativeZero = require('math-intrinsics/isNegativeZero');
var isObject = require('es-object-atoms/isObject');

var callBound = require('call-bound');
var $charAt = callBound('String.prototype.charAt');
var $stringToString = callBound('String.prototype.toString');

var CanonicalNumericIndexString = require('./CanonicalNumericIndexString');

var isPropertyKey = require('../helpers/isPropertyKey');
var isInteger = require('math-intrinsics/isInteger');

// https://262.ecma-international.org/12.0/#sec-stringgetownproperty

module.exports = function StringGetOwnProperty(S, P) {
	var str;
	if (isObject(S)) {
		try {
			str = $stringToString(S);
		} catch (e) { /**/ }
	}
	if (typeof str !== 'string') {
		throw new $TypeError('Assertion failed: `S` must be a boxed string object');
	}
	if (!isPropertyKey(P)) {
		throw new $TypeError('Assertion failed: P is not a Property Key');
	}
	if (typeof P !== 'string') {
		return void undefined;
	}
	var index = CanonicalNumericIndexString(P);
	var len = str.length;
	if (typeof index === 'undefined' || !isInteger(index) || isNegativeZero(index) || index < 0 || len <= index) {
		return void undefined;
	}
	var resultStr = $charAt(S, index);
	return {
		'[[Configurable]]': false,
		'[[Enumerable]]': true,
		'[[Value]]': resultStr,
		'[[Writable]]': false
	};
};
'use strict';

var callBound = require('call-bound');

var $TypeError = require('es-errors/type');
var isInteger = require('math-intrinsics/isInteger');

var $slice = callBound('String.prototype.slice');

// https://262.ecma-international.org/16.0/#sec-stringindexof

module.exports = function StringIndexOf(string, searchValue, fromIndex) {
	if (typeof string !== 'string') {
		throw new $TypeError('Assertion failed: `string` must be a String');
	}
	if (typeof searchValue !== 'string') {
		throw new $TypeError('Assertion failed: `searchValue` must be a String');
	}
	if (!isInteger(fromIndex) || fromIndex < 0) {
		throw new $TypeError('Assertion failed: `fromIndex` must be a non-negative integer');
	}

	var len = string.length; // step 1
	if (searchValue === '' && fromIndex <= len) {
		return fromIndex; // step 2
	}

	var searchLen = searchValue.length; // step 3
	for (var i = fromIndex; i <= (len - searchLen); i += 1) { // step 4
		var candidate = $slice(string, i, i + searchLen); // step 4.a
		if (candidate === searchValue) {
			return i; // step 4.b
		}
	}
	return 'NOT-FOUND'; // step 5
};
'use strict';

var $TypeError = require('es-errors/type');

var substring = require('./substring');

var isInteger = require('../helpers/isInteger');

// https://262.ecma-international.org/16.0/#sec-stringlastindexof

module.exports = function StringLastIndexOf(string, searchValue, fromIndex) {
	if (typeof string !== 'string') {
		throw new $TypeError('Assertion failed: `string` must be a string');
	}
	if (typeof searchValue !== 'string') {
		throw new $TypeError('Assertion failed: `searchValue` must be a string');
	}
	if (!isInteger(fromIndex) || fromIndex < 0) {
		throw new $TypeError('Assertion failed: `fromIndex` must be a non-negative integer');
	}

	var len = string.length; // step 1

	var searchLen = searchValue.length; // step 2

	if (!((fromIndex + searchLen) <= len)) {
		throw new $TypeError('Assertion failed: fromIndex + searchLen ≤ len'); // step 3
	}

	for (var i = fromIndex; i >= 0; i--) { // step 4
		var candidate = substring(string, i, i + searchLen); // step 4.a
		if (candidate === searchValue) {
			return i; // step 4.b
		}
	}

	return 'NOT-FOUND'; // step 5
};
'use strict';

var $TypeError = require('es-errors/type');

var StringPad = require('./StringPad');
var ToLength = require('./ToLength');
var ToString = require('./ToString');

// https://262.ecma-international.org/15.0/#sec-stringpaddingbuiltinsimpl

module.exports = function StringPaddingBuiltinsImpl(O, maxLength, fillString, placement) {
	if (placement !== 'start' && placement !== 'end' && placement !== 'START' && placement !== 'END') {
		throw new $TypeError('Assertion failed: `placement` must be ~START~ or ~END~');
	}

	var S = ToString(O); // step 1

	var intMaxLength = ToLength(maxLength); // step 2

	var stringLength = S.length; // step 3

	if (intMaxLength <= stringLength) { return S; } // step 4

	var filler = typeof fillString === 'undefined' ? ' ' : ToString(fillString); // steps 5-6

	return StringPad(S, intMaxLength, filler, placement); // step 7
};
'use strict';

var $TypeError = require('es-errors/type');
var callBound = require('call-bound');
var isInteger = require('math-intrinsics/isInteger');

var $strSlice = callBound('String.prototype.slice');

// https://262.ecma-international.org/15.0/#sec-stringpad

module.exports = function StringPad(S, maxLength, fillString, placement) {
	if (typeof S !== 'string') {
		throw new $TypeError('Assertion failed: `S` must be a String');
	}
	if (!isInteger(maxLength) || maxLength < 0) {
		throw new $TypeError('Assertion failed: `maxLength` must be a non-negative integer');
	}
	if (typeof fillString !== 'string') {
		throw new $TypeError('Assertion failed: `fillString` must be a String');
	}
	if (placement !== 'start' && placement !== 'end' && placement !== 'START' && placement !== 'END') {
		throw new $TypeError('Assertion failed: `placement` must be ~START~ or ~END~');
	}

	var stringLength = S.length; // step 1

	if (maxLength <= stringLength) { return S; } // step 2

	if (fillString === '') { return S; } // step 3

	var fillLen = maxLength - stringLength; // step 4

	// 5. Let _truncatedStringFiller_ be the String value consisting of repeated concatenations of _fillString_ truncated to length _fillLen_.
	var truncatedStringFiller = '';
	while (truncatedStringFiller.length < fillLen) {
		truncatedStringFiller += fillString;
	}
	truncatedStringFiller = $strSlice(truncatedStringFiller, 0, fillLen);

	if (placement === 'start' || placement === 'START') { return truncatedStringFiller + S; } // step 6

	return S + truncatedStringFiller; // step 7
};
'use strict';

var GetIntrinsic = require('get-intrinsic');

var $BigInt = GetIntrinsic('%BigInt%', true);
var $TypeError = require('es-errors/type');
var $SyntaxError = require('es-errors/syntax');

// https://262.ecma-international.org/14.0/#sec-stringtobigint

module.exports = function StringToBigInt(argument) {
	if (typeof argument !== 'string') {
		throw new $TypeError('`argument` must be a string');
	}
	if (!$BigInt) {
		throw new $SyntaxError('BigInts are not supported in this environment');
	}
	try {
		return $BigInt(argument);
	} catch (e) {
		return void undefined;
	}
};
'use strict';

var $TypeError = require('es-errors/type');

var CodePointAt = require('./CodePointAt');

// https://262.ecma-international.org/12.0/#sec-stringtocodepoints

module.exports = function StringToCodePoints(string) {
	if (typeof string !== 'string') {
		throw new $TypeError('Assertion failed: `string` must be a String');
	}
	var codePoints = [];
	var size = string.length;
	var position = 0;
	while (position < size) {
		var cp = CodePointAt(string, position);
		codePoints[codePoints.length] = cp['[[CodePoint]]'];
		position += cp['[[CodeUnitCount]]'];
	}
	return codePoints;
};
'use strict';

var GetIntrinsic = require('get-intrinsic');

var $RegExp = GetIntrinsic('%RegExp%');
var $TypeError = require('es-errors/type');
var $parseInteger = GetIntrinsic('%parseInt%');

var callBound = require('call-bound');
var regexTester = require('safe-regex-test');

var $strSlice = callBound('String.prototype.slice');
var isBinary = regexTester(/^0b[01]+$/i);
var isOctal = regexTester(/^0o[0-7]+$/i);
var isInvalidHexLiteral = regexTester(/^[-+]0x[0-9a-f]+$/i);
var nonWS = ['\u0085', '\u200b', '\ufffe'].join('');
var nonWSregex = new $RegExp('[' + nonWS + ']', 'g');
var hasNonWS = regexTester(nonWSregex);

var $trim = require('string.prototype.trim');

// https://262.ecma-international.org/13.0/#sec-stringtonumber

module.exports = function StringToNumber(argument) {
	if (typeof argument !== 'string') {
		throw new $TypeError('Assertion failed: `argument` is not a String');
	}
	if (isBinary(argument)) {
		return +$parseInteger($strSlice(argument, 2), 2);
	}
	if (isOctal(argument)) {
		return +$parseInteger($strSlice(argument, 2), 8);
	}
	if (hasNonWS(argument) || isInvalidHexLiteral(argument)) {
		return NaN;
	}
	var trimmed = $trim(argument);
	if (trimmed !== argument) {
		return StringToNumber(trimmed);
	}
	return +argument;
};
'use strict';

var $TypeError = require('es-errors/type');
var isInteger = require('math-intrinsics/isInteger');
var callBound = require('call-bound');

var $slice = callBound('String.prototype.slice');

// https://262.ecma-international.org/12.0/#substring
module.exports = function substring(S, inclusiveStart, exclusiveEnd) {
	if (typeof S !== 'string' || !isInteger(inclusiveStart) || (arguments.length > 2 && !isInteger(exclusiveEnd))) {
		throw new $TypeError('`S` must be a String, and `inclusiveStart` and `exclusiveEnd` must be integers');
	}
	return $slice(S, inclusiveStart, arguments.length > 2 ? exclusiveEnd : S.length);
};
'use strict';

var $TypeError = require('es-errors/type');

var callBound = require('call-bound');

var $SymbolToString = callBound('Symbol.prototype.toString', true);

// https://262.ecma-international.org/6.0/#sec-symboldescriptivestring

module.exports = function SymbolDescriptiveString(sym) {
	if (typeof sym !== 'symbol') {
		throw new $TypeError('Assertion failed: `sym` must be a Symbol');
	}
	return $SymbolToString(sym);
};
'use strict';

var callBind = require('call-bind');

var I402 = typeof Intl === 'undefined' ? null : Intl;
var DateTimeFormat = I402 && I402.DateTimeFormat;
var resolvedOptions = DateTimeFormat && callBind(DateTimeFormat.prototype.resolvedOptions);

// https://262.ecma-international.org/15.0/#sec-systemtimezoneidentifier

module.exports = function SystemTimeZoneIdentifier() {
	if (DateTimeFormat && resolvedOptions) {
		return resolvedOptions(new DateTimeFormat()).timeZone; // steps 2 - 3

	}

	return 'UTC'; // step 1
};
'use strict';

var $gOPD = require('gopd');
var $TypeError = require('es-errors/type');

var every = require('../helpers/every');
var OwnPropertyKeys = require('own-keys');
var isObject = require('es-object-atoms/isObject');

var IsDataDescriptor = require('./IsDataDescriptor');
var IsExtensible = require('./IsExtensible');
var ToPropertyDescriptor = require('./ToPropertyDescriptor');

// https://262.ecma-international.org/6.0/#sec-testintegritylevel

module.exports = function TestIntegrityLevel(O, level) {
	if (!isObject(O)) {
		throw new $TypeError('Assertion failed: Type(O) is not Object');
	}
	if (level !== 'sealed' && level !== 'frozen') {
		throw new $TypeError('Assertion failed: `level` must be `"sealed"` or `"frozen"`');
	}
	var status = IsExtensible(O);
	if (status || !$gOPD) {
		return false;
	}
	var theKeys = OwnPropertyKeys(O);
	return theKeys.length === 0 || every(theKeys, function (k) {
		var currentDesc = $gOPD(O, k);
		if (typeof currentDesc !== 'undefined') {
			if (currentDesc.configurable) {
				return false;
			}
			if (level === 'frozen' && IsDataDescriptor(ToPropertyDescriptor(currentDesc)) && currentDesc.writable) {
				return false;
			}
		}
		return true;
	});
};
'use strict';

var callBound = require('call-bound');

var $SyntaxError = require('es-errors/syntax');
var $bigIntValueOf = callBound('BigInt.prototype.valueOf', true);

// https://262.ecma-international.org/15.0/#sec-thisbigintvalue

module.exports = function ThisBigIntValue(value) {
	if (typeof value === 'bigint') {
		return value;
	}

	if (!$bigIntValueOf) {
		throw new $SyntaxError('BigInt is not supported');
	}

	return $bigIntValueOf(value);
};
'use strict';

var $BooleanValueOf = require('call-bound')('Boolean.prototype.valueOf');

// https://262.ecma-international.org/15.0/#sec-properties-of-the-boolean-prototype-object

module.exports = function ThisBooleanValue(value) {
	if (typeof value === 'boolean') {
		return value;
	}

	return $BooleanValueOf(value);
};
'use strict';

var callBound = require('call-bound');

var $NumberValueOf = callBound('Number.prototype.valueOf');

// https://262.ecma-international.org/15.0/#sec-thisnumbervalue

module.exports = function ThisNumberValue(value) {
	if (typeof value === 'number') {
		return value;
	}

	return $NumberValueOf(value);
};
'use strict';

var $StringValueOf = require('call-bound')('String.prototype.valueOf');

// https://262.ecma-international.org/15.0/#sec-properties-of-the-string-prototype-object

module.exports = function ThisStringValue(value) {
	if (typeof value === 'string') {
		return value;
	}

	return $StringValueOf(value);
};
'use strict';

var $SyntaxError = require('es-errors/syntax');
var callBound = require('call-bound');

var $SymbolValueOf = callBound('Symbol.prototype.valueOf', true);

// https://262.ecma-international.org/15.0/#sec-thissymbolvalue

module.exports = function ThisSymbolValue(value) {
	if (typeof value === 'symbol') {
		return value;
	}

	if (!$SymbolValueOf) {
		throw new $SyntaxError('Symbols are not supported; thisSymbolValue requires that `value` be a Symbol or a Symbol object');
	}

	return $SymbolValueOf(value);
};
'use strict';

var CompletionRecord = require('./CompletionRecord');

// https://262.ecma-international.org/9.0/#sec-throwcompletion

module.exports = function ThrowCompletion(argument) {
	return new CompletionRecord('throw', argument);
};
'use strict';

var GetIntrinsic = require('get-intrinsic');

var $Date = GetIntrinsic('%Date%');

var $isFinite = require('math-intrinsics/isFinite');
var abs = require('math-intrinsics/abs');

var ToNumber = require('./ToNumber');

// https://262.ecma-international.org/5.1/#sec-15.9.1.14

module.exports = function TimeClip(time) {
	if (!$isFinite(time) || abs(time) > 8.64e15) {
		return NaN;
	}
	return +new $Date(ToNumber(time));
};

'use strict';

var msPerDay = require('../helpers/timeConstants').msPerDay;

var DayFromYear = require('./DayFromYear');

// https://262.ecma-international.org/5.1/#sec-15.9.1.3

module.exports = function TimeFromYear(y) {
	return msPerDay * DayFromYear(y);
};
'use strict';

var $TypeError = require('es-errors/type');

var $isNaN = require('math-intrinsics/isNaN');

var HourFromTime = require('./HourFromTime');
var MinFromTime = require('./MinFromTime');
var SecFromTime = require('./SecFromTime');
var ToZeroPaddedDecimalString = require('./ToZeroPaddedDecimalString');

// https://262.ecma-international.org/13.0/#sec-timestring

module.exports = function TimeString(tv) {
	if (typeof tv !== 'number' || $isNaN(tv)) {
		throw new $TypeError('Assertion failed: `tv` must be a non-NaN Number');
	}

	var hour = ToZeroPaddedDecimalString(HourFromTime(tv), 2); // step 1

	var minute = ToZeroPaddedDecimalString(MinFromTime(tv), 2); // step 2

	var second = ToZeroPaddedDecimalString(SecFromTime(tv), 2); // step 3

	return hour + ':' + minute + ':' + second + ' GMT'; // step 4
};
'use strict';

var modulo = require('./modulo');

var msPerDay = require('../helpers/timeConstants').msPerDay;

// https://262.ecma-international.org/5.1/#sec-15.9.1.2

module.exports = function TimeWithinDay(t) {
	return modulo(t, msPerDay);
};

'use strict';

var GetIntrinsic = require('get-intrinsic');

var $Date = GetIntrinsic('%Date%');
var $TypeError = require('es-errors/type');
var callBound = require('call-bound');
var isInteger = require('math-intrinsics/isInteger');

var $indexOf = callBound('String.prototype.indexOf');
var $slice = callBound('String.prototype.slice');
var $toTimeString = callBound('Date.prototype.toTimeString');

// https://262.ecma-international.org/14.0/#sec-timezoneestring

module.exports = function TimeZoneString(tv) {
	if (!isInteger(tv)) {
		throw new $TypeError('Assertion failed: `tv` must be an integral Number');
	}

	// 1. Let localTimeZone be DefaultTimeZone().
	// 2. If IsTimeZoneOffsetString(localTimeZone) is true, then
	//   a. Let offsetNs be ParseTimeZoneOffsetString(localTimeZone).
	// 3. Else,
	//   a. Let offsetNs be GetNamedTimeZoneOffsetNanoseconds(localTimeZone, ℤ(ℝ(tv) × 106)).
	// 4. Let offset be 𝔽(truncate(offsetNs / 106)).
	// 5. If offset is +0𝔽 or offset > +0𝔽, then
	//   a. Let offsetSign be "+".
	//   b. Let absOffset be offset.
	// 6. Else,
	//   a. Let offsetSign be "-".
	//   b. Let absOffset be -offset.
	// 7. Let offsetMin be ToZeroPaddedDecimalString(ℝ(MinFromTime(absOffset)), 2).
	// 8. Let offsetHour be ToZeroPaddedDecimalString(ℝ(HourFromTime(absOffset)), 2).
	// 9. Let tzName be an implementation-defined string that is either the empty String or the string-concatenation of the code unit 0x0020 (SPACE), the code unit 0x0028 (LEFT PARENTHESIS), an implementation-defined timezone name, and the code unit 0x0029 (RIGHT PARENTHESIS).
	// 10. Return the string-concatenation of offsetSign, offsetHour, offsetMin, and tzName.

	// hack until DefaultTimeZone, IsTimeZoneOffsetString, ParseTimeZoneOffsetString, GetNamedTimeZoneOffsetNanoseconds, and "implementation-defined string" are available
	var ts = $toTimeString(new $Date(tv));
	return $slice(ts, $indexOf(ts, '(') + 1, $indexOf(ts, ')'));
};
'use strict';

var GetIntrinsic = require('get-intrinsic');

var $BigInt = GetIntrinsic('%BigInt%', true);
var $pow = require('math-intrinsics/pow');

var ToBigInt = require('./ToBigInt');
var BigIntRemainder = require('./BigInt/remainder');

var modBigInt = require('../helpers/modBigInt');

// BigInt(2**63), but node v10.4-v10.8 have a bug where you can't `BigInt(x)` anything larger than MAX_SAFE_INTEGER
var twoSixtyThree = $BigInt && (BigInt($pow(2, 32)) * BigInt($pow(2, 31)));

// BigInt(2**64), but node v10.4-v10.8 have a bug where you can't `BigInt(x)` anything larger than MAX_SAFE_INTEGER
var twoSixtyFour = $BigInt && (BigInt($pow(2, 32)) * BigInt($pow(2, 32)));

// https://262.ecma-international.org/11.0/#sec-tobigint64

module.exports = function ToBigInt64(argument) {
	var n = ToBigInt(argument);
	var int64bit = modBigInt(BigIntRemainder, n, twoSixtyFour);
	return int64bit >= twoSixtyThree ? int64bit - twoSixtyFour : int64bit;
};
'use strict';

var GetIntrinsic = require('get-intrinsic');

var $BigInt = GetIntrinsic('%BigInt%', true);
var $Number = GetIntrinsic('%Number%');
var $TypeError = require('es-errors/type');
var $SyntaxError = require('es-errors/syntax');

var StringToBigInt = require('./StringToBigInt');
var ToPrimitive = require('./ToPrimitive');

// https://262.ecma-international.org/13.0/#sec-tobigint

module.exports = function ToBigInt(argument) {
	if (!$BigInt) {
		throw new $SyntaxError('BigInts are not supported in this environment');
	}

	var prim = ToPrimitive(argument, $Number);

	if (prim == null) {
		throw new $TypeError('Cannot convert null or undefined to a BigInt');
	}

	if (typeof prim === 'boolean') {
		return prim ? $BigInt(1) : $BigInt(0);
	}

	if (typeof prim === 'number') {
		throw new $TypeError('Cannot convert a Number value to a BigInt');
	}

	if (typeof prim === 'string') {
		var n = StringToBigInt(prim);
		if (typeof n === 'undefined') {
			throw new $TypeError('Failed to parse String to BigInt');
		}
		return n;
	}

	if (typeof prim === 'symbol') {
		throw new $TypeError('Cannot convert a Symbol value to a BigInt');
	}

	if (typeof prim !== 'bigint') {
		throw new $SyntaxError('Assertion failed: unknown primitive type');
	}

	return prim;
};
'use strict';

var GetIntrinsic = require('get-intrinsic');

var $BigInt = GetIntrinsic('%BigInt%', true);

var $pow = require('math-intrinsics/pow');

var ToBigInt = require('./ToBigInt');
var BigIntRemainder = require('./BigInt/remainder');

var modBigInt = require('../helpers/modBigInt');

// BigInt(2**64), but node v10.4-v10.8 have a bug where you can't `BigInt(x)` anything larger than MAX_SAFE_INTEGER
var twoSixtyFour = $BigInt && (BigInt($pow(2, 32)) * BigInt($pow(2, 32)));

// https://262.ecma-international.org/11.0/#sec-tobiguint64

module.exports = function ToBigUint64(argument) {
	var n = ToBigInt(argument);
	var int64bit = modBigInt(BigIntRemainder, n, twoSixtyFour);
	return int64bit;
};
'use strict';

// http://262.ecma-international.org/5.1/#sec-9.2

module.exports = function ToBoolean(value) { return !!value; };
'use strict';

var GetIntrinsic = require('get-intrinsic');

var $TypeError = require('es-errors/type');
var $Date = GetIntrinsic('%Date%');
var $String = GetIntrinsic('%String%');

var $isNaN = require('math-intrinsics/isNaN');

// https://262.ecma-international.org/6.0/#sec-todatestring

module.exports = function ToDateString(tv) {
	if (typeof tv !== 'number') {
		throw new $TypeError('Assertion failed: `tv` must be a Number');
	}
	if ($isNaN(tv)) {
		return 'Invalid Date';
	}
	return $String(new $Date(tv));
};
'use strict';

var $RangeError = require('es-errors/range');

var ToIntegerOrInfinity = require('./ToIntegerOrInfinity');

var MAX_SAFE_INTEGER = require('math-intrinsics/constants/maxSafeInteger');

// https://262.ecma-international.org/15.0/#sec-toindex

module.exports = function ToIndex(value) {
	if (typeof value === 'undefined') {
		return 0;
	}
	var integer = ToIntegerOrInfinity(value);
	if (integer < 0 || integer >= MAX_SAFE_INTEGER) {
		throw new $RangeError('index must be >= 0 and < 2 ** 53 - 1');
	}
	return integer;
};
'use strict';

var modulo = require('./modulo');
var ToNumber = require('./ToNumber');
var truncate = require('./truncate');

var isFinite = require('math-intrinsics/isFinite');

// https://262.ecma-international.org/14.0/#sec-toint16

var two16 = 0x10000; // Math.pow(2, 16);

module.exports = function ToInt16(argument) {
	var number = ToNumber(argument);
	if (!isFinite(number) || number === 0) {
		return 0;
	}
	var int = truncate(number);
	var int16bit = modulo(int, two16);
	return int16bit >= 0x8000 ? int16bit - two16 : int16bit;
};
'use strict';

var modulo = require('./modulo');
var ToNumber = require('./ToNumber');
var truncate = require('./truncate');

var isFinite = require('math-intrinsics/isFinite');

// https://262.ecma-international.org/14.0/#sec-toint32

var two31 = 0x80000000; // Math.pow(2, 31);
var two32 = 0x100000000; // Math.pow(2, 32);

module.exports = function ToInt32(argument) {
	var number = ToNumber(argument);
	if (!isFinite(number) || number === 0) {
		return 0;
	}
	var int = truncate(number);
	var int32bit = modulo(int, two32);
	var result = int32bit >= two31 ? int32bit - two32 : int32bit;
	return result === 0 ? 0 : result; // in the spec, these are math values, so we filter out -0 here
};
'use strict';

var modulo = require('./modulo');
var ToNumber = require('./ToNumber');
var truncate = require('./truncate');

var isFinite = require('math-intrinsics/isFinite');

// https://262.ecma-international.org/14.0/#sec-toint8

module.exports = function ToInt8(argument) {
	var number = ToNumber(argument);
	if (!isFinite(number) || number === 0) {
		return 0;
	}
	var int = truncate(number);
	var int8bit = modulo(int, 0x100);
	return int8bit >= 0x80 ? int8bit - 0x100 : int8bit;
};
'use strict';

var ToNumber = require('./ToNumber');
var truncate = require('./truncate');

var $isNaN = require('math-intrinsics/isNaN');
var $isFinite = require('math-intrinsics/isFinite');

// https://262.ecma-international.org/14.0/#sec-tointegerorinfinity

module.exports = function ToIntegerOrInfinity(value) {
	var number = ToNumber(value);
	if ($isNaN(number) || number === 0) { return 0; }
	if (!$isFinite(number)) { return number; }
	return truncate(number);
};
'use strict';

var MAX_SAFE_INTEGER = require('math-intrinsics/constants/maxSafeInteger');

var ToIntegerOrInfinity = require('./ToIntegerOrInfinity');

// https://262.ecma-international.org/12.0/#sec-tolength

module.exports = function ToLength(argument) {
	var len = ToIntegerOrInfinity(argument);
	if (len <= 0) { return 0; } // includes converting -0 to +0
	if (len > MAX_SAFE_INTEGER) { return MAX_SAFE_INTEGER; }
	return len;
};
'use strict';

var GetIntrinsic = require('get-intrinsic');

var $TypeError = require('es-errors/type');
var $Number = GetIntrinsic('%Number%');
var isPrimitive = require('../helpers/isPrimitive');

var ToPrimitive = require('./ToPrimitive');
var StringToNumber = require('./StringToNumber');

// https://262.ecma-international.org/13.0/#sec-tonumber

module.exports = function ToNumber(argument) {
	var value = isPrimitive(argument) ? argument : ToPrimitive(argument, $Number);
	if (typeof value === 'symbol') {
		throw new $TypeError('Cannot convert a Symbol value to a number');
	}
	if (typeof value === 'bigint') {
		throw new $TypeError('Conversion from \'BigInt\' to \'number\' is not allowed.');
	}
	if (typeof value === 'string') {
		return StringToNumber(value);
	}
	return +value;
};
'use strict';

var GetIntrinsic = require('get-intrinsic');

var $Number = GetIntrinsic('%Number%');

var isPrimitive = require('../helpers/isPrimitive');

var ToPrimitive = require('./ToPrimitive');
var ToNumber = require('./ToNumber');

// https://262.ecma-international.org/11.0/#sec-tonumeric

module.exports = function ToNumeric(argument) {
	var primValue = isPrimitive(argument) ? argument : ToPrimitive(argument, $Number);
	if (typeof primValue === 'bigint') {
		return primValue;
	}
	return ToNumber(primValue);
};
'use strict';

// https://262.ecma-international.org/6.0/#sec-toobject

module.exports = require('es-object-atoms/ToObject');
'use strict';

var toPrimitive = require('es-to-primitive/es2015');

// https://262.ecma-international.org/6.0/#sec-toprimitive

module.exports = function ToPrimitive(input) {
	if (arguments.length > 1) {
		return toPrimitive(input, arguments[1]);
	}
	return toPrimitive(input);
};
'use strict';

var hasOwn = require('hasown');

var $TypeError = require('es-errors/type');
var isObject = require('es-object-atoms/isObject');

var IsCallable = require('./IsCallable');
var ToBoolean = require('./ToBoolean');

// https://262.ecma-international.org/5.1/#sec-8.10.5

module.exports = function ToPropertyDescriptor(Obj) {
	if (!isObject(Obj)) {
		throw new $TypeError('ToPropertyDescriptor requires an object');
	}

	var desc = {};
	if (hasOwn(Obj, 'enumerable')) {
		desc['[[Enumerable]]'] = ToBoolean(Obj.enumerable);
	}
	if (hasOwn(Obj, 'configurable')) {
		desc['[[Configurable]]'] = ToBoolean(Obj.configurable);
	}
	if (hasOwn(Obj, 'value')) {
		desc['[[Value]]'] = Obj.value;
	}
	if (hasOwn(Obj, 'writable')) {
		desc['[[Writable]]'] = ToBoolean(Obj.writable);
	}
	if (hasOwn(Obj, 'get')) {
		var getter = Obj.get;
		if (typeof getter !== 'undefined' && !IsCallable(getter)) {
			throw new $TypeError('getter must be a function');
		}
		desc['[[Get]]'] = getter;
	}
	if (hasOwn(Obj, 'set')) {
		var setter = Obj.set;
		if (typeof setter !== 'undefined' && !IsCallable(setter)) {
			throw new $TypeError('setter must be a function');
		}
		desc['[[Set]]'] = setter;
	}

	if ((hasOwn(desc, '[[Get]]') || hasOwn(desc, '[[Set]]')) && (hasOwn(desc, '[[Value]]') || hasOwn(desc, '[[Writable]]'))) {
		throw new $TypeError('Invalid property descriptor. Cannot both specify accessors and a value or writable attribute');
	}
	return desc;
};
'use strict';

var GetIntrinsic = require('get-intrinsic');

var $String = GetIntrinsic('%String%');

var ToPrimitive = require('./ToPrimitive');
var ToString = require('./ToString');

// https://262.ecma-international.org/6.0/#sec-topropertykey

module.exports = function ToPropertyKey(argument) {
	var key = ToPrimitive(argument, $String);
	return typeof key === 'symbol' ? key : ToString(key);
};
'use strict';

var GetIntrinsic = require('get-intrinsic');

var $String = GetIntrinsic('%String%');
var $TypeError = require('es-errors/type');

// https://262.ecma-international.org/6.0/#sec-tostring

module.exports = function ToString(argument) {
	if (typeof argument === 'symbol') {
		throw new $TypeError('Cannot convert a Symbol value to a string');
	}
	return $String(argument);
};
'use strict';

var modulo = require('./modulo');
var ToNumber = require('./ToNumber');
var truncate = require('./truncate');

var isFinite = require('math-intrinsics/isFinite');

// https://262.ecma-international.org/14.0/#sec-touint16

var two16 = 0x10000; // Math.pow(2, 16)

module.exports = function ToUint16(argument) {
	var number = ToNumber(argument);
	if (!isFinite(number) || number === 0) {
		return 0;
	}
	var int = truncate(number);
	var int16bit = modulo(int, two16);
	return int16bit === 0 ? 0 : int16bit; // in the spec, these are math values, so we filter out -0 here
};
'use strict';

var modulo = require('./modulo');
var ToNumber = require('./ToNumber');
var truncate = require('./truncate');

var isFinite = require('math-intrinsics/isFinite');

// https://262.ecma-international.org/14.0/#sec-touint32

var two32 = 0x100000000; // Math.pow(2, 32);

module.exports = function ToUint32(argument) {
	var number = ToNumber(argument);
	if (!isFinite(number) || number === 0) {
		return 0;
	}
	var int = truncate(number);
	var int32bit = modulo(int, two32);
	return int32bit === 0 ? 0 : int32bit; // in the spec, these are math values, so we filter out -0 here
};
'use strict';

var clamp = require('./clamp');

var ToNumber = require('./ToNumber');
var floor = require('./floor');

var $isNaN = require('math-intrinsics/isNaN');

// https://262.ecma-international.org/15.0/#sec-touint8clamp

module.exports = function ToUint8Clamp(argument) {
	var number = ToNumber(argument); // step 1

	if ($isNaN(number)) { return 0; } // step 2

	var clamped = clamp(number, 0, 255); // step 4

	var f = floor(clamped); // step 5

	if (clamped < (f + 0.5)) { return f; } // step 6

	if (clamped > (f + 0.5)) { return f + 1; } // step 7

	return f % 2 === 0 ? f : f + 1; // step 8
};
'use strict';

var isFinite = require('math-intrinsics/isFinite');

var modulo = require('./modulo');
var ToNumber = require('./ToNumber');
var truncate = require('./truncate');

// https://262.ecma-international.org/14.0/#sec-touint8

module.exports = function ToUint8(argument) {
	var number = ToNumber(argument);
	if (!isFinite(number) || number === 0) {
		return 0;
	}
	var int = truncate(number);
	var int8bit = modulo(int, 0x100);
	return int8bit;
};
'use strict';

var GetIntrinsic = require('get-intrinsic');

var $String = GetIntrinsic('%String%');
var $RangeError = require('es-errors/range');
var isInteger = require('math-intrinsics/isInteger');

var StringPad = require('./StringPad');

// https://262.ecma-international.org/13.0/#sec-tozeropaddeddecimalstring

module.exports = function ToZeroPaddedDecimalString(n, minLength) {
	if (!isInteger(n) || n < 0) {
		throw new $RangeError('Assertion failed: `q` must be a non-negative integer');
	}
	var S = $String(n);
	return StringPad(S, minLength, '0', 'start');
};
'use strict';

var trimStart = require('string.prototype.trimstart');
var trimEnd = require('string.prototype.trimend');

var $TypeError = require('es-errors/type');

var RequireObjectCoercible = require('./RequireObjectCoercible');
var ToString = require('./ToString');

// https://262.ecma-international.org/10.0/#sec-trimstring

module.exports = function TrimString(string, where) {
	var str = RequireObjectCoercible(string);
	var S = ToString(str);
	var T;
	if (where === 'start') {
		T = trimStart(S);
	} else if (where === 'end') {
		T = trimEnd(S);
	} else if (where === 'start+end') {
		T = trimStart(trimEnd(S));
	} else {
		throw new $TypeError('Assertion failed: invalid `where` value; must be "start", "end", or "start+end"');
	}
	return T;
};
'use strict';

var floor = require('./floor');

var $TypeError = require('es-errors/type');

// https://262.ecma-international.org/14.0/#eqn-truncate

module.exports = function truncate(x) {
	if (typeof x !== 'number' && typeof x !== 'bigint') {
		throw new $TypeError('argument must be a Number or a BigInt');
	}
	var result = x < 0 ? -floor(-x) : floor(x);
	return result === 0 ? 0 : result; // in the spec, these are math values, so we filter out -0 here
};
'use strict';

var $TypeError = require('es-errors/type');

var IsFixedLengthArrayBuffer = require('./IsFixedLengthArrayBuffer');
var IsTypedArrayOutOfBounds = require('./IsTypedArrayOutOfBounds');
var TypedArrayElementSize = require('./TypedArrayElementSize');
var TypedArrayLength = require('./TypedArrayLength');

var isTypedArrayWithBufferWitnessRecord = require('../helpers/records/typed-array-with-buffer-witness-record');

var typedArrayByffer = require('typed-array-buffer');
var typedArrayByteLength = require('typed-array-byte-length');

// https://262.ecma-international.org/15.0/#sec-typedarraybytelength

module.exports = function TypedArrayByteLength(taRecord) {
	if (!isTypedArrayWithBufferWitnessRecord(taRecord)) {
		throw new $TypeError('Assertion failed: `taRecord` must be a TypedArray With Buffer Witness Record');
	}

	if (IsTypedArrayOutOfBounds(taRecord)) {
		return 0; // step 1
	}
	var length = TypedArrayLength(taRecord); // step 2

	if (length === 0) {
		return 0; // step 3
	}

	var O = taRecord['[[Object]]']; // step 4

	var isFixed = IsFixedLengthArrayBuffer(typedArrayByffer(O));

	var byteLength = isFixed ? typedArrayByteLength(O) : 'AUTO';
	if (byteLength !== 'AUTO') {
		return byteLength; // step 5
	}

	var elementSize = TypedArrayElementSize(O); // step 6

	return length * elementSize; // step 7
};
'use strict';

var $SyntaxError = require('es-errors/syntax');
var $TypeError = require('es-errors/type');

var IsArray = require('./IsArray');
var IsConstructor = require('./IsConstructor');
var IsTypedArrayOutOfBounds = require('./IsTypedArrayOutOfBounds');
var TypedArrayLength = require('./TypedArrayLength');
var ValidateTypedArray = require('./ValidateTypedArray');

var availableTypedArrays = require('available-typed-arrays')();

// https://262.ecma-international.org/15.0/#typedarraycreatefromconstructor

module.exports = function TypedArrayCreateFromConstructor(constructor, argumentList) {
	if (!IsConstructor(constructor)) {
		throw new $TypeError('Assertion failed: `constructor` must be a constructor');
	}
	if (!IsArray(argumentList)) {
		throw new $TypeError('Assertion failed: `argumentList` must be a List');
	}
	if (availableTypedArrays.length === 0) {
		throw new $SyntaxError('Assertion failed: Typed Arrays are not supported in this environment');
	}

	// var newTypedArray = Construct(constructor, argumentList); // step 1
	var newTypedArray;
	if (argumentList.length === 0) {
		newTypedArray = new constructor();
	} else if (argumentList.length === 1) {
		newTypedArray = new constructor(argumentList[0]);
	} else if (argumentList.length === 2) {
		newTypedArray = new constructor(argumentList[0], argumentList[1]);
	} else {
		newTypedArray = new constructor(argumentList[0], argumentList[1], argumentList[2]);
	}

	var taRecord = ValidateTypedArray(newTypedArray, 'SEQ-CST'); // step 2

	if (argumentList.length === 1 && typeof argumentList[0] === 'number') { // step 3
		if (IsTypedArrayOutOfBounds(taRecord)) {
			throw new $TypeError('new Typed Array is out of bounds'); // step 3.a
		}
		var length = TypedArrayLength(taRecord); // step 3.b
		if (length < argumentList[0]) {
			throw new $TypeError('`argumentList[0]` must be <= `newTypedArray.length`'); // step 3.c
		}
	}

	return newTypedArray; // step 4
};
'use strict';

var $SyntaxError = require('es-errors/syntax');
var $TypeError = require('es-errors/type');

var whichTypedArray = require('which-typed-array');
var availableTypedArrays = require('available-typed-arrays')();

var IsArray = require('./IsArray');
var TypedArrayCreateFromConstructor = require('./TypedArrayCreateFromConstructor');

var getConstructor = require('../helpers/typedArrayConstructors');

// https://262.ecma-international.org/15.0/#sec-typedarray-create-same-type

module.exports = function TypedArrayCreateSameType(exemplar, argumentList) {
	if (availableTypedArrays.length === 0) {
		throw new $SyntaxError('Assertion failed: Typed Arrays are not supported in this environment');
	}

	var kind = whichTypedArray(exemplar);
	if (!kind) {
		throw new $TypeError('Assertion failed: exemplar must be a TypedArray'); // step 1
	}
	if (!IsArray(argumentList)) {
		throw new $TypeError('Assertion failed: `argumentList` must be a List'); // step 1
	}

	var constructor = getConstructor(kind); // step 2
	if (typeof constructor !== 'function') {
		throw new $SyntaxError('Assertion failed: `constructor` of `exemplar` (' + kind + ') must exist. Please report this!');
	}

	return TypedArrayCreateFromConstructor(constructor, argumentList); // steps 3 - 6
};
'use strict';

var $SyntaxError = require('es-errors/syntax');
var $TypeError = require('es-errors/type');
var isInteger = require('math-intrinsics/isInteger');
var whichTypedArray = require('which-typed-array');

// https://262.ecma-international.org/13.0/#sec-typedarrayelementsize

var tableTAO = require('./tables/typed-array-objects');

module.exports = function TypedArrayElementSize(O) {
	var type = whichTypedArray(O);
	if (!type) {
		throw new $TypeError('Assertion failed: `O` must be a TypedArray');
	}
	var size = tableTAO.size['$' + tableTAO.name['$' + type]];
	if (!isInteger(size) || size < 0) {
		throw new $SyntaxError('Assertion failed: Unknown TypedArray type `' + type + '`');
	}

	return size;
};
'use strict';

var $SyntaxError = require('es-errors/syntax');
var $TypeError = require('es-errors/type');

var whichTypedArray = require('which-typed-array');

// https://262.ecma-international.org/13.0/#sec-typedarrayelementtype

var tableTAO = require('./tables/typed-array-objects');

module.exports = function TypedArrayElementType(O) {
	var type = whichTypedArray(O);
	if (!type) {
		throw new $TypeError('Assertion failed: `O` must be a TypedArray');
	}
	var result = tableTAO.name['$' + type];
	if (typeof result !== 'string') {
		throw new $SyntaxError('Assertion failed: Unknown TypedArray type `' + type + '`');
	}

	return result;
};
'use strict';

var $TypeError = require('es-errors/type');

var GetValueFromBuffer = require('./GetValueFromBuffer');
var IsValidIntegerIndex = require('./IsValidIntegerIndex');
var TypedArrayElementSize = require('./TypedArrayElementSize');
var TypedArrayElementType = require('./TypedArrayElementType');

var isTypedArray = require('is-typed-array');
var typedArrayBuffer = require('typed-array-buffer');
var typedArrayByteOffset = require('typed-array-byte-offset');

// https://262.ecma-international.org/15.0/#sec-typedarraygetelement

module.exports = function TypedArrayGetElement(O, index) {
	if (!isTypedArray(O)) {
		throw new $TypeError('Assertion failed: `O` must be a TypedArray instance');
	}
	if (typeof index !== 'number') {
		throw new $TypeError('Assertion failed: `index` must be a Number');
	}

	if (!IsValidIntegerIndex(O, index)) {
		return undefined; // step 1
	}

	var offset = typedArrayByteOffset(O); // step 2

	var elementSize = TypedArrayElementSize(O); // step 3

	var byteIndexInBuffer = (index * elementSize) + offset; // step 4

	var elementType = TypedArrayElementType(O); // step 5

	return GetValueFromBuffer(typedArrayBuffer(O), byteIndexInBuffer, elementType, true, 'UNORDERED'); // step 6
};
'use strict';

var $TypeError = require('es-errors/type');

var floor = require('./floor');
var IsFixedLengthArrayBuffer = require('./IsFixedLengthArrayBuffer');
var IsTypedArrayOutOfBounds = require('./IsTypedArrayOutOfBounds');
var TypedArrayElementSize = require('./TypedArrayElementSize');

var isTypedArrayWithBufferWitnessRecord = require('../helpers/records/typed-array-with-buffer-witness-record');

var typedArrayBuffer = require('typed-array-buffer');
var typedArrayByteOffset = require('typed-array-byte-offset');
var typedArrayLength = require('typed-array-length');

// https://www.ecma-international.org/ecma-262/15.0/#sec-typedarraylength

module.exports = function TypedArrayLength(taRecord) {
	if (!isTypedArrayWithBufferWitnessRecord(taRecord)) {
		throw new $TypeError('Assertion failed: `taRecord` must be a TypedArray With Buffer Witness Record');
	}

	if (IsTypedArrayOutOfBounds(taRecord)) {
		throw new $TypeError('Assertion failed: `taRecord` is out of bounds'); // step 1
	}

	var O = taRecord['[[Object]]']; // step 2

	var isFixed = IsFixedLengthArrayBuffer(typedArrayBuffer(O));

	var length = isFixed ? typedArrayLength(O) : 'AUTO';
	if (length !== 'AUTO') {
		return length; // step 3
	}

	if (isFixed) {
		throw new $TypeError('Assertion failed: array buffer is not fixed length'); // step 4
	}

	var byteOffset = typedArrayByteOffset(O); // step 5

	var elementSize = TypedArrayElementSize(O); // step 6

	var byteLength = taRecord['[[CachedBufferByteLength]]']; // step 7

	if (byteLength === 'DETACHED') {
		throw new $TypeError('Assertion failed: typed array is detached'); // step 8
	}

	return floor((byteLength - byteOffset) / elementSize); // step 9
};
'use strict';

var $TypeError = require('es-errors/type');

var IsValidIntegerIndex = require('./IsValidIntegerIndex');
var SetValueInBuffer = require('./SetValueInBuffer');
var ToBigInt = require('./ToBigInt');
var ToNumber = require('./ToNumber');
var TypedArrayElementSize = require('./TypedArrayElementSize');
var TypedArrayElementType = require('./TypedArrayElementType');

var typedArrayBuffer = require('typed-array-buffer');
var typedArrayByteOffset = require('typed-array-byte-offset');
var whichTypedArray = require('which-typed-array');

// http://www.ecma-international.org/ecma-262/15.0/#sec-typedarraysetelement

module.exports = function TypedArraySetElement(O, index, value) {
	var which = whichTypedArray(O);
	if (!which) {
		throw new $TypeError('Assertion failed: `O` must be a Typed Array');
	}
	if (typeof index !== 'number') {
		throw new $TypeError('Assertion failed: `index` must be a Number');
	}

	var contentType = which === 'BigInt64Array' || which === 'BigUint64Array' ? 'BIGINT' : 'NUMBER';

	var numValue = contentType === 'BIGINT' ? ToBigInt(value) : ToNumber(value); // steps 1 - 2

	if (IsValidIntegerIndex(O, index)) { // step 3
		var offset = typedArrayByteOffset(O); // step 3.a

		var elementSize = TypedArrayElementSize(O); // step 3.b

		var byteIndexInBuffer = (index * elementSize) + offset; // step 3.c

		var elementType = TypedArrayElementType(O); // step 3.d

		SetValueInBuffer(typedArrayBuffer(O), byteIndexInBuffer, elementType, numValue, true, 'UNORDERED'); // step 3.e
	}
};
'use strict';

var $SyntaxError = require('es-errors/syntax');
var $TypeError = require('es-errors/type');

var whichTypedArray = require('which-typed-array');
var availableTypedArrays = require('available-typed-arrays')();

var IsArray = require('./IsArray');
var SpeciesConstructor = require('./SpeciesConstructor');
var TypedArrayCreateFromConstructor = require('./TypedArrayCreateFromConstructor');

var getConstructor = require('../helpers/typedArrayConstructors');

// https://262.ecma-international.org/15.0/#typedarray-species-create

module.exports = function TypedArraySpeciesCreate(exemplar, argumentList) {
	if (availableTypedArrays.length === 0) {
		throw new $SyntaxError('Assertion failed: Typed Arrays are not supported in this environment');
	}

	var kind = whichTypedArray(exemplar);
	if (!kind) {
		throw new $TypeError('Assertion failed: exemplar must be a TypedArray'); // step 1
	}
	if (!IsArray(argumentList)) {
		throw new $TypeError('Assertion failed: `argumentList` must be a List'); // step 1
	}

	var defaultConstructor = getConstructor(kind); // step 2
	if (typeof defaultConstructor !== 'function') {
		throw new $SyntaxError('Assertion failed: `constructor` of `exemplar` (' + kind + ') must exist. Please report this!');
	}
	var constructor = SpeciesConstructor(exemplar, defaultConstructor); // step 3

	return TypedArrayCreateFromConstructor(constructor, argumentList); // step 4
};
'use strict';

var $TypeError = require('es-errors/type');

var callBound = require('call-bound');

var $charCodeAt = callBound('String.prototype.charCodeAt');
var $numberToString = callBound('Number.prototype.toString');
var $toLowerCase = callBound('String.prototype.toLowerCase');

var StringPad = require('./StringPad');

// https://262.ecma-international.org/11.0/#sec-unicodeescape

module.exports = function UnicodeEscape(C) {
	if (typeof C !== 'string' || C.length !== 1) {
		throw new $TypeError('Assertion failed: `C` must be a single code unit');
	}
	var n = $charCodeAt(C, 0);
	if (n > 0xFFFF) {
		throw new $TypeError('`Assertion failed: numeric value of `C` must be <= 0xFFFF');
	}

	return '\\u' + StringPad($toLowerCase($numberToString(n, 16)), 4, '0', 'start');
};
'use strict';

var $TypeError = require('es-errors/type');
var callBound = require('call-bound');
var hasOwn = require('hasown');

var isRegExpRecord = require('../helpers/records/regexp-record');

var $charAt = callBound('String.prototype.charAt');

// https://262.ecma-international.org/16.0/#sec-updatemodifiers

module.exports = function UpdateModifiers(rer, add, remove) {
	if (!isRegExpRecord(rer)) {
		throw new $TypeError('Assertion failed: `rer` must be a RegExp Record');
	}
	if (typeof add !== 'string') {
		throw new $TypeError('Assertion failed: `add` must be a string');
	}
	if (typeof remove !== 'string') {
		throw new $TypeError('Assertion failed: `remove` must be a string');
	}

	// 1. Assert: add and remove have no elements in common.
	var adds = { __proto__: null };
	var removes = { __proto__: null };
	for (var i = 0; i < add.length; i++) {
		var toAdd = $charAt(add, i);
		adds[toAdd] = true;
	}
	for (var j = 0; j < remove.length; j++) {
		var toRemove = $charAt(remove, j);
		if (hasOwn(adds, toRemove)) {
			throw new $TypeError('Assertion failed: `add` and `remove` have elements in common');
		}
		removes[toRemove] = true;
	}

	var ignoreCase = rer['[[IgnoreCase]]']; // step 2

	var multiline = rer['[[Multiline]]']; // step 3

	var dotAll = rer['[[DotAll]]']; // step 4

	var unicode = rer['[[Unicode]]']; // step 5

	var unicodeSets = rer['[[UnicodeSets]]']; // step 6

	var capturingGroupsCount = rer['[[CapturingGroupsCount]]']; // step 7

	if (hasOwn(removes, 'i')) {
		ignoreCase = false; // step 8
	} else if (hasOwn(adds, 'i')) {
		ignoreCase = true; // step 9
	}

	if (hasOwn(removes, 'm')) {
		multiline = false; // step 10
	} else if (hasOwn(adds, 'm')) {
		multiline = true; // step 11
	}

	if (hasOwn(removes, 's')) {
		dotAll = false; // step 12
	} else if (hasOwn(adds, 's')) {
		dotAll = true; // step 13
	}

	return {
		'[[IgnoreCase]]': !!ignoreCase,
		'[[Multiline]]': !!multiline,
		'[[DotAll]]': !!dotAll,
		'[[Unicode]]': !!unicode,
		'[[UnicodeSets]]': !!unicodeSets,
		'[[CapturingGroupsCount]]': capturingGroupsCount
	}; // step 14
};
'use strict';

var GetIntrinsic = require('get-intrinsic');

var $TypeError = require('es-errors/type');
var $fromCharCode = GetIntrinsic('%String.fromCharCode%');

var floor = require('./floor');
var modulo = require('./modulo');

var isCodePoint = require('../helpers/isCodePoint');

// https://262.ecma-international.org/12.0/#sec-utf16encoding

module.exports = function UTF16EncodeCodePoint(cp) {
	if (!isCodePoint(cp)) {
		throw new $TypeError('Assertion failed: `cp` must be >= 0 and <= 0x10FFFF');
	}
	if (cp <= 65535) {
		return $fromCharCode(cp);
	}
	var cu1 = $fromCharCode(floor((cp - 65536) / 1024) + 0xD800);
	var cu2 = $fromCharCode(modulo(cp - 65536, 1024) + 0xDC00);
	return cu1 + cu2;
};
'use strict';

var GetIntrinsic = require('get-intrinsic');

var $TypeError = require('es-errors/type');
var $fromCharCode = GetIntrinsic('%String.fromCharCode%');

var isLeadingSurrogate = require('../helpers/isLeadingSurrogate');
var isTrailingSurrogate = require('../helpers/isTrailingSurrogate');

// https://262.ecma-international.org/12.0/#sec-utf16decodesurrogatepair

module.exports = function UTF16SurrogatePairToCodePoint(lead, trail) {
	if (!isLeadingSurrogate(lead) || !isTrailingSurrogate(trail)) {
		throw new $TypeError('Assertion failed: `lead` must be a leading surrogate char code, and `trail` must be a trailing surrogate char code');
	}
	// var cp = (lead - 0xD800) * 0x400 + (trail - 0xDC00) + 0x10000;
	return $fromCharCode(lead) + $fromCharCode(trail);
};
'use strict';

var $TypeError = require('es-errors/type');
var isObject = require('es-object-atoms/isObject');

var DefineOwnProperty = require('../helpers/DefineOwnProperty');
var isFullyPopulatedPropertyDescriptor = require('../helpers/isFullyPopulatedPropertyDescriptor');
var isPropertyDescriptor = require('../helpers/records/property-descriptor');

var FromPropertyDescriptor = require('./FromPropertyDescriptor');
var IsAccessorDescriptor = require('./IsAccessorDescriptor');
var IsDataDescriptor = require('./IsDataDescriptor');
var IsGenericDescriptor = require('./IsGenericDescriptor');
var isPropertyKey = require('../helpers/isPropertyKey');
var SameValue = require('./SameValue');

// https://262.ecma-international.org/13.0/#sec-validateandapplypropertydescriptor

// see https://github.com/tc39/ecma262/pull/2468 for ES2022 changes

// eslint-disable-next-line max-lines-per-function, max-statements
module.exports = function ValidateAndApplyPropertyDescriptor(O, P, extensible, Desc, current) {
	if (typeof O !== 'undefined' && !isObject(O)) {
		throw new $TypeError('Assertion failed: O must be undefined or an Object');
	}
	if (!isPropertyKey(P)) {
		throw new $TypeError('Assertion failed: P must be a Property Key');
	}
	if (typeof extensible !== 'boolean') {
		throw new $TypeError('Assertion failed: extensible must be a Boolean');
	}
	if (!isPropertyDescriptor(Desc)) {
		throw new $TypeError('Assertion failed: Desc must be a Property Descriptor');
	}
	if (typeof current !== 'undefined' && !isPropertyDescriptor(current)) {
		throw new $TypeError('Assertion failed: current must be a Property Descriptor, or undefined');
	}

	if (typeof current === 'undefined') { // step 2
		if (!extensible) {
			return false; // step 2.a
		}
		if (typeof O === 'undefined') {
			return true; // step 2.b
		}
		if (IsAccessorDescriptor(Desc)) { // step 2.c
			return DefineOwnProperty(
				IsDataDescriptor,
				SameValue,
				FromPropertyDescriptor,
				O,
				P,
				Desc
			);
		}
		// step 2.d
		return DefineOwnProperty(
			IsDataDescriptor,
			SameValue,
			FromPropertyDescriptor,
			O,
			P,
			{
				'[[Configurable]]': !!Desc['[[Configurable]]'],
				'[[Enumerable]]': !!Desc['[[Enumerable]]'],
				'[[Value]]': Desc['[[Value]]'],
				'[[Writable]]': !!Desc['[[Writable]]']
			}
		);
	}

	// 3. Assert: current is a fully populated Property Descriptor.
	if (
		!isFullyPopulatedPropertyDescriptor(
			{
				IsAccessorDescriptor: IsAccessorDescriptor,
				IsDataDescriptor: IsDataDescriptor
			},
			current
		)
	) {
		throw new $TypeError('`current`, when present, must be a fully populated and valid Property Descriptor');
	}

	// 4. If every field in Desc is absent, return true.
	// this can't really match the assertion that it's a Property Descriptor in our JS implementation

	// 5. If current.[[Configurable]] is false, then
	if (!current['[[Configurable]]']) {
		if ('[[Configurable]]' in Desc && Desc['[[Configurable]]']) {
			// step 5.a
			return false;
		}
		if ('[[Enumerable]]' in Desc && !SameValue(Desc['[[Enumerable]]'], current['[[Enumerable]]'])) {
			// step 5.b
			return false;
		}
		if (!IsGenericDescriptor(Desc) && !SameValue(IsAccessorDescriptor(Desc), IsAccessorDescriptor(current))) {
			// step 5.c
			return false;
		}
		if (IsAccessorDescriptor(current)) { // step 5.d
			if ('[[Get]]' in Desc && !SameValue(Desc['[[Get]]'], current['[[Get]]'])) {
				return false;
			}
			if ('[[Set]]' in Desc && !SameValue(Desc['[[Set]]'], current['[[Set]]'])) {
				return false;
			}
		} else if (!current['[[Writable]]']) { // step 5.e
			if ('[[Writable]]' in Desc && Desc['[[Writable]]']) {
				return false;
			}
			if ('[[Value]]' in Desc && !SameValue(Desc['[[Value]]'], current['[[Value]]'])) {
				return false;
			}
		}
	}

	// 6. If O is not undefined, then
	if (typeof O !== 'undefined') {
		var configurable;
		var enumerable;
		if (IsDataDescriptor(current) && IsAccessorDescriptor(Desc)) { // step 6.a
			configurable = ('[[Configurable]]' in Desc ? Desc : current)['[[Configurable]]'];
			enumerable = ('[[Enumerable]]' in Desc ? Desc : current)['[[Enumerable]]'];
			// Replace the property named P of object O with an accessor property having [[Configurable]] and [[Enumerable]] attributes as described by current and each other attribute set to its default value.
			return DefineOwnProperty(
				IsDataDescriptor,
				SameValue,
				FromPropertyDescriptor,
				O,
				P,
				{
					'[[Configurable]]': !!configurable,
					'[[Enumerable]]': !!enumerable,
					'[[Get]]': ('[[Get]]' in Desc ? Desc : current)['[[Get]]'],
					'[[Set]]': ('[[Set]]' in Desc ? Desc : current)['[[Set]]']
				}
			);
		} else if (IsAccessorDescriptor(current) && IsDataDescriptor(Desc)) {
			configurable = ('[[Configurable]]' in Desc ? Desc : current)['[[Configurable]]'];
			enumerable = ('[[Enumerable]]' in Desc ? Desc : current)['[[Enumerable]]'];
			// i. Replace the property named P of object O with a data property having [[Configurable]] and [[Enumerable]] attributes as described by current and each other attribute set to its default value.
			return DefineOwnProperty(
				IsDataDescriptor,
				SameValue,
				FromPropertyDescriptor,
				O,
				P,
				{
					'[[Configurable]]': !!configurable,
					'[[Enumerable]]': !!enumerable,
					'[[Value]]': ('[[Value]]' in Desc ? Desc : current)['[[Value]]'],
					'[[Writable]]': !!('[[Writable]]' in Desc ? Desc : current)['[[Writable]]']
				}
			);
		}

		// For each field of Desc that is present, set the corresponding attribute of the property named P of object O to the value of the field.
		return DefineOwnProperty(
			IsDataDescriptor,
			SameValue,
			FromPropertyDescriptor,
			O,
			P,
			Desc
		);
	}

	return true; // step 7
};
'use strict';

var $RangeError = require('es-errors/range');
var $TypeError = require('es-errors/type');

var ToIndex = require('./ToIndex');
var TypedArrayElementSize = require('./TypedArrayElementSize');
var TypedArrayLength = require('./TypedArrayLength');

var isTypedArrayWithBufferWitnessRecord = require('../helpers/records/typed-array-with-buffer-witness-record');

var typedArrayByteOffset = require('typed-array-byte-offset');

// https://262.ecma-international.org/15.0/#sec-validateatomicaccess

module.exports = function ValidateAtomicAccess(taRecord, requestIndex) {
	if (!isTypedArrayWithBufferWitnessRecord(taRecord)) {
		throw new $TypeError('Assertion failed: `taRecord` must be a TypedArray With Buffer Witness Record');
	}

	var length = TypedArrayLength(taRecord); // step 1

	var accessIndex = ToIndex(requestIndex); // step 2

	/*
	// this assertion can never be reached
	if (!(accessIndex >= 0)) {
		throw new $TypeError('Assertion failed: accessIndex >= 0'); // step 4
	}
	*/

	if (accessIndex >= length) {
		throw new $RangeError('index out of range'); // step 4
	}

	var typedArray = taRecord['[[Object]]']; // step 5

	var elementSize = TypedArrayElementSize(typedArray); // step 6

	var offset = typedArrayByteOffset(typedArray); // step 7

	return (accessIndex * elementSize) + offset; // step 8
};
'use strict';

var $TypeError = require('es-errors/type');

var ValidateAtomicAccess = require('./ValidateAtomicAccess');
var ValidateIntegerTypedArray = require('./ValidateIntegerTypedArray');

// https://262.ecma-international.org/15.0/#sec-availablenamedtimezoneidentifiers

module.exports = function ValidateAtomicAccessOnIntegerTypedArray(typedArray, requestIndex) {
	var waitable = arguments.length > 2 ? arguments[2] : false; // step 1

	if (typeof waitable !== 'boolean') {
		throw new $TypeError('waitable must be a boolean');
	}

	var taRecord = ValidateIntegerTypedArray(typedArray, waitable); // step 2
	return ValidateAtomicAccess(taRecord, requestIndex); // step 3
};
'use strict';

var $TypeError = require('es-errors/type');

var IsBigIntElementType = require('./IsBigIntElementType');
var IsUnclampedIntegerElementType = require('./IsUnclampedIntegerElementType');
var TypedArrayElementType = require('./TypedArrayElementType');
var ValidateTypedArray = require('./ValidateTypedArray');

// https://262.ecma-international.org/15.0/#sec-validateintegertypedarray

module.exports = function ValidateIntegerTypedArray(typedArray, waitable) {
	if (typeof waitable !== 'boolean') {
		throw new $TypeError('Assertion failed: `waitable` must be a Boolean');
	}

	var taRecord = ValidateTypedArray(typedArray, 'UNORDERED'); // step 1

	// 2. NOTE: Bounds checking is not a synchronizing operation when typedArray's backing buffer is a growable SharedArrayBuffer.

	var type = TypedArrayElementType(typedArray); // step 4.a
	if (waitable) { // step 3
		if (type !== 'INT32' && type !== 'BIGINT64') {
			throw new $TypeError('Assertion failed: `typedArray` must be an Int32Array or BigInt64Array when `waitable` is true'); // step 5.a
		}
	} else if (!IsUnclampedIntegerElementType(type) && !IsBigIntElementType(type)) { // step 4
		throw new $TypeError('Assertion failed: `typedArray` must be an integer TypedArray'); // step 4.b
	}

	return taRecord; // step 5
};
'use strict';

var $TypeError = require('es-errors/type');
var isObject = require('es-object-atoms/isObject');

var IsTypedArrayOutOfBounds = require('./IsTypedArrayOutOfBounds');
var MakeTypedArrayWithBufferWitnessRecord = require('./MakeTypedArrayWithBufferWitnessRecord');

var isTypedArray = require('is-typed-array');

// https://262.ecma-international.org/15.0/#sec-validatetypedarray

module.exports = function ValidateTypedArray(O, order) {
	if (order !== 'SEQ-CST' && order !== 'UNORDERED') {
		throw new $TypeError('Assertion failed: `order` must be ~SEQ-CST~ or ~UNORDERED~');
	}

	if (!isObject(O)) {
		throw new $TypeError('Assertion failed: `O` must be an Object'); // step 1
	}
	if (!isTypedArray(O)) {
		throw new $TypeError('Assertion failed: `O` must be a Typed Array'); // steps 1 - 2
	}

	var taRecord = MakeTypedArrayWithBufferWitnessRecord(O, order); // step 3

	if (IsTypedArrayOutOfBounds(taRecord)) {
		throw new $TypeError('`O` must be in-bounds and backed by a non-detached buffer'); // step 4
	}

	return taRecord; // step 5
};
'use strict';

var callBound = require('call-bound');

var $TypeError = require('es-errors/type');
var $deref = callBound('WeakRef.prototype.deref', true);

var isWeakRef = require('is-weakref');

var AddToKeptObjects = require('./AddToKeptObjects');

// https://262.ecma-international.org/12.0/#sec-weakrefderef

module.exports = function WeakRefDeref(weakRef) {
	if (!isWeakRef(weakRef)) {
		throw new $TypeError('Assertion failed: `weakRef` must be a WeakRef');
	}
	var target = $deref(weakRef);
	if (target) {
		AddToKeptObjects(target);
	}
	return target;
};
'use strict';

var Day = require('./Day');
var modulo = require('./modulo');

// https://262.ecma-international.org/5.1/#sec-15.9.1.6

module.exports = function WeekDay(t) {
	return modulo(Day(t) + 4, 7);
};
'use strict';

var $TypeError = require('es-errors/type');

var callBound = require('call-bound');
var $indexOf = callBound('String.prototype.indexOf');

var Canonicalize = require('./Canonicalize');

var caseFolding = require('../helpers/caseFolding.json');
var forEach = require('../helpers/forEach');
var isRegExpRecord = require('../helpers/records/regexp-record');
var OwnPropertyKeys = require('own-keys');

var basicWordChars = 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789_'; // step 1

// https://262.ecma-international.org/14.0/#sec-runtime-semantics-wordcharacters-abstract-operation

module.exports = function WordCharacters(rer) {
	if (!isRegExpRecord(rer)) {
		throw new $TypeError('Assertion failed: `rer` must be a RegExp Record');
	}

	var extraWordChars = '';
	forEach(OwnPropertyKeys(caseFolding.C), function (c) {
		if (
			$indexOf(basicWordChars, c) === -1 // c not in A
			&& $indexOf(basicWordChars, Canonicalize(rer, c)) > -1 // canonicalized c IS in A
		) {
			extraWordChars += caseFolding.C[c]; // step 3
		}
	});
	forEach(OwnPropertyKeys(caseFolding.S), function (c) {
		if (
			$indexOf(basicWordChars, c) === -1 // c not in A
			&& $indexOf(basicWordChars, Canonicalize(rer, c)) > -1 // canonicalized c IS in A
		) {
			extraWordChars += caseFolding.S[c]; // step 3
		}
	});

	if ((!rer['[[Unicode]]'] || !rer['[[IgnoreCase]]']) && extraWordChars.length > 0) {
		throw new $TypeError('Assertion failed: `extraWordChars` must be empty when `rer.[[IgnoreCase]]` and `rer.[[Unicode]]` are not both true'); // step 3
	}

	return basicWordChars + extraWordChars; // step 4
};
'use strict';

var GetIntrinsic = require('get-intrinsic');

var $Date = GetIntrinsic('%Date%');

var callBound = require('call-bound');

var $getUTCFullYear = callBound('Date.prototype.getUTCFullYear');

// https://262.ecma-international.org/5.1/#sec-15.9.1.3

module.exports = function YearFromTime(t) {
	// largest y such that this.TimeFromYear(y) <= t
	return $getUTCFullYear(new $Date(t));
};
'use strict';

var $abs = require('math-intrinsics/abs');

// https://262.ecma-international.org/5.1/#sec-5.2

module.exports = function abs(x) {
	return $abs(x);
};
'use strict';

var isObject = require('es-object-atoms/isObject');

var ToNumber = require('./ToNumber');
var ToPrimitive = require('./ToPrimitive');

var isSameType = require('../helpers/isSameType');

// https://262.ecma-international.org/5.1/#sec-11.9.3

module.exports = function AbstractEqualityComparison(x, y) {
	if (isSameType(x, y)) {
		return x === y; // ES6+ specified this shortcut anyways.
	}
	if (x == null && y == null) {
		return true;
	}
	if (typeof x === 'number' && typeof y === 'string') {
		return AbstractEqualityComparison(x, ToNumber(y));
	}
	if (typeof x === 'string' && typeof y === 'number') {
		return AbstractEqualityComparison(ToNumber(x), y);
	}
	if (typeof x === 'boolean') {
		return AbstractEqualityComparison(ToNumber(x), y);
	}
	if (typeof y === 'boolean') {
		return AbstractEqualityComparison(x, ToNumber(y));
	}
	if ((typeof x === 'string' || typeof x === 'number') && isObject(y)) {
		return AbstractEqualityComparison(x, ToPrimitive(y));
	}
	if (isObject(x) && (typeof y === 'string' || typeof y === 'number')) {
		return AbstractEqualityComparison(ToPrimitive(x), y);
	}
	return false;
};
'use strict';

var GetIntrinsic = require('get-intrinsic');

var $Number = GetIntrinsic('%Number%');
var $TypeError = require('es-errors/type');
var $isNaN = require('math-intrinsics/isNaN');
var $isFinite = require('math-intrinsics/isFinite');

var isPrefixOf = require('../helpers/isPrefixOf');

var ToNumber = require('./ToNumber');
var ToPrimitive = require('./ToPrimitive');

// https://262.ecma-international.org/5.1/#sec-11.8.5

// eslint-disable-next-line max-statements
module.exports = function AbstractRelationalComparison(x, y, LeftFirst) {
	if (typeof LeftFirst !== 'boolean') {
		throw new $TypeError('Assertion failed: LeftFirst argument must be a Boolean');
	}
	var px;
	var py;
	if (LeftFirst) {
		px = ToPrimitive(x, $Number);
		py = ToPrimitive(y, $Number);
	} else {
		py = ToPrimitive(y, $Number);
		px = ToPrimitive(x, $Number);
	}
	var bothStrings = typeof px === 'string' && typeof py === 'string';
	if (!bothStrings) {
		var nx = ToNumber(px);
		var ny = ToNumber(py);
		if ($isNaN(nx) || $isNaN(ny)) {
			return undefined;
		}
		if ($isFinite(nx) && $isFinite(ny) && nx === ny) {
			return false;
		}
		if (nx === Infinity) {
			return false;
		}
		if (ny === Infinity) {
			return true;
		}
		if (ny === -Infinity) {
			return false;
		}
		if (nx === -Infinity) {
			return true;
		}
		return nx < ny; // by now, these are both nonzero, finite, and not equal
	}
	if (isPrefixOf(py, px)) {
		return false;
	}
	if (isPrefixOf(px, py)) {
		return true;
	}
	return px < py; // both strings, neither a prefix of the other. shortcut for steps c-f
};
'use strict';

var $TypeError = require('es-errors/type');

var callBound = require('call-bound');

var $charCodeAt = callBound('String.prototype.charCodeAt');
var $toUpperCase = callBound('String.prototype.toUpperCase');

// https://262.ecma-international.org/5.1/#sec-15.10.2.8

module.exports = function Canonicalize(ch, IgnoreCase) {
	if (typeof ch !== 'string' || ch.length !== 1) {
		throw new $TypeError('Assertion failed: `ch` must be a character');
	}

	if (typeof IgnoreCase !== 'boolean') {
		throw new $TypeError('Assertion failed: `IgnoreCase` must be a Boolean');
	}

	if (!IgnoreCase) {
		return ch; // step 1
	}

	var u = $toUpperCase(ch); // step 2

	if (u.length !== 1) {
		return ch; // step 3
	}

	var cu = u; // step 4

	if ($charCodeAt(ch, 0) >= 128 && $charCodeAt(cu, 0) < 128) {
		return ch; // step 5
	}

	return cu;
};
'use strict';

var RequireObjectCoercible = require('es-object-atoms/RequireObjectCoercible');

// http://262.ecma-international.org/5.1/#sec-9.10

module.exports = function CheckObjectCoercible(value) {
	return RequireObjectCoercible(value, arguments.length > 1 ? arguments[1] : void undefined);
};
'use strict';

var $EvalError = require('es-errors/eval');

var DayWithinYear = require('./DayWithinYear');
var InLeapYear = require('./InLeapYear');
var MonthFromTime = require('./MonthFromTime');

// https://262.ecma-international.org/5.1/#sec-15.9.1.5

module.exports = function DateFromTime(t) {
	var m = MonthFromTime(t);
	var d = DayWithinYear(t);
	if (m === 0) {
		return d + 1;
	}
	if (m === 1) {
		return d - 30;
	}
	var leap = InLeapYear(t);
	if (m === 2) {
		return d - 58 - leap;
	}
	if (m === 3) {
		return d - 89 - leap;
	}
	if (m === 4) {
		return d - 119 - leap;
	}
	if (m === 5) {
		return d - 150 - leap;
	}
	if (m === 6) {
		return d - 180 - leap;
	}
	if (m === 7) {
		return d - 211 - leap;
	}
	if (m === 8) {
		return d - 242 - leap;
	}
	if (m === 9) {
		return d - 272 - leap;
	}
	if (m === 10) {
		return d - 303 - leap;
	}
	if (m === 11) {
		return d - 333 - leap;
	}
	throw new $EvalError('Assertion failed: MonthFromTime returned an impossible value: ' + m);
};
'use strict';

var floor = require('./floor');

// https://262.ecma-international.org/5.1/#sec-15.9.1.3

module.exports = function DayFromYear(y) {
	return (365 * (y - 1970)) + floor((y - 1969) / 4) - floor((y - 1901) / 100) + floor((y - 1601) / 400);
};

'use strict';

var floor = require('./floor');

var msPerDay = require('../helpers/timeConstants').msPerDay;

// https://262.ecma-international.org/5.1/#sec-15.9.1.2

module.exports = function Day(t) {
	return floor(t / msPerDay);
};
'use strict';

var modulo = require('./modulo');

// https://262.ecma-international.org/5.1/#sec-15.9.1.3

module.exports = function DaysInYear(y) {
	if (modulo(y, 4) !== 0) {
		return 365;
	}
	if (modulo(y, 100) !== 0) {
		return 366;
	}
	if (modulo(y, 400) !== 0) {
		return 365;
	}
	return 366;
};
'use strict';

var Day = require('./Day');
var DayFromYear = require('./DayFromYear');
var YearFromTime = require('./YearFromTime');

// https://262.ecma-international.org/5.1/#sec-15.9.1.4

module.exports = function DayWithinYear(t) {
	return Day(t) - DayFromYear(YearFromTime(t));
};
'use strict';

// var modulo = require('./modulo');
var $floor = require('math-intrinsics/floor');

// http://262.ecma-international.org/5.1/#sec-5.2

module.exports = function floor(x) {
	// return x - modulo(x, 1);
	return $floor(x);
};
'use strict';

var $TypeError = require('es-errors/type');

var IsDataDescriptor = require('./IsDataDescriptor');
var IsAccessorDescriptor = require('./IsAccessorDescriptor');

var isPropertyDescriptor = require('../helpers/records/property-descriptor');

// https://262.ecma-international.org/5.1/#sec-8.10.4

module.exports = function FromPropertyDescriptor(Desc) {
	if (typeof Desc === 'undefined') {
		return Desc;
	}

	if (!isPropertyDescriptor(Desc)) {
		throw new $TypeError('Assertion failed: `Desc` must be a Property Descriptor');
	}

	if (IsDataDescriptor(Desc)) {
		return {
			value: Desc['[[Value]]'],
			writable: !!Desc['[[Writable]]'],
			enumerable: !!Desc['[[Enumerable]]'],
			configurable: !!Desc['[[Configurable]]']
		};
	} else if (IsAccessorDescriptor(Desc)) {
		return {
			get: Desc['[[Get]]'],
			set: Desc['[[Set]]'],
			enumerable: !!Desc['[[Enumerable]]'],
			configurable: !!Desc['[[Configurable]]']
		};
	}
	throw new $TypeError('FromPropertyDescriptor must be called with a fully populated Property Descriptor');

};
'use strict';

var floor = require('./floor');
var modulo = require('./modulo');

var timeConstants = require('../helpers/timeConstants');
var msPerHour = timeConstants.msPerHour;
var HoursPerDay = timeConstants.HoursPerDay;

// https://262.ecma-international.org/5.1/#sec-15.9.1.10

module.exports = function HourFromTime(t) {
	return modulo(floor(t / msPerHour), HoursPerDay);
};
'use strict';

var $EvalError = require('es-errors/eval');

var DaysInYear = require('./DaysInYear');
var YearFromTime = require('./YearFromTime');

// https://262.ecma-international.org/5.1/#sec-15.9.1.3

module.exports = function InLeapYear(t) {
	var days = DaysInYear(YearFromTime(t));
	if (days === 365) {
		return 0;
	}
	if (days === 366) {
		return 1;
	}
	throw new $EvalError('Assertion failed: there are not 365 or 366 days in a year, got: ' + days);
};
'use strict';

var $TypeError = require('es-errors/type');

var hasOwn = require('hasown');

var isPropertyDescriptor = require('../helpers/records/property-descriptor');

// https://262.ecma-international.org/5.1/#sec-8.10.1

module.exports = function IsAccessorDescriptor(Desc) {
	if (typeof Desc === 'undefined') {
		return false;
	}

	if (!isPropertyDescriptor(Desc)) {
		throw new $TypeError('Assertion failed: `Desc` must be a Property Descriptor');
	}

	if (!hasOwn(Desc, '[[Get]]') && !hasOwn(Desc, '[[Set]]')) {
		return false;
	}

	return true;
};
'use strict';

// http://262.ecma-international.org/5.1/#sec-9.11

module.exports = require('is-callable');
'use strict';

var $TypeError = require('es-errors/type');

var hasOwn = require('hasown');

var isPropertyDescriptor = require('../helpers/records/property-descriptor');

// https://262.ecma-international.org/5.1/#sec-8.10.2

module.exports = function IsDataDescriptor(Desc) {
	if (typeof Desc === 'undefined') {
		return false;
	}

	if (!isPropertyDescriptor(Desc)) {
		throw new $TypeError('Assertion failed: `Desc` must be a Property Descriptor');
	}

	if (!hasOwn(Desc, '[[Value]]') && !hasOwn(Desc, '[[Writable]]')) {
		return false;
	}

	return true;
};
'use strict';

var $TypeError = require('es-errors/type');

var IsAccessorDescriptor = require('./IsAccessorDescriptor');
var IsDataDescriptor = require('./IsDataDescriptor');

var isPropertyDescriptor = require('./IsPropertyDescriptor');

// https://262.ecma-international.org/5.1/#sec-8.10.3

module.exports = function IsGenericDescriptor(Desc) {
	if (typeof Desc === 'undefined') {
		return false;
	}

	if (!isPropertyDescriptor(Desc)) {
		throw new $TypeError('Assertion failed: `Desc` must be a Property Descriptor');
	}

	if (!IsAccessorDescriptor(Desc) && !IsDataDescriptor(Desc)) {
		return true;
	}

	return false;
};
'use strict';

// TODO, semver-major: delete this

var isPropertyDescriptor = require('../helpers/records/property-descriptor');

// https://262.ecma-international.org/6.0/#sec-property-descriptor-specification-type

module.exports = function IsPropertyDescriptor(Desc) {
	return isPropertyDescriptor(Desc);
};
'use strict';

var $isFinite = require('math-intrinsics/isFinite');

var msPerDay = require('../helpers/timeConstants').msPerDay;

// https://262.ecma-international.org/5.1/#sec-15.9.1.13

module.exports = function MakeDate(day, time) {
	if (!$isFinite(day) || !$isFinite(time)) {
		return NaN;
	}
	return (day * msPerDay) + time;
};
'use strict';

var GetIntrinsic = require('get-intrinsic');

var $DateUTC = GetIntrinsic('%Date.UTC%');

var $isFinite = require('math-intrinsics/isFinite');

var DateFromTime = require('./DateFromTime');
var Day = require('./Day');
var floor = require('./floor');
var modulo = require('./modulo');
var MonthFromTime = require('./MonthFromTime');
var ToInteger = require('./ToInteger');
var YearFromTime = require('./YearFromTime');

// https://262.ecma-international.org/5.1/#sec-15.9.1.12

module.exports = function MakeDay(year, month, date) {
	if (!$isFinite(year) || !$isFinite(month) || !$isFinite(date)) {
		return NaN;
	}
	var y = ToInteger(year);
	var m = ToInteger(month);
	var dt = ToInteger(date);
	var ym = y + floor(m / 12);
	var mn = modulo(m, 12);
	var t = $DateUTC(ym, mn, 1);
	if (YearFromTime(t) !== ym || MonthFromTime(t) !== mn || DateFromTime(t) !== 1) {
		return NaN;
	}
	return Day(t) + dt - 1;
};
'use strict';

var $isFinite = require('math-intrinsics/isFinite');

var timeConstants = require('../helpers/timeConstants');
var msPerSecond = timeConstants.msPerSecond;
var msPerMinute = timeConstants.msPerMinute;
var msPerHour = timeConstants.msPerHour;

var ToInteger = require('./ToInteger');

// https://262.ecma-international.org/5.1/#sec-15.9.1.11

module.exports = function MakeTime(hour, min, sec, ms) {
	if (!$isFinite(hour) || !$isFinite(min) || !$isFinite(sec) || !$isFinite(ms)) {
		return NaN;
	}
	var h = ToInteger(hour);
	var m = ToInteger(min);
	var s = ToInteger(sec);
	var milli = ToInteger(ms);
	var t = (h * msPerHour) + (m * msPerMinute) + (s * msPerSecond) + milli;
	return t;
};
'use strict';

var floor = require('./floor');
var modulo = require('./modulo');

var timeConstants = require('../helpers/timeConstants');
var msPerMinute = timeConstants.msPerMinute;
var MinutesPerHour = timeConstants.MinutesPerHour;

// https://262.ecma-international.org/5.1/#sec-15.9.1.10

module.exports = function MinFromTime(t) {
	return modulo(floor(t / msPerMinute), MinutesPerHour);
};
'use strict';

var mod = require('../helpers/mod');

// https://262.ecma-international.org/5.1/#sec-5.2

module.exports = function modulo(x, y) {
	return mod(x, y);
};
'use strict';

var $RangeError = require('es-errors/range');

var DayWithinYear = require('./DayWithinYear');
var InLeapYear = require('./InLeapYear');

// https://262.ecma-international.org/5.1/#sec-15.9.1.4

module.exports = function MonthFromTime(t) {
	var day = DayWithinYear(t);
	if (0 <= day && day < 31) {
		return 0;
	}
	var leap = InLeapYear(t);
	if (31 <= day && day < (59 + leap)) {
		return 1;
	}
	if ((59 + leap) <= day && day < (90 + leap)) {
		return 2;
	}
	if ((90 + leap) <= day && day < (120 + leap)) {
		return 3;
	}
	if ((120 + leap) <= day && day < (151 + leap)) {
		return 4;
	}
	if ((151 + leap) <= day && day < (181 + leap)) {
		return 5;
	}
	if ((181 + leap) <= day && day < (212 + leap)) {
		return 6;
	}
	if ((212 + leap) <= day && day < (243 + leap)) {
		return 7;
	}
	if ((243 + leap) <= day && day < (273 + leap)) {
		return 8;
	}
	if ((273 + leap) <= day && day < (304 + leap)) {
		return 9;
	}
	if ((304 + leap) <= day && day < (334 + leap)) {
		return 10;
	}
	if ((334 + leap) <= day && day < (365 + leap)) {
		return 11;
	}

	throw new $RangeError('Assertion failed: `day` is out of range');
};
'use strict';

var modulo = require('./modulo');

var msPerSecond = require('../helpers/timeConstants').msPerSecond;

// https://262.ecma-international.org/5.1/#sec-15.9.1.10

module.exports = function msFromTime(t) {
	return modulo(t, msPerSecond);
};
'use strict';

var $isNaN = require('math-intrinsics/isNaN');

// http://262.ecma-international.org/5.1/#sec-9.12

module.exports = function SameValue(x, y) {
	if (x === y) { // 0 === -0, but they are not identical.
		if (x === 0) { return 1 / x === 1 / y; }
		return true;
	}
	return $isNaN(x) && $isNaN(y);
};
'use strict';

var floor = require('./floor');
var modulo = require('./modulo');

var timeConstants = require('../helpers/timeConstants');
var msPerSecond = timeConstants.msPerSecond;
var SecondsPerMinute = timeConstants.SecondsPerMinute;

// https://262.ecma-international.org/5.1/#sec-15.9.1.10

module.exports = function SecFromTime(t) {
	return modulo(floor(t / msPerSecond), SecondsPerMinute);
};
'use strict';

var Type = require('./Type');

// https://262.ecma-international.org/5.1/#sec-11.9.6

module.exports = function StrictEqualityComparison(x, y) {
	if (Type(x) !== Type(y)) {
		return false;
	}
	if (typeof x === 'undefined' || x === null) {
		return true;
	}
	return x === y; // shortcut for steps 4-7
};
'use strict';

var GetIntrinsic = require('get-intrinsic');

var $Date = GetIntrinsic('%Date%');

var $isFinite = require('math-intrinsics/isFinite');
var abs = require('math-intrinsics/abs');

var ToNumber = require('./ToNumber');

// https://262.ecma-international.org/5.1/#sec-15.9.1.14

module.exports = function TimeClip(time) {
	if (!$isFinite(time) || abs(time) > 8.64e15) {
		return NaN;
	}
	return +new $Date(ToNumber(time));
};

'use strict';

var msPerDay = require('../helpers/timeConstants').msPerDay;

var DayFromYear = require('./DayFromYear');

// https://262.ecma-international.org/5.1/#sec-15.9.1.3

module.exports = function TimeFromYear(y) {
	return msPerDay * DayFromYear(y);
};
'use strict';

var modulo = require('./modulo');

var msPerDay = require('../helpers/timeConstants').msPerDay;

// https://262.ecma-international.org/5.1/#sec-15.9.1.2

module.exports = function TimeWithinDay(t) {
	return modulo(t, msPerDay);
};

'use strict';

// http://262.ecma-international.org/5.1/#sec-9.2

module.exports = function ToBoolean(value) { return !!value; };
'use strict';

var ToNumber = require('./ToNumber');

// http://262.ecma-international.org/5.1/#sec-9.5

module.exports = function ToInt32(x) {
	return ToNumber(x) >> 0;
};
'use strict';

var ToNumber = require('./ToNumber');

var abs = require('math-intrinsics/abs');
var floor = require('math-intrinsics/floor');
var $isNaN = require('math-intrinsics/isNaN');
var $isFinite = require('math-intrinsics/isFinite');
var $sign = require('math-intrinsics/sign');

// http://262.ecma-international.org/5.1/#sec-9.4

module.exports = function ToInteger(value) {
	var number = ToNumber(value);
	if ($isNaN(number)) { return 0; }
	if (number === 0 || !$isFinite(number)) { return number; }
	return $sign(number) * floor(abs(number));
};
'use strict';

var ToPrimitive = require('./ToPrimitive');

var callBound = require('call-bound');

var $replace = callBound('String.prototype.replace');

var safeRegexTester = require('safe-regex-test');

var isNonDecimal = safeRegexTester(/^0[ob]|^[+-]0x/);

var $Number = Number;

// http://262.ecma-international.org/5.1/#sec-9.3

module.exports = function ToNumber(value) {
	var prim = ToPrimitive(value, $Number);
	if (typeof prim !== 'string') {
		return $Number(prim);
	}

	var trimmed = $replace(
		prim,
		// eslint-disable-next-line no-control-regex
		/^[ \t\x0b\f\xa0\ufeff\n\r\u2028\u2029\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000\u0085]+|[ \t\x0b\f\xa0\ufeff\n\r\u2028\u2029\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000\u0085]+$/g,
		''
	);
	if (isNonDecimal(trimmed)) {
		return NaN;
	}

	return +trimmed;
};
'use strict';

// http://262.ecma-international.org/5.1/#sec-9.9

module.exports = require('es-object-atoms/ToObject');
'use strict';

// http://262.ecma-international.org/5.1/#sec-9.1

module.exports = require('es-to-primitive/es5');
'use strict';

var hasOwn = require('hasown');

var $TypeError = require('es-errors/type');
var isObject = require('es-object-atoms/isObject');

var IsCallable = require('./IsCallable');
var ToBoolean = require('./ToBoolean');

// https://262.ecma-international.org/5.1/#sec-8.10.5

module.exports = function ToPropertyDescriptor(Obj) {
	if (!isObject(Obj)) {
		throw new $TypeError('ToPropertyDescriptor requires an object');
	}

	var desc = {};
	if (hasOwn(Obj, 'enumerable')) {
		desc['[[Enumerable]]'] = ToBoolean(Obj.enumerable);
	}
	if (hasOwn(Obj, 'configurable')) {
		desc['[[Configurable]]'] = ToBoolean(Obj.configurable);
	}
	if (hasOwn(Obj, 'value')) {
		desc['[[Value]]'] = Obj.value;
	}
	if (hasOwn(Obj, 'writable')) {
		desc['[[Writable]]'] = ToBoolean(Obj.writable);
	}
	if (hasOwn(Obj, 'get')) {
		var getter = Obj.get;
		if (typeof getter !== 'undefined' && !IsCallable(getter)) {
			throw new $TypeError('getter must be a function');
		}
		desc['[[Get]]'] = getter;
	}
	if (hasOwn(Obj, 'set')) {
		var setter = Obj.set;
		if (typeof setter !== 'undefined' && !IsCallable(setter)) {
			throw new $TypeError('setter must be a function');
		}
		desc['[[Set]]'] = setter;
	}

	if ((hasOwn(desc, '[[Get]]') || hasOwn(desc, '[[Set]]')) && (hasOwn(desc, '[[Value]]') || hasOwn(desc, '[[Writable]]'))) {
		throw new $TypeError('Invalid property descriptor. Cannot both specify accessors and a value or writable attribute');
	}
	return desc;
};
'use strict';

var GetIntrinsic = require('get-intrinsic');

var $String = GetIntrinsic('%String%');

// http://262.ecma-international.org/5.1/#sec-9.8

module.exports = function ToString(value) {
	return $String(value);
};

'use strict';

var modulo = require('./modulo');
var ToNumber = require('./ToNumber');

var abs = require('math-intrinsics/abs');
var floor = require('math-intrinsics/floor');
var $isNaN = require('math-intrinsics/isNaN');
var $isFinite = require('math-intrinsics/isFinite');
var $sign = require('math-intrinsics/sign');

// http://262.ecma-international.org/5.1/#sec-9.7

module.exports = function ToUint16(value) {
	var number = ToNumber(value);
	if ($isNaN(number) || number === 0 || !$isFinite(number)) { return 0; }
	var posInt = $sign(number) * floor(abs(number));
	return modulo(posInt, 0x10000);
};
'use strict';

var ToNumber = require('./ToNumber');

// http://262.ecma-international.org/5.1/#sec-9.6

module.exports = function ToUint32(x) {
	return ToNumber(x) >>> 0;
};
'use strict';

var isObject = require('es-object-atoms/isObject');

// https://262.ecma-international.org/5.1/#sec-8

module.exports = function Type(x) {
	if (x === null) {
		return 'Null';
	}
	if (typeof x === 'undefined') {
		return 'Undefined';
	}
	if (isObject(x)) {
		return 'Object';
	}
	if (typeof x === 'number') {
		return 'Number';
	}
	if (typeof x === 'boolean') {
		return 'Boolean';
	}
	if (typeof x === 'string') {
		return 'String';
	}
};
'use strict';

var Day = require('./Day');
var modulo = require('./modulo');

// https://262.ecma-international.org/5.1/#sec-15.9.1.6

module.exports = function WeekDay(t) {
	return modulo(Day(t) + 4, 7);
};
'use strict';

var GetIntrinsic = require('get-intrinsic');

var $Date = GetIntrinsic('%Date%');

var callBound = require('call-bound');

var $getUTCFullYear = callBound('Date.prototype.getUTCFullYear');

// https://262.ecma-international.org/5.1/#sec-15.9.1.3

module.exports = function YearFromTime(t) {
	// largest y such that this.TimeFromYear(y) <= t
	return $getUTCFullYear(new $Date(t));
};
'use strict';

// TODO, semver-major: delete this

var $TypeError = require('es-errors/type');
var $SyntaxError = require('es-errors/syntax');

var isMatchRecord = require('./records/match-record');
var isPropertyDescriptor = require('./records/property-descriptor');
var isIteratorRecord = require('./records/iterator-record-2023');
var isPromiseCapabilityRecord = require('./records/promise-capability-record');
var isAsyncGeneratorRequestRecord = require('./records/async-generator-request-record');
var isRegExpRecord = require('./records/regexp-record');

var predicates = {
	'Property Descriptor': isPropertyDescriptor,
	'Match Record': isMatchRecord,
	'Iterator Record': isIteratorRecord,
	'PromiseCapability Record': isPromiseCapabilityRecord,
	'AsyncGeneratorRequest Record': isAsyncGeneratorRequestRecord,
	'RegExp Record': isRegExpRecord
};

module.exports = function assertRecord(Type, recordType, argumentName, value) {
	var predicate = predicates[recordType];
	if (typeof predicate !== 'function') {
		throw new $SyntaxError('unknown record type: ' + recordType);
	}
	if (!predicate(value)) {
		throw new $TypeError(argumentName + ' must be a ' + recordType);
	}
};
'use strict';

var GetIntrinsic = require('get-intrinsic');

var hasOwn = require('hasown');

var $assign = GetIntrinsic('%Object.assign%', true);

module.exports = function assign(target, source) {
	if ($assign) {
		return $assign(target, source);
	}

	// eslint-disable-next-line no-restricted-syntax
	for (var key in source) {
		if (hasOwn(source, key)) {
			// eslint-disable-next-line no-param-reassign
			target[key] = source[key];
		}
	}
	return target;
};
'use strict';

var $pow = require('math-intrinsics/pow');

module.exports = function bytesAsFloat32(rawBytes) {
	// return new $Float16Array(new $Uint8Array(rawBytes).buffer)[0];
	/*
        Let value be the byte elements of rawBytes concatenated and interpreted as a little-endian bit string encoding of an IEEE 754-2019 binary16 value.
        If value is a NaN, return NaN.
        Return the Number value that corresponds to value.
    */

	var bits = (rawBytes[1] << 8) | rawBytes[0];

	// extract sign, exponent, mantissa
	var sign = bits & 0x8000 ? -1 : 1;
	var exponent = (bits & 0x7C00) >> 10;
	var mantissa = bits & 0x03FF;

	// zero (±0)
	if (exponent === 0 && mantissa === 0) {
		return sign === 1 ? 0 : -0;
	}

	// infinities
	if (exponent === 0x1F && mantissa === 0) {
		return sign === 1 ? Infinity : -Infinity;
	}

	// NaN
	if (exponent === 0x1F && mantissa !== 0) {
		return NaN;
	}

	// remove bias (15)
	exponent -= 15;

	// subnormals
	if (exponent === -15) {
		// value = sign * (mantissa) * 2^(1-bias-10) = mantissa * 2^(-14-10)
		return sign * mantissa * $pow(2, -24);
	}

	// normals
	// value = sign * (1 + mantissa/2^10) * 2^exponent
	return sign * (1 + (mantissa * $pow(2, -10))) * $pow(2, exponent);
};
'use strict';

var $pow = require('math-intrinsics/pow');

module.exports = function bytesAsFloat32(rawBytes) {
	// return new $Float32Array(new $Uint8Array(rawBytes).buffer)[0];

	/*
        Let value be the byte elements of rawBytes concatenated and interpreted as a little-endian bit string encoding of an IEEE 754-2008 binary32 value.
If value is an IEEE 754-2008 binary32 NaN value, return the NaN Number value.
Return the Number value that corresponds to value.
        */
	var sign = rawBytes[3] & 0x80 ? -1 : 1; // Check the sign bit
	var exponent = ((rawBytes[3] & 0x7F) << 1)
		| (rawBytes[2] >> 7); // Combine bits for exponent
	var mantissa = ((rawBytes[2] & 0x7F) << 16)
		| (rawBytes[1] << 8)
		| rawBytes[0]; // Combine bits for mantissa

	if (exponent === 0 && mantissa === 0) {
		return sign === 1 ? 0 : -0;
	}
	if (exponent === 0xFF && mantissa === 0) {
		return sign === 1 ? Infinity : -Infinity;
	}
	if (exponent === 0xFF && mantissa !== 0) {
		return NaN;
	}

	exponent -= 127; // subtract the bias

	if (exponent === -127) {
		return sign * mantissa * $pow(2, -126 - 23);
	}
	return sign * (1 + (mantissa * $pow(2, -23))) * $pow(2, exponent);
};
'use strict';

var $pow = require('math-intrinsics/pow');

module.exports = function bytesAsFloat64(rawBytes) {
	// return new $Float64Array(new $Uint8Array(rawBytes).buffer)[0];

	/*
    Let value be the byte elements of rawBytes concatenated and interpreted as a little-endian bit string encoding of an IEEE 754-2008 binary64 value.
If value is an IEEE 754-2008 binary64 NaN value, return the NaN Number value.
Return the Number value that corresponds to value.
    */
	var sign = rawBytes[7] & 0x80 ? -1 : 1; // first bit
	var exponent = ((rawBytes[7] & 0x7F) << 4) // 7 bits from index 7
        | ((rawBytes[6] & 0xF0) >> 4); // 4 bits from index 6
	var mantissa = ((rawBytes[6] & 0x0F) * 0x1000000000000) // 4 bits from index 6
        + (rawBytes[5] * 0x10000000000) // 8 bits from index 5
        + (rawBytes[4] * 0x100000000) // 8 bits from index 4
        + (rawBytes[3] * 0x1000000) // 8 bits from index 3
        + (rawBytes[2] * 0x10000) // 8 bits from index 2
        + (rawBytes[1] * 0x100) // 8 bits from index 1
        + rawBytes[0]; // 8 bits from index 0

	if (exponent === 0 && mantissa === 0) {
		return sign * 0;
	}
	if (exponent === 0x7FF && mantissa !== 0) {
		return NaN;
	}
	if (exponent === 0x7FF && mantissa === 0) {
		return sign * Infinity;
	}

	exponent -= 1023; // subtract the bias

	// Handle subnormal numbers
	if (exponent === -1023) {
		return sign * mantissa * 5e-324; // $pow(2, -1022 - 52)
	}

	return sign * (1 + (mantissa / 0x10000000000000)) * $pow(2, exponent);
};
'use strict';

var GetIntrinsic = require('get-intrinsic');

var $pow = require('math-intrinsics/pow');

var $Number = GetIntrinsic('%Number%');
var $BigInt = GetIntrinsic('%BigInt%', true);

module.exports = function bytesAsInteger(rawBytes, elementSize, isUnsigned, isBigInt) {
	var Z = isBigInt ? $BigInt : $Number;

	// this is common to both branches
	var intValue = Z(0);
	for (var i = 0; i < rawBytes.length; i++) {
		intValue += Z(rawBytes[i] * $pow(2, 8 * i));
	}
	/*
	Let intValue be the byte elements of rawBytes concatenated and interpreted as a bit string encoding of an unsigned little-endian binary number.
	*/

	if (!isUnsigned) { // steps 5-6
		// Let intValue be the byte elements of rawBytes concatenated and interpreted as a bit string encoding of a binary little-endian 2's complement number of bit length elementSize × 8.
		var bitLength = elementSize * 8;

		if (rawBytes[elementSize - 1] & 0x80) {
			intValue -= Z($pow(2, bitLength));
		}
	}

	return intValue; // step 7
};
'use strict';

// TODO; semver-major: remove

module.exports = require('call-bind');
'use strict';

// TODO; semver-major: remove

module.exports = require('call-bound');
'use strict';

var $TypeError = require('es-errors/type');

var GetIntrinsic = require('get-intrinsic');
var callBound = require('call-bound');
var hasOwn = require('hasown');

var caseFolding = require('./caseFolding.json');
var IsArray = require('./IsArray');
var isLeadingSurrogate = require('./isLeadingSurrogate');
var isTrailingSurrogate = require('./isTrailingSurrogate');

var $charCodeAt = callBound('%String.prototype.charCodeAt%');
var $fromCharCode = GetIntrinsic('%String.fromCharCode%');

/* eslint func-style: 0  */

function CharSet(test, yieldCh) {
	if (typeof test !== 'function') {
		throw new $TypeError('Assertion failed: `test` must be a function');
	}
	if (typeof yieldCh !== 'function') {
		throw new $TypeError('Assertion failed: `yield` must be a function');
	}
	this.test = test;
	this.yield = yieldCh;
}
CharSet.prototype.count = function () {
	var count = 0;
	this.yield(function () { count += 1; });
	return count;
};

function testCodeUnits(CharSetElement) {
	if (typeof CharSetElement !== 'string') {
		throw new $TypeError('Assertion failed: `CharSetElement` must be a string');
	}
	return CharSetElement.length !== 1;
}
function yieldCodeUnits(emit) {
	for (var i = 0; i <= 0xDFFF; i += 1) {
		emit($fromCharCode(i));
	}
}

function testCodePoints(CharSetElement) {
	if (typeof CharSetElement !== 'string') {
		throw new $TypeError('Assertion failed: `CharSetElement` must be a string');
	}

	if (CharSetElement.length === 1) {
		return true;
	}
	if (CharSetElement.length === 2) {
		var hi = $charCodeAt(CharSetElement, 0);
		var lo = $charCodeAt(CharSetElement, 1);
		return isLeadingSurrogate(hi) && isTrailingSurrogate(lo);
	}

	return false;
}

function yieldCodePoints(emit) {
	for (var i = 0; i <= 0xDFFF; i += 1) {
		emit($fromCharCode(i));
	}
	for (var u = 0x10000; u <= 0x10FFFF; u += 1) {
		var cp = u - 0x10000;
		var high = (cp >> 10) + 0xD800;
		var low = (cp & 0x3FF) + 0xDC00;
		emit($fromCharCode(high, low));
	}
}

function charsToMap(chars) {
	if (!IsArray(chars)) {
		throw new $TypeError('Assertion failed: `chars` must be an array');
	}

	var map = { __proto__: null };
	for (var i = 0; i < chars.length; i += 1) {
		var char = chars[i];
		if (typeof char !== 'string' || (char.length !== 1 && char.length !== 2)) {
			throw new $TypeError('Assertion failed: `chars` must be an array of strings of length 1');
		}
		map[char] = true;
	}
	return map;
}

module.exports = {
	CharSet: CharSet,
	from: function from(chars) {
		var map = charsToMap(chars);
		return new CharSet(
			function test(CharSetElement) {
				return hasOwn(map, CharSetElement);
			},
			function yieldChar(emit) {
				// eslint-disable-next-line no-restricted-syntax
				for (var k in map) {
					if (hasOwn(map, k)) {
						emit(k);
					}
				}
			}
		);
	},
	getCodeUnits: function () {
		return new CharSet(testCodeUnits, yieldCodeUnits);
	},
	getCodePoints: function () {
		return new CharSet(testCodePoints, yieldCodePoints);
	},
	getNonSimpleCaseFoldingCodePoints: function () {
		return new CharSet(
			function test(CharSetElement) {
				return testCodePoints(CharSetElement) && !hasOwn(caseFolding.S, CharSetElement);
			},
			function yieldChar(emit) {
				yieldCodePoints(function (CharSetElement) {
					if (!hasOwn(caseFolding.S, CharSetElement)) {
						emit(CharSetElement);
					}
				});
			}
		);
	}
};
'use strict';

var GetIntrinsic = require('get-intrinsic');

var $Uint8Array = GetIntrinsic('%Uint8Array%', true);
var $Uint32Array = GetIntrinsic('%Uint32Array%', true);

var typedArrayBuffer = require('typed-array-buffer');

var uInt32 = $Uint32Array && new $Uint32Array([0x12345678]);
var uInt8 = uInt32 && new $Uint8Array(typedArrayBuffer(uInt32));

module.exports = uInt8
	? uInt8[0] === 0x78
		? 'little'
		: uInt8[0] === 0x12
			? 'big'
			: uInt8[0] === 0x34
				? 'mixed' // https://developer.mozilla.org/en-US/docs/Glossary/Endianness
				: 'unknown' // ???
	: 'indeterminate'; // no way to know
'use strict';

var hasPropertyDescriptors = require('has-property-descriptors');

var $defineProperty = require('es-define-property');

var hasArrayLengthDefineBug = hasPropertyDescriptors.hasArrayLengthDefineBug();

// eslint-disable-next-line global-require
var isArray = hasArrayLengthDefineBug && require('../helpers/IsArray');

var callBound = require('call-bound');

var $isEnumerable = callBound('Object.prototype.propertyIsEnumerable');

// eslint-disable-next-line max-params
module.exports = function DefineOwnProperty(IsDataDescriptor, SameValue, FromPropertyDescriptor, O, P, desc) {
	if (!$defineProperty) {
		if (!IsDataDescriptor(desc)) {
			// ES3 does not support getters/setters
			return false;
		}
		if (!desc['[[Configurable]]'] || !desc['[[Writable]]']) {
			return false;
		}

		// fallback for ES3
		if (P in O && $isEnumerable(O, P) !== !!desc['[[Enumerable]]']) {
			// a non-enumerable existing property
			return false;
		}

		// property does not exist at all, or exists but is enumerable
		var V = desc['[[Value]]'];
		// eslint-disable-next-line no-param-reassign
		O[P] = V; // will use [[Define]]
		return SameValue(O[P], V);
	}
	if (
		hasArrayLengthDefineBug
		&& P === 'length'
		&& '[[Value]]' in desc
		&& isArray(O)
		&& O.length !== desc['[[Value]]']
	) {
		// eslint-disable-next-line no-param-reassign
		O.length = desc['[[Value]]'];
		return O.length === desc['[[Value]]'];
	}

	$defineProperty(O, P, FromPropertyDescriptor(desc));
	return true;
};
'use strict';

module.exports = function every(array, predicate) {
	for (var i = 0; i < array.length; i += 1) {
		if (!predicate(array[i], i, array)) {
			return false;
		}
	}
	return true;
};
'use strict';

module.exports = function forEach(array, callback) {
	for (var i = 0; i < array.length; i += 1) {
		callback(array[i], i, array); // eslint-disable-line callback-return
	}
};
'use strict';

var MAX_ITER = 1075; // 1023+52 (subnormals) => BIAS+NUM_SIGNFICAND_BITS-1
var maxBits = 54; // only 53 bits for fraction

module.exports = function fractionToBitString(x) {
	var str = '';
	if (x === 0) {
		return str;
	}
	var j = MAX_ITER;

	var y;
	// Each time we multiply by 2 and find a ones digit, add a '1'; otherwise, add a '0'..
	for (var i = 0; i < MAX_ITER; i += 1) {
		y = x * 2;
		if (y >= 1) {
			x = y - 1; // eslint-disable-line no-param-reassign
			str += '1';
			if (j === MAX_ITER) {
				j = i; // first 1
			}
		} else {
			x = y; // eslint-disable-line no-param-reassign
			str += '0';
		}
		// Stop when we have no more decimals to process or in the event we found a fraction which cannot be represented in a finite number of bits...
		if (y === 1 || i - j > maxBits) {
			return str;
		}
	}
	return str;
};
'use strict';

module.exports = function fromPropertyDescriptor(Desc) {
	if (typeof Desc === 'undefined') {
		return Desc;
	}
	var obj = {};
	if ('[[Value]]' in Desc) {
		obj.value = Desc['[[Value]]'];
	}
	if ('[[Writable]]' in Desc) {
		obj.writable = !!Desc['[[Writable]]'];
	}
	if ('[[Get]]' in Desc) {
		obj.get = Desc['[[Get]]'];
	}
	if ('[[Set]]' in Desc) {
		obj.set = Desc['[[Set]]'];
	}
	if ('[[Enumerable]]' in Desc) {
		obj.enumerable = !!Desc['[[Enumerable]]'];
	}
	if ('[[Configurable]]' in Desc) {
		obj.configurable = !!Desc['[[Configurable]]'];
	}
	return obj;
};
'use strict';

// TODO: remove, semver-major
module.exports = require('get-symbol-description/getInferredName');
'use strict';

var hasSymbols = require('has-symbols')();
var GetIntrinsic = require('get-intrinsic');
var callBound = require('call-bound');
var isString = require('is-string');

var $iterator = GetIntrinsic('%Symbol.iterator%', true);
var $stringSlice = callBound('String.prototype.slice');
var $String = GetIntrinsic('%String%');

var IsArray = require('./IsArray');

module.exports = function getIteratorMethod(ES, iterable) {
	var usingIterator;
	if (hasSymbols) {
		usingIterator = ES.GetMethod(iterable, $iterator);
	} else if (IsArray(iterable)) {
		usingIterator = function () {
			var i = -1;
			var arr = this; // eslint-disable-line no-invalid-this
			return {
				next: function () {
					i += 1;
					return {
						done: i >= arr.length,
						value: arr[i]
					};
				}
			};
		};
	} else if (isString(iterable)) {
		usingIterator = function () {
			var i = 0;
			return {
				next: function () {
					var nextIndex = ES.AdvanceStringIndex($String(iterable), i, true);
					var value = $stringSlice(iterable, i, nextIndex);
					i = nextIndex;
					var done = nextIndex > iterable.length;
					return {
						done: done,
						value: done ? void undefined : value
					};
				}
			};
		};
	}
	return usingIterator;
};
'use strict';

// TODO: remove, semver-major

module.exports = require('gopd');
'use strict';

// TODO, semver-major: remove
module.exports = require('get-proto');
'use strict';

// TODO: remove, semver-major
module.exports = require('get-symbol-description');
'use strict';

var GetIntrinsic = require('get-intrinsic');

var $Number = GetIntrinsic('%Number%');
var $BigInt = GetIntrinsic('%BigInt%', true);

module.exports = function integerToNBytes(intValue, n, isLittleEndian) {
	var Z = typeof intValue === 'bigint' ? $BigInt : $Number;
	/*
	if (intValue >= 0) { // step 3.d
		// Let rawBytes be a List containing the n-byte binary encoding of intValue. If isLittleEndian is false, the bytes are ordered in big endian order. Otherwise, the bytes are ordered in little endian order.
	} else { // step 3.e
		// Let rawBytes be a List containing the n-byte binary 2's complement encoding of intValue. If isLittleEndian is false, the bytes are ordered in big endian order. Otherwise, the bytes are ordered in little endian order.
	}
    */
	if (intValue < 0) {
		intValue >>>= 0; // eslint-disable-line no-param-reassign
	}

	var rawBytes = [];
	for (var i = 0; i < n; i++) {
		rawBytes[isLittleEndian ? i : n - 1 - i] = $Number(intValue & Z(0xFF));
		intValue >>= Z(8); // eslint-disable-line no-param-reassign
	}

	return rawBytes; // step 4
};
'use strict';

var $floor = require('math-intrinsics/floor');

// https://runestone.academy/ns/books/published/pythonds/BasicDS/ConvertingDecimalNumberstoBinaryNumbers.html#:~:text=The%20Divide%20by%202%20algorithm,have%20a%20remainder%20of%200

module.exports = function intToBinaryString(x) {
	var str = '';
	var y;

	while (x > 0) {
		y = x / 2;
		x = $floor(y); // eslint-disable-line no-param-reassign
		if (y === x) {
			str = '0' + str;
		} else {
			str = '1' + str;
		}
	}
	return str;
};
'use strict';

var functionName = require('function.prototype.name');

var anon = functionName(function () {});

module.exports = function isAbstractClosure(x) {
	return typeof x === 'function' && (!x.prototype || functionName(x) === anon);
};
'use strict';

var GetIntrinsic = require('get-intrinsic');

var $Array = GetIntrinsic('%Array%');

// eslint-disable-next-line global-require
var toStr = !$Array.isArray && require('call-bound')('Object.prototype.toString');

module.exports = $Array.isArray || function IsArray(argument) {
	return toStr(argument) === '[object Array]';
};
'use strict';

module.exports = function isByteValue(value) {
	return typeof value === 'number' && value >= 0 && value <= 255 && (value | 0) === value;
};
'use strict';

module.exports = function isCodePoint(cp) {
	return typeof cp === 'number' && cp >= 0 && cp <= 0x10FFFF && (cp | 0) === cp;
};
'use strict';

// TODO, semver-major: delete
module.exports = require('math-intrinsics/isFinite');
'use strict';

var isPropertyDescriptor = require('./records/property-descriptor');

module.exports = function isFullyPopulatedPropertyDescriptor(ES, Desc) {
	return isPropertyDescriptor(Desc)
		&& '[[Enumerable]]' in Desc
		&& '[[Configurable]]' in Desc
		&& (ES.IsAccessorDescriptor(Desc) || ES.IsDataDescriptor(Desc));
};
'use strict';

// TODO, semver-major: delete
module.exports = require('math-intrinsics/isInteger');
'use strict';

module.exports = function isLeadingSurrogate(charCode) {
	return typeof charCode === 'number' && charCode >= 0xD800 && charCode <= 0xDBFF;
};
'use strict';

// https://262.ecma-international.org/5.1/#sec-7.3

module.exports = function isLineTerminator(c) {
	return c === '\n' || c === '\r' || c === '\u2028' || c === '\u2029';
};
'use strict';

module.exports = Number.isNaN || function isNaN(a) {
	return a !== a;
};
'use strict';

// TODO, semver-major: remove
module.exports = function isNegativeZero(x) {
	return x === 0 && 1 / x === 1 / -0;
};
'use strict';

// TODO: remove, semver-major

module.exports = require('es-object-atoms/isObject');
'use strict';

var $strSlice = require('call-bound')('String.prototype.slice');

module.exports = function isPrefixOf(prefix, string) {
	if (prefix === string) {
		return true;
	}
	if (prefix.length > string.length) {
		return false;
	}
	return $strSlice(string, 0, prefix.length) === prefix;
};
'use strict';

module.exports = function isPrimitive(value) {
	return value === null || (typeof value !== 'function' && typeof value !== 'object');
};
'use strict';

module.exports = function isPropertyKey(argument) {
	return typeof argument === 'string' || typeof argument === 'symbol';
};
'use strict';

var every = require('./every');

module.exports = function isSamePropertyDescriptor(ES, D1, D2) {
	var fields = [
		'[[Configurable]]',
		'[[Enumerable]]',
		'[[Get]]',
		'[[Set]]',
		'[[Value]]',
		'[[Writable]]'
	];
	return every(fields, function (field) {
		if ((field in D1) !== (field in D2)) {
			return false;
		}
		return ES.SameValue(D1[field], D2[field]);
	});
};
'use strict';

module.exports = function isSameType(x, y) {
	if (x === y) {
		return true;
	}

	if (typeof x === typeof y) {
		if (typeof x !== 'object' || typeof y !== 'object') {
			return true;
		}
		return !!x === !!y;
	}

	return false;
};
'use strict';

// TODO: semver-major: remove

var canDistinguishSparseFromUndefined = 0 in [undefined]; // IE 6 - 8 have a bug where this returns false

module.exports = function isStringOrHole(item, index, arr) {
	return typeof item === 'string' || (canDistinguishSparseFromUndefined ? !(index in arr) : typeof item === 'undefined');
};
'use strict';

module.exports = function isStringOrUndefined(item) {
	return typeof item === 'string' || typeof item === 'undefined';
};
'use strict';

module.exports = function isTrailingSurrogate(charCode) {
	return typeof charCode === 'number' && charCode >= 0xDC00 && charCode <= 0xDFFF;
};
'use strict';

// TODO, semver-major: delete
module.exports = require('math-intrinsics/constants/maxSafeInteger');
'use strict';

module.exports = Number.MAX_VALUE || 1.7976931348623157e+308;
'use strict';

module.exports = function bigIntMod(BigIntRemainder, bigint, modulo) {
	var remain = BigIntRemainder(bigint, modulo);
	return remain >= 0 ? remain : remain + modulo;
};
'use strict';

// TODO, semver-major: delete
module.exports = require('math-intrinsics/mod');
'use strict';

// TODO, semver-major: remove
module.exports = require('own-keys');
'use strict';

var callBound = require('call-bound');

var $strSlice = callBound('String.prototype.slice');

module.exports = function padTimeComponent(c, count) {
	return $strSlice('00' + c, -(count || 2));
};
'use strict';

module.exports = function reduce(arr, fn, init) {
	var acc = init;
	for (var i = 0; i < arr.length; i += 1) {
		acc = fn(acc, arr[i], i);
	}
	return acc;
};
'use strict';

// TODO: remove, semver-major

module.exports = require('safe-regex-test');
'use strict';

// TODO, semver-major: remove
module.exports = require('set-proto');
'use strict';

// TODO, semver-major: delete
module.exports = require('math-intrinsics/sign');
'use strict';

module.exports = function some(array, predicate) {
	for (var i = 0; i < array.length; i += 1) {
		if (predicate(array[i], i, array)) {
			return true;
		}
	}
	return false;
};
'use strict';

var HoursPerDay = 24;
var MinutesPerHour = 60;
var SecondsPerMinute = 60;
var msPerSecond = 1e3;
var msPerMinute = msPerSecond * SecondsPerMinute;
var msPerHour = msPerMinute * MinutesPerHour;
var msPerDay = 86400000;

module.exports = {
	HoursPerDay: HoursPerDay,
	MinutesPerHour: MinutesPerHour,
	SecondsPerMinute: SecondsPerMinute,
	msPerSecond: msPerSecond,
	msPerMinute: msPerMinute,
	msPerHour: msPerHour,
	msPerDay: msPerDay
};
'use strict';

var $DateGetTime = require('call-bound')('Date.prototype.getTime');

module.exports = function timeValue(x) {
	return $DateGetTime(x);
};
'use strict';

var GetIntrinsic = require('get-intrinsic');

var constructors = {
	__proto__: null,
	$Int8Array: GetIntrinsic('%Int8Array%', true),
	$Uint8Array: GetIntrinsic('%Uint8Array%', true),
	$Uint8ClampedArray: GetIntrinsic('%Uint8ClampedArray%', true),
	$Int16Array: GetIntrinsic('%Int16Array%', true),
	$Uint16Array: GetIntrinsic('%Uint16Array%', true),
	$Int32Array: GetIntrinsic('%Int32Array%', true),
	$Uint32Array: GetIntrinsic('%Uint32Array%', true),
	$BigInt64Array: GetIntrinsic('%BigInt64Array%', true),
	$BigUint64Array: GetIntrinsic('%BigUint64Array%', true),
	$Float16Array: GetIntrinsic('%Float16Array%', true),
	$Float32Array: GetIntrinsic('%Float32Array%', true),
	$Float64Array: GetIntrinsic('%Float64Array%', true)
};

module.exports = function getConstructor(kind) {
	return constructors['$' + kind];
};
'use strict';

var $abs = require('math-intrinsics/abs');
var $floor = require('math-intrinsics/floor');
var $pow = require('math-intrinsics/pow');

var isFinite = require('math-intrinsics/isFinite');
var isNaN = require('math-intrinsics/isNaN');
var isNegativeZero = require('math-intrinsics/isNegativeZero');

var maxFiniteFloat16 = 65504; // 2**16 - 2**5

module.exports = function valueToFloat16Bytes(value, isLittleEndian) {
	// NaN → exponent=all-ones, mantissa MSB=1 → 0x7e00
	if (isNaN(value)) {
		return isLittleEndian
			? [0x00, 0x7e]
			: [0x7e, 0x00];
	}

	var leastSig;

	// ±0 → just the sign bit
	if (value === 0) {
		leastSig = isNegativeZero(value) ? 0x80 : 0x00;
		return isLittleEndian
			? [0x00, leastSig]
			: [leastSig, 0x00];
	}

	// ±∞ → exponent=all-ones, mantissa=0 → 0x7c00 or 0xfc00
	if ($abs(value) > maxFiniteFloat16 || !isFinite(value)) {
		leastSig = value < 0 ? 0xfc : 0x7c;
		return isLittleEndian
			? [0x00, leastSig]
			: [leastSig, 0x00];
	}

	var sign = value < 0 ? 1 : 0;
	value = $abs(value); // eslint-disable-line no-param-reassign

	// normalize to [1,2)
	var exponent = 0;
	while (value >= 2) {
		exponent += 1;
		value /= 2; // eslint-disable-line no-param-reassign
	}
	while (value < 1) {
		exponent -= 1;
		value *= 2; // eslint-disable-line no-param-reassign
	}

	// build mantissa (10 bits)
	var mantissa = value - 1;
	mantissa *= $pow(2, 10) + 0.5;
	mantissa = $floor(mantissa);

	// apply bias (15) and shift into place
	exponent += 15;
	exponent <<= 10;

	// pack sign, exponent, mantissa
	var result = (sign << 15) | exponent | mantissa;

	// split into two bytes
	var byte0 = result & 0xFF;
	result >>= 8;
	var byte1 = result & 0xFF;

	return isLittleEndian
		? [byte0, byte1]
		: [byte1, byte0];
};
'use strict';

var $abs = require('math-intrinsics/abs');
var $floor = require('math-intrinsics/floor');
var $pow = require('math-intrinsics/pow');

var isFinite = require('math-intrinsics/isFinite');
var isNaN = require('math-intrinsics/isNaN');
var isNegativeZero = require('math-intrinsics/isNegativeZero');

var maxFiniteFloat32 = 3.4028234663852886e+38; // roughly 2 ** 128 - 1

module.exports = function valueToFloat32Bytes(value, isLittleEndian) {
	if (isNaN(value)) {
		return isLittleEndian ? [0, 0, 192, 127] : [127, 192, 0, 0]; // hardcoded
	}

	var leastSig;

	if (value === 0) {
		leastSig = isNegativeZero(value) ? 0x80 : 0;
		return isLittleEndian ? [0, 0, 0, leastSig] : [leastSig, 0, 0, 0];
	}

	if ($abs(value) > maxFiniteFloat32 || !isFinite(value)) {
		leastSig = value < 0 ? 255 : 127;
		return isLittleEndian ? [0, 0, 128, leastSig] : [leastSig, 128, 0, 0];
	}

	var sign = value < 0 ? 1 : 0;
	value = $abs(value); // eslint-disable-line no-param-reassign

	var exponent = 0;
	while (value >= 2) {
		exponent += 1;
		value /= 2; // eslint-disable-line no-param-reassign
	}

	while (value < 1) {
		exponent -= 1;
		value *= 2; // eslint-disable-line no-param-reassign
	}

	var mantissa = value - 1;
	mantissa *= $pow(2, 23) + 0.5;
	mantissa = $floor(mantissa);

	exponent += 127;
	exponent <<= 23;

	var result = (sign << 31)
        | exponent
        | mantissa;

	var byte0 = result & 255;
	result >>= 8;
	var byte1 = result & 255;
	result >>= 8;
	var byte2 = result & 255;
	result >>= 8;
	var byte3 = result & 255;

	if (isLittleEndian) {
		return [byte0, byte1, byte2, byte3];
	}
	return [byte3, byte2, byte1, byte0];
};
'use strict';

var GetIntrinsic = require('get-intrinsic');

var $parseInt = GetIntrinsic('%parseInt%');
var $abs = require('math-intrinsics/abs');
var $floor = require('math-intrinsics/floor');
var isNegativeZero = require('math-intrinsics/isNegativeZero');

var callBound = require('call-bound');

var $strIndexOf = callBound('String.prototype.indexOf');
var $strSlice = callBound('String.prototype.slice');

var fractionToBitString = require('../helpers/fractionToBinaryString');
var intToBinString = require('../helpers/intToBinaryString');

var float64bias = 1023;

var elevenOnes = '11111111111';
var elevenZeroes = '00000000000';
var fiftyOneZeroes = elevenZeroes + elevenZeroes + elevenZeroes + elevenZeroes + '0000000';

// IEEE 754-1985
module.exports = function valueToFloat64Bytes(value, isLittleEndian) {
	var signBit = value < 0 || isNegativeZero(value) ? '1' : '0';
	var exponentBits;
	var significandBits;

	if (isNaN(value)) {
		exponentBits = elevenOnes;
		significandBits = '1' + fiftyOneZeroes;
	} else if (!isFinite(value)) {
		exponentBits = elevenOnes;
		significandBits = '0' + fiftyOneZeroes;
	} else if (value === 0) {
		exponentBits = elevenZeroes;
		significandBits = '0' + fiftyOneZeroes;
	} else {
		value = $abs(value); // eslint-disable-line no-param-reassign

		// Isolate the integer part (digits before the decimal):
		var integerPart = $floor(value);

		var intBinString = intToBinString(integerPart); // bit string for integer part
		var fracBinString = fractionToBitString(value - integerPart); // bit string for fractional part

		var numberOfBits;
		// find exponent needed to normalize integer+fractional parts
		if (intBinString) {
			exponentBits = intBinString.length - 1; // move the decimal to the left
		} else {
			var first1 = $strIndexOf(fracBinString, '1');
			if (first1 > -1) {
				numberOfBits = first1 + 1;
			}
			exponentBits = -numberOfBits; // move the decimal to the right
		}

		significandBits = intBinString + fracBinString;
		if (exponentBits < 0) {
			// subnormals
			if (exponentBits <= -float64bias) {
				numberOfBits = float64bias - 1; // limit number of removed bits
			}
			significandBits = $strSlice(significandBits, numberOfBits); // remove all leading 0s and the first 1 for normal values; for subnormals, remove up to `float64bias - 1` leading bits
		} else {
			significandBits = $strSlice(significandBits, 1); // remove the leading '1' (implicit/hidden bit)
		}
		exponentBits = $strSlice(elevenZeroes + intToBinString(exponentBits + float64bias), -11); // Convert the exponent to a bit string

		significandBits = $strSlice(significandBits + fiftyOneZeroes + '0', 0, 52); // fill in any trailing zeros and ensure we have only 52 fraction bits
	}

	var bits = signBit + exponentBits + significandBits;
	var rawBytes = [];
	for (var i = 0; i < 8; i++) {
		var targetIndex = isLittleEndian ? 8 - i - 1 : i;
		rawBytes[targetIndex] = $parseInt($strSlice(bits, i * 8, (i + 1) * 8), 2);
	}

	return rawBytes;
};
'use strict';

module.exports = {
	IsPropertyDescriptor: 'https://262.ecma-international.org/6.0/#sec-property-descriptor-specification-type', // not actually an abstract op

	abs: {
		url: 'https://262.ecma-international.org/6.0/#sec-algorithm-conventions'
	},
	'Abstract Equality Comparison': {
		url: 'https://262.ecma-international.org/6.0/#sec-abstract-equality-comparison'
	},
	'Abstract Relational Comparison': {
		url: 'https://262.ecma-international.org/6.0/#sec-abstract-relational-comparison'
	},
	AddRestrictedFunctionProperties: {
		url: 'https://262.ecma-international.org/6.0/#sec-addrestrictedfunctionproperties'
	},
	AdvanceStringIndex: {
		url: 'https://262.ecma-international.org/6.0/#sec-advancestringindex'
	},
	AllocateArrayBuffer: {
		url: 'https://262.ecma-international.org/6.0/#sec-allocatearraybuffer'
	},
	AllocateTypedArray: {
		url: 'https://262.ecma-international.org/6.0/#sec-allocatetypedarray'
	},
	ArrayCreate: {
		url: 'https://262.ecma-international.org/6.0/#sec-arraycreate'
	},
	ArraySetLength: {
		url: 'https://262.ecma-international.org/6.0/#sec-arraysetlength'
	},
	ArraySpeciesCreate: {
		url: 'https://262.ecma-international.org/6.0/#sec-arrayspeciescreate'
	},
	BoundFunctionCreate: {
		url: 'https://262.ecma-international.org/6.0/#sec-boundfunctioncreate'
	},
	Call: {
		url: 'https://262.ecma-international.org/6.0/#sec-call'
	},
	Canonicalize: {
		url: 'https://262.ecma-international.org/6.0/#sec-runtime-semantics-canonicalize-ch'
	},
	CanonicalNumericIndexString: {
		url: 'https://262.ecma-international.org/6.0/#sec-canonicalnumericindexstring'
	},
	CharacterRange: {
		url: 'https://262.ecma-international.org/6.0/#sec-runtime-semantics-characterrange-abstract-operation'
	},
	CharacterSetMatcher: {
		url: 'https://262.ecma-international.org/6.0/#sec-runtime-semantics-charactersetmatcher-abstract-operation'
	},
	CloneArrayBuffer: {
		url: 'https://262.ecma-international.org/6.0/#sec-clonearraybuffer'
	},
	CompletePropertyDescriptor: {
		url: 'https://262.ecma-international.org/6.0/#sec-completepropertydescriptor'
	},
	Completion: {
		url: 'https://262.ecma-international.org/6.0/#sec-implicit-completion-values'
	},
	CompletionRecord: {
		url: 'https://262.ecma-international.org/6.0/#sec-completion-record-specification-type'
	},
	Construct: {
		url: 'https://262.ecma-international.org/6.0/#sec-construct'
	},
	CopyDataBlockBytes: {
		url: 'https://262.ecma-international.org/6.0/#sec-copydatablockbytes'
	},
	CreateArrayFromList: {
		url: 'https://262.ecma-international.org/6.0/#sec-createarrayfromlist'
	},
	CreateArrayIterator: {
		url: 'https://262.ecma-international.org/6.0/#sec-createarrayiterator'
	},
	CreateBuiltinFunction: {
		url: 'https://262.ecma-international.org/6.0/#sec-createbuiltinfunction'
	},
	CreateByteDataBlock: {
		url: 'https://262.ecma-international.org/6.0/#sec-createbytedatablock'
	},
	CreateDataProperty: {
		url: 'https://262.ecma-international.org/6.0/#sec-createdataproperty'
	},
	CreateDataPropertyOrThrow: {
		url: 'https://262.ecma-international.org/6.0/#sec-createdatapropertyorthrow'
	},
	CreateDynamicFunction: {
		url: 'https://262.ecma-international.org/6.0/#sec-createdynamicfunction'
	},
	CreateHTML: {
		url: 'https://262.ecma-international.org/6.0/#sec-createhtml'
	},
	CreateIntrinsics: {
		url: 'https://262.ecma-international.org/6.0/#sec-createintrinsics'
	},
	CreateIterResultObject: {
		url: 'https://262.ecma-international.org/6.0/#sec-createiterresultobject'
	},
	CreateListFromArrayLike: {
		url: 'https://262.ecma-international.org/6.0/#sec-createlistfromarraylike'
	},
	CreateListIterator: {
		url: 'https://262.ecma-international.org/6.0/#sec-createlistiterator'
	},
	CreateMapIterator: {
		url: 'https://262.ecma-international.org/6.0/#sec-createmapiterator'
	},
	CreateMappedArgumentsObject: {
		url: 'https://262.ecma-international.org/6.0/#sec-createmappedargumentsobject'
	},
	CreateMethodProperty: {
		url: 'https://262.ecma-international.org/6.0/#sec-createmethodproperty'
	},
	CreatePerIterationEnvironment: {
		url: 'https://262.ecma-international.org/6.0/#sec-createperiterationenvironment'
	},
	CreateRealm: {
		url: 'https://262.ecma-international.org/6.0/#sec-createrealm'
	},
	CreateSetIterator: {
		url: 'https://262.ecma-international.org/6.0/#sec-createsetiterator'
	},
	CreateUnmappedArgumentsObject: {
		url: 'https://262.ecma-international.org/6.0/#sec-createunmappedargumentsobject'
	},
	DateFromTime: {
		url: 'https://262.ecma-international.org/6.0/#sec-date-number'
	},
	Day: {
		url: 'https://262.ecma-international.org/6.0/#sec-day-number-and-time-within-day'
	},
	DayFromYear: {
		url: 'https://262.ecma-international.org/6.0/#sec-year-number'
	},
	DaylightSavingTA: {
		url: 'https://262.ecma-international.org/6.0/#sec-daylight-saving-time-adjustment'
	},
	DaysInYear: {
		url: 'https://262.ecma-international.org/6.0/#sec-year-number'
	},
	DayWithinYear: {
		url: 'https://262.ecma-international.org/6.0/#sec-month-number'
	},
	Decode: {
		url: 'https://262.ecma-international.org/6.0/#sec-decode'
	},
	DefinePropertyOrThrow: {
		url: 'https://262.ecma-international.org/6.0/#sec-definepropertyorthrow'
	},
	DeletePropertyOrThrow: {
		url: 'https://262.ecma-international.org/6.0/#sec-deletepropertyorthrow'
	},
	DetachArrayBuffer: {
		url: 'https://262.ecma-international.org/6.0/#sec-detacharraybuffer'
	},
	Encode: {
		url: 'https://262.ecma-international.org/6.0/#sec-encode'
	},
	EnqueueJob: {
		url: 'https://262.ecma-international.org/6.0/#sec-enqueuejob'
	},
	EnumerableOwnNames: {
		url: 'https://262.ecma-international.org/6.0/#sec-enumerableownnames'
	},
	EscapeRegExpPattern: {
		url: 'https://262.ecma-international.org/6.0/#sec-escaperegexppattern'
	},
	EvalDeclarationInstantiation: {
		url: 'https://262.ecma-international.org/6.0/#sec-evaldeclarationinstantiation'
	},
	EvaluateCall: {
		url: 'https://262.ecma-international.org/6.0/#sec-evaluatecall'
	},
	EvaluateDirectCall: {
		url: 'https://262.ecma-international.org/6.0/#sec-evaluatedirectcall'
	},
	EvaluateNew: {
		url: 'https://262.ecma-international.org/6.0/#sec-evaluatenew'
	},
	floor: {
		url: 'https://262.ecma-international.org/6.0/#sec-algorithm-conventions'
	},
	ForBodyEvaluation: {
		url: 'https://262.ecma-international.org/6.0/#sec-forbodyevaluation'
	},
	'ForIn/OfBodyEvaluation': {
		url: 'https://262.ecma-international.org/6.0/#sec-runtime-semantics-forin-div-ofbodyevaluation-lhs-stmt-iterator-lhskind-labelset'
	},
	'ForIn/OfHeadEvaluation': {
		url: 'https://262.ecma-international.org/6.0/#sec-runtime-semantics-forin-div-ofheadevaluation-tdznames-expr-iterationkind'
	},
	FromPropertyDescriptor: {
		url: 'https://262.ecma-international.org/6.0/#sec-frompropertydescriptor'
	},
	FulfillPromise: {
		url: 'https://262.ecma-international.org/6.0/#sec-fulfillpromise'
	},
	FunctionAllocate: {
		url: 'https://262.ecma-international.org/6.0/#sec-functionallocate'
	},
	FunctionCreate: {
		url: 'https://262.ecma-international.org/6.0/#sec-functioncreate'
	},
	FunctionInitialize: {
		url: 'https://262.ecma-international.org/6.0/#sec-functioninitialize'
	},
	GeneratorFunctionCreate: {
		url: 'https://262.ecma-international.org/6.0/#sec-generatorfunctioncreate'
	},
	GeneratorResume: {
		url: 'https://262.ecma-international.org/6.0/#sec-generatorresume'
	},
	GeneratorResumeAbrupt: {
		url: 'https://262.ecma-international.org/6.0/#sec-generatorresumeabrupt'
	},
	GeneratorStart: {
		url: 'https://262.ecma-international.org/6.0/#sec-generatorstart'
	},
	GeneratorValidate: {
		url: 'https://262.ecma-international.org/6.0/#sec-generatorvalidate'
	},
	GeneratorYield: {
		url: 'https://262.ecma-international.org/6.0/#sec-generatoryield'
	},
	Get: {
		url: 'https://262.ecma-international.org/6.0/#sec-get-o-p'
	},
	GetBase: {
		url: 'https://262.ecma-international.org/6.0/#sec-jobs-and-job-queues'
	},
	GetFunctionRealm: {
		url: 'https://262.ecma-international.org/6.0/#sec-getfunctionrealm'
	},
	GetGlobalObject: {
		url: 'https://262.ecma-international.org/6.0/#sec-getglobalobject'
	},
	GetIdentifierReference: {
		url: 'https://262.ecma-international.org/6.0/#sec-getidentifierreference'
	},
	GetIterator: {
		url: 'https://262.ecma-international.org/6.0/#sec-getiterator'
	},
	GetMethod: {
		url: 'https://262.ecma-international.org/6.0/#sec-getmethod'
	},
	GetModuleNamespace: {
		url: 'https://262.ecma-international.org/6.0/#sec-getmodulenamespace'
	},
	GetNewTarget: {
		url: 'https://262.ecma-international.org/6.0/#sec-getnewtarget'
	},
	GetOwnPropertyKeys: {
		url: 'https://262.ecma-international.org/6.0/#sec-getownpropertykeys'
	},
	GetPrototypeFromConstructor: {
		url: 'https://262.ecma-international.org/6.0/#sec-getprototypefromconstructor'
	},
	GetReferencedName: {
		url: 'https://262.ecma-international.org/6.0/#sec-jobs-and-job-queues'
	},
	GetSubstitution: {
		url: 'https://262.ecma-international.org/6.0/#sec-getsubstitution'
	},
	GetSuperConstructor: {
		url: 'https://262.ecma-international.org/6.0/#sec-getsuperconstructor'
	},
	GetTemplateObject: {
		url: 'https://262.ecma-international.org/6.0/#sec-gettemplateobject'
	},
	GetThisEnvironment: {
		url: 'https://262.ecma-international.org/6.0/#sec-getthisenvironment'
	},
	GetThisValue: {
		url: 'https://262.ecma-international.org/6.0/#sec-getthisvalue'
	},
	GetV: {
		url: 'https://262.ecma-international.org/6.0/#sec-getv'
	},
	GetValue: {
		url: 'https://262.ecma-international.org/6.0/#sec-getvalue'
	},
	GetValueFromBuffer: {
		url: 'https://262.ecma-international.org/6.0/#sec-getvaluefrombuffer'
	},
	GetViewValue: {
		url: 'https://262.ecma-international.org/6.0/#sec-getviewvalue'
	},
	HasOwnProperty: {
		url: 'https://262.ecma-international.org/6.0/#sec-hasownproperty'
	},
	HasPrimitiveBase: {
		url: 'https://262.ecma-international.org/6.0/#sec-jobs-and-job-queues'
	},
	HasProperty: {
		url: 'https://262.ecma-international.org/6.0/#sec-hasproperty'
	},
	HourFromTime: {
		url: 'https://262.ecma-international.org/6.0/#sec-hours-minutes-second-and-milliseconds'
	},
	ImportedLocalNames: {
		url: 'https://262.ecma-international.org/6.0/#sec-importedlocalnames'
	},
	InitializeHostDefinedRealm: {
		url: 'https://262.ecma-international.org/6.0/#sec-initializehostdefinedrealm'
	},
	InitializeReferencedBinding: {
		url: 'https://262.ecma-international.org/6.0/#sec-initializereferencedbinding'
	},
	InLeapYear: {
		url: 'https://262.ecma-international.org/6.0/#sec-year-number'
	},
	InstanceofOperator: {
		url: 'https://262.ecma-international.org/6.0/#sec-instanceofoperator'
	},
	IntegerIndexedElementGet: {
		url: 'https://262.ecma-international.org/6.0/#sec-integerindexedelementget'
	},
	IntegerIndexedElementSet: {
		url: 'https://262.ecma-international.org/6.0/#sec-integerindexedelementset'
	},
	IntegerIndexedObjectCreate: {
		url: 'https://262.ecma-international.org/6.0/#sec-integerindexedobjectcreate'
	},
	InternalizeJSONProperty: {
		url: 'https://262.ecma-international.org/6.0/#sec-internalizejsonproperty'
	},
	Invoke: {
		url: 'https://262.ecma-international.org/6.0/#sec-invoke'
	},
	IsAccessorDescriptor: {
		url: 'https://262.ecma-international.org/6.0/#sec-isaccessordescriptor'
	},
	IsAnonymousFunctionDefinition: {
		url: 'https://262.ecma-international.org/6.0/#sec-isanonymousfunctiondefinition'
	},
	IsArray: {
		url: 'https://262.ecma-international.org/6.0/#sec-isarray'
	},
	IsCallable: {
		url: 'https://262.ecma-international.org/6.0/#sec-iscallable'
	},
	IsCompatiblePropertyDescriptor: {
		url: 'https://262.ecma-international.org/6.0/#sec-iscompatiblepropertydescriptor'
	},
	IsConcatSpreadable: {
		url: 'https://262.ecma-international.org/6.0/#sec-isconcatspreadable'
	},
	IsConstructor: {
		url: 'https://262.ecma-international.org/6.0/#sec-isconstructor'
	},
	IsDataDescriptor: {
		url: 'https://262.ecma-international.org/6.0/#sec-isdatadescriptor'
	},
	IsDetachedBuffer: {
		url: 'https://262.ecma-international.org/6.0/#sec-isdetachedbuffer'
	},
	IsExtensible: {
		url: 'https://262.ecma-international.org/6.0/#sec-isextensible-o'
	},
	IsGenericDescriptor: {
		url: 'https://262.ecma-international.org/6.0/#sec-isgenericdescriptor'
	},
	IsInTailPosition: {
		url: 'https://262.ecma-international.org/6.0/#sec-isintailposition'
	},
	IsInteger: {
		url: 'https://262.ecma-international.org/6.0/#sec-isinteger'
	},
	IsLabelledFunction: {
		url: 'https://262.ecma-international.org/6.0/#sec-islabelledfunction'
	},
	IsPromise: {
		url: 'https://262.ecma-international.org/6.0/#sec-ispromise'
	},
	IsPropertyKey: {
		url: 'https://262.ecma-international.org/6.0/#sec-ispropertykey'
	},
	IsPropertyReference: {
		url: 'https://262.ecma-international.org/6.0/#sec-jobs-and-job-queues'
	},
	IsRegExp: {
		url: 'https://262.ecma-international.org/6.0/#sec-isregexp'
	},
	IsStrictReference: {
		url: 'https://262.ecma-international.org/6.0/#sec-jobs-and-job-queues'
	},
	IsSuperReference: {
		url: 'https://262.ecma-international.org/6.0/#sec-jobs-and-job-queues'
	},
	IsUnresolvableReference: {
		url: 'https://262.ecma-international.org/6.0/#sec-jobs-and-job-queues'
	},
	IsWordChar: {
		url: 'https://262.ecma-international.org/6.0/#sec-runtime-semantics-iswordchar-abstract-operation'
	},
	IteratorClose: {
		url: 'https://262.ecma-international.org/6.0/#sec-iteratorclose'
	},
	IteratorComplete: {
		url: 'https://262.ecma-international.org/6.0/#sec-iteratorcomplete'
	},
	IteratorNext: {
		url: 'https://262.ecma-international.org/6.0/#sec-iteratornext'
	},
	IteratorStep: {
		url: 'https://262.ecma-international.org/6.0/#sec-iteratorstep'
	},
	IteratorValue: {
		url: 'https://262.ecma-international.org/6.0/#sec-iteratorvalue'
	},
	LocalTime: {
		url: 'https://262.ecma-international.org/6.0/#sec-localtime'
	},
	LoopContinues: {
		url: 'https://262.ecma-international.org/6.0/#sec-loopcontinues'
	},
	MakeArgGetter: {
		url: 'https://262.ecma-international.org/6.0/#sec-makearggetter'
	},
	MakeArgSetter: {
		url: 'https://262.ecma-international.org/6.0/#sec-makeargsetter'
	},
	MakeClassConstructor: {
		url: 'https://262.ecma-international.org/6.0/#sec-makeclassconstructor'
	},
	MakeConstructor: {
		url: 'https://262.ecma-international.org/6.0/#sec-makeconstructor'
	},
	MakeDate: {
		url: 'https://262.ecma-international.org/6.0/#sec-makedate'
	},
	MakeDay: {
		url: 'https://262.ecma-international.org/6.0/#sec-makeday'
	},
	MakeMethod: {
		url: 'https://262.ecma-international.org/6.0/#sec-makemethod'
	},
	MakeSuperPropertyReference: {
		url: 'https://262.ecma-international.org/6.0/#sec-makesuperpropertyreference'
	},
	MakeTime: {
		url: 'https://262.ecma-international.org/6.0/#sec-maketime'
	},
	max: {
		url: 'https://262.ecma-international.org/6.0/#sec-algorithm-conventions'
	},
	min: {
		url: 'https://262.ecma-international.org/6.0/#sec-algorithm-conventions'
	},
	MinFromTime: {
		url: 'https://262.ecma-international.org/6.0/#sec-hours-minutes-second-and-milliseconds'
	},
	ModuleNamespaceCreate: {
		url: 'https://262.ecma-international.org/6.0/#sec-modulenamespacecreate'
	},
	modulo: {
		url: 'https://262.ecma-international.org/6.0/#sec-algorithm-conventions'
	},
	MonthFromTime: {
		url: 'https://262.ecma-international.org/6.0/#sec-month-number'
	},
	msFromTime: {
		url: 'https://262.ecma-international.org/6.0/#sec-hours-minutes-second-and-milliseconds'
	},
	msPerDay: {
		url: 'https://262.ecma-international.org/6.0/#sec-day-number-and-time-within-day'
	},
	NewDeclarativeEnvironment: {
		url: 'https://262.ecma-international.org/6.0/#sec-newdeclarativeenvironment'
	},
	NewFunctionEnvironment: {
		url: 'https://262.ecma-international.org/6.0/#sec-newfunctionenvironment'
	},
	NewGlobalEnvironment: {
		url: 'https://262.ecma-international.org/6.0/#sec-newglobalenvironment'
	},
	NewModuleEnvironment: {
		url: 'https://262.ecma-international.org/6.0/#sec-newmoduleenvironment'
	},
	NewObjectEnvironment: {
		url: 'https://262.ecma-international.org/6.0/#sec-newobjectenvironment'
	},
	NewPromiseCapability: {
		url: 'https://262.ecma-international.org/6.0/#sec-newpromisecapability'
	},
	NormalCompletion: {
		url: 'https://262.ecma-international.org/6.0/#sec-normalcompletion'
	},
	ObjectCreate: {
		url: 'https://262.ecma-international.org/6.0/#sec-objectcreate'
	},
	ObjectDefineProperties: {
		url: 'https://262.ecma-international.org/6.0/#sec-objectdefineproperties'
	},
	OrdinaryCallBindThis: {
		url: 'https://262.ecma-international.org/6.0/#sec-ordinarycallbindthis'
	},
	OrdinaryCallEvaluateBody: {
		url: 'https://262.ecma-international.org/6.0/#sec-ordinarycallevaluatebody'
	},
	OrdinaryCreateFromConstructor: {
		url: 'https://262.ecma-international.org/6.0/#sec-ordinarycreatefromconstructor'
	},
	OrdinaryDefineOwnProperty: {
		url: 'https://262.ecma-international.org/6.0/#sec-ordinarydefineownproperty'
	},
	OrdinaryGetOwnProperty: {
		url: 'https://262.ecma-international.org/6.0/#sec-ordinarygetownproperty'
	},
	OrdinaryHasInstance: {
		url: 'https://262.ecma-international.org/6.0/#sec-ordinaryhasinstance'
	},
	OrdinaryHasProperty: {
		url: 'https://262.ecma-international.org/6.0/#sec-ordinaryhasproperty'
	},
	ParseModule: {
		url: 'https://262.ecma-international.org/6.0/#sec-parsemodule'
	},
	PerformEval: {
		url: 'https://262.ecma-international.org/6.0/#sec-performeval'
	},
	PerformPromiseAll: {
		url: 'https://262.ecma-international.org/6.0/#sec-performpromiseall'
	},
	PerformPromiseRace: {
		url: 'https://262.ecma-international.org/6.0/#sec-performpromiserace'
	},
	PerformPromiseThen: {
		url: 'https://262.ecma-international.org/6.0/#sec-performpromisethen'
	},
	PrepareForOrdinaryCall: {
		url: 'https://262.ecma-international.org/6.0/#sec-prepareforordinarycall'
	},
	PrepareForTailCall: {
		url: 'https://262.ecma-international.org/6.0/#sec-preparefortailcall'
	},
	ProxyCreate: {
		url: 'https://262.ecma-international.org/6.0/#sec-proxycreate'
	},
	PutValue: {
		url: 'https://262.ecma-international.org/6.0/#sec-putvalue'
	},
	QuoteJSONString: {
		url: 'https://262.ecma-international.org/6.0/#sec-quotejsonstring'
	},
	RegExpAlloc: {
		url: 'https://262.ecma-international.org/6.0/#sec-regexpalloc'
	},
	RegExpBuiltinExec: {
		url: 'https://262.ecma-international.org/6.0/#sec-regexpbuiltinexec'
	},
	RegExpCreate: {
		url: 'https://262.ecma-international.org/6.0/#sec-regexpcreate'
	},
	RegExpExec: {
		url: 'https://262.ecma-international.org/6.0/#sec-regexpexec'
	},
	RegExpInitialize: {
		url: 'https://262.ecma-international.org/6.0/#sec-regexpinitialize'
	},
	RejectPromise: {
		url: 'https://262.ecma-international.org/6.0/#sec-rejectpromise'
	},
	RepeatMatcher: {
		url: 'https://262.ecma-international.org/6.0/#sec-runtime-semantics-repeatmatcher-abstract-operation'
	},
	RequireObjectCoercible: {
		url: 'https://262.ecma-international.org/6.0/#sec-requireobjectcoercible'
	},
	ResolveBinding: {
		url: 'https://262.ecma-international.org/6.0/#sec-resolvebinding'
	},
	ResolveThisBinding: {
		url: 'https://262.ecma-international.org/6.0/#sec-resolvethisbinding'
	},
	SameValue: {
		url: 'https://262.ecma-international.org/6.0/#sec-samevalue'
	},
	SameValueZero: {
		url: 'https://262.ecma-international.org/6.0/#sec-samevaluezero'
	},
	SecFromTime: {
		url: 'https://262.ecma-international.org/6.0/#sec-hours-minutes-second-and-milliseconds'
	},
	SerializeJSONArray: {
		url: 'https://262.ecma-international.org/6.0/#sec-serializejsonarray'
	},
	SerializeJSONObject: {
		url: 'https://262.ecma-international.org/6.0/#sec-serializejsonobject'
	},
	SerializeJSONProperty: {
		url: 'https://262.ecma-international.org/6.0/#sec-serializejsonproperty'
	},
	Set: {
		url: 'https://262.ecma-international.org/6.0/#sec-set-o-p-v-throw'
	},
	SetDefaultGlobalBindings: {
		url: 'https://262.ecma-international.org/6.0/#sec-setdefaultglobalbindings'
	},
	SetFunctionName: {
		url: 'https://262.ecma-international.org/6.0/#sec-setfunctionname'
	},
	SetIntegrityLevel: {
		url: 'https://262.ecma-international.org/6.0/#sec-setintegritylevel'
	},
	SetRealmGlobalObject: {
		url: 'https://262.ecma-international.org/6.0/#sec-setrealmglobalobject'
	},
	SetValueInBuffer: {
		url: 'https://262.ecma-international.org/6.0/#sec-setvalueinbuffer'
	},
	SetViewValue: {
		url: 'https://262.ecma-international.org/6.0/#sec-setviewvalue'
	},
	sign: {
		url: 'https://262.ecma-international.org/6.0/#sec-algorithm-conventions'
	},
	SortCompare: {
		url: 'https://262.ecma-international.org/6.0/#sec-sortcompare'
	},
	SpeciesConstructor: {
		url: 'https://262.ecma-international.org/6.0/#sec-speciesconstructor'
	},
	SplitMatch: {
		url: 'https://262.ecma-international.org/6.0/#sec-splitmatch'
	},
	'Strict Equality Comparison': {
		url: 'https://262.ecma-international.org/6.0/#sec-strict-equality-comparison'
	},
	StringCreate: {
		url: 'https://262.ecma-international.org/6.0/#sec-stringcreate'
	},
	StringGetIndexProperty: {
		url: 'https://262.ecma-international.org/6.0/#sec-stringgetindexproperty'
	},
	SymbolDescriptiveString: {
		url: 'https://262.ecma-international.org/6.0/#sec-symboldescriptivestring'
	},
	TestIntegrityLevel: {
		url: 'https://262.ecma-international.org/6.0/#sec-testintegritylevel'
	},
	thisBooleanValue: {
		url: 'https://262.ecma-international.org/6.0/#sec-properties-of-the-boolean-prototype-object'
	},
	thisNumberValue: {
		url: 'https://262.ecma-international.org/6.0/#sec-properties-of-the-number-prototype-object'
	},
	thisStringValue: {
		url: 'https://262.ecma-international.org/6.0/#sec-properties-of-the-string-prototype-object'
	},
	thisTimeValue: {
		url: 'https://262.ecma-international.org/6.0/#sec-properties-of-the-date-prototype-object'
	},
	TimeClip: {
		url: 'https://262.ecma-international.org/6.0/#sec-timeclip'
	},
	TimeFromYear: {
		url: 'https://262.ecma-international.org/6.0/#sec-year-number'
	},
	TimeWithinDay: {
		url: 'https://262.ecma-international.org/6.0/#sec-day-number-and-time-within-day'
	},
	ToBoolean: {
		url: 'https://262.ecma-international.org/6.0/#sec-toboolean'
	},
	ToDateString: {
		url: 'https://262.ecma-international.org/6.0/#sec-todatestring'
	},
	ToInt16: {
		url: 'https://262.ecma-international.org/6.0/#sec-toint16'
	},
	ToInt32: {
		url: 'https://262.ecma-international.org/6.0/#sec-toint32'
	},
	ToInt8: {
		url: 'https://262.ecma-international.org/6.0/#sec-toint8'
	},
	ToInteger: {
		url: 'https://262.ecma-international.org/6.0/#sec-tointeger'
	},
	ToLength: {
		url: 'https://262.ecma-international.org/6.0/#sec-tolength'
	},
	ToNumber: {
		url: 'https://262.ecma-international.org/6.0/#sec-tonumber'
	},
	ToObject: {
		url: 'https://262.ecma-international.org/6.0/#sec-toobject'
	},
	ToPrimitive: {
		url: 'https://262.ecma-international.org/6.0/#sec-toprimitive'
	},
	ToPropertyDescriptor: {
		url: 'https://262.ecma-international.org/6.0/#sec-topropertydescriptor'
	},
	ToPropertyKey: {
		url: 'https://262.ecma-international.org/6.0/#sec-topropertykey'
	},
	ToString: {
		url: 'https://262.ecma-international.org/6.0/#sec-tostring'
	},
	ToUint16: {
		url: 'https://262.ecma-international.org/6.0/#sec-touint16'
	},
	ToUint32: {
		url: 'https://262.ecma-international.org/6.0/#sec-touint32'
	},
	ToUint8: {
		url: 'https://262.ecma-international.org/6.0/#sec-touint8'
	},
	ToUint8Clamp: {
		url: 'https://262.ecma-international.org/6.0/#sec-touint8clamp'
	},
	TriggerPromiseReactions: {
		url: 'https://262.ecma-international.org/6.0/#sec-triggerpromisereactions'
	},
	Type: {
		url: 'https://262.ecma-international.org/6.0/#sec-ecmascript-data-types-and-values'
	},
	TypedArrayFrom: {
		url: 'https://262.ecma-international.org/6.0/#sec-typedarrayfrom'
	},
	UpdateEmpty: {
		url: 'https://262.ecma-international.org/6.0/#sec-updateempty'
	},
	UTC: {
		url: 'https://262.ecma-international.org/6.0/#sec-utc-t'
	},
	ValidateAndApplyPropertyDescriptor: {
		url: 'https://262.ecma-international.org/6.0/#sec-validateandapplypropertydescriptor'
	},
	ValidateTypedArray: {
		url: 'https://262.ecma-international.org/6.0/#sec-validatetypedarray'
	},
	WeekDay: {
		url: 'https://262.ecma-international.org/6.0/#sec-week-day'
	},
	YearFromTime: {
		url: 'https://262.ecma-international.org/6.0/#sec-year-number'
	}
};
'use strict';

module.exports = {
	IsPropertyDescriptor: 'https://262.ecma-international.org/6.0/#sec-property-descriptor-specification-type', // not actually an abstract op

	abs: {
		url: 'https://262.ecma-international.org/7.0/#sec-algorithm-conventions'
	},
	'Abstract Equality Comparison': {
		url: 'https://262.ecma-international.org/7.0/#sec-abstract-equality-comparison'
	},
	'Abstract Relational Comparison': {
		url: 'https://262.ecma-international.org/7.0/#sec-abstract-relational-comparison'
	},
	AddRestrictedFunctionProperties: {
		url: 'https://262.ecma-international.org/7.0/#sec-addrestrictedfunctionproperties'
	},
	AdvanceStringIndex: {
		url: 'https://262.ecma-international.org/7.0/#sec-advancestringindex'
	},
	AllocateArrayBuffer: {
		url: 'https://262.ecma-international.org/7.0/#sec-allocatearraybuffer'
	},
	AllocateTypedArray: {
		url: 'https://262.ecma-international.org/7.0/#sec-allocatetypedarray'
	},
	AllocateTypedArrayBuffer: {
		url: 'https://262.ecma-international.org/7.0/#sec-allocatetypedarraybuffer'
	},
	ArrayCreate: {
		url: 'https://262.ecma-international.org/7.0/#sec-arraycreate'
	},
	ArraySetLength: {
		url: 'https://262.ecma-international.org/7.0/#sec-arraysetlength'
	},
	ArraySpeciesCreate: {
		url: 'https://262.ecma-international.org/7.0/#sec-arrayspeciescreate'
	},
	BlockDeclarationInstantiation: {
		url: 'https://262.ecma-international.org/7.0/#sec-blockdeclarationinstantiation'
	},
	BoundFunctionCreate: {
		url: 'https://262.ecma-international.org/7.0/#sec-boundfunctioncreate'
	},
	Call: {
		url: 'https://262.ecma-international.org/7.0/#sec-call'
	},
	Canonicalize: {
		url: 'https://262.ecma-international.org/7.0/#sec-runtime-semantics-canonicalize-ch'
	},
	CanonicalNumericIndexString: {
		url: 'https://262.ecma-international.org/7.0/#sec-canonicalnumericindexstring'
	},
	CharacterRange: {
		url: 'https://262.ecma-international.org/7.0/#sec-runtime-semantics-characterrange-abstract-operation'
	},
	CharacterRangeOrUnion: {
		url: 'https://262.ecma-international.org/7.0/#sec-runtime-semantics-characterrangeorunion-abstract-operation'
	},
	CharacterSetMatcher: {
		url: 'https://262.ecma-international.org/7.0/#sec-runtime-semantics-charactersetmatcher-abstract-operation'
	},
	CloneArrayBuffer: {
		url: 'https://262.ecma-international.org/7.0/#sec-clonearraybuffer'
	},
	CompletePropertyDescriptor: {
		url: 'https://262.ecma-international.org/7.0/#sec-completepropertydescriptor'
	},
	Completion: {
		url: 'https://262.ecma-international.org/7.0/#sec-completion-record-specification-type'
	},
	CompletionRecord: {
		url: 'https://262.ecma-international.org/7.0/#sec-completion-record-specification-type'
	},
	Construct: {
		url: 'https://262.ecma-international.org/7.0/#sec-construct'
	},
	CopyDataBlockBytes: {
		url: 'https://262.ecma-international.org/7.0/#sec-copydatablockbytes'
	},
	CreateArrayFromList: {
		url: 'https://262.ecma-international.org/7.0/#sec-createarrayfromlist'
	},
	CreateArrayIterator: {
		url: 'https://262.ecma-international.org/7.0/#sec-createarrayiterator'
	},
	CreateBuiltinFunction: {
		url: 'https://262.ecma-international.org/7.0/#sec-createbuiltinfunction'
	},
	CreateByteDataBlock: {
		url: 'https://262.ecma-international.org/7.0/#sec-createbytedatablock'
	},
	CreateDataProperty: {
		url: 'https://262.ecma-international.org/7.0/#sec-createdataproperty'
	},
	CreateDataPropertyOrThrow: {
		url: 'https://262.ecma-international.org/7.0/#sec-createdatapropertyorthrow'
	},
	CreateDynamicFunction: {
		url: 'https://262.ecma-international.org/7.0/#sec-createdynamicfunction'
	},
	CreateHTML: {
		url: 'https://262.ecma-international.org/7.0/#sec-createhtml'
	},
	CreateIntrinsics: {
		url: 'https://262.ecma-international.org/7.0/#sec-createintrinsics'
	},
	CreateIterResultObject: {
		url: 'https://262.ecma-international.org/7.0/#sec-createiterresultobject'
	},
	CreateListFromArrayLike: {
		url: 'https://262.ecma-international.org/7.0/#sec-createlistfromarraylike'
	},
	CreateListIterator: {
		url: 'https://262.ecma-international.org/7.0/#sec-createlistiterator'
	},
	CreateMapIterator: {
		url: 'https://262.ecma-international.org/7.0/#sec-createmapiterator'
	},
	CreateMappedArgumentsObject: {
		url: 'https://262.ecma-international.org/7.0/#sec-createmappedargumentsobject'
	},
	CreateMethodProperty: {
		url: 'https://262.ecma-international.org/7.0/#sec-createmethodproperty'
	},
	CreatePerIterationEnvironment: {
		url: 'https://262.ecma-international.org/7.0/#sec-createperiterationenvironment'
	},
	CreateRealm: {
		url: 'https://262.ecma-international.org/7.0/#sec-createrealm'
	},
	CreateResolvingFunctions: {
		url: 'https://262.ecma-international.org/7.0/#sec-createresolvingfunctions'
	},
	CreateSetIterator: {
		url: 'https://262.ecma-international.org/7.0/#sec-createsetiterator'
	},
	CreateStringIterator: {
		url: 'https://262.ecma-international.org/7.0/#sec-createstringiterator'
	},
	CreateUnmappedArgumentsObject: {
		url: 'https://262.ecma-international.org/7.0/#sec-createunmappedargumentsobject'
	},
	DateFromTime: {
		url: 'https://262.ecma-international.org/7.0/#sec-date-number'
	},
	Day: {
		url: 'https://262.ecma-international.org/7.0/#sec-day-number-and-time-within-day'
	},
	DayFromYear: {
		url: 'https://262.ecma-international.org/7.0/#sec-year-number'
	},
	DaylightSavingTA: {
		url: 'https://262.ecma-international.org/7.0/#sec-daylight-saving-time-adjustment'
	},
	DaysInYear: {
		url: 'https://262.ecma-international.org/7.0/#sec-year-number'
	},
	DayWithinYear: {
		url: 'https://262.ecma-international.org/7.0/#sec-month-number'
	},
	Decode: {
		url: 'https://262.ecma-international.org/7.0/#sec-decode'
	},
	DefinePropertyOrThrow: {
		url: 'https://262.ecma-international.org/7.0/#sec-definepropertyorthrow'
	},
	DeletePropertyOrThrow: {
		url: 'https://262.ecma-international.org/7.0/#sec-deletepropertyorthrow'
	},
	DetachArrayBuffer: {
		url: 'https://262.ecma-international.org/7.0/#sec-detacharraybuffer'
	},
	Encode: {
		url: 'https://262.ecma-international.org/7.0/#sec-encode'
	},
	EnqueueJob: {
		url: 'https://262.ecma-international.org/7.0/#sec-enqueuejob'
	},
	EnumerableOwnNames: {
		url: 'https://262.ecma-international.org/7.0/#sec-enumerableownnames'
	},
	EnumerateObjectProperties: {
		url: 'https://262.ecma-international.org/7.0/#sec-enumerate-object-properties'
	},
	EscapeRegExpPattern: {
		url: 'https://262.ecma-international.org/7.0/#sec-escaperegexppattern'
	},
	EvalDeclarationInstantiation: {
		url: 'https://262.ecma-international.org/7.0/#sec-evaldeclarationinstantiation'
	},
	EvaluateCall: {
		url: 'https://262.ecma-international.org/7.0/#sec-evaluatecall'
	},
	EvaluateDirectCall: {
		url: 'https://262.ecma-international.org/7.0/#sec-evaluatedirectcall'
	},
	EvaluateNew: {
		url: 'https://262.ecma-international.org/7.0/#sec-evaluatenew'
	},
	floor: {
		url: 'https://262.ecma-international.org/7.0/#sec-algorithm-conventions'
	},
	ForBodyEvaluation: {
		url: 'https://262.ecma-international.org/7.0/#sec-forbodyevaluation'
	},
	'ForIn/OfBodyEvaluation': {
		url: 'https://262.ecma-international.org/7.0/#sec-runtime-semantics-forin-div-ofbodyevaluation-lhs-stmt-iterator-lhskind-labelset'
	},
	'ForIn/OfHeadEvaluation': {
		url: 'https://262.ecma-international.org/7.0/#sec-runtime-semantics-forin-div-ofheadevaluation-tdznames-expr-iterationkind'
	},
	FromPropertyDescriptor: {
		url: 'https://262.ecma-international.org/7.0/#sec-frompropertydescriptor'
	},
	FulfillPromise: {
		url: 'https://262.ecma-international.org/7.0/#sec-fulfillpromise'
	},
	FunctionAllocate: {
		url: 'https://262.ecma-international.org/7.0/#sec-functionallocate'
	},
	FunctionCreate: {
		url: 'https://262.ecma-international.org/7.0/#sec-functioncreate'
	},
	FunctionDeclarationInstantiation: {
		url: 'https://262.ecma-international.org/7.0/#sec-functiondeclarationinstantiation'
	},
	FunctionInitialize: {
		url: 'https://262.ecma-international.org/7.0/#sec-functioninitialize'
	},
	GeneratorFunctionCreate: {
		url: 'https://262.ecma-international.org/7.0/#sec-generatorfunctioncreate'
	},
	GeneratorResume: {
		url: 'https://262.ecma-international.org/7.0/#sec-generatorresume'
	},
	GeneratorResumeAbrupt: {
		url: 'https://262.ecma-international.org/7.0/#sec-generatorresumeabrupt'
	},
	GeneratorStart: {
		url: 'https://262.ecma-international.org/7.0/#sec-generatorstart'
	},
	GeneratorValidate: {
		url: 'https://262.ecma-international.org/7.0/#sec-generatorvalidate'
	},
	GeneratorYield: {
		url: 'https://262.ecma-international.org/7.0/#sec-generatoryield'
	},
	Get: {
		url: 'https://262.ecma-international.org/7.0/#sec-get-o-p'
	},
	GetActiveScriptOrModule: {
		url: 'https://262.ecma-international.org/7.0/#sec-getactivescriptormodule'
	},
	GetFunctionRealm: {
		url: 'https://262.ecma-international.org/7.0/#sec-getfunctionrealm'
	},
	GetGlobalObject: {
		url: 'https://262.ecma-international.org/7.0/#sec-getglobalobject'
	},
	GetIdentifierReference: {
		url: 'https://262.ecma-international.org/7.0/#sec-getidentifierreference'
	},
	GetIterator: {
		url: 'https://262.ecma-international.org/7.0/#sec-getiterator'
	},
	GetMethod: {
		url: 'https://262.ecma-international.org/7.0/#sec-getmethod'
	},
	GetModuleNamespace: {
		url: 'https://262.ecma-international.org/7.0/#sec-getmodulenamespace'
	},
	GetNewTarget: {
		url: 'https://262.ecma-international.org/7.0/#sec-getnewtarget'
	},
	GetOwnPropertyKeys: {
		url: 'https://262.ecma-international.org/7.0/#sec-getownpropertykeys'
	},
	GetPrototypeFromConstructor: {
		url: 'https://262.ecma-international.org/7.0/#sec-getprototypefromconstructor'
	},
	GetSubstitution: {
		url: 'https://262.ecma-international.org/7.0/#sec-getsubstitution'
	},
	GetSuperConstructor: {
		url: 'https://262.ecma-international.org/7.0/#sec-getsuperconstructor'
	},
	GetTemplateObject: {
		url: 'https://262.ecma-international.org/7.0/#sec-gettemplateobject'
	},
	GetThisEnvironment: {
		url: 'https://262.ecma-international.org/7.0/#sec-getthisenvironment'
	},
	GetThisValue: {
		url: 'https://262.ecma-international.org/7.0/#sec-getthisvalue'
	},
	GetV: {
		url: 'https://262.ecma-international.org/7.0/#sec-getv'
	},
	GetValue: {
		url: 'https://262.ecma-international.org/7.0/#sec-getvalue'
	},
	GetValueFromBuffer: {
		url: 'https://262.ecma-international.org/7.0/#sec-getvaluefrombuffer'
	},
	GetViewValue: {
		url: 'https://262.ecma-international.org/7.0/#sec-getviewvalue'
	},
	GlobalDeclarationInstantiation: {
		url: 'https://262.ecma-international.org/7.0/#sec-globaldeclarationinstantiation'
	},
	HasOwnProperty: {
		url: 'https://262.ecma-international.org/7.0/#sec-hasownproperty'
	},
	HasProperty: {
		url: 'https://262.ecma-international.org/7.0/#sec-hasproperty'
	},
	HourFromTime: {
		url: 'https://262.ecma-international.org/7.0/#sec-hours-minutes-second-and-milliseconds'
	},
	IfAbruptRejectPromise: {
		url: 'https://262.ecma-international.org/7.0/#sec-ifabruptrejectpromise'
	},
	ImportedLocalNames: {
		url: 'https://262.ecma-international.org/7.0/#sec-importedlocalnames'
	},
	InitializeBoundName: {
		url: 'https://262.ecma-international.org/7.0/#sec-initializeboundname'
	},
	InitializeHostDefinedRealm: {
		url: 'https://262.ecma-international.org/7.0/#sec-initializehostdefinedrealm'
	},
	InitializeReferencedBinding: {
		url: 'https://262.ecma-international.org/7.0/#sec-initializereferencedbinding'
	},
	InLeapYear: {
		url: 'https://262.ecma-international.org/7.0/#sec-year-number'
	},
	InstanceofOperator: {
		url: 'https://262.ecma-international.org/7.0/#sec-instanceofoperator'
	},
	IntegerIndexedElementGet: {
		url: 'https://262.ecma-international.org/7.0/#sec-integerindexedelementget'
	},
	IntegerIndexedElementSet: {
		url: 'https://262.ecma-international.org/7.0/#sec-integerindexedelementset'
	},
	IntegerIndexedObjectCreate: {
		url: 'https://262.ecma-international.org/7.0/#sec-integerindexedobjectcreate'
	},
	InternalizeJSONProperty: {
		url: 'https://262.ecma-international.org/7.0/#sec-internalizejsonproperty'
	},
	Invoke: {
		url: 'https://262.ecma-international.org/7.0/#sec-invoke'
	},
	IsAccessorDescriptor: {
		url: 'https://262.ecma-international.org/7.0/#sec-isaccessordescriptor'
	},
	IsAnonymousFunctionDefinition: {
		url: 'https://262.ecma-international.org/7.0/#sec-isanonymousfunctiondefinition'
	},
	IsArray: {
		url: 'https://262.ecma-international.org/7.0/#sec-isarray'
	},
	IsCallable: {
		url: 'https://262.ecma-international.org/7.0/#sec-iscallable'
	},
	IsCompatiblePropertyDescriptor: {
		url: 'https://262.ecma-international.org/7.0/#sec-iscompatiblepropertydescriptor'
	},
	IsConcatSpreadable: {
		url: 'https://262.ecma-international.org/7.0/#sec-isconcatspreadable'
	},
	IsConstructor: {
		url: 'https://262.ecma-international.org/7.0/#sec-isconstructor'
	},
	IsDataDescriptor: {
		url: 'https://262.ecma-international.org/7.0/#sec-isdatadescriptor'
	},
	IsDetachedBuffer: {
		url: 'https://262.ecma-international.org/7.0/#sec-isdetachedbuffer'
	},
	IsExtensible: {
		url: 'https://262.ecma-international.org/7.0/#sec-isextensible-o'
	},
	IsGenericDescriptor: {
		url: 'https://262.ecma-international.org/7.0/#sec-isgenericdescriptor'
	},
	IsInTailPosition: {
		url: 'https://262.ecma-international.org/7.0/#sec-isintailposition'
	},
	IsInteger: {
		url: 'https://262.ecma-international.org/7.0/#sec-isinteger'
	},
	IsLabelledFunction: {
		url: 'https://262.ecma-international.org/7.0/#sec-islabelledfunction'
	},
	IsPromise: {
		url: 'https://262.ecma-international.org/7.0/#sec-ispromise'
	},
	IsPropertyKey: {
		url: 'https://262.ecma-international.org/7.0/#sec-ispropertykey'
	},
	IsRegExp: {
		url: 'https://262.ecma-international.org/7.0/#sec-isregexp'
	},
	IsWordChar: {
		url: 'https://262.ecma-international.org/7.0/#sec-runtime-semantics-iswordchar-abstract-operation'
	},
	IterableToArrayLike: {
		url: 'https://262.ecma-international.org/7.0/#sec-iterabletoarraylike'
	},
	IteratorClose: {
		url: 'https://262.ecma-international.org/7.0/#sec-iteratorclose'
	},
	IteratorComplete: {
		url: 'https://262.ecma-international.org/7.0/#sec-iteratorcomplete'
	},
	IteratorNext: {
		url: 'https://262.ecma-international.org/7.0/#sec-iteratornext'
	},
	IteratorStep: {
		url: 'https://262.ecma-international.org/7.0/#sec-iteratorstep'
	},
	IteratorValue: {
		url: 'https://262.ecma-international.org/7.0/#sec-iteratorvalue'
	},
	LocalTime: {
		url: 'https://262.ecma-international.org/7.0/#sec-localtime'
	},
	LoopContinues: {
		url: 'https://262.ecma-international.org/7.0/#sec-loopcontinues'
	},
	MakeArgGetter: {
		url: 'https://262.ecma-international.org/7.0/#sec-makearggetter'
	},
	MakeArgSetter: {
		url: 'https://262.ecma-international.org/7.0/#sec-makeargsetter'
	},
	MakeClassConstructor: {
		url: 'https://262.ecma-international.org/7.0/#sec-makeclassconstructor'
	},
	MakeConstructor: {
		url: 'https://262.ecma-international.org/7.0/#sec-makeconstructor'
	},
	MakeDate: {
		url: 'https://262.ecma-international.org/7.0/#sec-makedate'
	},
	MakeDay: {
		url: 'https://262.ecma-international.org/7.0/#sec-makeday'
	},
	MakeMethod: {
		url: 'https://262.ecma-international.org/7.0/#sec-makemethod'
	},
	MakeSuperPropertyReference: {
		url: 'https://262.ecma-international.org/7.0/#sec-makesuperpropertyreference'
	},
	MakeTime: {
		url: 'https://262.ecma-international.org/7.0/#sec-maketime'
	},
	max: {
		url: 'https://262.ecma-international.org/7.0/#sec-algorithm-conventions'
	},
	min: {
		url: 'https://262.ecma-international.org/7.0/#sec-algorithm-conventions'
	},
	MinFromTime: {
		url: 'https://262.ecma-international.org/7.0/#sec-hours-minutes-second-and-milliseconds'
	},
	ModuleNamespaceCreate: {
		url: 'https://262.ecma-international.org/7.0/#sec-modulenamespacecreate'
	},
	modulo: {
		url: 'https://262.ecma-international.org/7.0/#sec-algorithm-conventions'
	},
	MonthFromTime: {
		url: 'https://262.ecma-international.org/7.0/#sec-month-number'
	},
	msFromTime: {
		url: 'https://262.ecma-international.org/7.0/#sec-hours-minutes-second-and-milliseconds'
	},
	NewDeclarativeEnvironment: {
		url: 'https://262.ecma-international.org/7.0/#sec-newdeclarativeenvironment'
	},
	NewFunctionEnvironment: {
		url: 'https://262.ecma-international.org/7.0/#sec-newfunctionenvironment'
	},
	NewGlobalEnvironment: {
		url: 'https://262.ecma-international.org/7.0/#sec-newglobalenvironment'
	},
	NewModuleEnvironment: {
		url: 'https://262.ecma-international.org/7.0/#sec-newmoduleenvironment'
	},
	NewObjectEnvironment: {
		url: 'https://262.ecma-international.org/7.0/#sec-newobjectenvironment'
	},
	NewPromiseCapability: {
		url: 'https://262.ecma-international.org/7.0/#sec-newpromisecapability'
	},
	NextJob: {
		url: 'https://262.ecma-international.org/7.0/#sec-nextjob-result'
	},
	NormalCompletion: {
		url: 'https://262.ecma-international.org/7.0/#sec-normalcompletion'
	},
	ObjectCreate: {
		url: 'https://262.ecma-international.org/7.0/#sec-objectcreate'
	},
	ObjectDefineProperties: {
		url: 'https://262.ecma-international.org/7.0/#sec-objectdefineproperties'
	},
	OrdinaryCallBindThis: {
		url: 'https://262.ecma-international.org/7.0/#sec-ordinarycallbindthis'
	},
	OrdinaryCallEvaluateBody: {
		url: 'https://262.ecma-international.org/7.0/#sec-ordinarycallevaluatebody'
	},
	OrdinaryCreateFromConstructor: {
		url: 'https://262.ecma-international.org/7.0/#sec-ordinarycreatefromconstructor'
	},
	OrdinaryDefineOwnProperty: {
		url: 'https://262.ecma-international.org/7.0/#sec-ordinarydefineownproperty'
	},
	OrdinaryDelete: {
		url: 'https://262.ecma-international.org/7.0/#sec-ordinarydelete'
	},
	OrdinaryGet: {
		url: 'https://262.ecma-international.org/7.0/#sec-ordinaryget'
	},
	OrdinaryGetOwnProperty: {
		url: 'https://262.ecma-international.org/7.0/#sec-ordinarygetownproperty'
	},
	OrdinaryGetPrototypeOf: {
		url: 'https://262.ecma-international.org/7.0/#sec-ordinarygetprototypeof'
	},
	OrdinaryHasInstance: {
		url: 'https://262.ecma-international.org/7.0/#sec-ordinaryhasinstance'
	},
	OrdinaryHasProperty: {
		url: 'https://262.ecma-international.org/7.0/#sec-ordinaryhasproperty'
	},
	OrdinaryIsExtensible: {
		url: 'https://262.ecma-international.org/7.0/#sec-ordinaryisextensible'
	},
	OrdinaryOwnPropertyKeys: {
		url: 'https://262.ecma-international.org/7.0/#sec-ordinaryownpropertykeys'
	},
	OrdinaryPreventExtensions: {
		url: 'https://262.ecma-international.org/7.0/#sec-ordinarypreventextensions'
	},
	OrdinarySet: {
		url: 'https://262.ecma-international.org/7.0/#sec-ordinaryset'
	},
	OrdinarySetPrototypeOf: {
		url: 'https://262.ecma-international.org/7.0/#sec-ordinarysetprototypeof'
	},
	ParseModule: {
		url: 'https://262.ecma-international.org/7.0/#sec-parsemodule'
	},
	ParseScript: {
		url: 'https://262.ecma-international.org/7.0/#sec-parse-script'
	},
	PerformEval: {
		url: 'https://262.ecma-international.org/7.0/#sec-performeval'
	},
	PerformPromiseAll: {
		url: 'https://262.ecma-international.org/7.0/#sec-performpromiseall'
	},
	PerformPromiseRace: {
		url: 'https://262.ecma-international.org/7.0/#sec-performpromiserace'
	},
	PerformPromiseThen: {
		url: 'https://262.ecma-international.org/7.0/#sec-performpromisethen'
	},
	PrepareForOrdinaryCall: {
		url: 'https://262.ecma-international.org/7.0/#sec-prepareforordinarycall'
	},
	PrepareForTailCall: {
		url: 'https://262.ecma-international.org/7.0/#sec-preparefortailcall'
	},
	PromiseReactionJob: {
		url: 'https://262.ecma-international.org/7.0/#sec-promisereactionjob'
	},
	PromiseResolveThenableJob: {
		url: 'https://262.ecma-international.org/7.0/#sec-promiseresolvethenablejob'
	},
	ProxyCreate: {
		url: 'https://262.ecma-international.org/7.0/#sec-proxycreate'
	},
	PutValue: {
		url: 'https://262.ecma-international.org/7.0/#sec-putvalue'
	},
	QuoteJSONString: {
		url: 'https://262.ecma-international.org/7.0/#sec-quotejsonstring'
	},
	RegExpAlloc: {
		url: 'https://262.ecma-international.org/7.0/#sec-regexpalloc'
	},
	RegExpBuiltinExec: {
		url: 'https://262.ecma-international.org/7.0/#sec-regexpbuiltinexec'
	},
	RegExpCreate: {
		url: 'https://262.ecma-international.org/7.0/#sec-regexpcreate'
	},
	RegExpExec: {
		url: 'https://262.ecma-international.org/7.0/#sec-regexpexec'
	},
	RegExpInitialize: {
		url: 'https://262.ecma-international.org/7.0/#sec-regexpinitialize'
	},
	RejectPromise: {
		url: 'https://262.ecma-international.org/7.0/#sec-rejectpromise'
	},
	RepeatMatcher: {
		url: 'https://262.ecma-international.org/7.0/#sec-runtime-semantics-repeatmatcher-abstract-operation'
	},
	RequireObjectCoercible: {
		url: 'https://262.ecma-international.org/7.0/#sec-requireobjectcoercible'
	},
	ResolveBinding: {
		url: 'https://262.ecma-international.org/7.0/#sec-resolvebinding'
	},
	ResolveThisBinding: {
		url: 'https://262.ecma-international.org/7.0/#sec-resolvethisbinding'
	},
	ReturnIfAbrupt: {
		url: 'https://262.ecma-international.org/7.0/#sec-returnifabrupt'
	},
	SameValue: {
		url: 'https://262.ecma-international.org/7.0/#sec-samevalue'
	},
	SameValueNonNumber: {
		url: 'https://262.ecma-international.org/7.0/#sec-samevaluenonnumber'
	},
	SameValueZero: {
		url: 'https://262.ecma-international.org/7.0/#sec-samevaluezero'
	},
	ScriptEvaluation: {
		url: 'https://262.ecma-international.org/7.0/#sec-runtime-semantics-scriptevaluation'
	},
	ScriptEvaluationJob: {
		url: 'https://262.ecma-international.org/7.0/#sec-scriptevaluationjob'
	},
	SecFromTime: {
		url: 'https://262.ecma-international.org/7.0/#sec-hours-minutes-second-and-milliseconds'
	},
	SerializeJSONArray: {
		url: 'https://262.ecma-international.org/7.0/#sec-serializejsonarray'
	},
	SerializeJSONObject: {
		url: 'https://262.ecma-international.org/7.0/#sec-serializejsonobject'
	},
	SerializeJSONProperty: {
		url: 'https://262.ecma-international.org/7.0/#sec-serializejsonproperty'
	},
	Set: {
		url: 'https://262.ecma-international.org/7.0/#sec-set-o-p-v-throw'
	},
	SetDefaultGlobalBindings: {
		url: 'https://262.ecma-international.org/7.0/#sec-setdefaultglobalbindings'
	},
	SetFunctionName: {
		url: 'https://262.ecma-international.org/7.0/#sec-setfunctionname'
	},
	SetIntegrityLevel: {
		url: 'https://262.ecma-international.org/7.0/#sec-setintegritylevel'
	},
	SetRealmGlobalObject: {
		url: 'https://262.ecma-international.org/7.0/#sec-setrealmglobalobject'
	},
	SetValueInBuffer: {
		url: 'https://262.ecma-international.org/7.0/#sec-setvalueinbuffer'
	},
	SetViewValue: {
		url: 'https://262.ecma-international.org/7.0/#sec-setviewvalue'
	},
	SortCompare: {
		url: 'https://262.ecma-international.org/7.0/#sec-sortcompare'
	},
	SpeciesConstructor: {
		url: 'https://262.ecma-international.org/7.0/#sec-speciesconstructor'
	},
	SplitMatch: {
		url: 'https://262.ecma-international.org/7.0/#sec-splitmatch'
	},
	'Strict Equality Comparison': {
		url: 'https://262.ecma-international.org/7.0/#sec-strict-equality-comparison'
	},
	StringCreate: {
		url: 'https://262.ecma-international.org/7.0/#sec-stringcreate'
	},
	SymbolDescriptiveString: {
		url: 'https://262.ecma-international.org/7.0/#sec-symboldescriptivestring'
	},
	TestIntegrityLevel: {
		url: 'https://262.ecma-international.org/7.0/#sec-testintegritylevel'
	},
	thisBooleanValue: {
		url: 'https://262.ecma-international.org/7.0/#sec-thisbooleanvalue'
	},
	thisNumberValue: {
		url: 'https://262.ecma-international.org/7.0/#sec-properties-of-the-number-prototype-object'
	},
	thisStringValue: {
		url: 'https://262.ecma-international.org/7.0/#sec-properties-of-the-string-prototype-object'
	},
	thisTimeValue: {
		url: 'https://262.ecma-international.org/7.0/#sec-properties-of-the-date-prototype-object'
	},
	TimeClip: {
		url: 'https://262.ecma-international.org/7.0/#sec-timeclip'
	},
	TimeFromYear: {
		url: 'https://262.ecma-international.org/7.0/#sec-year-number'
	},
	TimeWithinDay: {
		url: 'https://262.ecma-international.org/7.0/#sec-day-number-and-time-within-day'
	},
	ToBoolean: {
		url: 'https://262.ecma-international.org/7.0/#sec-toboolean'
	},
	ToDateString: {
		url: 'https://262.ecma-international.org/7.0/#sec-todatestring'
	},
	ToInt16: {
		url: 'https://262.ecma-international.org/7.0/#sec-toint16'
	},
	ToInt32: {
		url: 'https://262.ecma-international.org/7.0/#sec-toint32'
	},
	ToInt8: {
		url: 'https://262.ecma-international.org/7.0/#sec-toint8'
	},
	ToInteger: {
		url: 'https://262.ecma-international.org/7.0/#sec-tointeger'
	},
	ToLength: {
		url: 'https://262.ecma-international.org/7.0/#sec-tolength'
	},
	ToNumber: {
		url: 'https://262.ecma-international.org/7.0/#sec-tonumber'
	},
	ToObject: {
		url: 'https://262.ecma-international.org/7.0/#sec-toobject'
	},
	TopLevelModuleEvaluationJob: {
		url: 'https://262.ecma-international.org/7.0/#sec-toplevelmoduleevaluationjob'
	},
	ToPrimitive: {
		url: 'https://262.ecma-international.org/7.0/#sec-toprimitive'
	},
	ToPropertyDescriptor: {
		url: 'https://262.ecma-international.org/7.0/#sec-topropertydescriptor'
	},
	ToPropertyKey: {
		url: 'https://262.ecma-international.org/7.0/#sec-topropertykey'
	},
	ToString: {
		url: 'https://262.ecma-international.org/7.0/#sec-tostring'
	},
	'ToString Applied to the Number Type': {
		url: 'https://262.ecma-international.org/7.0/#sec-tostring-applied-to-the-number-type'
	},
	ToUint16: {
		url: 'https://262.ecma-international.org/7.0/#sec-touint16'
	},
	ToUint32: {
		url: 'https://262.ecma-international.org/7.0/#sec-touint32'
	},
	ToUint8: {
		url: 'https://262.ecma-international.org/7.0/#sec-touint8'
	},
	ToUint8Clamp: {
		url: 'https://262.ecma-international.org/7.0/#sec-touint8clamp'
	},
	TriggerPromiseReactions: {
		url: 'https://262.ecma-international.org/7.0/#sec-triggerpromisereactions'
	},
	Type: {
		url: 'https://262.ecma-international.org/7.0/#sec-ecmascript-data-types-and-values'
	},
	TypedArrayCreate: {
		url: 'https://262.ecma-international.org/7.0/#typedarray-create'
	},
	TypedArraySpeciesCreate: {
		url: 'https://262.ecma-international.org/7.0/#typedarray-species-create'
	},
	UpdateEmpty: {
		url: 'https://262.ecma-international.org/7.0/#sec-updateempty'
	},
	UTC: {
		url: 'https://262.ecma-international.org/7.0/#sec-utc-t'
	},
	UTF16Decode: {
		url: 'https://262.ecma-international.org/7.0/#sec-utf16decode'
	},
	UTF16Encoding: {
		url: 'https://262.ecma-international.org/7.0/#sec-utf16encoding'
	},
	ValidateAndApplyPropertyDescriptor: {
		url: 'https://262.ecma-international.org/7.0/#sec-validateandapplypropertydescriptor'
	},
	ValidateTypedArray: {
		url: 'https://262.ecma-international.org/7.0/#sec-validatetypedarray'
	},
	WeekDay: {
		url: 'https://262.ecma-international.org/7.0/#sec-week-day'
	},
	YearFromTime: {
		url: 'https://262.ecma-international.org/7.0/#sec-year-number'
	}
};
'use strict';

module.exports = {
	IsPropertyDescriptor: 'https://262.ecma-international.org/6.0/#sec-property-descriptor-specification-type', // not actually an abstract op

	abs: {
		url: 'https://262.ecma-international.org/8.0/#eqn-abs'
	},
	'Abstract Equality Comparison': {
		url: 'https://262.ecma-international.org/8.0/#sec-abstract-equality-comparison'
	},
	'Abstract Relational Comparison': {
		url: 'https://262.ecma-international.org/8.0/#sec-abstract-relational-comparison'
	},
	AddRestrictedFunctionProperties: {
		url: 'https://262.ecma-international.org/8.0/#sec-addrestrictedfunctionproperties'
	},
	AddWaiter: {
		url: 'https://262.ecma-international.org/8.0/#sec-addwaiter'
	},
	AdvanceStringIndex: {
		url: 'https://262.ecma-international.org/8.0/#sec-advancestringindex'
	},
	'agent-order': {
		url: 'https://262.ecma-international.org/8.0/#sec-agent-order'
	},
	AgentCanSuspend: {
		url: 'https://262.ecma-international.org/8.0/#sec-agentcansuspend'
	},
	AgentSignifier: {
		url: 'https://262.ecma-international.org/8.0/#sec-agentsignifier'
	},
	AllocateArrayBuffer: {
		url: 'https://262.ecma-international.org/8.0/#sec-allocatearraybuffer'
	},
	AllocateSharedArrayBuffer: {
		url: 'https://262.ecma-international.org/8.0/#sec-allocatesharedarraybuffer'
	},
	AllocateTypedArray: {
		url: 'https://262.ecma-international.org/8.0/#sec-allocatetypedarray'
	},
	AllocateTypedArrayBuffer: {
		url: 'https://262.ecma-international.org/8.0/#sec-allocatetypedarraybuffer'
	},
	ArrayCreate: {
		url: 'https://262.ecma-international.org/8.0/#sec-arraycreate'
	},
	ArraySetLength: {
		url: 'https://262.ecma-international.org/8.0/#sec-arraysetlength'
	},
	ArraySpeciesCreate: {
		url: 'https://262.ecma-international.org/8.0/#sec-arrayspeciescreate'
	},
	AsyncFunctionAwait: {
		url: 'https://262.ecma-international.org/8.0/#sec-async-functions-abstract-operations-async-function-await'
	},
	AsyncFunctionCreate: {
		url: 'https://262.ecma-international.org/8.0/#sec-async-functions-abstract-operations-async-function-create'
	},
	AsyncFunctionStart: {
		url: 'https://262.ecma-international.org/8.0/#sec-async-functions-abstract-operations-async-function-start'
	},
	AtomicLoad: {
		url: 'https://262.ecma-international.org/8.0/#sec-atomicload'
	},
	AtomicReadModifyWrite: {
		url: 'https://262.ecma-international.org/8.0/#sec-atomicreadmodifywrite'
	},
	BlockDeclarationInstantiation: {
		url: 'https://262.ecma-international.org/8.0/#sec-blockdeclarationinstantiation'
	},
	BoundFunctionCreate: {
		url: 'https://262.ecma-international.org/8.0/#sec-boundfunctioncreate'
	},
	Call: {
		url: 'https://262.ecma-international.org/8.0/#sec-call'
	},
	Canonicalize: {
		url: 'https://262.ecma-international.org/8.0/#sec-runtime-semantics-canonicalize-ch'
	},
	CanonicalNumericIndexString: {
		url: 'https://262.ecma-international.org/8.0/#sec-canonicalnumericindexstring'
	},
	CharacterRange: {
		url: 'https://262.ecma-international.org/8.0/#sec-runtime-semantics-characterrange-abstract-operation'
	},
	CharacterRangeOrUnion: {
		url: 'https://262.ecma-international.org/8.0/#sec-runtime-semantics-characterrangeorunion-abstract-operation'
	},
	CharacterSetMatcher: {
		url: 'https://262.ecma-international.org/8.0/#sec-runtime-semantics-charactersetmatcher-abstract-operation'
	},
	CloneArrayBuffer: {
		url: 'https://262.ecma-international.org/8.0/#sec-clonearraybuffer'
	},
	CompletePropertyDescriptor: {
		url: 'https://262.ecma-international.org/8.0/#sec-completepropertydescriptor'
	},
	Completion: {
		url: 'https://262.ecma-international.org/8.0/#sec-completion-record-specification-type'
	},
	CompletionRecord: {
		url: 'https://262.ecma-international.org/8.0/#sec-completion-record-specification-type'
	},
	ComposeWriteEventBytes: {
		url: 'https://262.ecma-international.org/8.0/#sec-composewriteeventbytes'
	},
	Construct: {
		url: 'https://262.ecma-international.org/8.0/#sec-construct'
	},
	CopyDataBlockBytes: {
		url: 'https://262.ecma-international.org/8.0/#sec-copydatablockbytes'
	},
	CreateArrayFromList: {
		url: 'https://262.ecma-international.org/8.0/#sec-createarrayfromlist'
	},
	CreateArrayIterator: {
		url: 'https://262.ecma-international.org/8.0/#sec-createarrayiterator'
	},
	CreateBuiltinFunction: {
		url: 'https://262.ecma-international.org/8.0/#sec-createbuiltinfunction'
	},
	CreateByteDataBlock: {
		url: 'https://262.ecma-international.org/8.0/#sec-createbytedatablock'
	},
	CreateDataProperty: {
		url: 'https://262.ecma-international.org/8.0/#sec-createdataproperty'
	},
	CreateDataPropertyOrThrow: {
		url: 'https://262.ecma-international.org/8.0/#sec-createdatapropertyorthrow'
	},
	CreateDynamicFunction: {
		url: 'https://262.ecma-international.org/8.0/#sec-createdynamicfunction'
	},
	CreateHTML: {
		url: 'https://262.ecma-international.org/8.0/#sec-createhtml'
	},
	CreateIntrinsics: {
		url: 'https://262.ecma-international.org/8.0/#sec-createintrinsics'
	},
	CreateIterResultObject: {
		url: 'https://262.ecma-international.org/8.0/#sec-createiterresultobject'
	},
	CreateListFromArrayLike: {
		url: 'https://262.ecma-international.org/8.0/#sec-createlistfromarraylike'
	},
	CreateListIterator: {
		url: 'https://262.ecma-international.org/8.0/#sec-createlistiterator'
	},
	CreateMapIterator: {
		url: 'https://262.ecma-international.org/8.0/#sec-createmapiterator'
	},
	CreateMappedArgumentsObject: {
		url: 'https://262.ecma-international.org/8.0/#sec-createmappedargumentsobject'
	},
	CreateMethodProperty: {
		url: 'https://262.ecma-international.org/8.0/#sec-createmethodproperty'
	},
	CreatePerIterationEnvironment: {
		url: 'https://262.ecma-international.org/8.0/#sec-createperiterationenvironment'
	},
	CreateRealm: {
		url: 'https://262.ecma-international.org/8.0/#sec-createrealm'
	},
	CreateResolvingFunctions: {
		url: 'https://262.ecma-international.org/8.0/#sec-createresolvingfunctions'
	},
	CreateSetIterator: {
		url: 'https://262.ecma-international.org/8.0/#sec-createsetiterator'
	},
	CreateSharedByteDataBlock: {
		url: 'https://262.ecma-international.org/8.0/#sec-createsharedbytedatablock'
	},
	CreateStringIterator: {
		url: 'https://262.ecma-international.org/8.0/#sec-createstringiterator'
	},
	CreateUnmappedArgumentsObject: {
		url: 'https://262.ecma-international.org/8.0/#sec-createunmappedargumentsobject'
	},
	DateFromTime: {
		url: 'https://262.ecma-international.org/8.0/#sec-date-number'
	},
	Day: {
		url: 'https://262.ecma-international.org/8.0/#eqn-Day'
	},
	DayFromYear: {
		url: 'https://262.ecma-international.org/8.0/#eqn-DaysFromYear'
	},
	DaylightSavingTA: {
		url: 'https://262.ecma-international.org/8.0/#sec-daylight-saving-time-adjustment'
	},
	DaysInYear: {
		url: 'https://262.ecma-international.org/8.0/#eqn-DaysInYear'
	},
	DayWithinYear: {
		url: 'https://262.ecma-international.org/8.0/#eqn-DayWithinYear'
	},
	Decode: {
		url: 'https://262.ecma-international.org/8.0/#sec-decode'
	},
	DefinePropertyOrThrow: {
		url: 'https://262.ecma-international.org/8.0/#sec-definepropertyorthrow'
	},
	DeletePropertyOrThrow: {
		url: 'https://262.ecma-international.org/8.0/#sec-deletepropertyorthrow'
	},
	DetachArrayBuffer: {
		url: 'https://262.ecma-international.org/8.0/#sec-detacharraybuffer'
	},
	Encode: {
		url: 'https://262.ecma-international.org/8.0/#sec-encode'
	},
	EnqueueJob: {
		url: 'https://262.ecma-international.org/8.0/#sec-enqueuejob'
	},
	EnterCriticalSection: {
		url: 'https://262.ecma-international.org/8.0/#sec-entercriticalsection'
	},
	EnumerableOwnProperties: {
		url: 'https://262.ecma-international.org/8.0/#sec-enumerableownproperties'
	},
	EnumerateObjectProperties: {
		url: 'https://262.ecma-international.org/8.0/#sec-enumerate-object-properties'
	},
	EscapeRegExpPattern: {
		url: 'https://262.ecma-international.org/8.0/#sec-escaperegexppattern'
	},
	EvalDeclarationInstantiation: {
		url: 'https://262.ecma-international.org/8.0/#sec-evaldeclarationinstantiation'
	},
	EvaluateCall: {
		url: 'https://262.ecma-international.org/8.0/#sec-evaluatecall'
	},
	EvaluateDirectCall: {
		url: 'https://262.ecma-international.org/8.0/#sec-evaluatedirectcall'
	},
	EvaluateNew: {
		url: 'https://262.ecma-international.org/8.0/#sec-evaluatenew'
	},
	EventSet: {
		url: 'https://262.ecma-international.org/8.0/#sec-event-set'
	},
	floor: {
		url: 'https://262.ecma-international.org/8.0/#eqn-floor'
	},
	ForBodyEvaluation: {
		url: 'https://262.ecma-international.org/8.0/#sec-forbodyevaluation'
	},
	'ForIn/OfBodyEvaluation': {
		url: 'https://262.ecma-international.org/8.0/#sec-runtime-semantics-forin-div-ofbodyevaluation-lhs-stmt-iterator-lhskind-labelset'
	},
	'ForIn/OfHeadEvaluation': {
		url: 'https://262.ecma-international.org/8.0/#sec-runtime-semantics-forin-div-ofheadevaluation-tdznames-expr-iterationkind'
	},
	FromPropertyDescriptor: {
		url: 'https://262.ecma-international.org/8.0/#sec-frompropertydescriptor'
	},
	FulfillPromise: {
		url: 'https://262.ecma-international.org/8.0/#sec-fulfillpromise'
	},
	FunctionAllocate: {
		url: 'https://262.ecma-international.org/8.0/#sec-functionallocate'
	},
	FunctionCreate: {
		url: 'https://262.ecma-international.org/8.0/#sec-functioncreate'
	},
	FunctionDeclarationInstantiation: {
		url: 'https://262.ecma-international.org/8.0/#sec-functiondeclarationinstantiation'
	},
	FunctionInitialize: {
		url: 'https://262.ecma-international.org/8.0/#sec-functioninitialize'
	},
	GeneratorFunctionCreate: {
		url: 'https://262.ecma-international.org/8.0/#sec-generatorfunctioncreate'
	},
	GeneratorResume: {
		url: 'https://262.ecma-international.org/8.0/#sec-generatorresume'
	},
	GeneratorResumeAbrupt: {
		url: 'https://262.ecma-international.org/8.0/#sec-generatorresumeabrupt'
	},
	GeneratorStart: {
		url: 'https://262.ecma-international.org/8.0/#sec-generatorstart'
	},
	GeneratorValidate: {
		url: 'https://262.ecma-international.org/8.0/#sec-generatorvalidate'
	},
	GeneratorYield: {
		url: 'https://262.ecma-international.org/8.0/#sec-generatoryield'
	},
	Get: {
		url: 'https://262.ecma-international.org/8.0/#sec-get-o-p'
	},
	GetActiveScriptOrModule: {
		url: 'https://262.ecma-international.org/8.0/#sec-getactivescriptormodule'
	},
	GetBase: {
		url: 'https://262.ecma-international.org/8.0/#ao-getbase'
	},
	GetFunctionRealm: {
		url: 'https://262.ecma-international.org/8.0/#sec-getfunctionrealm'
	},
	GetGlobalObject: {
		url: 'https://262.ecma-international.org/8.0/#sec-getglobalobject'
	},
	GetIdentifierReference: {
		url: 'https://262.ecma-international.org/8.0/#sec-getidentifierreference'
	},
	GetIterator: {
		url: 'https://262.ecma-international.org/8.0/#sec-getiterator'
	},
	GetMethod: {
		url: 'https://262.ecma-international.org/8.0/#sec-getmethod'
	},
	GetModifySetValueInBuffer: {
		url: 'https://262.ecma-international.org/8.0/#sec-getmodifysetvalueinbuffer'
	},
	GetModuleNamespace: {
		url: 'https://262.ecma-international.org/8.0/#sec-getmodulenamespace'
	},
	GetNewTarget: {
		url: 'https://262.ecma-international.org/8.0/#sec-getnewtarget'
	},
	GetOwnPropertyKeys: {
		url: 'https://262.ecma-international.org/8.0/#sec-getownpropertykeys'
	},
	GetPrototypeFromConstructor: {
		url: 'https://262.ecma-international.org/8.0/#sec-getprototypefromconstructor'
	},
	GetReferencedName: {
		url: 'https://262.ecma-international.org/8.0/#ao-getreferencedname'
	},
	GetSubstitution: {
		url: 'https://262.ecma-international.org/8.0/#sec-getsubstitution'
	},
	GetSuperConstructor: {
		url: 'https://262.ecma-international.org/8.0/#sec-getsuperconstructor'
	},
	GetTemplateObject: {
		url: 'https://262.ecma-international.org/8.0/#sec-gettemplateobject'
	},
	GetThisEnvironment: {
		url: 'https://262.ecma-international.org/8.0/#sec-getthisenvironment'
	},
	GetThisValue: {
		url: 'https://262.ecma-international.org/8.0/#sec-getthisvalue'
	},
	GetV: {
		url: 'https://262.ecma-international.org/8.0/#sec-getv'
	},
	GetValue: {
		url: 'https://262.ecma-international.org/8.0/#sec-getvalue'
	},
	GetValueFromBuffer: {
		url: 'https://262.ecma-international.org/8.0/#sec-getvaluefrombuffer'
	},
	GetViewValue: {
		url: 'https://262.ecma-international.org/8.0/#sec-getviewvalue'
	},
	GetWaiterList: {
		url: 'https://262.ecma-international.org/8.0/#sec-getwaiterlist'
	},
	GlobalDeclarationInstantiation: {
		url: 'https://262.ecma-international.org/8.0/#sec-globaldeclarationinstantiation'
	},
	'happens-before': {
		url: 'https://262.ecma-international.org/8.0/#sec-happens-before'
	},
	HasOwnProperty: {
		url: 'https://262.ecma-international.org/8.0/#sec-hasownproperty'
	},
	HasPrimitiveBase: {
		url: 'https://262.ecma-international.org/8.0/#ao-hasprimitivebase'
	},
	HasProperty: {
		url: 'https://262.ecma-international.org/8.0/#sec-hasproperty'
	},
	'host-synchronizes-with': {
		url: 'https://262.ecma-international.org/8.0/#sec-host-synchronizes-with'
	},
	HostEventSet: {
		url: 'https://262.ecma-international.org/8.0/#sec-hosteventset'
	},
	HourFromTime: {
		url: 'https://262.ecma-international.org/8.0/#eqn-HourFromTime'
	},
	IfAbruptRejectPromise: {
		url: 'https://262.ecma-international.org/8.0/#sec-ifabruptrejectpromise'
	},
	ImportedLocalNames: {
		url: 'https://262.ecma-international.org/8.0/#sec-importedlocalnames'
	},
	InitializeBoundName: {
		url: 'https://262.ecma-international.org/8.0/#sec-initializeboundname'
	},
	InitializeHostDefinedRealm: {
		url: 'https://262.ecma-international.org/8.0/#sec-initializehostdefinedrealm'
	},
	InitializeReferencedBinding: {
		url: 'https://262.ecma-international.org/8.0/#sec-initializereferencedbinding'
	},
	InLeapYear: {
		url: 'https://262.ecma-international.org/8.0/#eqn-InLeapYear'
	},
	InstanceofOperator: {
		url: 'https://262.ecma-international.org/8.0/#sec-instanceofoperator'
	},
	IntegerIndexedElementGet: {
		url: 'https://262.ecma-international.org/8.0/#sec-integerindexedelementget'
	},
	IntegerIndexedElementSet: {
		url: 'https://262.ecma-international.org/8.0/#sec-integerindexedelementset'
	},
	IntegerIndexedObjectCreate: {
		url: 'https://262.ecma-international.org/8.0/#sec-integerindexedobjectcreate'
	},
	InternalizeJSONProperty: {
		url: 'https://262.ecma-international.org/8.0/#sec-internalizejsonproperty'
	},
	Invoke: {
		url: 'https://262.ecma-international.org/8.0/#sec-invoke'
	},
	IsAccessorDescriptor: {
		url: 'https://262.ecma-international.org/8.0/#sec-isaccessordescriptor'
	},
	IsAnonymousFunctionDefinition: {
		url: 'https://262.ecma-international.org/8.0/#sec-isanonymousfunctiondefinition'
	},
	IsArray: {
		url: 'https://262.ecma-international.org/8.0/#sec-isarray'
	},
	IsCallable: {
		url: 'https://262.ecma-international.org/8.0/#sec-iscallable'
	},
	IsCompatiblePropertyDescriptor: {
		url: 'https://262.ecma-international.org/8.0/#sec-iscompatiblepropertydescriptor'
	},
	IsConcatSpreadable: {
		url: 'https://262.ecma-international.org/8.0/#sec-isconcatspreadable'
	},
	IsConstructor: {
		url: 'https://262.ecma-international.org/8.0/#sec-isconstructor'
	},
	IsDataDescriptor: {
		url: 'https://262.ecma-international.org/8.0/#sec-isdatadescriptor'
	},
	IsDetachedBuffer: {
		url: 'https://262.ecma-international.org/8.0/#sec-isdetachedbuffer'
	},
	IsExtensible: {
		url: 'https://262.ecma-international.org/8.0/#sec-isextensible-o'
	},
	IsGenericDescriptor: {
		url: 'https://262.ecma-international.org/8.0/#sec-isgenericdescriptor'
	},
	IsInTailPosition: {
		url: 'https://262.ecma-international.org/8.0/#sec-isintailposition'
	},
	IsInteger: {
		url: 'https://262.ecma-international.org/8.0/#sec-isinteger'
	},
	IsLabelledFunction: {
		url: 'https://262.ecma-international.org/8.0/#sec-islabelledfunction'
	},
	IsPromise: {
		url: 'https://262.ecma-international.org/8.0/#sec-ispromise'
	},
	IsPropertyKey: {
		url: 'https://262.ecma-international.org/8.0/#sec-ispropertykey'
	},
	IsPropertyReference: {
		url: 'https://262.ecma-international.org/8.0/#ao-ispropertyreference'
	},
	IsRegExp: {
		url: 'https://262.ecma-international.org/8.0/#sec-isregexp'
	},
	IsSharedArrayBuffer: {
		url: 'https://262.ecma-international.org/8.0/#sec-issharedarraybuffer'
	},
	IsStrictReference: {
		url: 'https://262.ecma-international.org/8.0/#ao-isstrictreference'
	},
	IsSuperReference: {
		url: 'https://262.ecma-international.org/8.0/#ao-issuperreference'
	},
	IsUnresolvableReference: {
		url: 'https://262.ecma-international.org/8.0/#ao-isunresolvablereference'
	},
	IsWordChar: {
		url: 'https://262.ecma-international.org/8.0/#sec-runtime-semantics-iswordchar-abstract-operation'
	},
	IterableToList: {
		url: 'https://262.ecma-international.org/8.0/#sec-iterabletolist'
	},
	IteratorClose: {
		url: 'https://262.ecma-international.org/8.0/#sec-iteratorclose'
	},
	IteratorComplete: {
		url: 'https://262.ecma-international.org/8.0/#sec-iteratorcomplete'
	},
	IteratorNext: {
		url: 'https://262.ecma-international.org/8.0/#sec-iteratornext'
	},
	IteratorStep: {
		url: 'https://262.ecma-international.org/8.0/#sec-iteratorstep'
	},
	IteratorValue: {
		url: 'https://262.ecma-international.org/8.0/#sec-iteratorvalue'
	},
	LeaveCriticalSection: {
		url: 'https://262.ecma-international.org/8.0/#sec-leavecriticalsection'
	},
	LocalTime: {
		url: 'https://262.ecma-international.org/8.0/#sec-localtime'
	},
	LoopContinues: {
		url: 'https://262.ecma-international.org/8.0/#sec-loopcontinues'
	},
	MakeArgGetter: {
		url: 'https://262.ecma-international.org/8.0/#sec-makearggetter'
	},
	MakeArgSetter: {
		url: 'https://262.ecma-international.org/8.0/#sec-makeargsetter'
	},
	MakeClassConstructor: {
		url: 'https://262.ecma-international.org/8.0/#sec-makeclassconstructor'
	},
	MakeConstructor: {
		url: 'https://262.ecma-international.org/8.0/#sec-makeconstructor'
	},
	MakeDate: {
		url: 'https://262.ecma-international.org/8.0/#sec-makedate'
	},
	MakeDay: {
		url: 'https://262.ecma-international.org/8.0/#sec-makeday'
	},
	MakeMethod: {
		url: 'https://262.ecma-international.org/8.0/#sec-makemethod'
	},
	MakeSuperPropertyReference: {
		url: 'https://262.ecma-international.org/8.0/#sec-makesuperpropertyreference'
	},
	MakeTime: {
		url: 'https://262.ecma-international.org/8.0/#sec-maketime'
	},
	max: {
		url: 'https://262.ecma-international.org/8.0/#eqn-max'
	},
	'memory-order': {
		url: 'https://262.ecma-international.org/8.0/#sec-memory-order'
	},
	min: {
		url: 'https://262.ecma-international.org/8.0/#eqn-min'
	},
	MinFromTime: {
		url: 'https://262.ecma-international.org/8.0/#eqn-MinFromTime'
	},
	ModuleNamespaceCreate: {
		url: 'https://262.ecma-international.org/8.0/#sec-modulenamespacecreate'
	},
	modulo: {
		url: 'https://262.ecma-international.org/8.0/#eqn-modulo'
	},
	MonthFromTime: {
		url: 'https://262.ecma-international.org/8.0/#eqn-MonthFromTime'
	},
	msFromTime: {
		url: 'https://262.ecma-international.org/8.0/#eqn-msFromTime'
	},
	NewDeclarativeEnvironment: {
		url: 'https://262.ecma-international.org/8.0/#sec-newdeclarativeenvironment'
	},
	NewFunctionEnvironment: {
		url: 'https://262.ecma-international.org/8.0/#sec-newfunctionenvironment'
	},
	NewGlobalEnvironment: {
		url: 'https://262.ecma-international.org/8.0/#sec-newglobalenvironment'
	},
	NewModuleEnvironment: {
		url: 'https://262.ecma-international.org/8.0/#sec-newmoduleenvironment'
	},
	NewObjectEnvironment: {
		url: 'https://262.ecma-international.org/8.0/#sec-newobjectenvironment'
	},
	NewPromiseCapability: {
		url: 'https://262.ecma-international.org/8.0/#sec-newpromisecapability'
	},
	NormalCompletion: {
		url: 'https://262.ecma-international.org/8.0/#sec-normalcompletion'
	},
	NumberToRawBytes: {
		url: 'https://262.ecma-international.org/8.0/#sec-numbertorawbytes'
	},
	ObjectCreate: {
		url: 'https://262.ecma-international.org/8.0/#sec-objectcreate'
	},
	ObjectDefineProperties: {
		url: 'https://262.ecma-international.org/8.0/#sec-objectdefineproperties'
	},
	OrdinaryCallBindThis: {
		url: 'https://262.ecma-international.org/8.0/#sec-ordinarycallbindthis'
	},
	OrdinaryCallEvaluateBody: {
		url: 'https://262.ecma-international.org/8.0/#sec-ordinarycallevaluatebody'
	},
	OrdinaryCreateFromConstructor: {
		url: 'https://262.ecma-international.org/8.0/#sec-ordinarycreatefromconstructor'
	},
	OrdinaryDefineOwnProperty: {
		url: 'https://262.ecma-international.org/8.0/#sec-ordinarydefineownproperty'
	},
	OrdinaryDelete: {
		url: 'https://262.ecma-international.org/8.0/#sec-ordinarydelete'
	},
	OrdinaryGet: {
		url: 'https://262.ecma-international.org/8.0/#sec-ordinaryget'
	},
	OrdinaryGetOwnProperty: {
		url: 'https://262.ecma-international.org/8.0/#sec-ordinarygetownproperty'
	},
	OrdinaryGetPrototypeOf: {
		url: 'https://262.ecma-international.org/8.0/#sec-ordinarygetprototypeof'
	},
	OrdinaryHasInstance: {
		url: 'https://262.ecma-international.org/8.0/#sec-ordinaryhasinstance'
	},
	OrdinaryHasProperty: {
		url: 'https://262.ecma-international.org/8.0/#sec-ordinaryhasproperty'
	},
	OrdinaryIsExtensible: {
		url: 'https://262.ecma-international.org/8.0/#sec-ordinaryisextensible'
	},
	OrdinaryOwnPropertyKeys: {
		url: 'https://262.ecma-international.org/8.0/#sec-ordinaryownpropertykeys'
	},
	OrdinaryPreventExtensions: {
		url: 'https://262.ecma-international.org/8.0/#sec-ordinarypreventextensions'
	},
	OrdinarySet: {
		url: 'https://262.ecma-international.org/8.0/#sec-ordinaryset'
	},
	OrdinarySetPrototypeOf: {
		url: 'https://262.ecma-international.org/8.0/#sec-ordinarysetprototypeof'
	},
	OrdinaryToPrimitive: {
		url: 'https://262.ecma-international.org/8.0/#sec-ordinarytoprimitive'
	},
	ParseModule: {
		url: 'https://262.ecma-international.org/8.0/#sec-parsemodule'
	},
	ParseScript: {
		url: 'https://262.ecma-international.org/8.0/#sec-parse-script'
	},
	PerformEval: {
		url: 'https://262.ecma-international.org/8.0/#sec-performeval'
	},
	PerformPromiseAll: {
		url: 'https://262.ecma-international.org/8.0/#sec-performpromiseall'
	},
	PerformPromiseRace: {
		url: 'https://262.ecma-international.org/8.0/#sec-performpromiserace'
	},
	PerformPromiseThen: {
		url: 'https://262.ecma-international.org/8.0/#sec-performpromisethen'
	},
	PrepareForOrdinaryCall: {
		url: 'https://262.ecma-international.org/8.0/#sec-prepareforordinarycall'
	},
	PrepareForTailCall: {
		url: 'https://262.ecma-international.org/8.0/#sec-preparefortailcall'
	},
	PromiseReactionJob: {
		url: 'https://262.ecma-international.org/8.0/#sec-promisereactionjob'
	},
	PromiseResolveThenableJob: {
		url: 'https://262.ecma-international.org/8.0/#sec-promiseresolvethenablejob'
	},
	ProxyCreate: {
		url: 'https://262.ecma-international.org/8.0/#sec-proxycreate'
	},
	PutValue: {
		url: 'https://262.ecma-international.org/8.0/#sec-putvalue'
	},
	QuoteJSONString: {
		url: 'https://262.ecma-international.org/8.0/#sec-quotejsonstring'
	},
	RawBytesToNumber: {
		url: 'https://262.ecma-international.org/8.0/#sec-rawbytestonumber'
	},
	'reads-bytes-from': {
		url: 'https://262.ecma-international.org/8.0/#sec-reads-bytes-from'
	},
	'reads-from': {
		url: 'https://262.ecma-international.org/8.0/#sec-reads-from'
	},
	RegExpAlloc: {
		url: 'https://262.ecma-international.org/8.0/#sec-regexpalloc'
	},
	RegExpBuiltinExec: {
		url: 'https://262.ecma-international.org/8.0/#sec-regexpbuiltinexec'
	},
	RegExpCreate: {
		url: 'https://262.ecma-international.org/8.0/#sec-regexpcreate'
	},
	RegExpExec: {
		url: 'https://262.ecma-international.org/8.0/#sec-regexpexec'
	},
	RegExpInitialize: {
		url: 'https://262.ecma-international.org/8.0/#sec-regexpinitialize'
	},
	RejectPromise: {
		url: 'https://262.ecma-international.org/8.0/#sec-rejectpromise'
	},
	RemoveWaiter: {
		url: 'https://262.ecma-international.org/8.0/#sec-removewaiter'
	},
	RemoveWaiters: {
		url: 'https://262.ecma-international.org/8.0/#sec-removewaiters'
	},
	RepeatMatcher: {
		url: 'https://262.ecma-international.org/8.0/#sec-runtime-semantics-repeatmatcher-abstract-operation'
	},
	RequireObjectCoercible: {
		url: 'https://262.ecma-international.org/8.0/#sec-requireobjectcoercible'
	},
	ResolveBinding: {
		url: 'https://262.ecma-international.org/8.0/#sec-resolvebinding'
	},
	ResolveThisBinding: {
		url: 'https://262.ecma-international.org/8.0/#sec-resolvethisbinding'
	},
	ReturnIfAbrupt: {
		url: 'https://262.ecma-international.org/8.0/#sec-returnifabrupt'
	},
	RunJobs: {
		url: 'https://262.ecma-international.org/8.0/#sec-runjobs'
	},
	SameValue: {
		url: 'https://262.ecma-international.org/8.0/#sec-samevalue'
	},
	SameValueNonNumber: {
		url: 'https://262.ecma-international.org/8.0/#sec-samevaluenonnumber'
	},
	SameValueZero: {
		url: 'https://262.ecma-international.org/8.0/#sec-samevaluezero'
	},
	ScriptEvaluation: {
		url: 'https://262.ecma-international.org/8.0/#sec-runtime-semantics-scriptevaluation'
	},
	ScriptEvaluationJob: {
		url: 'https://262.ecma-international.org/8.0/#sec-scriptevaluationjob'
	},
	SecFromTime: {
		url: 'https://262.ecma-international.org/8.0/#eqn-SecFromTime'
	},
	SerializeJSONArray: {
		url: 'https://262.ecma-international.org/8.0/#sec-serializejsonarray'
	},
	SerializeJSONObject: {
		url: 'https://262.ecma-international.org/8.0/#sec-serializejsonobject'
	},
	SerializeJSONProperty: {
		url: 'https://262.ecma-international.org/8.0/#sec-serializejsonproperty'
	},
	Set: {
		url: 'https://262.ecma-international.org/8.0/#sec-set-o-p-v-throw'
	},
	SetDefaultGlobalBindings: {
		url: 'https://262.ecma-international.org/8.0/#sec-setdefaultglobalbindings'
	},
	SetFunctionName: {
		url: 'https://262.ecma-international.org/8.0/#sec-setfunctionname'
	},
	SetImmutablePrototype: {
		url: 'https://262.ecma-international.org/8.0/#sec-set-immutable-prototype'
	},
	SetIntegrityLevel: {
		url: 'https://262.ecma-international.org/8.0/#sec-setintegritylevel'
	},
	SetRealmGlobalObject: {
		url: 'https://262.ecma-international.org/8.0/#sec-setrealmglobalobject'
	},
	SetValueInBuffer: {
		url: 'https://262.ecma-international.org/8.0/#sec-setvalueinbuffer'
	},
	SetViewValue: {
		url: 'https://262.ecma-international.org/8.0/#sec-setviewvalue'
	},
	SharedDataBlockEventSet: {
		url: 'https://262.ecma-international.org/8.0/#sec-sharedatablockeventset'
	},
	SortCompare: {
		url: 'https://262.ecma-international.org/8.0/#sec-sortcompare'
	},
	SpeciesConstructor: {
		url: 'https://262.ecma-international.org/8.0/#sec-speciesconstructor'
	},
	SplitMatch: {
		url: 'https://262.ecma-international.org/8.0/#sec-splitmatch'
	},
	'Strict Equality Comparison': {
		url: 'https://262.ecma-international.org/8.0/#sec-strict-equality-comparison'
	},
	StringCreate: {
		url: 'https://262.ecma-international.org/8.0/#sec-stringcreate'
	},
	StringGetOwnProperty: {
		url: 'https://262.ecma-international.org/8.0/#sec-stringgetownproperty'
	},
	Suspend: {
		url: 'https://262.ecma-international.org/8.0/#sec-suspend'
	},
	SymbolDescriptiveString: {
		url: 'https://262.ecma-international.org/8.0/#sec-symboldescriptivestring'
	},
	'synchronizes-with': {
		url: 'https://262.ecma-international.org/8.0/#sec-synchronizes-with'
	},
	TestIntegrityLevel: {
		url: 'https://262.ecma-international.org/8.0/#sec-testintegritylevel'
	},
	thisBooleanValue: {
		url: 'https://262.ecma-international.org/8.0/#sec-thisbooleanvalue'
	},
	thisNumberValue: {
		url: 'https://262.ecma-international.org/8.0/#sec-thisnumbervalue'
	},
	thisStringValue: {
		url: 'https://262.ecma-international.org/8.0/#sec-thisstringvalue'
	},
	thisTimeValue: {
		url: 'https://262.ecma-international.org/8.0/#sec-thistimevalue'
	},
	TimeClip: {
		url: 'https://262.ecma-international.org/8.0/#sec-timeclip'
	},
	TimeFromYear: {
		url: 'https://262.ecma-international.org/8.0/#eqn-TimeFromYear'
	},
	TimeWithinDay: {
		url: 'https://262.ecma-international.org/8.0/#eqn-TimeWithinDay'
	},
	ToBoolean: {
		url: 'https://262.ecma-international.org/8.0/#sec-toboolean'
	},
	ToDateString: {
		url: 'https://262.ecma-international.org/8.0/#sec-todatestring'
	},
	ToIndex: {
		url: 'https://262.ecma-international.org/8.0/#sec-toindex'
	},
	ToInt16: {
		url: 'https://262.ecma-international.org/8.0/#sec-toint16'
	},
	ToInt32: {
		url: 'https://262.ecma-international.org/8.0/#sec-toint32'
	},
	ToInt8: {
		url: 'https://262.ecma-international.org/8.0/#sec-toint8'
	},
	ToInteger: {
		url: 'https://262.ecma-international.org/8.0/#sec-tointeger'
	},
	ToLength: {
		url: 'https://262.ecma-international.org/8.0/#sec-tolength'
	},
	ToNumber: {
		url: 'https://262.ecma-international.org/8.0/#sec-tonumber'
	},
	ToObject: {
		url: 'https://262.ecma-international.org/8.0/#sec-toobject'
	},
	TopLevelModuleEvaluationJob: {
		url: 'https://262.ecma-international.org/8.0/#sec-toplevelmoduleevaluationjob'
	},
	ToPrimitive: {
		url: 'https://262.ecma-international.org/8.0/#sec-toprimitive'
	},
	ToPropertyDescriptor: {
		url: 'https://262.ecma-international.org/8.0/#sec-topropertydescriptor'
	},
	ToPropertyKey: {
		url: 'https://262.ecma-international.org/8.0/#sec-topropertykey'
	},
	ToString: {
		url: 'https://262.ecma-international.org/8.0/#sec-tostring'
	},
	'ToString Applied to the Number Type': {
		url: 'https://262.ecma-international.org/8.0/#sec-tostring-applied-to-the-number-type'
	},
	ToUint16: {
		url: 'https://262.ecma-international.org/8.0/#sec-touint16'
	},
	ToUint32: {
		url: 'https://262.ecma-international.org/8.0/#sec-touint32'
	},
	ToUint8: {
		url: 'https://262.ecma-international.org/8.0/#sec-touint8'
	},
	ToUint8Clamp: {
		url: 'https://262.ecma-international.org/8.0/#sec-touint8clamp'
	},
	TriggerPromiseReactions: {
		url: 'https://262.ecma-international.org/8.0/#sec-triggerpromisereactions'
	},
	Type: {
		url: 'https://262.ecma-international.org/8.0/#sec-ecmascript-data-types-and-values'
	},
	TypedArrayCreate: {
		url: 'https://262.ecma-international.org/8.0/#typedarray-create'
	},
	TypedArraySpeciesCreate: {
		url: 'https://262.ecma-international.org/8.0/#typedarray-species-create'
	},
	UpdateEmpty: {
		url: 'https://262.ecma-international.org/8.0/#sec-updateempty'
	},
	UTC: {
		url: 'https://262.ecma-international.org/8.0/#sec-utc-t'
	},
	UTF16Decode: {
		url: 'https://262.ecma-international.org/8.0/#sec-utf16decode'
	},
	UTF16Encoding: {
		url: 'https://262.ecma-international.org/8.0/#sec-utf16encoding'
	},
	ValidateAndApplyPropertyDescriptor: {
		url: 'https://262.ecma-international.org/8.0/#sec-validateandapplypropertydescriptor'
	},
	ValidateAtomicAccess: {
		url: 'https://262.ecma-international.org/8.0/#sec-validateatomicaccess'
	},
	ValidateSharedIntegerTypedArray: {
		url: 'https://262.ecma-international.org/8.0/#sec-validatesharedintegertypedarray'
	},
	ValidateTypedArray: {
		url: 'https://262.ecma-international.org/8.0/#sec-validatetypedarray'
	},
	ValueOfReadEvent: {
		url: 'https://262.ecma-international.org/8.0/#sec-valueofreadevent'
	},
	WakeWaiter: {
		url: 'https://262.ecma-international.org/8.0/#sec-wakewaiter'
	},
	WeekDay: {
		url: 'https://262.ecma-international.org/8.0/#sec-week-day'
	},
	WordCharacters: {
		url: 'https://262.ecma-international.org/8.0/#sec-runtime-semantics-wordcharacters-abstract-operation'
	},
	YearFromTime: {
		url: 'https://262.ecma-international.org/8.0/#eqn-YearFromTime'
	}
};
'use strict';

module.exports = {
	abs: {
		url: 'https://262.ecma-international.org/9.0/#eqn-abs'
	},
	'Abstract Equality Comparison': {
		url: 'https://262.ecma-international.org/9.0/#sec-abstract-equality-comparison'
	},
	'Abstract Relational Comparison': {
		url: 'https://262.ecma-international.org/9.0/#sec-abstract-relational-comparison'
	},
	AddRestrictedFunctionProperties: {
		url: 'https://262.ecma-international.org/9.0/#sec-addrestrictedfunctionproperties'
	},
	AddWaiter: {
		url: 'https://262.ecma-international.org/9.0/#sec-addwaiter'
	},
	AdvanceStringIndex: {
		url: 'https://262.ecma-international.org/9.0/#sec-advancestringindex'
	},
	'agent-order': {
		url: 'https://262.ecma-international.org/9.0/#sec-agent-order'
	},
	AgentCanSuspend: {
		url: 'https://262.ecma-international.org/9.0/#sec-agentcansuspend'
	},
	AgentSignifier: {
		url: 'https://262.ecma-international.org/9.0/#sec-agentsignifier'
	},
	AllocateArrayBuffer: {
		url: 'https://262.ecma-international.org/9.0/#sec-allocatearraybuffer'
	},
	AllocateSharedArrayBuffer: {
		url: 'https://262.ecma-international.org/9.0/#sec-allocatesharedarraybuffer'
	},
	AllocateTypedArray: {
		url: 'https://262.ecma-international.org/9.0/#sec-allocatetypedarray'
	},
	AllocateTypedArrayBuffer: {
		url: 'https://262.ecma-international.org/9.0/#sec-allocatetypedarraybuffer'
	},
	ArrayCreate: {
		url: 'https://262.ecma-international.org/9.0/#sec-arraycreate'
	},
	ArraySetLength: {
		url: 'https://262.ecma-international.org/9.0/#sec-arraysetlength'
	},
	ArraySpeciesCreate: {
		url: 'https://262.ecma-international.org/9.0/#sec-arrayspeciescreate'
	},
	AsyncFunctionCreate: {
		url: 'https://262.ecma-international.org/9.0/#sec-async-functions-abstract-operations-async-function-create'
	},
	AsyncFunctionStart: {
		url: 'https://262.ecma-international.org/9.0/#sec-async-functions-abstract-operations-async-function-start'
	},
	AsyncGeneratorEnqueue: {
		url: 'https://262.ecma-international.org/9.0/#sec-asyncgeneratorenqueue'
	},
	AsyncGeneratorFunctionCreate: {
		url: 'https://262.ecma-international.org/9.0/#sec-asyncgeneratorfunctioncreate'
	},
	AsyncGeneratorReject: {
		url: 'https://262.ecma-international.org/9.0/#sec-asyncgeneratorreject'
	},
	AsyncGeneratorResolve: {
		url: 'https://262.ecma-international.org/9.0/#sec-asyncgeneratorresolve'
	},
	AsyncGeneratorResumeNext: {
		url: 'https://262.ecma-international.org/9.0/#sec-asyncgeneratorresumenext'
	},
	AsyncGeneratorStart: {
		url: 'https://262.ecma-international.org/9.0/#sec-asyncgeneratorstart'
	},
	AsyncGeneratorYield: {
		url: 'https://262.ecma-international.org/9.0/#sec-asyncgeneratoryield'
	},
	AsyncIteratorClose: {
		url: 'https://262.ecma-international.org/9.0/#sec-asynciteratorclose'
	},
	AtomicLoad: {
		url: 'https://262.ecma-international.org/9.0/#sec-atomicload'
	},
	AtomicReadModifyWrite: {
		url: 'https://262.ecma-international.org/9.0/#sec-atomicreadmodifywrite'
	},
	Await: {
		url: 'https://262.ecma-international.org/9.0/#await'
	},
	BackreferenceMatcher: {
		url: 'https://262.ecma-international.org/9.0/#sec-backreference-matcher'
	},
	BlockDeclarationInstantiation: {
		url: 'https://262.ecma-international.org/9.0/#sec-blockdeclarationinstantiation'
	},
	BoundFunctionCreate: {
		url: 'https://262.ecma-international.org/9.0/#sec-boundfunctioncreate'
	},
	Call: {
		url: 'https://262.ecma-international.org/9.0/#sec-call'
	},
	Canonicalize: {
		url: 'https://262.ecma-international.org/9.0/#sec-runtime-semantics-canonicalize-ch'
	},
	CanonicalNumericIndexString: {
		url: 'https://262.ecma-international.org/9.0/#sec-canonicalnumericindexstring'
	},
	CaseClauseIsSelected: {
		url: 'https://262.ecma-international.org/9.0/#sec-runtime-semantics-caseclauseisselected'
	},
	CharacterRange: {
		url: 'https://262.ecma-international.org/9.0/#sec-runtime-semantics-characterrange-abstract-operation'
	},
	CharacterRangeOrUnion: {
		url: 'https://262.ecma-international.org/9.0/#sec-runtime-semantics-characterrangeorunion-abstract-operation'
	},
	CharacterSetMatcher: {
		url: 'https://262.ecma-international.org/9.0/#sec-runtime-semantics-charactersetmatcher-abstract-operation'
	},
	CloneArrayBuffer: {
		url: 'https://262.ecma-international.org/9.0/#sec-clonearraybuffer'
	},
	CompletePropertyDescriptor: {
		url: 'https://262.ecma-international.org/9.0/#sec-completepropertydescriptor'
	},
	Completion: {
		url: 'https://262.ecma-international.org/9.0/#sec-completion-record-specification-type'
	},
	CompletionRecord: {
		url: 'https://262.ecma-international.org/9.0/#sec-completion-record-specification-type'
	},
	ComposeWriteEventBytes: {
		url: 'https://262.ecma-international.org/9.0/#sec-composewriteeventbytes'
	},
	Construct: {
		url: 'https://262.ecma-international.org/9.0/#sec-construct'
	},
	CopyDataBlockBytes: {
		url: 'https://262.ecma-international.org/9.0/#sec-copydatablockbytes'
	},
	CopyDataProperties: {
		url: 'https://262.ecma-international.org/9.0/#sec-copydataproperties'
	},
	CreateArrayFromList: {
		url: 'https://262.ecma-international.org/9.0/#sec-createarrayfromlist'
	},
	CreateArrayIterator: {
		url: 'https://262.ecma-international.org/9.0/#sec-createarrayiterator'
	},
	CreateAsyncFromSyncIterator: {
		url: 'https://262.ecma-international.org/9.0/#sec-createasyncfromsynciterator'
	},
	CreateBuiltinFunction: {
		url: 'https://262.ecma-international.org/9.0/#sec-createbuiltinfunction'
	},
	CreateByteDataBlock: {
		url: 'https://262.ecma-international.org/9.0/#sec-createbytedatablock'
	},
	CreateDataProperty: {
		url: 'https://262.ecma-international.org/9.0/#sec-createdataproperty'
	},
	CreateDataPropertyOrThrow: {
		url: 'https://262.ecma-international.org/9.0/#sec-createdatapropertyorthrow'
	},
	CreateDynamicFunction: {
		url: 'https://262.ecma-international.org/9.0/#sec-createdynamicfunction'
	},
	CreateHTML: {
		url: 'https://262.ecma-international.org/9.0/#sec-createhtml'
	},
	CreateIntrinsics: {
		url: 'https://262.ecma-international.org/9.0/#sec-createintrinsics'
	},
	CreateIterResultObject: {
		url: 'https://262.ecma-international.org/9.0/#sec-createiterresultobject'
	},
	CreateListFromArrayLike: {
		url: 'https://262.ecma-international.org/9.0/#sec-createlistfromarraylike'
	},
	CreateListIteratorRecord: {
		url: 'https://262.ecma-international.org/9.0/#sec-createlistiteratorRecord'
	},
	CreateMapIterator: {
		url: 'https://262.ecma-international.org/9.0/#sec-createmapiterator'
	},
	CreateMappedArgumentsObject: {
		url: 'https://262.ecma-international.org/9.0/#sec-createmappedargumentsobject'
	},
	CreateMethodProperty: {
		url: 'https://262.ecma-international.org/9.0/#sec-createmethodproperty'
	},
	CreatePerIterationEnvironment: {
		url: 'https://262.ecma-international.org/9.0/#sec-createperiterationenvironment'
	},
	CreateRealm: {
		url: 'https://262.ecma-international.org/9.0/#sec-createrealm'
	},
	CreateResolvingFunctions: {
		url: 'https://262.ecma-international.org/9.0/#sec-createresolvingfunctions'
	},
	CreateSetIterator: {
		url: 'https://262.ecma-international.org/9.0/#sec-createsetiterator'
	},
	CreateSharedByteDataBlock: {
		url: 'https://262.ecma-international.org/9.0/#sec-createsharedbytedatablock'
	},
	CreateStringIterator: {
		url: 'https://262.ecma-international.org/9.0/#sec-createstringiterator'
	},
	CreateUnmappedArgumentsObject: {
		url: 'https://262.ecma-international.org/9.0/#sec-createunmappedargumentsobject'
	},
	DateFromTime: {
		url: 'https://262.ecma-international.org/9.0/#sec-date-number'
	},
	DateString: {
		url: 'https://262.ecma-international.org/9.0/#sec-datestring'
	},
	Day: {
		url: 'https://262.ecma-international.org/9.0/#eqn-Day'
	},
	DayFromYear: {
		url: 'https://262.ecma-international.org/9.0/#eqn-DaysFromYear'
	},
	DaysInYear: {
		url: 'https://262.ecma-international.org/9.0/#eqn-DaysInYear'
	},
	DayWithinYear: {
		url: 'https://262.ecma-international.org/9.0/#eqn-DayWithinYear'
	},
	Decode: {
		url: 'https://262.ecma-international.org/9.0/#sec-decode'
	},
	DefinePropertyOrThrow: {
		url: 'https://262.ecma-international.org/9.0/#sec-definepropertyorthrow'
	},
	DeletePropertyOrThrow: {
		url: 'https://262.ecma-international.org/9.0/#sec-deletepropertyorthrow'
	},
	DetachArrayBuffer: {
		url: 'https://262.ecma-international.org/9.0/#sec-detacharraybuffer'
	},
	Encode: {
		url: 'https://262.ecma-international.org/9.0/#sec-encode'
	},
	EnqueueJob: {
		url: 'https://262.ecma-international.org/9.0/#sec-enqueuejob'
	},
	EnterCriticalSection: {
		url: 'https://262.ecma-international.org/9.0/#sec-entercriticalsection'
	},
	EnumerableOwnPropertyNames: {
		url: 'https://262.ecma-international.org/9.0/#sec-enumerableownpropertynames'
	},
	EnumerateObjectProperties: {
		url: 'https://262.ecma-international.org/9.0/#sec-enumerate-object-properties'
	},
	EscapeRegExpPattern: {
		url: 'https://262.ecma-international.org/9.0/#sec-escaperegexppattern'
	},
	EvalDeclarationInstantiation: {
		url: 'https://262.ecma-international.org/9.0/#sec-evaldeclarationinstantiation'
	},
	EvaluateCall: {
		url: 'https://262.ecma-international.org/9.0/#sec-evaluatecall'
	},
	EvaluateNew: {
		url: 'https://262.ecma-international.org/9.0/#sec-evaluatenew'
	},
	EventSet: {
		url: 'https://262.ecma-international.org/9.0/#sec-event-set'
	},
	floor: {
		url: 'https://262.ecma-international.org/9.0/#eqn-floor'
	},
	ForBodyEvaluation: {
		url: 'https://262.ecma-international.org/9.0/#sec-forbodyevaluation'
	},
	'ForIn/OfBodyEvaluation': {
		url: 'https://262.ecma-international.org/9.0/#sec-runtime-semantics-forin-div-ofbodyevaluation-lhs-stmt-iterator-lhskind-labelset'
	},
	'ForIn/OfHeadEvaluation': {
		url: 'https://262.ecma-international.org/9.0/#sec-runtime-semantics-forin-div-ofheadevaluation-tdznames-expr-iterationkind'
	},
	FromPropertyDescriptor: {
		url: 'https://262.ecma-international.org/9.0/#sec-frompropertydescriptor'
	},
	FulfillPromise: {
		url: 'https://262.ecma-international.org/9.0/#sec-fulfillpromise'
	},
	FunctionAllocate: {
		url: 'https://262.ecma-international.org/9.0/#sec-functionallocate'
	},
	FunctionCreate: {
		url: 'https://262.ecma-international.org/9.0/#sec-functioncreate'
	},
	FunctionDeclarationInstantiation: {
		url: 'https://262.ecma-international.org/9.0/#sec-functiondeclarationinstantiation'
	},
	FunctionInitialize: {
		url: 'https://262.ecma-international.org/9.0/#sec-functioninitialize'
	},
	GeneratorFunctionCreate: {
		url: 'https://262.ecma-international.org/9.0/#sec-generatorfunctioncreate'
	},
	GeneratorResume: {
		url: 'https://262.ecma-international.org/9.0/#sec-generatorresume'
	},
	GeneratorResumeAbrupt: {
		url: 'https://262.ecma-international.org/9.0/#sec-generatorresumeabrupt'
	},
	GeneratorStart: {
		url: 'https://262.ecma-international.org/9.0/#sec-generatorstart'
	},
	GeneratorValidate: {
		url: 'https://262.ecma-international.org/9.0/#sec-generatorvalidate'
	},
	GeneratorYield: {
		url: 'https://262.ecma-international.org/9.0/#sec-generatoryield'
	},
	Get: {
		url: 'https://262.ecma-international.org/9.0/#sec-get-o-p'
	},
	GetActiveScriptOrModule: {
		url: 'https://262.ecma-international.org/9.0/#sec-getactivescriptormodule'
	},
	GetBase: {
		url: 'https://262.ecma-international.org/9.0/#sec-getbase'
	},
	GetFunctionRealm: {
		url: 'https://262.ecma-international.org/9.0/#sec-getfunctionrealm'
	},
	GetGeneratorKind: {
		url: 'https://262.ecma-international.org/9.0/#sec-getgeneratorkind'
	},
	GetGlobalObject: {
		url: 'https://262.ecma-international.org/9.0/#sec-getglobalobject'
	},
	GetIdentifierReference: {
		url: 'https://262.ecma-international.org/9.0/#sec-getidentifierreference'
	},
	GetIterator: {
		url: 'https://262.ecma-international.org/9.0/#sec-getiterator'
	},
	GetMethod: {
		url: 'https://262.ecma-international.org/9.0/#sec-getmethod'
	},
	GetModifySetValueInBuffer: {
		url: 'https://262.ecma-international.org/9.0/#sec-getmodifysetvalueinbuffer'
	},
	GetModuleNamespace: {
		url: 'https://262.ecma-international.org/9.0/#sec-getmodulenamespace'
	},
	GetNewTarget: {
		url: 'https://262.ecma-international.org/9.0/#sec-getnewtarget'
	},
	GetOwnPropertyKeys: {
		url: 'https://262.ecma-international.org/9.0/#sec-getownpropertykeys'
	},
	GetPrototypeFromConstructor: {
		url: 'https://262.ecma-international.org/9.0/#sec-getprototypefromconstructor'
	},
	GetReferencedName: {
		url: 'https://262.ecma-international.org/9.0/#sec-getreferencedname'
	},
	GetSubstitution: {
		url: 'https://262.ecma-international.org/9.0/#sec-getsubstitution'
	},
	GetSuperConstructor: {
		url: 'https://262.ecma-international.org/9.0/#sec-getsuperconstructor'
	},
	GetTemplateObject: {
		url: 'https://262.ecma-international.org/9.0/#sec-gettemplateobject'
	},
	GetThisEnvironment: {
		url: 'https://262.ecma-international.org/9.0/#sec-getthisenvironment'
	},
	GetThisValue: {
		url: 'https://262.ecma-international.org/9.0/#sec-getthisvalue'
	},
	GetV: {
		url: 'https://262.ecma-international.org/9.0/#sec-getv'
	},
	GetValue: {
		url: 'https://262.ecma-international.org/9.0/#sec-getvalue'
	},
	GetValueFromBuffer: {
		url: 'https://262.ecma-international.org/9.0/#sec-getvaluefrombuffer'
	},
	GetViewValue: {
		url: 'https://262.ecma-international.org/9.0/#sec-getviewvalue'
	},
	GetWaiterList: {
		url: 'https://262.ecma-international.org/9.0/#sec-getwaiterlist'
	},
	GlobalDeclarationInstantiation: {
		url: 'https://262.ecma-international.org/9.0/#sec-globaldeclarationinstantiation'
	},
	'happens-before': {
		url: 'https://262.ecma-international.org/9.0/#sec-happens-before'
	},
	HasOwnProperty: {
		url: 'https://262.ecma-international.org/9.0/#sec-hasownproperty'
	},
	HasPrimitiveBase: {
		url: 'https://262.ecma-international.org/9.0/#sec-hasprimitivebase'
	},
	HasProperty: {
		url: 'https://262.ecma-international.org/9.0/#sec-hasproperty'
	},
	'host-synchronizes-with': {
		url: 'https://262.ecma-international.org/9.0/#sec-host-synchronizes-with'
	},
	HostEventSet: {
		url: 'https://262.ecma-international.org/9.0/#sec-hosteventset'
	},
	HourFromTime: {
		url: 'https://262.ecma-international.org/9.0/#eqn-HourFromTime'
	},
	IfAbruptRejectPromise: {
		url: 'https://262.ecma-international.org/9.0/#sec-ifabruptrejectpromise'
	},
	ImportedLocalNames: {
		url: 'https://262.ecma-international.org/9.0/#sec-importedlocalnames'
	},
	InitializeBoundName: {
		url: 'https://262.ecma-international.org/9.0/#sec-initializeboundname'
	},
	InitializeHostDefinedRealm: {
		url: 'https://262.ecma-international.org/9.0/#sec-initializehostdefinedrealm'
	},
	InitializeReferencedBinding: {
		url: 'https://262.ecma-international.org/9.0/#sec-initializereferencedbinding'
	},
	InLeapYear: {
		url: 'https://262.ecma-international.org/9.0/#eqn-InLeapYear'
	},
	InnerModuleEvaluation: {
		url: 'https://262.ecma-international.org/9.0/#sec-innermoduleevaluation'
	},
	InnerModuleInstantiation: {
		url: 'https://262.ecma-international.org/9.0/#sec-innermoduleinstantiation'
	},
	InstanceofOperator: {
		url: 'https://262.ecma-international.org/9.0/#sec-instanceofoperator'
	},
	IntegerIndexedElementGet: {
		url: 'https://262.ecma-international.org/9.0/#sec-integerindexedelementget'
	},
	IntegerIndexedElementSet: {
		url: 'https://262.ecma-international.org/9.0/#sec-integerindexedelementset'
	},
	IntegerIndexedObjectCreate: {
		url: 'https://262.ecma-international.org/9.0/#sec-integerindexedobjectcreate'
	},
	InternalizeJSONProperty: {
		url: 'https://262.ecma-international.org/9.0/#sec-internalizejsonproperty'
	},
	Invoke: {
		url: 'https://262.ecma-international.org/9.0/#sec-invoke'
	},
	IsAccessorDescriptor: {
		url: 'https://262.ecma-international.org/9.0/#sec-isaccessordescriptor'
	},
	IsAnonymousFunctionDefinition: {
		url: 'https://262.ecma-international.org/9.0/#sec-isanonymousfunctiondefinition'
	},
	IsArray: {
		url: 'https://262.ecma-international.org/9.0/#sec-isarray'
	},
	IsCallable: {
		url: 'https://262.ecma-international.org/9.0/#sec-iscallable'
	},
	IsCompatiblePropertyDescriptor: {
		url: 'https://262.ecma-international.org/9.0/#sec-iscompatiblepropertydescriptor'
	},
	IsConcatSpreadable: {
		url: 'https://262.ecma-international.org/9.0/#sec-isconcatspreadable'
	},
	IsConstructor: {
		url: 'https://262.ecma-international.org/9.0/#sec-isconstructor'
	},
	IsDataDescriptor: {
		url: 'https://262.ecma-international.org/9.0/#sec-isdatadescriptor'
	},
	IsDetachedBuffer: {
		url: 'https://262.ecma-international.org/9.0/#sec-isdetachedbuffer'
	},
	IsExtensible: {
		url: 'https://262.ecma-international.org/9.0/#sec-isextensible-o'
	},
	IsGenericDescriptor: {
		url: 'https://262.ecma-international.org/9.0/#sec-isgenericdescriptor'
	},
	IsInTailPosition: {
		url: 'https://262.ecma-international.org/9.0/#sec-isintailposition'
	},
	IsInteger: {
		url: 'https://262.ecma-international.org/9.0/#sec-isinteger'
	},
	IsLabelledFunction: {
		url: 'https://262.ecma-international.org/9.0/#sec-islabelledfunction'
	},
	IsPromise: {
		url: 'https://262.ecma-international.org/9.0/#sec-ispromise'
	},
	IsPropertyKey: {
		url: 'https://262.ecma-international.org/9.0/#sec-ispropertykey'
	},
	IsPropertyReference: {
		url: 'https://262.ecma-international.org/9.0/#sec-ispropertyreference'
	},
	IsRegExp: {
		url: 'https://262.ecma-international.org/9.0/#sec-isregexp'
	},
	IsSharedArrayBuffer: {
		url: 'https://262.ecma-international.org/9.0/#sec-issharedarraybuffer'
	},
	IsStrictReference: {
		url: 'https://262.ecma-international.org/9.0/#sec-isstrictreference'
	},
	IsStringPrefix: {
		url: 'https://262.ecma-international.org/9.0/#sec-isstringprefix'
	},
	IsSuperReference: {
		url: 'https://262.ecma-international.org/9.0/#sec-issuperreference'
	},
	IsUnresolvableReference: {
		url: 'https://262.ecma-international.org/9.0/#sec-isunresolvablereference'
	},
	IsWordChar: {
		url: 'https://262.ecma-international.org/9.0/#sec-runtime-semantics-iswordchar-abstract-operation'
	},
	IterableToList: {
		url: 'https://262.ecma-international.org/9.0/#sec-iterabletolist'
	},
	IteratorClose: {
		url: 'https://262.ecma-international.org/9.0/#sec-iteratorclose'
	},
	IteratorComplete: {
		url: 'https://262.ecma-international.org/9.0/#sec-iteratorcomplete'
	},
	IteratorNext: {
		url: 'https://262.ecma-international.org/9.0/#sec-iteratornext'
	},
	IteratorStep: {
		url: 'https://262.ecma-international.org/9.0/#sec-iteratorstep'
	},
	IteratorValue: {
		url: 'https://262.ecma-international.org/9.0/#sec-iteratorvalue'
	},
	LeaveCriticalSection: {
		url: 'https://262.ecma-international.org/9.0/#sec-leavecriticalsection'
	},
	LocalTime: {
		url: 'https://262.ecma-international.org/9.0/#sec-localtime'
	},
	LoopContinues: {
		url: 'https://262.ecma-international.org/9.0/#sec-loopcontinues'
	},
	MakeArgGetter: {
		url: 'https://262.ecma-international.org/9.0/#sec-makearggetter'
	},
	MakeArgSetter: {
		url: 'https://262.ecma-international.org/9.0/#sec-makeargsetter'
	},
	MakeClassConstructor: {
		url: 'https://262.ecma-international.org/9.0/#sec-makeclassconstructor'
	},
	MakeConstructor: {
		url: 'https://262.ecma-international.org/9.0/#sec-makeconstructor'
	},
	MakeDate: {
		url: 'https://262.ecma-international.org/9.0/#sec-makedate'
	},
	MakeDay: {
		url: 'https://262.ecma-international.org/9.0/#sec-makeday'
	},
	MakeMethod: {
		url: 'https://262.ecma-international.org/9.0/#sec-makemethod'
	},
	MakeSuperPropertyReference: {
		url: 'https://262.ecma-international.org/9.0/#sec-makesuperpropertyreference'
	},
	MakeTime: {
		url: 'https://262.ecma-international.org/9.0/#sec-maketime'
	},
	max: {
		url: 'https://262.ecma-international.org/9.0/#eqn-max'
	},
	'memory-order': {
		url: 'https://262.ecma-international.org/9.0/#sec-memory-order'
	},
	min: {
		url: 'https://262.ecma-international.org/9.0/#eqn-min'
	},
	MinFromTime: {
		url: 'https://262.ecma-international.org/9.0/#eqn-MinFromTime'
	},
	ModuleDeclarationEnvironmentSetup: {
		url: 'https://262.ecma-international.org/9.0/#sec-moduledeclarationenvironmentsetup'
	},
	ModuleExecution: {
		url: 'https://262.ecma-international.org/9.0/#sec-moduleexecution'
	},
	ModuleNamespaceCreate: {
		url: 'https://262.ecma-international.org/9.0/#sec-modulenamespacecreate'
	},
	modulo: {
		url: 'https://262.ecma-international.org/9.0/#eqn-modulo'
	},
	MonthFromTime: {
		url: 'https://262.ecma-international.org/9.0/#eqn-MonthFromTime'
	},
	msFromTime: {
		url: 'https://262.ecma-international.org/9.0/#eqn-msFromTime'
	},
	NewDeclarativeEnvironment: {
		url: 'https://262.ecma-international.org/9.0/#sec-newdeclarativeenvironment'
	},
	NewFunctionEnvironment: {
		url: 'https://262.ecma-international.org/9.0/#sec-newfunctionenvironment'
	},
	NewGlobalEnvironment: {
		url: 'https://262.ecma-international.org/9.0/#sec-newglobalenvironment'
	},
	NewModuleEnvironment: {
		url: 'https://262.ecma-international.org/9.0/#sec-newmoduleenvironment'
	},
	NewObjectEnvironment: {
		url: 'https://262.ecma-international.org/9.0/#sec-newobjectenvironment'
	},
	NewPromiseCapability: {
		url: 'https://262.ecma-international.org/9.0/#sec-newpromisecapability'
	},
	NormalCompletion: {
		url: 'https://262.ecma-international.org/9.0/#sec-normalcompletion'
	},
	NumberToRawBytes: {
		url: 'https://262.ecma-international.org/9.0/#sec-numbertorawbytes'
	},
	NumberToString: {
		url: 'https://262.ecma-international.org/9.0/#sec-tostring-applied-to-the-number-type'
	},
	ObjectCreate: {
		url: 'https://262.ecma-international.org/9.0/#sec-objectcreate'
	},
	ObjectDefineProperties: {
		url: 'https://262.ecma-international.org/9.0/#sec-objectdefineproperties'
	},
	OrdinaryCallBindThis: {
		url: 'https://262.ecma-international.org/9.0/#sec-ordinarycallbindthis'
	},
	OrdinaryCallEvaluateBody: {
		url: 'https://262.ecma-international.org/9.0/#sec-ordinarycallevaluatebody'
	},
	OrdinaryCreateFromConstructor: {
		url: 'https://262.ecma-international.org/9.0/#sec-ordinarycreatefromconstructor'
	},
	OrdinaryDefineOwnProperty: {
		url: 'https://262.ecma-international.org/9.0/#sec-ordinarydefineownproperty'
	},
	OrdinaryDelete: {
		url: 'https://262.ecma-international.org/9.0/#sec-ordinarydelete'
	},
	OrdinaryGet: {
		url: 'https://262.ecma-international.org/9.0/#sec-ordinaryget'
	},
	OrdinaryGetOwnProperty: {
		url: 'https://262.ecma-international.org/9.0/#sec-ordinarygetownproperty'
	},
	OrdinaryGetPrototypeOf: {
		url: 'https://262.ecma-international.org/9.0/#sec-ordinarygetprototypeof'
	},
	OrdinaryHasInstance: {
		url: 'https://262.ecma-international.org/9.0/#sec-ordinaryhasinstance'
	},
	OrdinaryHasProperty: {
		url: 'https://262.ecma-international.org/9.0/#sec-ordinaryhasproperty'
	},
	OrdinaryIsExtensible: {
		url: 'https://262.ecma-international.org/9.0/#sec-ordinaryisextensible'
	},
	OrdinaryOwnPropertyKeys: {
		url: 'https://262.ecma-international.org/9.0/#sec-ordinaryownpropertykeys'
	},
	OrdinaryPreventExtensions: {
		url: 'https://262.ecma-international.org/9.0/#sec-ordinarypreventextensions'
	},
	OrdinarySet: {
		url: 'https://262.ecma-international.org/9.0/#sec-ordinaryset'
	},
	OrdinarySetPrototypeOf: {
		url: 'https://262.ecma-international.org/9.0/#sec-ordinarysetprototypeof'
	},
	OrdinarySetWithOwnDescriptor: {
		url: 'https://262.ecma-international.org/9.0/#sec-ordinarysetwithowndescriptor'
	},
	OrdinaryToPrimitive: {
		url: 'https://262.ecma-international.org/9.0/#sec-ordinarytoprimitive'
	},
	ParseModule: {
		url: 'https://262.ecma-international.org/9.0/#sec-parsemodule'
	},
	ParseScript: {
		url: 'https://262.ecma-international.org/9.0/#sec-parse-script'
	},
	PerformEval: {
		url: 'https://262.ecma-international.org/9.0/#sec-performeval'
	},
	PerformPromiseAll: {
		url: 'https://262.ecma-international.org/9.0/#sec-performpromiseall'
	},
	PerformPromiseRace: {
		url: 'https://262.ecma-international.org/9.0/#sec-performpromiserace'
	},
	PerformPromiseThen: {
		url: 'https://262.ecma-international.org/9.0/#sec-performpromisethen'
	},
	PrepareForOrdinaryCall: {
		url: 'https://262.ecma-international.org/9.0/#sec-prepareforordinarycall'
	},
	PrepareForTailCall: {
		url: 'https://262.ecma-international.org/9.0/#sec-preparefortailcall'
	},
	PromiseReactionJob: {
		url: 'https://262.ecma-international.org/9.0/#sec-promisereactionjob'
	},
	PromiseResolve: {
		url: 'https://262.ecma-international.org/9.0/#sec-promise-resolve'
	},
	PromiseResolveThenableJob: {
		url: 'https://262.ecma-international.org/9.0/#sec-promiseresolvethenablejob'
	},
	ProxyCreate: {
		url: 'https://262.ecma-international.org/9.0/#sec-proxycreate'
	},
	PutValue: {
		url: 'https://262.ecma-international.org/9.0/#sec-putvalue'
	},
	QuoteJSONString: {
		url: 'https://262.ecma-international.org/9.0/#sec-quotejsonstring'
	},
	RawBytesToNumber: {
		url: 'https://262.ecma-international.org/9.0/#sec-rawbytestonumber'
	},
	'reads-bytes-from': {
		url: 'https://262.ecma-international.org/9.0/#sec-reads-bytes-from'
	},
	'reads-from': {
		url: 'https://262.ecma-international.org/9.0/#sec-reads-from'
	},
	RegExpAlloc: {
		url: 'https://262.ecma-international.org/9.0/#sec-regexpalloc'
	},
	RegExpBuiltinExec: {
		url: 'https://262.ecma-international.org/9.0/#sec-regexpbuiltinexec'
	},
	RegExpCreate: {
		url: 'https://262.ecma-international.org/9.0/#sec-regexpcreate'
	},
	RegExpExec: {
		url: 'https://262.ecma-international.org/9.0/#sec-regexpexec'
	},
	RegExpInitialize: {
		url: 'https://262.ecma-international.org/9.0/#sec-regexpinitialize'
	},
	RejectPromise: {
		url: 'https://262.ecma-international.org/9.0/#sec-rejectpromise'
	},
	RemoveWaiter: {
		url: 'https://262.ecma-international.org/9.0/#sec-removewaiter'
	},
	RemoveWaiters: {
		url: 'https://262.ecma-international.org/9.0/#sec-removewaiters'
	},
	RepeatMatcher: {
		url: 'https://262.ecma-international.org/9.0/#sec-runtime-semantics-repeatmatcher-abstract-operation'
	},
	RequireObjectCoercible: {
		url: 'https://262.ecma-international.org/9.0/#sec-requireobjectcoercible'
	},
	ResolveBinding: {
		url: 'https://262.ecma-international.org/9.0/#sec-resolvebinding'
	},
	ResolveThisBinding: {
		url: 'https://262.ecma-international.org/9.0/#sec-resolvethisbinding'
	},
	ReturnIfAbrupt: {
		url: 'https://262.ecma-international.org/9.0/#sec-returnifabrupt'
	},
	RunJobs: {
		url: 'https://262.ecma-international.org/9.0/#sec-runjobs'
	},
	SameValue: {
		url: 'https://262.ecma-international.org/9.0/#sec-samevalue'
	},
	SameValueNonNumber: {
		url: 'https://262.ecma-international.org/9.0/#sec-samevaluenonnumber'
	},
	SameValueZero: {
		url: 'https://262.ecma-international.org/9.0/#sec-samevaluezero'
	},
	ScriptEvaluation: {
		url: 'https://262.ecma-international.org/9.0/#sec-runtime-semantics-scriptevaluation'
	},
	ScriptEvaluationJob: {
		url: 'https://262.ecma-international.org/9.0/#sec-scriptevaluationjob'
	},
	SecFromTime: {
		url: 'https://262.ecma-international.org/9.0/#eqn-SecFromTime'
	},
	SerializeJSONArray: {
		url: 'https://262.ecma-international.org/9.0/#sec-serializejsonarray'
	},
	SerializeJSONObject: {
		url: 'https://262.ecma-international.org/9.0/#sec-serializejsonobject'
	},
	SerializeJSONProperty: {
		url: 'https://262.ecma-international.org/9.0/#sec-serializejsonproperty'
	},
	Set: {
		url: 'https://262.ecma-international.org/9.0/#sec-set-o-p-v-throw'
	},
	SetDefaultGlobalBindings: {
		url: 'https://262.ecma-international.org/9.0/#sec-setdefaultglobalbindings'
	},
	SetFunctionLength: {
		url: 'https://262.ecma-international.org/9.0/#sec-setfunctionlength'
	},
	SetFunctionName: {
		url: 'https://262.ecma-international.org/9.0/#sec-setfunctionname'
	},
	SetImmutablePrototype: {
		url: 'https://262.ecma-international.org/9.0/#sec-set-immutable-prototype'
	},
	SetIntegrityLevel: {
		url: 'https://262.ecma-international.org/9.0/#sec-setintegritylevel'
	},
	SetRealmGlobalObject: {
		url: 'https://262.ecma-international.org/9.0/#sec-setrealmglobalobject'
	},
	SetValueInBuffer: {
		url: 'https://262.ecma-international.org/9.0/#sec-setvalueinbuffer'
	},
	SetViewValue: {
		url: 'https://262.ecma-international.org/9.0/#sec-setviewvalue'
	},
	SharedDataBlockEventSet: {
		url: 'https://262.ecma-international.org/9.0/#sec-sharedatablockeventset'
	},
	SortCompare: {
		url: 'https://262.ecma-international.org/9.0/#sec-sortcompare'
	},
	SpeciesConstructor: {
		url: 'https://262.ecma-international.org/9.0/#sec-speciesconstructor'
	},
	SplitMatch: {
		url: 'https://262.ecma-international.org/9.0/#sec-splitmatch'
	},
	'Strict Equality Comparison': {
		url: 'https://262.ecma-international.org/9.0/#sec-strict-equality-comparison'
	},
	StringCreate: {
		url: 'https://262.ecma-international.org/9.0/#sec-stringcreate'
	},
	StringGetOwnProperty: {
		url: 'https://262.ecma-international.org/9.0/#sec-stringgetownproperty'
	},
	Suspend: {
		url: 'https://262.ecma-international.org/9.0/#sec-suspend'
	},
	SymbolDescriptiveString: {
		url: 'https://262.ecma-international.org/9.0/#sec-symboldescriptivestring'
	},
	'synchronizes-with': {
		url: 'https://262.ecma-international.org/9.0/#sec-synchronizes-with'
	},
	TestIntegrityLevel: {
		url: 'https://262.ecma-international.org/9.0/#sec-testintegritylevel'
	},
	thisBooleanValue: {
		url: 'https://262.ecma-international.org/9.0/#sec-thisbooleanvalue'
	},
	thisNumberValue: {
		url: 'https://262.ecma-international.org/9.0/#sec-thisnumbervalue'
	},
	thisStringValue: {
		url: 'https://262.ecma-international.org/9.0/#sec-thisstringvalue'
	},
	thisSymbolValue: {
		url: 'https://262.ecma-international.org/9.0/#sec-thissymbolvalue'
	},
	thisTimeValue: {
		url: 'https://262.ecma-international.org/9.0/#sec-thistimevalue'
	},
	ThrowCompletion: {
		url: 'https://262.ecma-international.org/9.0/#sec-throwcompletion'
	},
	TimeClip: {
		url: 'https://262.ecma-international.org/9.0/#sec-timeclip'
	},
	TimeFromYear: {
		url: 'https://262.ecma-international.org/9.0/#eqn-TimeFromYear'
	},
	TimeString: {
		url: 'https://262.ecma-international.org/9.0/#sec-timestring'
	},
	TimeWithinDay: {
		url: 'https://262.ecma-international.org/9.0/#eqn-TimeWithinDay'
	},
	TimeZoneString: {
		url: 'https://262.ecma-international.org/9.0/#sec-timezoneestring'
	},
	ToBoolean: {
		url: 'https://262.ecma-international.org/9.0/#sec-toboolean'
	},
	ToDateString: {
		url: 'https://262.ecma-international.org/9.0/#sec-todatestring'
	},
	ToIndex: {
		url: 'https://262.ecma-international.org/9.0/#sec-toindex'
	},
	ToInt16: {
		url: 'https://262.ecma-international.org/9.0/#sec-toint16'
	},
	ToInt32: {
		url: 'https://262.ecma-international.org/9.0/#sec-toint32'
	},
	ToInt8: {
		url: 'https://262.ecma-international.org/9.0/#sec-toint8'
	},
	ToInteger: {
		url: 'https://262.ecma-international.org/9.0/#sec-tointeger'
	},
	ToLength: {
		url: 'https://262.ecma-international.org/9.0/#sec-tolength'
	},
	ToNumber: {
		url: 'https://262.ecma-international.org/9.0/#sec-tonumber'
	},
	ToObject: {
		url: 'https://262.ecma-international.org/9.0/#sec-toobject'
	},
	TopLevelModuleEvaluationJob: {
		url: 'https://262.ecma-international.org/9.0/#sec-toplevelmoduleevaluationjob'
	},
	ToPrimitive: {
		url: 'https://262.ecma-international.org/9.0/#sec-toprimitive'
	},
	ToPropertyDescriptor: {
		url: 'https://262.ecma-international.org/9.0/#sec-topropertydescriptor'
	},
	ToPropertyKey: {
		url: 'https://262.ecma-international.org/9.0/#sec-topropertykey'
	},
	ToString: {
		url: 'https://262.ecma-international.org/9.0/#sec-tostring'
	},
	ToUint16: {
		url: 'https://262.ecma-international.org/9.0/#sec-touint16'
	},
	ToUint32: {
		url: 'https://262.ecma-international.org/9.0/#sec-touint32'
	},
	ToUint8: {
		url: 'https://262.ecma-international.org/9.0/#sec-touint8'
	},
	ToUint8Clamp: {
		url: 'https://262.ecma-international.org/9.0/#sec-touint8clamp'
	},
	TriggerPromiseReactions: {
		url: 'https://262.ecma-international.org/9.0/#sec-triggerpromisereactions'
	},
	Type: {
		url: 'https://262.ecma-international.org/9.0/#sec-ecmascript-data-types-and-values'
	},
	TypedArrayCreate: {
		url: 'https://262.ecma-international.org/9.0/#typedarray-create'
	},
	TypedArraySpeciesCreate: {
		url: 'https://262.ecma-international.org/9.0/#typedarray-species-create'
	},
	UnicodeEscape: {
		url: 'https://262.ecma-international.org/9.0/#sec-unicodeescape'
	},
	UnicodeMatchProperty: {
		url: 'https://262.ecma-international.org/9.0/#sec-runtime-semantics-unicodematchproperty-p'
	},
	UnicodeMatchPropertyValue: {
		url: 'https://262.ecma-international.org/9.0/#sec-runtime-semantics-unicodematchpropertyvalue-p-v'
	},
	UpdateEmpty: {
		url: 'https://262.ecma-international.org/9.0/#sec-updateempty'
	},
	UTC: {
		url: 'https://262.ecma-international.org/9.0/#sec-utc-t'
	},
	UTF16Decode: {
		url: 'https://262.ecma-international.org/9.0/#sec-utf16decode'
	},
	UTF16Encoding: {
		url: 'https://262.ecma-international.org/9.0/#sec-utf16encoding'
	},
	ValidateAndApplyPropertyDescriptor: {
		url: 'https://262.ecma-international.org/9.0/#sec-validateandapplypropertydescriptor'
	},
	ValidateAtomicAccess: {
		url: 'https://262.ecma-international.org/9.0/#sec-validateatomicaccess'
	},
	ValidateSharedIntegerTypedArray: {
		url: 'https://262.ecma-international.org/9.0/#sec-validatesharedintegertypedarray'
	},
	ValidateTypedArray: {
		url: 'https://262.ecma-international.org/9.0/#sec-validatetypedarray'
	},
	ValueOfReadEvent: {
		url: 'https://262.ecma-international.org/9.0/#sec-valueofreadevent'
	},
	WakeWaiter: {
		url: 'https://262.ecma-international.org/9.0/#sec-wakewaiter'
	},
	WeekDay: {
		url: 'https://262.ecma-international.org/9.0/#sec-week-day'
	},
	WordCharacters: {
		url: 'https://262.ecma-international.org/9.0/#sec-runtime-semantics-wordcharacters-abstract-operation'
	},
	YearFromTime: {
		url: 'https://262.ecma-international.org/9.0/#eqn-YearFromTime'
	}
};
'use strict';

module.exports = {
	abs: {
		url: 'https://262.ecma-international.org/10.0/#eqn-abs'
	},
	'Abstract Equality Comparison': {
		url: 'https://262.ecma-international.org/10.0/#sec-abstract-equality-comparison'
	},
	'Abstract Relational Comparison': {
		url: 'https://262.ecma-international.org/10.0/#sec-abstract-relational-comparison'
	},
	AddEntriesFromIterable: {
		url: 'https://262.ecma-international.org/10.0/#sec-add-entries-from-iterable'
	},
	AddRestrictedFunctionProperties: {
		url: 'https://262.ecma-international.org/10.0/#sec-addrestrictedfunctionproperties'
	},
	AddWaiter: {
		url: 'https://262.ecma-international.org/10.0/#sec-addwaiter'
	},
	AdvanceStringIndex: {
		url: 'https://262.ecma-international.org/10.0/#sec-advancestringindex'
	},
	'agent-order': {
		url: 'https://262.ecma-international.org/10.0/#sec-agent-order'
	},
	AgentCanSuspend: {
		url: 'https://262.ecma-international.org/10.0/#sec-agentcansuspend'
	},
	AgentSignifier: {
		url: 'https://262.ecma-international.org/10.0/#sec-agentsignifier'
	},
	AllocateArrayBuffer: {
		url: 'https://262.ecma-international.org/10.0/#sec-allocatearraybuffer'
	},
	AllocateSharedArrayBuffer: {
		url: 'https://262.ecma-international.org/10.0/#sec-allocatesharedarraybuffer'
	},
	AllocateTypedArray: {
		url: 'https://262.ecma-international.org/10.0/#sec-allocatetypedarray'
	},
	AllocateTypedArrayBuffer: {
		url: 'https://262.ecma-international.org/10.0/#sec-allocatetypedarraybuffer'
	},
	ArrayCreate: {
		url: 'https://262.ecma-international.org/10.0/#sec-arraycreate'
	},
	ArraySetLength: {
		url: 'https://262.ecma-international.org/10.0/#sec-arraysetlength'
	},
	ArraySpeciesCreate: {
		url: 'https://262.ecma-international.org/10.0/#sec-arrayspeciescreate'
	},
	AsyncFromSyncIteratorContinuation: {
		url: 'https://262.ecma-international.org/10.0/#sec-asyncfromsynciteratorcontinuation'
	},
	AsyncFunctionCreate: {
		url: 'https://262.ecma-international.org/10.0/#sec-async-functions-abstract-operations-async-function-create'
	},
	AsyncFunctionStart: {
		url: 'https://262.ecma-international.org/10.0/#sec-async-functions-abstract-operations-async-function-start'
	},
	AsyncGeneratorEnqueue: {
		url: 'https://262.ecma-international.org/10.0/#sec-asyncgeneratorenqueue'
	},
	AsyncGeneratorFunctionCreate: {
		url: 'https://262.ecma-international.org/10.0/#sec-asyncgeneratorfunctioncreate'
	},
	AsyncGeneratorReject: {
		url: 'https://262.ecma-international.org/10.0/#sec-asyncgeneratorreject'
	},
	AsyncGeneratorResolve: {
		url: 'https://262.ecma-international.org/10.0/#sec-asyncgeneratorresolve'
	},
	AsyncGeneratorResumeNext: {
		url: 'https://262.ecma-international.org/10.0/#sec-asyncgeneratorresumenext'
	},
	AsyncGeneratorStart: {
		url: 'https://262.ecma-international.org/10.0/#sec-asyncgeneratorstart'
	},
	AsyncGeneratorYield: {
		url: 'https://262.ecma-international.org/10.0/#sec-asyncgeneratoryield'
	},
	AsyncIteratorClose: {
		url: 'https://262.ecma-international.org/10.0/#sec-asynciteratorclose'
	},
	AtomicLoad: {
		url: 'https://262.ecma-international.org/10.0/#sec-atomicload'
	},
	AtomicReadModifyWrite: {
		url: 'https://262.ecma-international.org/10.0/#sec-atomicreadmodifywrite'
	},
	Await: {
		url: 'https://262.ecma-international.org/10.0/#await'
	},
	BackreferenceMatcher: {
		url: 'https://262.ecma-international.org/10.0/#sec-backreference-matcher'
	},
	BlockDeclarationInstantiation: {
		url: 'https://262.ecma-international.org/10.0/#sec-blockdeclarationinstantiation'
	},
	BoundFunctionCreate: {
		url: 'https://262.ecma-international.org/10.0/#sec-boundfunctioncreate'
	},
	Call: {
		url: 'https://262.ecma-international.org/10.0/#sec-call'
	},
	Canonicalize: {
		url: 'https://262.ecma-international.org/10.0/#sec-runtime-semantics-canonicalize-ch'
	},
	CanonicalNumericIndexString: {
		url: 'https://262.ecma-international.org/10.0/#sec-canonicalnumericindexstring'
	},
	CaseClauseIsSelected: {
		url: 'https://262.ecma-international.org/10.0/#sec-runtime-semantics-caseclauseisselected'
	},
	CharacterRange: {
		url: 'https://262.ecma-international.org/10.0/#sec-runtime-semantics-characterrange-abstract-operation'
	},
	CharacterRangeOrUnion: {
		url: 'https://262.ecma-international.org/10.0/#sec-runtime-semantics-characterrangeorunion-abstract-operation'
	},
	CharacterSetMatcher: {
		url: 'https://262.ecma-international.org/10.0/#sec-runtime-semantics-charactersetmatcher-abstract-operation'
	},
	CloneArrayBuffer: {
		url: 'https://262.ecma-international.org/10.0/#sec-clonearraybuffer'
	},
	CompletePropertyDescriptor: {
		url: 'https://262.ecma-international.org/10.0/#sec-completepropertydescriptor'
	},
	Completion: {
		url: 'https://262.ecma-international.org/10.0/#sec-completion-record-specification-type'
	},
	CompletionRecord: {
		url: 'https://262.ecma-international.org/10.0/#sec-completion-record-specification-type'
	},
	ComposeWriteEventBytes: {
		url: 'https://262.ecma-international.org/10.0/#sec-composewriteeventbytes'
	},
	Construct: {
		url: 'https://262.ecma-international.org/10.0/#sec-construct'
	},
	CopyDataBlockBytes: {
		url: 'https://262.ecma-international.org/10.0/#sec-copydatablockbytes'
	},
	CopyDataProperties: {
		url: 'https://262.ecma-international.org/10.0/#sec-copydataproperties'
	},
	CreateArrayFromList: {
		url: 'https://262.ecma-international.org/10.0/#sec-createarrayfromlist'
	},
	CreateArrayIterator: {
		url: 'https://262.ecma-international.org/10.0/#sec-createarrayiterator'
	},
	CreateAsyncFromSyncIterator: {
		url: 'https://262.ecma-international.org/10.0/#sec-createasyncfromsynciterator'
	},
	CreateBuiltinFunction: {
		url: 'https://262.ecma-international.org/10.0/#sec-createbuiltinfunction'
	},
	CreateByteDataBlock: {
		url: 'https://262.ecma-international.org/10.0/#sec-createbytedatablock'
	},
	CreateDataProperty: {
		url: 'https://262.ecma-international.org/10.0/#sec-createdataproperty'
	},
	CreateDataPropertyOrThrow: {
		url: 'https://262.ecma-international.org/10.0/#sec-createdatapropertyorthrow'
	},
	CreateDynamicFunction: {
		url: 'https://262.ecma-international.org/10.0/#sec-createdynamicfunction'
	},
	CreateHTML: {
		url: 'https://262.ecma-international.org/10.0/#sec-createhtml'
	},
	CreateIntrinsics: {
		url: 'https://262.ecma-international.org/10.0/#sec-createintrinsics'
	},
	CreateIterResultObject: {
		url: 'https://262.ecma-international.org/10.0/#sec-createiterresultobject'
	},
	CreateListFromArrayLike: {
		url: 'https://262.ecma-international.org/10.0/#sec-createlistfromarraylike'
	},
	CreateListIteratorRecord: {
		url: 'https://262.ecma-international.org/10.0/#sec-createlistiteratorRecord'
	},
	CreateMapIterator: {
		url: 'https://262.ecma-international.org/10.0/#sec-createmapiterator'
	},
	CreateMappedArgumentsObject: {
		url: 'https://262.ecma-international.org/10.0/#sec-createmappedargumentsobject'
	},
	CreateMethodProperty: {
		url: 'https://262.ecma-international.org/10.0/#sec-createmethodproperty'
	},
	CreatePerIterationEnvironment: {
		url: 'https://262.ecma-international.org/10.0/#sec-createperiterationenvironment'
	},
	CreateRealm: {
		url: 'https://262.ecma-international.org/10.0/#sec-createrealm'
	},
	CreateResolvingFunctions: {
		url: 'https://262.ecma-international.org/10.0/#sec-createresolvingfunctions'
	},
	CreateSetIterator: {
		url: 'https://262.ecma-international.org/10.0/#sec-createsetiterator'
	},
	CreateSharedByteDataBlock: {
		url: 'https://262.ecma-international.org/10.0/#sec-createsharedbytedatablock'
	},
	CreateStringIterator: {
		url: 'https://262.ecma-international.org/10.0/#sec-createstringiterator'
	},
	CreateUnmappedArgumentsObject: {
		url: 'https://262.ecma-international.org/10.0/#sec-createunmappedargumentsobject'
	},
	DateFromTime: {
		url: 'https://262.ecma-international.org/10.0/#sec-date-number'
	},
	DateString: {
		url: 'https://262.ecma-international.org/10.0/#sec-datestring'
	},
	Day: {
		url: 'https://262.ecma-international.org/10.0/#eqn-Day'
	},
	DayFromYear: {
		url: 'https://262.ecma-international.org/10.0/#eqn-DaysFromYear'
	},
	DaysInYear: {
		url: 'https://262.ecma-international.org/10.0/#eqn-DaysInYear'
	},
	DayWithinYear: {
		url: 'https://262.ecma-international.org/10.0/#eqn-DayWithinYear'
	},
	Decode: {
		url: 'https://262.ecma-international.org/10.0/#sec-decode'
	},
	DefinePropertyOrThrow: {
		url: 'https://262.ecma-international.org/10.0/#sec-definepropertyorthrow'
	},
	DeletePropertyOrThrow: {
		url: 'https://262.ecma-international.org/10.0/#sec-deletepropertyorthrow'
	},
	DetachArrayBuffer: {
		url: 'https://262.ecma-international.org/10.0/#sec-detacharraybuffer'
	},
	Encode: {
		url: 'https://262.ecma-international.org/10.0/#sec-encode'
	},
	EnqueueJob: {
		url: 'https://262.ecma-international.org/10.0/#sec-enqueuejob'
	},
	EnterCriticalSection: {
		url: 'https://262.ecma-international.org/10.0/#sec-entercriticalsection'
	},
	EnumerableOwnPropertyNames: {
		url: 'https://262.ecma-international.org/10.0/#sec-enumerableownpropertynames'
	},
	EnumerateObjectProperties: {
		url: 'https://262.ecma-international.org/10.0/#sec-enumerate-object-properties'
	},
	EscapeRegExpPattern: {
		url: 'https://262.ecma-international.org/10.0/#sec-escaperegexppattern'
	},
	EvalDeclarationInstantiation: {
		url: 'https://262.ecma-international.org/10.0/#sec-evaldeclarationinstantiation'
	},
	EvaluateCall: {
		url: 'https://262.ecma-international.org/10.0/#sec-evaluatecall'
	},
	EvaluateNew: {
		url: 'https://262.ecma-international.org/10.0/#sec-evaluatenew'
	},
	EventSet: {
		url: 'https://262.ecma-international.org/10.0/#sec-event-set'
	},
	ExecuteModule: {
		url: 'https://262.ecma-international.org/10.0/#sec-source-text-module-record-execute-module'
	},
	FlattenIntoArray: {
		url: 'https://262.ecma-international.org/10.0/#sec-flattenintoarray'
	},
	floor: {
		url: 'https://262.ecma-international.org/10.0/#eqn-floor'
	},
	ForBodyEvaluation: {
		url: 'https://262.ecma-international.org/10.0/#sec-forbodyevaluation'
	},
	'ForIn/OfBodyEvaluation': {
		url: 'https://262.ecma-international.org/10.0/#sec-runtime-semantics-forin-div-ofbodyevaluation-lhs-stmt-iterator-lhskind-labelset'
	},
	'ForIn/OfHeadEvaluation': {
		url: 'https://262.ecma-international.org/10.0/#sec-runtime-semantics-forin-div-ofheadevaluation-tdznames-expr-iterationkind'
	},
	FromPropertyDescriptor: {
		url: 'https://262.ecma-international.org/10.0/#sec-frompropertydescriptor'
	},
	FulfillPromise: {
		url: 'https://262.ecma-international.org/10.0/#sec-fulfillpromise'
	},
	FunctionAllocate: {
		url: 'https://262.ecma-international.org/10.0/#sec-functionallocate'
	},
	FunctionCreate: {
		url: 'https://262.ecma-international.org/10.0/#sec-functioncreate'
	},
	FunctionDeclarationInstantiation: {
		url: 'https://262.ecma-international.org/10.0/#sec-functiondeclarationinstantiation'
	},
	FunctionInitialize: {
		url: 'https://262.ecma-international.org/10.0/#sec-functioninitialize'
	},
	GeneratorFunctionCreate: {
		url: 'https://262.ecma-international.org/10.0/#sec-generatorfunctioncreate'
	},
	GeneratorResume: {
		url: 'https://262.ecma-international.org/10.0/#sec-generatorresume'
	},
	GeneratorResumeAbrupt: {
		url: 'https://262.ecma-international.org/10.0/#sec-generatorresumeabrupt'
	},
	GeneratorStart: {
		url: 'https://262.ecma-international.org/10.0/#sec-generatorstart'
	},
	GeneratorValidate: {
		url: 'https://262.ecma-international.org/10.0/#sec-generatorvalidate'
	},
	GeneratorYield: {
		url: 'https://262.ecma-international.org/10.0/#sec-generatoryield'
	},
	Get: {
		url: 'https://262.ecma-international.org/10.0/#sec-get-o-p'
	},
	GetActiveScriptOrModule: {
		url: 'https://262.ecma-international.org/10.0/#sec-getactivescriptormodule'
	},
	GetBase: {
		url: 'https://262.ecma-international.org/10.0/#sec-getbase'
	},
	GetFunctionRealm: {
		url: 'https://262.ecma-international.org/10.0/#sec-getfunctionrealm'
	},
	GetGeneratorKind: {
		url: 'https://262.ecma-international.org/10.0/#sec-getgeneratorkind'
	},
	GetGlobalObject: {
		url: 'https://262.ecma-international.org/10.0/#sec-getglobalobject'
	},
	GetIdentifierReference: {
		url: 'https://262.ecma-international.org/10.0/#sec-getidentifierreference'
	},
	GetIterator: {
		url: 'https://262.ecma-international.org/10.0/#sec-getiterator'
	},
	GetMethod: {
		url: 'https://262.ecma-international.org/10.0/#sec-getmethod'
	},
	GetModifySetValueInBuffer: {
		url: 'https://262.ecma-international.org/10.0/#sec-getmodifysetvalueinbuffer'
	},
	GetModuleNamespace: {
		url: 'https://262.ecma-international.org/10.0/#sec-getmodulenamespace'
	},
	GetNewTarget: {
		url: 'https://262.ecma-international.org/10.0/#sec-getnewtarget'
	},
	GetOwnPropertyKeys: {
		url: 'https://262.ecma-international.org/10.0/#sec-getownpropertykeys'
	},
	GetPrototypeFromConstructor: {
		url: 'https://262.ecma-international.org/10.0/#sec-getprototypefromconstructor'
	},
	GetReferencedName: {
		url: 'https://262.ecma-international.org/10.0/#sec-getreferencedname'
	},
	GetSubstitution: {
		url: 'https://262.ecma-international.org/10.0/#sec-getsubstitution'
	},
	GetSuperConstructor: {
		url: 'https://262.ecma-international.org/10.0/#sec-getsuperconstructor'
	},
	GetTemplateObject: {
		url: 'https://262.ecma-international.org/10.0/#sec-gettemplateobject'
	},
	GetThisEnvironment: {
		url: 'https://262.ecma-international.org/10.0/#sec-getthisenvironment'
	},
	GetThisValue: {
		url: 'https://262.ecma-international.org/10.0/#sec-getthisvalue'
	},
	GetV: {
		url: 'https://262.ecma-international.org/10.0/#sec-getv'
	},
	GetValue: {
		url: 'https://262.ecma-international.org/10.0/#sec-getvalue'
	},
	GetValueFromBuffer: {
		url: 'https://262.ecma-international.org/10.0/#sec-getvaluefrombuffer'
	},
	GetViewValue: {
		url: 'https://262.ecma-international.org/10.0/#sec-getviewvalue'
	},
	GetWaiterList: {
		url: 'https://262.ecma-international.org/10.0/#sec-getwaiterlist'
	},
	GlobalDeclarationInstantiation: {
		url: 'https://262.ecma-international.org/10.0/#sec-globaldeclarationinstantiation'
	},
	'happens-before': {
		url: 'https://262.ecma-international.org/10.0/#sec-happens-before'
	},
	HasOwnProperty: {
		url: 'https://262.ecma-international.org/10.0/#sec-hasownproperty'
	},
	HasPrimitiveBase: {
		url: 'https://262.ecma-international.org/10.0/#sec-hasprimitivebase'
	},
	HasProperty: {
		url: 'https://262.ecma-international.org/10.0/#sec-hasproperty'
	},
	'host-synchronizes-with': {
		url: 'https://262.ecma-international.org/10.0/#sec-host-synchronizes-with'
	},
	HostEventSet: {
		url: 'https://262.ecma-international.org/10.0/#sec-hosteventset'
	},
	HourFromTime: {
		url: 'https://262.ecma-international.org/10.0/#eqn-HourFromTime'
	},
	IfAbruptRejectPromise: {
		url: 'https://262.ecma-international.org/10.0/#sec-ifabruptrejectpromise'
	},
	ImportedLocalNames: {
		url: 'https://262.ecma-international.org/10.0/#sec-importedlocalnames'
	},
	InitializeBoundName: {
		url: 'https://262.ecma-international.org/10.0/#sec-initializeboundname'
	},
	InitializeEnvironment: {
		url: 'https://262.ecma-international.org/10.0/#sec-source-text-module-record-initialize-environment'
	},
	InitializeHostDefinedRealm: {
		url: 'https://262.ecma-international.org/10.0/#sec-initializehostdefinedrealm'
	},
	InitializeReferencedBinding: {
		url: 'https://262.ecma-international.org/10.0/#sec-initializereferencedbinding'
	},
	InLeapYear: {
		url: 'https://262.ecma-international.org/10.0/#eqn-InLeapYear'
	},
	InnerModuleEvaluation: {
		url: 'https://262.ecma-international.org/10.0/#sec-innermoduleevaluation'
	},
	InnerModuleInstantiation: {
		url: 'https://262.ecma-international.org/10.0/#sec-innermoduleinstantiation'
	},
	InstanceofOperator: {
		url: 'https://262.ecma-international.org/10.0/#sec-instanceofoperator'
	},
	IntegerIndexedElementGet: {
		url: 'https://262.ecma-international.org/10.0/#sec-integerindexedelementget'
	},
	IntegerIndexedElementSet: {
		url: 'https://262.ecma-international.org/10.0/#sec-integerindexedelementset'
	},
	IntegerIndexedObjectCreate: {
		url: 'https://262.ecma-international.org/10.0/#sec-integerindexedobjectcreate'
	},
	InternalizeJSONProperty: {
		url: 'https://262.ecma-international.org/10.0/#sec-internalizejsonproperty'
	},
	Invoke: {
		url: 'https://262.ecma-international.org/10.0/#sec-invoke'
	},
	IsAccessorDescriptor: {
		url: 'https://262.ecma-international.org/10.0/#sec-isaccessordescriptor'
	},
	IsAnonymousFunctionDefinition: {
		url: 'https://262.ecma-international.org/10.0/#sec-isanonymousfunctiondefinition'
	},
	IsArray: {
		url: 'https://262.ecma-international.org/10.0/#sec-isarray'
	},
	IsCallable: {
		url: 'https://262.ecma-international.org/10.0/#sec-iscallable'
	},
	IsCompatiblePropertyDescriptor: {
		url: 'https://262.ecma-international.org/10.0/#sec-iscompatiblepropertydescriptor'
	},
	IsConcatSpreadable: {
		url: 'https://262.ecma-international.org/10.0/#sec-isconcatspreadable'
	},
	IsConstructor: {
		url: 'https://262.ecma-international.org/10.0/#sec-isconstructor'
	},
	IsDataDescriptor: {
		url: 'https://262.ecma-international.org/10.0/#sec-isdatadescriptor'
	},
	IsDetachedBuffer: {
		url: 'https://262.ecma-international.org/10.0/#sec-isdetachedbuffer'
	},
	IsExtensible: {
		url: 'https://262.ecma-international.org/10.0/#sec-isextensible-o'
	},
	IsGenericDescriptor: {
		url: 'https://262.ecma-international.org/10.0/#sec-isgenericdescriptor'
	},
	IsInTailPosition: {
		url: 'https://262.ecma-international.org/10.0/#sec-isintailposition'
	},
	IsInteger: {
		url: 'https://262.ecma-international.org/10.0/#sec-isinteger'
	},
	IsLabelledFunction: {
		url: 'https://262.ecma-international.org/10.0/#sec-islabelledfunction'
	},
	IsPromise: {
		url: 'https://262.ecma-international.org/10.0/#sec-ispromise'
	},
	IsPropertyKey: {
		url: 'https://262.ecma-international.org/10.0/#sec-ispropertykey'
	},
	IsPropertyReference: {
		url: 'https://262.ecma-international.org/10.0/#sec-ispropertyreference'
	},
	IsRegExp: {
		url: 'https://262.ecma-international.org/10.0/#sec-isregexp'
	},
	IsSharedArrayBuffer: {
		url: 'https://262.ecma-international.org/10.0/#sec-issharedarraybuffer'
	},
	IsStrictReference: {
		url: 'https://262.ecma-international.org/10.0/#sec-isstrictreference'
	},
	IsStringPrefix: {
		url: 'https://262.ecma-international.org/10.0/#sec-isstringprefix'
	},
	IsSuperReference: {
		url: 'https://262.ecma-international.org/10.0/#sec-issuperreference'
	},
	IsUnresolvableReference: {
		url: 'https://262.ecma-international.org/10.0/#sec-isunresolvablereference'
	},
	IsWordChar: {
		url: 'https://262.ecma-international.org/10.0/#sec-runtime-semantics-iswordchar-abstract-operation'
	},
	IterableToList: {
		url: 'https://262.ecma-international.org/10.0/#sec-iterabletolist'
	},
	IteratorClose: {
		url: 'https://262.ecma-international.org/10.0/#sec-iteratorclose'
	},
	IteratorComplete: {
		url: 'https://262.ecma-international.org/10.0/#sec-iteratorcomplete'
	},
	IteratorNext: {
		url: 'https://262.ecma-international.org/10.0/#sec-iteratornext'
	},
	IteratorStep: {
		url: 'https://262.ecma-international.org/10.0/#sec-iteratorstep'
	},
	IteratorValue: {
		url: 'https://262.ecma-international.org/10.0/#sec-iteratorvalue'
	},
	LeaveCriticalSection: {
		url: 'https://262.ecma-international.org/10.0/#sec-leavecriticalsection'
	},
	LocalTime: {
		url: 'https://262.ecma-international.org/10.0/#sec-localtime'
	},
	LoopContinues: {
		url: 'https://262.ecma-international.org/10.0/#sec-loopcontinues'
	},
	MakeArgGetter: {
		url: 'https://262.ecma-international.org/10.0/#sec-makearggetter'
	},
	MakeArgSetter: {
		url: 'https://262.ecma-international.org/10.0/#sec-makeargsetter'
	},
	MakeClassConstructor: {
		url: 'https://262.ecma-international.org/10.0/#sec-makeclassconstructor'
	},
	MakeConstructor: {
		url: 'https://262.ecma-international.org/10.0/#sec-makeconstructor'
	},
	MakeDate: {
		url: 'https://262.ecma-international.org/10.0/#sec-makedate'
	},
	MakeDay: {
		url: 'https://262.ecma-international.org/10.0/#sec-makeday'
	},
	MakeMethod: {
		url: 'https://262.ecma-international.org/10.0/#sec-makemethod'
	},
	MakeSuperPropertyReference: {
		url: 'https://262.ecma-international.org/10.0/#sec-makesuperpropertyreference'
	},
	MakeTime: {
		url: 'https://262.ecma-international.org/10.0/#sec-maketime'
	},
	max: {
		url: 'https://262.ecma-international.org/10.0/#eqn-max'
	},
	'memory-order': {
		url: 'https://262.ecma-international.org/10.0/#sec-memory-order'
	},
	min: {
		url: 'https://262.ecma-international.org/10.0/#eqn-min'
	},
	MinFromTime: {
		url: 'https://262.ecma-international.org/10.0/#eqn-MinFromTime'
	},
	ModuleNamespaceCreate: {
		url: 'https://262.ecma-international.org/10.0/#sec-modulenamespacecreate'
	},
	modulo: {
		url: 'https://262.ecma-international.org/10.0/#eqn-modulo'
	},
	MonthFromTime: {
		url: 'https://262.ecma-international.org/10.0/#eqn-MonthFromTime'
	},
	msFromTime: {
		url: 'https://262.ecma-international.org/10.0/#eqn-msFromTime'
	},
	NewDeclarativeEnvironment: {
		url: 'https://262.ecma-international.org/10.0/#sec-newdeclarativeenvironment'
	},
	NewFunctionEnvironment: {
		url: 'https://262.ecma-international.org/10.0/#sec-newfunctionenvironment'
	},
	NewGlobalEnvironment: {
		url: 'https://262.ecma-international.org/10.0/#sec-newglobalenvironment'
	},
	NewModuleEnvironment: {
		url: 'https://262.ecma-international.org/10.0/#sec-newmoduleenvironment'
	},
	NewObjectEnvironment: {
		url: 'https://262.ecma-international.org/10.0/#sec-newobjectenvironment'
	},
	NewPromiseCapability: {
		url: 'https://262.ecma-international.org/10.0/#sec-newpromisecapability'
	},
	NormalCompletion: {
		url: 'https://262.ecma-international.org/10.0/#sec-normalcompletion'
	},
	NotifyWaiter: {
		url: 'https://262.ecma-international.org/10.0/#sec-notifywaiter'
	},
	NumberToRawBytes: {
		url: 'https://262.ecma-international.org/10.0/#sec-numbertorawbytes'
	},
	NumberToString: {
		url: 'https://262.ecma-international.org/10.0/#sec-tostring-applied-to-the-number-type'
	},
	ObjectCreate: {
		url: 'https://262.ecma-international.org/10.0/#sec-objectcreate'
	},
	ObjectDefineProperties: {
		url: 'https://262.ecma-international.org/10.0/#sec-objectdefineproperties'
	},
	OrdinaryCallBindThis: {
		url: 'https://262.ecma-international.org/10.0/#sec-ordinarycallbindthis'
	},
	OrdinaryCallEvaluateBody: {
		url: 'https://262.ecma-international.org/10.0/#sec-ordinarycallevaluatebody'
	},
	OrdinaryCreateFromConstructor: {
		url: 'https://262.ecma-international.org/10.0/#sec-ordinarycreatefromconstructor'
	},
	OrdinaryDefineOwnProperty: {
		url: 'https://262.ecma-international.org/10.0/#sec-ordinarydefineownproperty'
	},
	OrdinaryDelete: {
		url: 'https://262.ecma-international.org/10.0/#sec-ordinarydelete'
	},
	OrdinaryGet: {
		url: 'https://262.ecma-international.org/10.0/#sec-ordinaryget'
	},
	OrdinaryGetOwnProperty: {
		url: 'https://262.ecma-international.org/10.0/#sec-ordinarygetownproperty'
	},
	OrdinaryGetPrototypeOf: {
		url: 'https://262.ecma-international.org/10.0/#sec-ordinarygetprototypeof'
	},
	OrdinaryHasInstance: {
		url: 'https://262.ecma-international.org/10.0/#sec-ordinaryhasinstance'
	},
	OrdinaryHasProperty: {
		url: 'https://262.ecma-international.org/10.0/#sec-ordinaryhasproperty'
	},
	OrdinaryIsExtensible: {
		url: 'https://262.ecma-international.org/10.0/#sec-ordinaryisextensible'
	},
	OrdinaryOwnPropertyKeys: {
		url: 'https://262.ecma-international.org/10.0/#sec-ordinaryownpropertykeys'
	},
	OrdinaryPreventExtensions: {
		url: 'https://262.ecma-international.org/10.0/#sec-ordinarypreventextensions'
	},
	OrdinarySet: {
		url: 'https://262.ecma-international.org/10.0/#sec-ordinaryset'
	},
	OrdinarySetPrototypeOf: {
		url: 'https://262.ecma-international.org/10.0/#sec-ordinarysetprototypeof'
	},
	OrdinarySetWithOwnDescriptor: {
		url: 'https://262.ecma-international.org/10.0/#sec-ordinarysetwithowndescriptor'
	},
	OrdinaryToPrimitive: {
		url: 'https://262.ecma-international.org/10.0/#sec-ordinarytoprimitive'
	},
	ParseModule: {
		url: 'https://262.ecma-international.org/10.0/#sec-parsemodule'
	},
	ParseScript: {
		url: 'https://262.ecma-international.org/10.0/#sec-parse-script'
	},
	PerformEval: {
		url: 'https://262.ecma-international.org/10.0/#sec-performeval'
	},
	PerformPromiseAll: {
		url: 'https://262.ecma-international.org/10.0/#sec-performpromiseall'
	},
	PerformPromiseRace: {
		url: 'https://262.ecma-international.org/10.0/#sec-performpromiserace'
	},
	PerformPromiseThen: {
		url: 'https://262.ecma-international.org/10.0/#sec-performpromisethen'
	},
	PrepareForOrdinaryCall: {
		url: 'https://262.ecma-international.org/10.0/#sec-prepareforordinarycall'
	},
	PrepareForTailCall: {
		url: 'https://262.ecma-international.org/10.0/#sec-preparefortailcall'
	},
	PromiseReactionJob: {
		url: 'https://262.ecma-international.org/10.0/#sec-promisereactionjob'
	},
	PromiseResolve: {
		url: 'https://262.ecma-international.org/10.0/#sec-promise-resolve'
	},
	PromiseResolveThenableJob: {
		url: 'https://262.ecma-international.org/10.0/#sec-promiseresolvethenablejob'
	},
	ProxyCreate: {
		url: 'https://262.ecma-international.org/10.0/#sec-proxycreate'
	},
	PutValue: {
		url: 'https://262.ecma-international.org/10.0/#sec-putvalue'
	},
	QuoteJSONString: {
		url: 'https://262.ecma-international.org/10.0/#sec-quotejsonstring'
	},
	RawBytesToNumber: {
		url: 'https://262.ecma-international.org/10.0/#sec-rawbytestonumber'
	},
	'reads-bytes-from': {
		url: 'https://262.ecma-international.org/10.0/#sec-reads-bytes-from'
	},
	'reads-from': {
		url: 'https://262.ecma-international.org/10.0/#sec-reads-from'
	},
	RegExpAlloc: {
		url: 'https://262.ecma-international.org/10.0/#sec-regexpalloc'
	},
	RegExpBuiltinExec: {
		url: 'https://262.ecma-international.org/10.0/#sec-regexpbuiltinexec'
	},
	RegExpCreate: {
		url: 'https://262.ecma-international.org/10.0/#sec-regexpcreate'
	},
	RegExpExec: {
		url: 'https://262.ecma-international.org/10.0/#sec-regexpexec'
	},
	RegExpInitialize: {
		url: 'https://262.ecma-international.org/10.0/#sec-regexpinitialize'
	},
	RejectPromise: {
		url: 'https://262.ecma-international.org/10.0/#sec-rejectpromise'
	},
	RemoveWaiter: {
		url: 'https://262.ecma-international.org/10.0/#sec-removewaiter'
	},
	RemoveWaiters: {
		url: 'https://262.ecma-international.org/10.0/#sec-removewaiters'
	},
	RepeatMatcher: {
		url: 'https://262.ecma-international.org/10.0/#sec-runtime-semantics-repeatmatcher-abstract-operation'
	},
	RequireObjectCoercible: {
		url: 'https://262.ecma-international.org/10.0/#sec-requireobjectcoercible'
	},
	ResolveBinding: {
		url: 'https://262.ecma-international.org/10.0/#sec-resolvebinding'
	},
	ResolveThisBinding: {
		url: 'https://262.ecma-international.org/10.0/#sec-resolvethisbinding'
	},
	ReturnIfAbrupt: {
		url: 'https://262.ecma-international.org/10.0/#sec-returnifabrupt'
	},
	RunJobs: {
		url: 'https://262.ecma-international.org/10.0/#sec-runjobs'
	},
	SameValue: {
		url: 'https://262.ecma-international.org/10.0/#sec-samevalue'
	},
	SameValueNonNumber: {
		url: 'https://262.ecma-international.org/10.0/#sec-samevaluenonnumber'
	},
	SameValueZero: {
		url: 'https://262.ecma-international.org/10.0/#sec-samevaluezero'
	},
	ScriptEvaluation: {
		url: 'https://262.ecma-international.org/10.0/#sec-runtime-semantics-scriptevaluation'
	},
	ScriptEvaluationJob: {
		url: 'https://262.ecma-international.org/10.0/#sec-scriptevaluationjob'
	},
	SecFromTime: {
		url: 'https://262.ecma-international.org/10.0/#eqn-SecFromTime'
	},
	SerializeJSONArray: {
		url: 'https://262.ecma-international.org/10.0/#sec-serializejsonarray'
	},
	SerializeJSONObject: {
		url: 'https://262.ecma-international.org/10.0/#sec-serializejsonobject'
	},
	SerializeJSONProperty: {
		url: 'https://262.ecma-international.org/10.0/#sec-serializejsonproperty'
	},
	Set: {
		url: 'https://262.ecma-international.org/10.0/#sec-set-o-p-v-throw'
	},
	SetDefaultGlobalBindings: {
		url: 'https://262.ecma-international.org/10.0/#sec-setdefaultglobalbindings'
	},
	SetFunctionLength: {
		url: 'https://262.ecma-international.org/10.0/#sec-setfunctionlength'
	},
	SetFunctionName: {
		url: 'https://262.ecma-international.org/10.0/#sec-setfunctionname'
	},
	SetImmutablePrototype: {
		url: 'https://262.ecma-international.org/10.0/#sec-set-immutable-prototype'
	},
	SetIntegrityLevel: {
		url: 'https://262.ecma-international.org/10.0/#sec-setintegritylevel'
	},
	SetRealmGlobalObject: {
		url: 'https://262.ecma-international.org/10.0/#sec-setrealmglobalobject'
	},
	SetValueInBuffer: {
		url: 'https://262.ecma-international.org/10.0/#sec-setvalueinbuffer'
	},
	SetViewValue: {
		url: 'https://262.ecma-international.org/10.0/#sec-setviewvalue'
	},
	SharedDataBlockEventSet: {
		url: 'https://262.ecma-international.org/10.0/#sec-sharedatablockeventset'
	},
	SortCompare: {
		url: 'https://262.ecma-international.org/10.0/#sec-sortcompare'
	},
	SpeciesConstructor: {
		url: 'https://262.ecma-international.org/10.0/#sec-speciesconstructor'
	},
	SplitMatch: {
		url: 'https://262.ecma-international.org/10.0/#sec-splitmatch'
	},
	'Strict Equality Comparison': {
		url: 'https://262.ecma-international.org/10.0/#sec-strict-equality-comparison'
	},
	StringCreate: {
		url: 'https://262.ecma-international.org/10.0/#sec-stringcreate'
	},
	StringGetOwnProperty: {
		url: 'https://262.ecma-international.org/10.0/#sec-stringgetownproperty'
	},
	Suspend: {
		url: 'https://262.ecma-international.org/10.0/#sec-suspend'
	},
	SymbolDescriptiveString: {
		url: 'https://262.ecma-international.org/10.0/#sec-symboldescriptivestring'
	},
	SynchronizeEventSet: {
		url: 'https://262.ecma-international.org/10.0/#sec-synchronizeeventset'
	},
	'synchronizes-with': {
		url: 'https://262.ecma-international.org/10.0/#sec-synchronizes-with'
	},
	TestIntegrityLevel: {
		url: 'https://262.ecma-international.org/10.0/#sec-testintegritylevel'
	},
	thisBooleanValue: {
		url: 'https://262.ecma-international.org/10.0/#sec-thisbooleanvalue'
	},
	thisNumberValue: {
		url: 'https://262.ecma-international.org/10.0/#sec-thisnumbervalue'
	},
	thisStringValue: {
		url: 'https://262.ecma-international.org/10.0/#sec-thisstringvalue'
	},
	thisSymbolValue: {
		url: 'https://262.ecma-international.org/10.0/#sec-thissymbolvalue'
	},
	thisTimeValue: {
		url: 'https://262.ecma-international.org/10.0/#sec-thistimevalue'
	},
	ThrowCompletion: {
		url: 'https://262.ecma-international.org/10.0/#sec-throwcompletion'
	},
	TimeClip: {
		url: 'https://262.ecma-international.org/10.0/#sec-timeclip'
	},
	TimeFromYear: {
		url: 'https://262.ecma-international.org/10.0/#eqn-TimeFromYear'
	},
	TimeString: {
		url: 'https://262.ecma-international.org/10.0/#sec-timestring'
	},
	TimeWithinDay: {
		url: 'https://262.ecma-international.org/10.0/#eqn-TimeWithinDay'
	},
	TimeZoneString: {
		url: 'https://262.ecma-international.org/10.0/#sec-timezoneestring'
	},
	ToBoolean: {
		url: 'https://262.ecma-international.org/10.0/#sec-toboolean'
	},
	ToDateString: {
		url: 'https://262.ecma-international.org/10.0/#sec-todatestring'
	},
	ToIndex: {
		url: 'https://262.ecma-international.org/10.0/#sec-toindex'
	},
	ToInt16: {
		url: 'https://262.ecma-international.org/10.0/#sec-toint16'
	},
	ToInt32: {
		url: 'https://262.ecma-international.org/10.0/#sec-toint32'
	},
	ToInt8: {
		url: 'https://262.ecma-international.org/10.0/#sec-toint8'
	},
	ToInteger: {
		url: 'https://262.ecma-international.org/10.0/#sec-tointeger'
	},
	ToLength: {
		url: 'https://262.ecma-international.org/10.0/#sec-tolength'
	},
	ToNumber: {
		url: 'https://262.ecma-international.org/10.0/#sec-tonumber'
	},
	ToObject: {
		url: 'https://262.ecma-international.org/10.0/#sec-toobject'
	},
	TopLevelModuleEvaluationJob: {
		url: 'https://262.ecma-international.org/10.0/#sec-toplevelmoduleevaluationjob'
	},
	ToPrimitive: {
		url: 'https://262.ecma-international.org/10.0/#sec-toprimitive'
	},
	ToPropertyDescriptor: {
		url: 'https://262.ecma-international.org/10.0/#sec-topropertydescriptor'
	},
	ToPropertyKey: {
		url: 'https://262.ecma-international.org/10.0/#sec-topropertykey'
	},
	ToString: {
		url: 'https://262.ecma-international.org/10.0/#sec-tostring'
	},
	ToUint16: {
		url: 'https://262.ecma-international.org/10.0/#sec-touint16'
	},
	ToUint32: {
		url: 'https://262.ecma-international.org/10.0/#sec-touint32'
	},
	ToUint8: {
		url: 'https://262.ecma-international.org/10.0/#sec-touint8'
	},
	ToUint8Clamp: {
		url: 'https://262.ecma-international.org/10.0/#sec-touint8clamp'
	},
	TriggerPromiseReactions: {
		url: 'https://262.ecma-international.org/10.0/#sec-triggerpromisereactions'
	},
	TrimString: {
		url: 'https://262.ecma-international.org/10.0/#sec-trimstring'
	},
	Type: {
		url: 'https://262.ecma-international.org/10.0/#sec-ecmascript-data-types-and-values'
	},
	TypedArrayCreate: {
		url: 'https://262.ecma-international.org/10.0/#typedarray-create'
	},
	TypedArraySpeciesCreate: {
		url: 'https://262.ecma-international.org/10.0/#typedarray-species-create'
	},
	UnicodeEscape: {
		url: 'https://262.ecma-international.org/10.0/#sec-unicodeescape'
	},
	UnicodeMatchProperty: {
		url: 'https://262.ecma-international.org/10.0/#sec-runtime-semantics-unicodematchproperty-p'
	},
	UnicodeMatchPropertyValue: {
		url: 'https://262.ecma-international.org/10.0/#sec-runtime-semantics-unicodematchpropertyvalue-p-v'
	},
	UpdateEmpty: {
		url: 'https://262.ecma-international.org/10.0/#sec-updateempty'
	},
	UTC: {
		url: 'https://262.ecma-international.org/10.0/#sec-utc-t'
	},
	UTF16Decode: {
		url: 'https://262.ecma-international.org/10.0/#sec-utf16decode'
	},
	UTF16Encoding: {
		url: 'https://262.ecma-international.org/10.0/#sec-utf16encoding'
	},
	ValidateAndApplyPropertyDescriptor: {
		url: 'https://262.ecma-international.org/10.0/#sec-validateandapplypropertydescriptor'
	},
	ValidateAtomicAccess: {
		url: 'https://262.ecma-international.org/10.0/#sec-validateatomicaccess'
	},
	ValidateSharedIntegerTypedArray: {
		url: 'https://262.ecma-international.org/10.0/#sec-validatesharedintegertypedarray'
	},
	ValidateTypedArray: {
		url: 'https://262.ecma-international.org/10.0/#sec-validatetypedarray'
	},
	ValueOfReadEvent: {
		url: 'https://262.ecma-international.org/10.0/#sec-valueofreadevent'
	},
	WeekDay: {
		url: 'https://262.ecma-international.org/10.0/#sec-week-day'
	},
	WordCharacters: {
		url: 'https://262.ecma-international.org/10.0/#sec-runtime-semantics-wordcharacters-abstract-operation'
	},
	YearFromTime: {
		url: 'https://262.ecma-international.org/10.0/#eqn-YearFromTime'
	}
};
'use strict';

module.exports = {
	abs: {
		url: 'https://262.ecma-international.org/11.0/#eqn-abs'
	},
	'Abstract Equality Comparison': {
		url: 'https://262.ecma-international.org/11.0/#sec-abstract-equality-comparison'
	},
	'Abstract Relational Comparison': {
		url: 'https://262.ecma-international.org/11.0/#sec-abstract-relational-comparison'
	},
	AddEntriesFromIterable: {
		url: 'https://262.ecma-international.org/11.0/#sec-add-entries-from-iterable'
	},
	AddRestrictedFunctionProperties: {
		url: 'https://262.ecma-international.org/11.0/#sec-addrestrictedfunctionproperties'
	},
	AddWaiter: {
		url: 'https://262.ecma-international.org/11.0/#sec-addwaiter'
	},
	AdvanceStringIndex: {
		url: 'https://262.ecma-international.org/11.0/#sec-advancestringindex'
	},
	'agent-order': {
		url: 'https://262.ecma-international.org/11.0/#sec-agent-order'
	},
	AgentCanSuspend: {
		url: 'https://262.ecma-international.org/11.0/#sec-agentcansuspend'
	},
	AgentSignifier: {
		url: 'https://262.ecma-international.org/11.0/#sec-agentsignifier'
	},
	AllocateArrayBuffer: {
		url: 'https://262.ecma-international.org/11.0/#sec-allocatearraybuffer'
	},
	AllocateSharedArrayBuffer: {
		url: 'https://262.ecma-international.org/11.0/#sec-allocatesharedarraybuffer'
	},
	AllocateTypedArray: {
		url: 'https://262.ecma-international.org/11.0/#sec-allocatetypedarray'
	},
	AllocateTypedArrayBuffer: {
		url: 'https://262.ecma-international.org/11.0/#sec-allocatetypedarraybuffer'
	},
	ArrayCreate: {
		url: 'https://262.ecma-international.org/11.0/#sec-arraycreate'
	},
	ArraySetLength: {
		url: 'https://262.ecma-international.org/11.0/#sec-arraysetlength'
	},
	ArraySpeciesCreate: {
		url: 'https://262.ecma-international.org/11.0/#sec-arrayspeciescreate'
	},
	AsyncFromSyncIteratorContinuation: {
		url: 'https://262.ecma-international.org/11.0/#sec-asyncfromsynciteratorcontinuation'
	},
	AsyncFunctionStart: {
		url: 'https://262.ecma-international.org/11.0/#sec-async-functions-abstract-operations-async-function-start'
	},
	AsyncGeneratorEnqueue: {
		url: 'https://262.ecma-international.org/11.0/#sec-asyncgeneratorenqueue'
	},
	AsyncGeneratorReject: {
		url: 'https://262.ecma-international.org/11.0/#sec-asyncgeneratorreject'
	},
	AsyncGeneratorResolve: {
		url: 'https://262.ecma-international.org/11.0/#sec-asyncgeneratorresolve'
	},
	AsyncGeneratorResumeNext: {
		url: 'https://262.ecma-international.org/11.0/#sec-asyncgeneratorresumenext'
	},
	AsyncGeneratorStart: {
		url: 'https://262.ecma-international.org/11.0/#sec-asyncgeneratorstart'
	},
	AsyncGeneratorYield: {
		url: 'https://262.ecma-international.org/11.0/#sec-asyncgeneratoryield'
	},
	AsyncIteratorClose: {
		url: 'https://262.ecma-international.org/11.0/#sec-asynciteratorclose'
	},
	AtomicLoad: {
		url: 'https://262.ecma-international.org/11.0/#sec-atomicload'
	},
	AtomicReadModifyWrite: {
		url: 'https://262.ecma-international.org/11.0/#sec-atomicreadmodifywrite'
	},
	Await: {
		url: 'https://262.ecma-international.org/11.0/#await'
	},
	BackreferenceMatcher: {
		url: 'https://262.ecma-international.org/11.0/#sec-backreference-matcher'
	},
	'BigInt::add': {
		url: 'https://262.ecma-international.org/11.0/#sec-numeric-types-bigint-add'
	},
	'BigInt::bitwiseAND': {
		url: 'https://262.ecma-international.org/11.0/#sec-numeric-types-bigint-bitwiseAND'
	},
	'BigInt::bitwiseNOT': {
		url: 'https://262.ecma-international.org/11.0/#sec-numeric-types-bigint-bitwiseNOT'
	},
	'BigInt::bitwiseOR': {
		url: 'https://262.ecma-international.org/11.0/#sec-numeric-types-bigint-bitwiseOR'
	},
	'BigInt::bitwiseXOR': {
		url: 'https://262.ecma-international.org/11.0/#sec-numeric-types-bigint-bitwiseXOR'
	},
	'BigInt::divide': {
		url: 'https://262.ecma-international.org/11.0/#sec-numeric-types-bigint-divide'
	},
	'BigInt::equal': {
		url: 'https://262.ecma-international.org/11.0/#sec-numeric-types-bigint-equal'
	},
	'BigInt::exponentiate': {
		url: 'https://262.ecma-international.org/11.0/#sec-numeric-types-bigint-exponentiate'
	},
	'BigInt::leftShift': {
		url: 'https://262.ecma-international.org/11.0/#sec-numeric-types-bigint-leftShift'
	},
	'BigInt::lessThan': {
		url: 'https://262.ecma-international.org/11.0/#sec-numeric-types-bigint-lessThan'
	},
	'BigInt::multiply': {
		url: 'https://262.ecma-international.org/11.0/#sec-numeric-types-bigint-multiply'
	},
	'BigInt::remainder': {
		url: 'https://262.ecma-international.org/11.0/#sec-numeric-types-bigint-remainder'
	},
	'BigInt::sameValue': {
		url: 'https://262.ecma-international.org/11.0/#sec-numeric-types-bigint-sameValue'
	},
	'BigInt::sameValueZero': {
		url: 'https://262.ecma-international.org/11.0/#sec-numeric-types-bigint-sameValueZero'
	},
	'BigInt::signedRightShift': {
		url: 'https://262.ecma-international.org/11.0/#sec-numeric-types-bigint-signedRightShift'
	},
	'BigInt::subtract': {
		url: 'https://262.ecma-international.org/11.0/#sec-numeric-types-bigint-subtract'
	},
	'BigInt::toString': {
		url: 'https://262.ecma-international.org/11.0/#sec-numeric-types-bigint-tostring'
	},
	'BigInt::unaryMinus': {
		url: 'https://262.ecma-international.org/11.0/#sec-numeric-types-bigint-unaryMinus'
	},
	'BigInt::unsignedRightShift': {
		url: 'https://262.ecma-international.org/11.0/#sec-numeric-types-bigint-unsignedRightShift'
	},
	BigIntBitwiseOp: {
		url: 'https://262.ecma-international.org/11.0/#sec-bigintbitwiseop'
	},
	BinaryAnd: {
		url: 'https://262.ecma-international.org/11.0/#sec-binaryand'
	},
	BinaryOr: {
		url: 'https://262.ecma-international.org/11.0/#sec-binaryor'
	},
	BinaryXor: {
		url: 'https://262.ecma-international.org/11.0/#sec-binaryxor'
	},
	BlockDeclarationInstantiation: {
		url: 'https://262.ecma-international.org/11.0/#sec-blockdeclarationinstantiation'
	},
	BoundFunctionCreate: {
		url: 'https://262.ecma-international.org/11.0/#sec-boundfunctioncreate'
	},
	Call: {
		url: 'https://262.ecma-international.org/11.0/#sec-call'
	},
	Canonicalize: {
		url: 'https://262.ecma-international.org/11.0/#sec-runtime-semantics-canonicalize-ch'
	},
	CanonicalNumericIndexString: {
		url: 'https://262.ecma-international.org/11.0/#sec-canonicalnumericindexstring'
	},
	CaseClauseIsSelected: {
		url: 'https://262.ecma-international.org/11.0/#sec-runtime-semantics-caseclauseisselected'
	},
	CharacterRange: {
		url: 'https://262.ecma-international.org/11.0/#sec-runtime-semantics-characterrange-abstract-operation'
	},
	CharacterRangeOrUnion: {
		url: 'https://262.ecma-international.org/11.0/#sec-runtime-semantics-characterrangeorunion-abstract-operation'
	},
	CharacterSetMatcher: {
		url: 'https://262.ecma-international.org/11.0/#sec-runtime-semantics-charactersetmatcher-abstract-operation'
	},
	CloneArrayBuffer: {
		url: 'https://262.ecma-international.org/11.0/#sec-clonearraybuffer'
	},
	CodePointAt: {
		url: 'https://262.ecma-international.org/11.0/#sec-codepointat'
	},
	CompletePropertyDescriptor: {
		url: 'https://262.ecma-international.org/11.0/#sec-completepropertydescriptor'
	},
	Completion: {
		url: 'https://262.ecma-international.org/11.0/#sec-completion-record-specification-type'
	},
	CompletionRecord: {
		url: 'https://262.ecma-international.org/11.0/#sec-completion-record-specification-type'
	},
	ComposeWriteEventBytes: {
		url: 'https://262.ecma-international.org/11.0/#sec-composewriteeventbytes'
	},
	Construct: {
		url: 'https://262.ecma-international.org/11.0/#sec-construct'
	},
	CopyDataBlockBytes: {
		url: 'https://262.ecma-international.org/11.0/#sec-copydatablockbytes'
	},
	CopyDataProperties: {
		url: 'https://262.ecma-international.org/11.0/#sec-copydataproperties'
	},
	CreateArrayFromList: {
		url: 'https://262.ecma-international.org/11.0/#sec-createarrayfromlist'
	},
	CreateArrayIterator: {
		url: 'https://262.ecma-international.org/11.0/#sec-createarrayiterator'
	},
	CreateAsyncFromSyncIterator: {
		url: 'https://262.ecma-international.org/11.0/#sec-createasyncfromsynciterator'
	},
	CreateBuiltinFunction: {
		url: 'https://262.ecma-international.org/11.0/#sec-createbuiltinfunction'
	},
	CreateByteDataBlock: {
		url: 'https://262.ecma-international.org/11.0/#sec-createbytedatablock'
	},
	CreateDataProperty: {
		url: 'https://262.ecma-international.org/11.0/#sec-createdataproperty'
	},
	CreateDataPropertyOrThrow: {
		url: 'https://262.ecma-international.org/11.0/#sec-createdatapropertyorthrow'
	},
	CreateDynamicFunction: {
		url: 'https://262.ecma-international.org/11.0/#sec-createdynamicfunction'
	},
	CreateForInIterator: {
		url: 'https://262.ecma-international.org/11.0/#sec-createforiniterator'
	},
	CreateHTML: {
		url: 'https://262.ecma-international.org/11.0/#sec-createhtml'
	},
	CreateIntrinsics: {
		url: 'https://262.ecma-international.org/11.0/#sec-createintrinsics'
	},
	CreateIterResultObject: {
		url: 'https://262.ecma-international.org/11.0/#sec-createiterresultobject'
	},
	CreateListFromArrayLike: {
		url: 'https://262.ecma-international.org/11.0/#sec-createlistfromarraylike'
	},
	CreateListIteratorRecord: {
		url: 'https://262.ecma-international.org/11.0/#sec-createlistiteratorRecord'
	},
	CreateMapIterator: {
		url: 'https://262.ecma-international.org/11.0/#sec-createmapiterator'
	},
	CreateMappedArgumentsObject: {
		url: 'https://262.ecma-international.org/11.0/#sec-createmappedargumentsobject'
	},
	CreateMethodProperty: {
		url: 'https://262.ecma-international.org/11.0/#sec-createmethodproperty'
	},
	CreatePerIterationEnvironment: {
		url: 'https://262.ecma-international.org/11.0/#sec-createperiterationenvironment'
	},
	CreateRealm: {
		url: 'https://262.ecma-international.org/11.0/#sec-createrealm'
	},
	CreateRegExpStringIterator: {
		url: 'https://262.ecma-international.org/11.0/#sec-createregexpstringiterator'
	},
	CreateResolvingFunctions: {
		url: 'https://262.ecma-international.org/11.0/#sec-createresolvingfunctions'
	},
	CreateSetIterator: {
		url: 'https://262.ecma-international.org/11.0/#sec-createsetiterator'
	},
	CreateSharedByteDataBlock: {
		url: 'https://262.ecma-international.org/11.0/#sec-createsharedbytedatablock'
	},
	CreateStringIterator: {
		url: 'https://262.ecma-international.org/11.0/#sec-createstringiterator'
	},
	CreateUnmappedArgumentsObject: {
		url: 'https://262.ecma-international.org/11.0/#sec-createunmappedargumentsobject'
	},
	DateFromTime: {
		url: 'https://262.ecma-international.org/11.0/#sec-date-number'
	},
	DateString: {
		url: 'https://262.ecma-international.org/11.0/#sec-datestring'
	},
	Day: {
		url: 'https://262.ecma-international.org/11.0/#eqn-Day'
	},
	DayFromYear: {
		url: 'https://262.ecma-international.org/11.0/#eqn-DaysFromYear'
	},
	DaysInYear: {
		url: 'https://262.ecma-international.org/11.0/#eqn-DaysInYear'
	},
	DayWithinYear: {
		url: 'https://262.ecma-international.org/11.0/#eqn-DayWithinYear'
	},
	Decode: {
		url: 'https://262.ecma-international.org/11.0/#sec-decode'
	},
	DefinePropertyOrThrow: {
		url: 'https://262.ecma-international.org/11.0/#sec-definepropertyorthrow'
	},
	DeletePropertyOrThrow: {
		url: 'https://262.ecma-international.org/11.0/#sec-deletepropertyorthrow'
	},
	DetachArrayBuffer: {
		url: 'https://262.ecma-international.org/11.0/#sec-detacharraybuffer'
	},
	Encode: {
		url: 'https://262.ecma-international.org/11.0/#sec-encode'
	},
	EnterCriticalSection: {
		url: 'https://262.ecma-international.org/11.0/#sec-entercriticalsection'
	},
	EnumerableOwnPropertyNames: {
		url: 'https://262.ecma-international.org/11.0/#sec-enumerableownpropertynames'
	},
	EnumerateObjectProperties: {
		url: 'https://262.ecma-international.org/11.0/#sec-enumerate-object-properties'
	},
	EscapeRegExpPattern: {
		url: 'https://262.ecma-international.org/11.0/#sec-escaperegexppattern'
	},
	EvalDeclarationInstantiation: {
		url: 'https://262.ecma-international.org/11.0/#sec-evaldeclarationinstantiation'
	},
	EvaluateCall: {
		url: 'https://262.ecma-international.org/11.0/#sec-evaluatecall'
	},
	EvaluateNew: {
		url: 'https://262.ecma-international.org/11.0/#sec-evaluatenew'
	},
	EvaluatePropertyAccessWithExpressionKey: {
		url: 'https://262.ecma-international.org/11.0/#sec-evaluate-property-access-with-expression-key'
	},
	EvaluatePropertyAccessWithIdentifierKey: {
		url: 'https://262.ecma-international.org/11.0/#sec-evaluate-property-access-with-identifier-key'
	},
	EventSet: {
		url: 'https://262.ecma-international.org/11.0/#sec-event-set'
	},
	ExecuteModule: {
		url: 'https://262.ecma-international.org/11.0/#sec-source-text-module-record-execute-module'
	},
	FinishDynamicImport: {
		url: 'https://262.ecma-international.org/11.0/#sec-finishdynamicimport'
	},
	FlattenIntoArray: {
		url: 'https://262.ecma-international.org/11.0/#sec-flattenintoarray'
	},
	floor: {
		url: 'https://262.ecma-international.org/11.0/#eqn-floor'
	},
	ForBodyEvaluation: {
		url: 'https://262.ecma-international.org/11.0/#sec-forbodyevaluation'
	},
	'ForIn/OfBodyEvaluation': {
		url: 'https://262.ecma-international.org/11.0/#sec-runtime-semantics-forin-div-ofbodyevaluation-lhs-stmt-iterator-lhskind-labelset'
	},
	'ForIn/OfHeadEvaluation': {
		url: 'https://262.ecma-international.org/11.0/#sec-runtime-semantics-forinofheadevaluation'
	},
	FromPropertyDescriptor: {
		url: 'https://262.ecma-international.org/11.0/#sec-frompropertydescriptor'
	},
	FulfillPromise: {
		url: 'https://262.ecma-international.org/11.0/#sec-fulfillpromise'
	},
	FunctionDeclarationInstantiation: {
		url: 'https://262.ecma-international.org/11.0/#sec-functiondeclarationinstantiation'
	},
	GeneratorResume: {
		url: 'https://262.ecma-international.org/11.0/#sec-generatorresume'
	},
	GeneratorResumeAbrupt: {
		url: 'https://262.ecma-international.org/11.0/#sec-generatorresumeabrupt'
	},
	GeneratorStart: {
		url: 'https://262.ecma-international.org/11.0/#sec-generatorstart'
	},
	GeneratorValidate: {
		url: 'https://262.ecma-international.org/11.0/#sec-generatorvalidate'
	},
	GeneratorYield: {
		url: 'https://262.ecma-international.org/11.0/#sec-generatoryield'
	},
	Get: {
		url: 'https://262.ecma-international.org/11.0/#sec-get-o-p'
	},
	GetActiveScriptOrModule: {
		url: 'https://262.ecma-international.org/11.0/#sec-getactivescriptormodule'
	},
	GetBase: {
		url: 'https://262.ecma-international.org/11.0/#sec-getbase'
	},
	GetFunctionRealm: {
		url: 'https://262.ecma-international.org/11.0/#sec-getfunctionrealm'
	},
	GetGeneratorKind: {
		url: 'https://262.ecma-international.org/11.0/#sec-getgeneratorkind'
	},
	GetGlobalObject: {
		url: 'https://262.ecma-international.org/11.0/#sec-getglobalobject'
	},
	GetIdentifierReference: {
		url: 'https://262.ecma-international.org/11.0/#sec-getidentifierreference'
	},
	GetIterator: {
		url: 'https://262.ecma-international.org/11.0/#sec-getiterator'
	},
	GetMethod: {
		url: 'https://262.ecma-international.org/11.0/#sec-getmethod'
	},
	GetModifySetValueInBuffer: {
		url: 'https://262.ecma-international.org/11.0/#sec-getmodifysetvalueinbuffer'
	},
	GetModuleNamespace: {
		url: 'https://262.ecma-international.org/11.0/#sec-getmodulenamespace'
	},
	GetNewTarget: {
		url: 'https://262.ecma-international.org/11.0/#sec-getnewtarget'
	},
	GetOwnPropertyKeys: {
		url: 'https://262.ecma-international.org/11.0/#sec-getownpropertykeys'
	},
	GetPrototypeFromConstructor: {
		url: 'https://262.ecma-international.org/11.0/#sec-getprototypefromconstructor'
	},
	GetReferencedName: {
		url: 'https://262.ecma-international.org/11.0/#sec-getreferencedname'
	},
	GetSubstitution: {
		url: 'https://262.ecma-international.org/11.0/#sec-getsubstitution'
	},
	GetSuperConstructor: {
		url: 'https://262.ecma-international.org/11.0/#sec-getsuperconstructor'
	},
	GetTemplateObject: {
		url: 'https://262.ecma-international.org/11.0/#sec-gettemplateobject'
	},
	GetThisEnvironment: {
		url: 'https://262.ecma-international.org/11.0/#sec-getthisenvironment'
	},
	GetThisValue: {
		url: 'https://262.ecma-international.org/11.0/#sec-getthisvalue'
	},
	GetV: {
		url: 'https://262.ecma-international.org/11.0/#sec-getv'
	},
	GetValue: {
		url: 'https://262.ecma-international.org/11.0/#sec-getvalue'
	},
	GetValueFromBuffer: {
		url: 'https://262.ecma-international.org/11.0/#sec-getvaluefrombuffer'
	},
	GetViewValue: {
		url: 'https://262.ecma-international.org/11.0/#sec-getviewvalue'
	},
	GetWaiterList: {
		url: 'https://262.ecma-international.org/11.0/#sec-getwaiterlist'
	},
	GlobalDeclarationInstantiation: {
		url: 'https://262.ecma-international.org/11.0/#sec-globaldeclarationinstantiation'
	},
	'happens-before': {
		url: 'https://262.ecma-international.org/11.0/#sec-happens-before'
	},
	HasOwnProperty: {
		url: 'https://262.ecma-international.org/11.0/#sec-hasownproperty'
	},
	HasPrimitiveBase: {
		url: 'https://262.ecma-international.org/11.0/#sec-hasprimitivebase'
	},
	HasProperty: {
		url: 'https://262.ecma-international.org/11.0/#sec-hasproperty'
	},
	'host-synchronizes-with': {
		url: 'https://262.ecma-international.org/11.0/#sec-host-synchronizes-with'
	},
	HostEventSet: {
		url: 'https://262.ecma-international.org/11.0/#sec-hosteventset'
	},
	HourFromTime: {
		url: 'https://262.ecma-international.org/11.0/#eqn-HourFromTime'
	},
	IfAbruptRejectPromise: {
		url: 'https://262.ecma-international.org/11.0/#sec-ifabruptrejectpromise'
	},
	ImportedLocalNames: {
		url: 'https://262.ecma-international.org/11.0/#sec-importedlocalnames'
	},
	InitializeBoundName: {
		url: 'https://262.ecma-international.org/11.0/#sec-initializeboundname'
	},
	InitializeEnvironment: {
		url: 'https://262.ecma-international.org/11.0/#sec-source-text-module-record-initialize-environment'
	},
	InitializeHostDefinedRealm: {
		url: 'https://262.ecma-international.org/11.0/#sec-initializehostdefinedrealm'
	},
	InitializeReferencedBinding: {
		url: 'https://262.ecma-international.org/11.0/#sec-initializereferencedbinding'
	},
	InLeapYear: {
		url: 'https://262.ecma-international.org/11.0/#eqn-InLeapYear'
	},
	InnerModuleEvaluation: {
		url: 'https://262.ecma-international.org/11.0/#sec-innermoduleevaluation'
	},
	InnerModuleLinking: {
		url: 'https://262.ecma-international.org/11.0/#sec-InnerModuleLinking'
	},
	InstanceofOperator: {
		url: 'https://262.ecma-international.org/11.0/#sec-instanceofoperator'
	},
	IntegerIndexedElementGet: {
		url: 'https://262.ecma-international.org/11.0/#sec-integerindexedelementget'
	},
	IntegerIndexedElementSet: {
		url: 'https://262.ecma-international.org/11.0/#sec-integerindexedelementset'
	},
	IntegerIndexedObjectCreate: {
		url: 'https://262.ecma-international.org/11.0/#sec-integerindexedobjectcreate'
	},
	InternalizeJSONProperty: {
		url: 'https://262.ecma-international.org/11.0/#sec-internalizejsonproperty'
	},
	Invoke: {
		url: 'https://262.ecma-international.org/11.0/#sec-invoke'
	},
	IsAccessorDescriptor: {
		url: 'https://262.ecma-international.org/11.0/#sec-isaccessordescriptor'
	},
	IsAnonymousFunctionDefinition: {
		url: 'https://262.ecma-international.org/11.0/#sec-isanonymousfunctiondefinition'
	},
	IsArray: {
		url: 'https://262.ecma-international.org/11.0/#sec-isarray'
	},
	IsBigIntElementType: {
		url: 'https://262.ecma-international.org/11.0/#sec-isbigintelementtype'
	},
	IsCallable: {
		url: 'https://262.ecma-international.org/11.0/#sec-iscallable'
	},
	IsCompatiblePropertyDescriptor: {
		url: 'https://262.ecma-international.org/11.0/#sec-iscompatiblepropertydescriptor'
	},
	IsConcatSpreadable: {
		url: 'https://262.ecma-international.org/11.0/#sec-isconcatspreadable'
	},
	IsConstructor: {
		url: 'https://262.ecma-international.org/11.0/#sec-isconstructor'
	},
	IsDataDescriptor: {
		url: 'https://262.ecma-international.org/11.0/#sec-isdatadescriptor'
	},
	IsDetachedBuffer: {
		url: 'https://262.ecma-international.org/11.0/#sec-isdetachedbuffer'
	},
	IsExtensible: {
		url: 'https://262.ecma-international.org/11.0/#sec-isextensible-o'
	},
	IsGenericDescriptor: {
		url: 'https://262.ecma-international.org/11.0/#sec-isgenericdescriptor'
	},
	IsInTailPosition: {
		url: 'https://262.ecma-international.org/11.0/#sec-isintailposition'
	},
	IsInteger: {
		url: 'https://262.ecma-international.org/11.0/#sec-isinteger'
	},
	IsLabelledFunction: {
		url: 'https://262.ecma-international.org/11.0/#sec-islabelledfunction'
	},
	IsNonNegativeInteger: {
		url: 'https://262.ecma-international.org/11.0/#sec-isnonnegativeinteger'
	},
	IsNoTearConfiguration: {
		url: 'https://262.ecma-international.org/11.0/#sec-isnotearconfiguration'
	},
	IsPromise: {
		url: 'https://262.ecma-international.org/11.0/#sec-ispromise'
	},
	IsPropertyKey: {
		url: 'https://262.ecma-international.org/11.0/#sec-ispropertykey'
	},
	IsPropertyReference: {
		url: 'https://262.ecma-international.org/11.0/#sec-ispropertyreference'
	},
	IsRegExp: {
		url: 'https://262.ecma-international.org/11.0/#sec-isregexp'
	},
	IsSharedArrayBuffer: {
		url: 'https://262.ecma-international.org/11.0/#sec-issharedarraybuffer'
	},
	IsStrictReference: {
		url: 'https://262.ecma-international.org/11.0/#sec-isstrictreference'
	},
	IsStringPrefix: {
		url: 'https://262.ecma-international.org/11.0/#sec-isstringprefix'
	},
	IsSuperReference: {
		url: 'https://262.ecma-international.org/11.0/#sec-issuperreference'
	},
	IsUnclampedIntegerElementType: {
		url: 'https://262.ecma-international.org/11.0/#sec-isunclampedintegerelementtype'
	},
	IsUnresolvableReference: {
		url: 'https://262.ecma-international.org/11.0/#sec-isunresolvablereference'
	},
	IsUnsignedElementType: {
		url: 'https://262.ecma-international.org/11.0/#sec-isunsignedelementtype'
	},
	IsValidIntegerIndex: {
		url: 'https://262.ecma-international.org/11.0/#sec-isvalidintegerindex'
	},
	IsValidRegularExpressionLiteral: {
		url: 'https://262.ecma-international.org/11.0/#sec-isvalidregularexpressionliteral'
	},
	IsWordChar: {
		url: 'https://262.ecma-international.org/11.0/#sec-runtime-semantics-iswordchar-abstract-operation'
	},
	IterableToList: {
		url: 'https://262.ecma-international.org/11.0/#sec-iterabletolist'
	},
	IteratorClose: {
		url: 'https://262.ecma-international.org/11.0/#sec-iteratorclose'
	},
	IteratorComplete: {
		url: 'https://262.ecma-international.org/11.0/#sec-iteratorcomplete'
	},
	IteratorNext: {
		url: 'https://262.ecma-international.org/11.0/#sec-iteratornext'
	},
	IteratorStep: {
		url: 'https://262.ecma-international.org/11.0/#sec-iteratorstep'
	},
	IteratorValue: {
		url: 'https://262.ecma-international.org/11.0/#sec-iteratorvalue'
	},
	LeaveCriticalSection: {
		url: 'https://262.ecma-international.org/11.0/#sec-leavecriticalsection'
	},
	LengthOfArrayLike: {
		url: 'https://262.ecma-international.org/11.0/#sec-lengthofarraylike'
	},
	LocalTime: {
		url: 'https://262.ecma-international.org/11.0/#sec-localtime'
	},
	LocalTZA: {
		url: 'https://262.ecma-international.org/11.0/#sec-local-time-zone-adjustment'
	},
	LoopContinues: {
		url: 'https://262.ecma-international.org/11.0/#sec-loopcontinues'
	},
	MakeArgGetter: {
		url: 'https://262.ecma-international.org/11.0/#sec-makearggetter'
	},
	MakeArgSetter: {
		url: 'https://262.ecma-international.org/11.0/#sec-makeargsetter'
	},
	MakeBasicObject: {
		url: 'https://262.ecma-international.org/11.0/#sec-makebasicobject'
	},
	MakeClassConstructor: {
		url: 'https://262.ecma-international.org/11.0/#sec-makeclassconstructor'
	},
	MakeConstructor: {
		url: 'https://262.ecma-international.org/11.0/#sec-makeconstructor'
	},
	MakeDate: {
		url: 'https://262.ecma-international.org/11.0/#sec-makedate'
	},
	MakeDay: {
		url: 'https://262.ecma-international.org/11.0/#sec-makeday'
	},
	MakeMethod: {
		url: 'https://262.ecma-international.org/11.0/#sec-makemethod'
	},
	MakeSuperPropertyReference: {
		url: 'https://262.ecma-international.org/11.0/#sec-makesuperpropertyreference'
	},
	MakeTime: {
		url: 'https://262.ecma-international.org/11.0/#sec-maketime'
	},
	max: {
		url: 'https://262.ecma-international.org/11.0/#eqn-max'
	},
	'memory-order': {
		url: 'https://262.ecma-international.org/11.0/#sec-memory-order'
	},
	min: {
		url: 'https://262.ecma-international.org/11.0/#eqn-min'
	},
	MinFromTime: {
		url: 'https://262.ecma-international.org/11.0/#eqn-MinFromTime'
	},
	ModuleNamespaceCreate: {
		url: 'https://262.ecma-international.org/11.0/#sec-modulenamespacecreate'
	},
	modulo: {
		url: 'https://262.ecma-international.org/11.0/#eqn-modulo'
	},
	MonthFromTime: {
		url: 'https://262.ecma-international.org/11.0/#eqn-MonthFromTime'
	},
	msFromTime: {
		url: 'https://262.ecma-international.org/11.0/#eqn-msFromTime'
	},
	NewDeclarativeEnvironment: {
		url: 'https://262.ecma-international.org/11.0/#sec-newdeclarativeenvironment'
	},
	NewFunctionEnvironment: {
		url: 'https://262.ecma-international.org/11.0/#sec-newfunctionenvironment'
	},
	NewGlobalEnvironment: {
		url: 'https://262.ecma-international.org/11.0/#sec-newglobalenvironment'
	},
	NewModuleEnvironment: {
		url: 'https://262.ecma-international.org/11.0/#sec-newmoduleenvironment'
	},
	NewObjectEnvironment: {
		url: 'https://262.ecma-international.org/11.0/#sec-newobjectenvironment'
	},
	NewPromiseCapability: {
		url: 'https://262.ecma-international.org/11.0/#sec-newpromisecapability'
	},
	NewPromiseReactionJob: {
		url: 'https://262.ecma-international.org/11.0/#sec-newpromisereactionjob'
	},
	NewPromiseResolveThenableJob: {
		url: 'https://262.ecma-international.org/11.0/#sec-newpromiseresolvethenablejob'
	},
	NormalCompletion: {
		url: 'https://262.ecma-international.org/11.0/#sec-normalcompletion'
	},
	NotifyWaiter: {
		url: 'https://262.ecma-international.org/11.0/#sec-notifywaiter'
	},
	'Number::add': {
		url: 'https://262.ecma-international.org/11.0/#sec-numeric-types-number-add'
	},
	'Number::bitwiseAND': {
		url: 'https://262.ecma-international.org/11.0/#sec-numeric-types-number-bitwiseAND'
	},
	'Number::bitwiseNOT': {
		url: 'https://262.ecma-international.org/11.0/#sec-numeric-types-number-bitwiseNOT'
	},
	'Number::bitwiseOR': {
		url: 'https://262.ecma-international.org/11.0/#sec-numeric-types-number-bitwiseOR'
	},
	'Number::bitwiseXOR': {
		url: 'https://262.ecma-international.org/11.0/#sec-numeric-types-number-bitwiseXOR'
	},
	'Number::divide': {
		url: 'https://262.ecma-international.org/11.0/#sec-numeric-types-number-divide'
	},
	'Number::equal': {
		url: 'https://262.ecma-international.org/11.0/#sec-numeric-types-number-equal'
	},
	'Number::exponentiate': {
		url: 'https://262.ecma-international.org/11.0/#sec-numeric-types-number-exponentiate'
	},
	'Number::leftShift': {
		url: 'https://262.ecma-international.org/11.0/#sec-numeric-types-number-leftShift'
	},
	'Number::lessThan': {
		url: 'https://262.ecma-international.org/11.0/#sec-numeric-types-number-lessThan'
	},
	'Number::multiply': {
		url: 'https://262.ecma-international.org/11.0/#sec-numeric-types-number-multiply'
	},
	'Number::remainder': {
		url: 'https://262.ecma-international.org/11.0/#sec-numeric-types-number-remainder'
	},
	'Number::sameValue': {
		url: 'https://262.ecma-international.org/11.0/#sec-numeric-types-number-sameValue'
	},
	'Number::sameValueZero': {
		url: 'https://262.ecma-international.org/11.0/#sec-numeric-types-number-sameValueZero'
	},
	'Number::signedRightShift': {
		url: 'https://262.ecma-international.org/11.0/#sec-numeric-types-number-signedRightShift'
	},
	'Number::subtract': {
		url: 'https://262.ecma-international.org/11.0/#sec-numeric-types-number-subtract'
	},
	'Number::toString': {
		url: 'https://262.ecma-international.org/11.0/#sec-numeric-types-number-tostring'
	},
	'Number::unaryMinus': {
		url: 'https://262.ecma-international.org/11.0/#sec-numeric-types-number-unaryMinus'
	},
	'Number::unsignedRightShift': {
		url: 'https://262.ecma-international.org/11.0/#sec-numeric-types-number-unsignedRightShift'
	},
	NumberBitwiseOp: {
		url: 'https://262.ecma-international.org/11.0/#sec-numberbitwiseop'
	},
	NumberToBigInt: {
		url: 'https://262.ecma-international.org/11.0/#sec-numbertobigint'
	},
	NumericToRawBytes: {
		url: 'https://262.ecma-international.org/11.0/#sec-numerictorawbytes'
	},
	ObjectDefineProperties: {
		url: 'https://262.ecma-international.org/11.0/#sec-objectdefineproperties'
	},
	OrdinaryCallBindThis: {
		url: 'https://262.ecma-international.org/11.0/#sec-ordinarycallbindthis'
	},
	OrdinaryCallEvaluateBody: {
		url: 'https://262.ecma-international.org/11.0/#sec-ordinarycallevaluatebody'
	},
	OrdinaryCreateFromConstructor: {
		url: 'https://262.ecma-international.org/11.0/#sec-ordinarycreatefromconstructor'
	},
	OrdinaryDefineOwnProperty: {
		url: 'https://262.ecma-international.org/11.0/#sec-ordinarydefineownproperty'
	},
	OrdinaryDelete: {
		url: 'https://262.ecma-international.org/11.0/#sec-ordinarydelete'
	},
	OrdinaryFunctionCreate: {
		url: 'https://262.ecma-international.org/11.0/#sec-ordinaryfunctioncreate'
	},
	OrdinaryGet: {
		url: 'https://262.ecma-international.org/11.0/#sec-ordinaryget'
	},
	OrdinaryGetOwnProperty: {
		url: 'https://262.ecma-international.org/11.0/#sec-ordinarygetownproperty'
	},
	OrdinaryGetPrototypeOf: {
		url: 'https://262.ecma-international.org/11.0/#sec-ordinarygetprototypeof'
	},
	OrdinaryHasInstance: {
		url: 'https://262.ecma-international.org/11.0/#sec-ordinaryhasinstance'
	},
	OrdinaryHasProperty: {
		url: 'https://262.ecma-international.org/11.0/#sec-ordinaryhasproperty'
	},
	OrdinaryIsExtensible: {
		url: 'https://262.ecma-international.org/11.0/#sec-ordinaryisextensible'
	},
	OrdinaryObjectCreate: {
		url: 'https://262.ecma-international.org/11.0/#sec-ordinaryobjectcreate'
	},
	OrdinaryOwnPropertyKeys: {
		url: 'https://262.ecma-international.org/11.0/#sec-ordinaryownpropertykeys'
	},
	OrdinaryPreventExtensions: {
		url: 'https://262.ecma-international.org/11.0/#sec-ordinarypreventextensions'
	},
	OrdinarySet: {
		url: 'https://262.ecma-international.org/11.0/#sec-ordinaryset'
	},
	OrdinarySetPrototypeOf: {
		url: 'https://262.ecma-international.org/11.0/#sec-ordinarysetprototypeof'
	},
	OrdinarySetWithOwnDescriptor: {
		url: 'https://262.ecma-international.org/11.0/#sec-ordinarysetwithowndescriptor'
	},
	OrdinaryToPrimitive: {
		url: 'https://262.ecma-international.org/11.0/#sec-ordinarytoprimitive'
	},
	ParseModule: {
		url: 'https://262.ecma-international.org/11.0/#sec-parsemodule'
	},
	ParseScript: {
		url: 'https://262.ecma-international.org/11.0/#sec-parse-script'
	},
	PerformEval: {
		url: 'https://262.ecma-international.org/11.0/#sec-performeval'
	},
	PerformPromiseAll: {
		url: 'https://262.ecma-international.org/11.0/#sec-performpromiseall'
	},
	PerformPromiseAllSettled: {
		url: 'https://262.ecma-international.org/11.0/#sec-performpromiseallsettled'
	},
	PerformPromiseRace: {
		url: 'https://262.ecma-international.org/11.0/#sec-performpromiserace'
	},
	PerformPromiseThen: {
		url: 'https://262.ecma-international.org/11.0/#sec-performpromisethen'
	},
	PrepareForOrdinaryCall: {
		url: 'https://262.ecma-international.org/11.0/#sec-prepareforordinarycall'
	},
	PrepareForTailCall: {
		url: 'https://262.ecma-international.org/11.0/#sec-preparefortailcall'
	},
	PromiseResolve: {
		url: 'https://262.ecma-international.org/11.0/#sec-promise-resolve'
	},
	ProxyCreate: {
		url: 'https://262.ecma-international.org/11.0/#sec-proxycreate'
	},
	PutValue: {
		url: 'https://262.ecma-international.org/11.0/#sec-putvalue'
	},
	QuoteJSONString: {
		url: 'https://262.ecma-international.org/11.0/#sec-quotejsonstring'
	},
	RawBytesToNumeric: {
		url: 'https://262.ecma-international.org/11.0/#sec-rawbytestonumeric'
	},
	'reads-bytes-from': {
		url: 'https://262.ecma-international.org/11.0/#sec-reads-bytes-from'
	},
	'reads-from': {
		url: 'https://262.ecma-international.org/11.0/#sec-reads-from'
	},
	RegExpAlloc: {
		url: 'https://262.ecma-international.org/11.0/#sec-regexpalloc'
	},
	RegExpBuiltinExec: {
		url: 'https://262.ecma-international.org/11.0/#sec-regexpbuiltinexec'
	},
	RegExpCreate: {
		url: 'https://262.ecma-international.org/11.0/#sec-regexpcreate'
	},
	RegExpExec: {
		url: 'https://262.ecma-international.org/11.0/#sec-regexpexec'
	},
	RegExpInitialize: {
		url: 'https://262.ecma-international.org/11.0/#sec-regexpinitialize'
	},
	RejectPromise: {
		url: 'https://262.ecma-international.org/11.0/#sec-rejectpromise'
	},
	RemoveWaiter: {
		url: 'https://262.ecma-international.org/11.0/#sec-removewaiter'
	},
	RemoveWaiters: {
		url: 'https://262.ecma-international.org/11.0/#sec-removewaiters'
	},
	RepeatMatcher: {
		url: 'https://262.ecma-international.org/11.0/#sec-runtime-semantics-repeatmatcher-abstract-operation'
	},
	RequireInternalSlot: {
		url: 'https://262.ecma-international.org/11.0/#sec-requireinternalslot'
	},
	RequireObjectCoercible: {
		url: 'https://262.ecma-international.org/11.0/#sec-requireobjectcoercible'
	},
	ResolveBinding: {
		url: 'https://262.ecma-international.org/11.0/#sec-resolvebinding'
	},
	ResolveThisBinding: {
		url: 'https://262.ecma-international.org/11.0/#sec-resolvethisbinding'
	},
	ReturnIfAbrupt: {
		url: 'https://262.ecma-international.org/11.0/#sec-returnifabrupt'
	},
	SameValue: {
		url: 'https://262.ecma-international.org/11.0/#sec-samevalue'
	},
	SameValueNonNumeric: {
		url: 'https://262.ecma-international.org/11.0/#sec-samevaluenonnumeric'
	},
	SameValueZero: {
		url: 'https://262.ecma-international.org/11.0/#sec-samevaluezero'
	},
	ScriptEvaluation: {
		url: 'https://262.ecma-international.org/11.0/#sec-runtime-semantics-scriptevaluation'
	},
	SecFromTime: {
		url: 'https://262.ecma-international.org/11.0/#eqn-SecFromTime'
	},
	SerializeJSONArray: {
		url: 'https://262.ecma-international.org/11.0/#sec-serializejsonarray'
	},
	SerializeJSONObject: {
		url: 'https://262.ecma-international.org/11.0/#sec-serializejsonobject'
	},
	SerializeJSONProperty: {
		url: 'https://262.ecma-international.org/11.0/#sec-serializejsonproperty'
	},
	Set: {
		url: 'https://262.ecma-international.org/11.0/#sec-set-o-p-v-throw'
	},
	SetDefaultGlobalBindings: {
		url: 'https://262.ecma-international.org/11.0/#sec-setdefaultglobalbindings'
	},
	SetFunctionLength: {
		url: 'https://262.ecma-international.org/11.0/#sec-setfunctionlength'
	},
	SetFunctionName: {
		url: 'https://262.ecma-international.org/11.0/#sec-setfunctionname'
	},
	SetImmutablePrototype: {
		url: 'https://262.ecma-international.org/11.0/#sec-set-immutable-prototype'
	},
	SetIntegrityLevel: {
		url: 'https://262.ecma-international.org/11.0/#sec-setintegritylevel'
	},
	SetRealmGlobalObject: {
		url: 'https://262.ecma-international.org/11.0/#sec-setrealmglobalobject'
	},
	SetValueInBuffer: {
		url: 'https://262.ecma-international.org/11.0/#sec-setvalueinbuffer'
	},
	SetViewValue: {
		url: 'https://262.ecma-international.org/11.0/#sec-setviewvalue'
	},
	SharedDataBlockEventSet: {
		url: 'https://262.ecma-international.org/11.0/#sec-sharedatablockeventset'
	},
	SortCompare: {
		url: 'https://262.ecma-international.org/11.0/#sec-sortcompare'
	},
	SpeciesConstructor: {
		url: 'https://262.ecma-international.org/11.0/#sec-speciesconstructor'
	},
	SplitMatch: {
		url: 'https://262.ecma-international.org/11.0/#sec-splitmatch'
	},
	'Strict Equality Comparison': {
		url: 'https://262.ecma-international.org/11.0/#sec-strict-equality-comparison'
	},
	StringCreate: {
		url: 'https://262.ecma-international.org/11.0/#sec-stringcreate'
	},
	StringGetOwnProperty: {
		url: 'https://262.ecma-international.org/11.0/#sec-stringgetownproperty'
	},
	StringPad: {
		url: 'https://262.ecma-international.org/11.0/#sec-stringpad'
	},
	StringToBigInt: {
		url: 'https://262.ecma-international.org/11.0/#sec-stringtobigint'
	},
	Suspend: {
		url: 'https://262.ecma-international.org/11.0/#sec-suspend'
	},
	SymbolDescriptiveString: {
		url: 'https://262.ecma-international.org/11.0/#sec-symboldescriptivestring'
	},
	'synchronizes-with': {
		url: 'https://262.ecma-international.org/11.0/#sec-synchronizes-with'
	},
	TestIntegrityLevel: {
		url: 'https://262.ecma-international.org/11.0/#sec-testintegritylevel'
	},
	thisBigIntValue: {
		url: 'https://262.ecma-international.org/11.0/#sec-thisbigintvalue'
	},
	thisBooleanValue: {
		url: 'https://262.ecma-international.org/11.0/#sec-thisbooleanvalue'
	},
	thisNumberValue: {
		url: 'https://262.ecma-international.org/11.0/#sec-thisnumbervalue'
	},
	thisStringValue: {
		url: 'https://262.ecma-international.org/11.0/#sec-thisstringvalue'
	},
	thisSymbolValue: {
		url: 'https://262.ecma-international.org/11.0/#sec-thissymbolvalue'
	},
	thisTimeValue: {
		url: 'https://262.ecma-international.org/11.0/#sec-thistimevalue'
	},
	ThrowCompletion: {
		url: 'https://262.ecma-international.org/11.0/#sec-throwcompletion'
	},
	TimeClip: {
		url: 'https://262.ecma-international.org/11.0/#sec-timeclip'
	},
	TimeFromYear: {
		url: 'https://262.ecma-international.org/11.0/#eqn-TimeFromYear'
	},
	TimeString: {
		url: 'https://262.ecma-international.org/11.0/#sec-timestring'
	},
	TimeWithinDay: {
		url: 'https://262.ecma-international.org/11.0/#eqn-TimeWithinDay'
	},
	TimeZoneString: {
		url: 'https://262.ecma-international.org/11.0/#sec-timezoneestring'
	},
	ToBigInt: {
		url: 'https://262.ecma-international.org/11.0/#sec-tobigint'
	},
	ToBigInt64: {
		url: 'https://262.ecma-international.org/11.0/#sec-tobigint64'
	},
	ToBigUint64: {
		url: 'https://262.ecma-international.org/11.0/#sec-tobiguint64'
	},
	ToBoolean: {
		url: 'https://262.ecma-international.org/11.0/#sec-toboolean'
	},
	ToDateString: {
		url: 'https://262.ecma-international.org/11.0/#sec-todatestring'
	},
	ToIndex: {
		url: 'https://262.ecma-international.org/11.0/#sec-toindex'
	},
	ToInt16: {
		url: 'https://262.ecma-international.org/11.0/#sec-toint16'
	},
	ToInt32: {
		url: 'https://262.ecma-international.org/11.0/#sec-toint32'
	},
	ToInt8: {
		url: 'https://262.ecma-international.org/11.0/#sec-toint8'
	},
	ToInteger: {
		url: 'https://262.ecma-international.org/11.0/#sec-tointeger'
	},
	ToLength: {
		url: 'https://262.ecma-international.org/11.0/#sec-tolength'
	},
	ToNumber: {
		url: 'https://262.ecma-international.org/11.0/#sec-tonumber'
	},
	ToNumeric: {
		url: 'https://262.ecma-international.org/11.0/#sec-tonumeric'
	},
	ToObject: {
		url: 'https://262.ecma-international.org/11.0/#sec-toobject'
	},
	ToPrimitive: {
		url: 'https://262.ecma-international.org/11.0/#sec-toprimitive'
	},
	ToPropertyDescriptor: {
		url: 'https://262.ecma-international.org/11.0/#sec-topropertydescriptor'
	},
	ToPropertyKey: {
		url: 'https://262.ecma-international.org/11.0/#sec-topropertykey'
	},
	ToString: {
		url: 'https://262.ecma-international.org/11.0/#sec-tostring'
	},
	ToUint16: {
		url: 'https://262.ecma-international.org/11.0/#sec-touint16'
	},
	ToUint32: {
		url: 'https://262.ecma-international.org/11.0/#sec-touint32'
	},
	ToUint8: {
		url: 'https://262.ecma-international.org/11.0/#sec-touint8'
	},
	ToUint8Clamp: {
		url: 'https://262.ecma-international.org/11.0/#sec-touint8clamp'
	},
	TriggerPromiseReactions: {
		url: 'https://262.ecma-international.org/11.0/#sec-triggerpromisereactions'
	},
	TrimString: {
		url: 'https://262.ecma-international.org/11.0/#sec-trimstring'
	},
	Type: {
		url: 'https://262.ecma-international.org/11.0/#sec-ecmascript-data-types-and-values'
	},
	TypedArrayCreate: {
		url: 'https://262.ecma-international.org/11.0/#typedarray-create'
	},
	TypedArraySpeciesCreate: {
		url: 'https://262.ecma-international.org/11.0/#typedarray-species-create'
	},
	UnicodeEscape: {
		url: 'https://262.ecma-international.org/11.0/#sec-unicodeescape'
	},
	UnicodeMatchProperty: {
		url: 'https://262.ecma-international.org/11.0/#sec-runtime-semantics-unicodematchproperty-p'
	},
	UnicodeMatchPropertyValue: {
		url: 'https://262.ecma-international.org/11.0/#sec-runtime-semantics-unicodematchpropertyvalue-p-v'
	},
	UpdateEmpty: {
		url: 'https://262.ecma-international.org/11.0/#sec-updateempty'
	},
	UTC: {
		url: 'https://262.ecma-international.org/11.0/#sec-utc-t'
	},
	UTF16DecodeString: {
		url: 'https://262.ecma-international.org/11.0/#sec-utf16decodestring'
	},
	UTF16DecodeSurrogatePair: {
		url: 'https://262.ecma-international.org/11.0/#sec-utf16decodesurrogatepair'
	},
	UTF16Encode: {
		url: 'https://262.ecma-international.org/11.0/#sec-utf16encode'
	},
	UTF16Encoding: {
		url: 'https://262.ecma-international.org/11.0/#sec-utf16encoding'
	},
	ValidateAndApplyPropertyDescriptor: {
		url: 'https://262.ecma-international.org/11.0/#sec-validateandapplypropertydescriptor'
	},
	ValidateAtomicAccess: {
		url: 'https://262.ecma-international.org/11.0/#sec-validateatomicaccess'
	},
	ValidateSharedIntegerTypedArray: {
		url: 'https://262.ecma-international.org/11.0/#sec-validatesharedintegertypedarray'
	},
	ValidateTypedArray: {
		url: 'https://262.ecma-international.org/11.0/#sec-validatetypedarray'
	},
	ValueOfReadEvent: {
		url: 'https://262.ecma-international.org/11.0/#sec-valueofreadevent'
	},
	WeekDay: {
		url: 'https://262.ecma-international.org/11.0/#sec-week-day'
	},
	WordCharacters: {
		url: 'https://262.ecma-international.org/11.0/#sec-runtime-semantics-wordcharacters-abstract-operation'
	},
	YearFromTime: {
		url: 'https://262.ecma-international.org/11.0/#eqn-YearFromTime'
	}
};
'use strict';

module.exports = {
	abs: {
		url: 'https://262.ecma-international.org/12.0/#eqn-abs'
	},
	'Abstract Equality Comparison': {
		url: 'https://262.ecma-international.org/12.0/#sec-abstract-equality-comparison'
	},
	'Abstract Relational Comparison': {
		url: 'https://262.ecma-international.org/12.0/#sec-abstract-relational-comparison'
	},
	AddEntriesFromIterable: {
		url: 'https://262.ecma-international.org/12.0/#sec-add-entries-from-iterable'
	},
	AddRestrictedFunctionProperties: {
		url: 'https://262.ecma-international.org/12.0/#sec-addrestrictedfunctionproperties'
	},
	AddToKeptObjects: {
		url: 'https://262.ecma-international.org/12.0/#sec-addtokeptobjects'
	},
	AddWaiter: {
		url: 'https://262.ecma-international.org/12.0/#sec-addwaiter'
	},
	AdvanceStringIndex: {
		url: 'https://262.ecma-international.org/12.0/#sec-advancestringindex'
	},
	'agent-order': {
		url: 'https://262.ecma-international.org/12.0/#sec-agent-order'
	},
	AgentCanSuspend: {
		url: 'https://262.ecma-international.org/12.0/#sec-agentcansuspend'
	},
	AgentSignifier: {
		url: 'https://262.ecma-international.org/12.0/#sec-agentsignifier'
	},
	AllocateArrayBuffer: {
		url: 'https://262.ecma-international.org/12.0/#sec-allocatearraybuffer'
	},
	AllocateSharedArrayBuffer: {
		url: 'https://262.ecma-international.org/12.0/#sec-allocatesharedarraybuffer'
	},
	AllocateTypedArray: {
		url: 'https://262.ecma-international.org/12.0/#sec-allocatetypedarray'
	},
	AllocateTypedArrayBuffer: {
		url: 'https://262.ecma-international.org/12.0/#sec-allocatetypedarraybuffer'
	},
	ApplyStringOrNumericBinaryOperator: {
		url: 'https://262.ecma-international.org/12.0/#sec-applystringornumericbinaryoperator'
	},
	ArrayCreate: {
		url: 'https://262.ecma-international.org/12.0/#sec-arraycreate'
	},
	ArraySetLength: {
		url: 'https://262.ecma-international.org/12.0/#sec-arraysetlength'
	},
	ArraySpeciesCreate: {
		url: 'https://262.ecma-international.org/12.0/#sec-arrayspeciescreate'
	},
	AsyncFromSyncIteratorContinuation: {
		url: 'https://262.ecma-international.org/12.0/#sec-asyncfromsynciteratorcontinuation'
	},
	AsyncFunctionStart: {
		url: 'https://262.ecma-international.org/12.0/#sec-async-functions-abstract-operations-async-function-start'
	},
	AsyncGeneratorEnqueue: {
		url: 'https://262.ecma-international.org/12.0/#sec-asyncgeneratorenqueue'
	},
	AsyncGeneratorReject: {
		url: 'https://262.ecma-international.org/12.0/#sec-asyncgeneratorreject'
	},
	AsyncGeneratorResolve: {
		url: 'https://262.ecma-international.org/12.0/#sec-asyncgeneratorresolve'
	},
	AsyncGeneratorResumeNext: {
		url: 'https://262.ecma-international.org/12.0/#sec-asyncgeneratorresumenext'
	},
	AsyncGeneratorStart: {
		url: 'https://262.ecma-international.org/12.0/#sec-asyncgeneratorstart'
	},
	AsyncGeneratorValidate: {
		url: 'https://262.ecma-international.org/12.0/#sec-asyncgeneratorvalidate'
	},
	AsyncGeneratorYield: {
		url: 'https://262.ecma-international.org/12.0/#sec-asyncgeneratoryield'
	},
	AsyncIteratorClose: {
		url: 'https://262.ecma-international.org/12.0/#sec-asynciteratorclose'
	},
	AtomicReadModifyWrite: {
		url: 'https://262.ecma-international.org/12.0/#sec-atomicreadmodifywrite'
	},
	Await: {
		url: 'https://262.ecma-international.org/12.0/#await'
	},
	BackreferenceMatcher: {
		url: 'https://262.ecma-international.org/12.0/#sec-backreference-matcher'
	},
	'BigInt::add': {
		url: 'https://262.ecma-international.org/12.0/#sec-numeric-types-bigint-add'
	},
	'BigInt::bitwiseAND': {
		url: 'https://262.ecma-international.org/12.0/#sec-numeric-types-bigint-bitwiseAND'
	},
	'BigInt::bitwiseNOT': {
		url: 'https://262.ecma-international.org/12.0/#sec-numeric-types-bigint-bitwiseNOT'
	},
	'BigInt::bitwiseOR': {
		url: 'https://262.ecma-international.org/12.0/#sec-numeric-types-bigint-bitwiseOR'
	},
	'BigInt::bitwiseXOR': {
		url: 'https://262.ecma-international.org/12.0/#sec-numeric-types-bigint-bitwiseXOR'
	},
	'BigInt::divide': {
		url: 'https://262.ecma-international.org/12.0/#sec-numeric-types-bigint-divide'
	},
	'BigInt::equal': {
		url: 'https://262.ecma-international.org/12.0/#sec-numeric-types-bigint-equal'
	},
	'BigInt::exponentiate': {
		url: 'https://262.ecma-international.org/12.0/#sec-numeric-types-bigint-exponentiate'
	},
	'BigInt::leftShift': {
		url: 'https://262.ecma-international.org/12.0/#sec-numeric-types-bigint-leftShift'
	},
	'BigInt::lessThan': {
		url: 'https://262.ecma-international.org/12.0/#sec-numeric-types-bigint-lessThan'
	},
	'BigInt::multiply': {
		url: 'https://262.ecma-international.org/12.0/#sec-numeric-types-bigint-multiply'
	},
	'BigInt::remainder': {
		url: 'https://262.ecma-international.org/12.0/#sec-numeric-types-bigint-remainder'
	},
	'BigInt::sameValue': {
		url: 'https://262.ecma-international.org/12.0/#sec-numeric-types-bigint-sameValue'
	},
	'BigInt::sameValueZero': {
		url: 'https://262.ecma-international.org/12.0/#sec-numeric-types-bigint-sameValueZero'
	},
	'BigInt::signedRightShift': {
		url: 'https://262.ecma-international.org/12.0/#sec-numeric-types-bigint-signedRightShift'
	},
	'BigInt::subtract': {
		url: 'https://262.ecma-international.org/12.0/#sec-numeric-types-bigint-subtract'
	},
	'BigInt::toString': {
		url: 'https://262.ecma-international.org/12.0/#sec-numeric-types-bigint-tostring'
	},
	'BigInt::unaryMinus': {
		url: 'https://262.ecma-international.org/12.0/#sec-numeric-types-bigint-unaryMinus'
	},
	'BigInt::unsignedRightShift': {
		url: 'https://262.ecma-international.org/12.0/#sec-numeric-types-bigint-unsignedRightShift'
	},
	BigIntBitwiseOp: {
		url: 'https://262.ecma-international.org/12.0/#sec-bigintbitwiseop'
	},
	BinaryAnd: {
		url: 'https://262.ecma-international.org/12.0/#sec-binaryand'
	},
	BinaryOr: {
		url: 'https://262.ecma-international.org/12.0/#sec-binaryor'
	},
	BinaryXor: {
		url: 'https://262.ecma-international.org/12.0/#sec-binaryxor'
	},
	BlockDeclarationInstantiation: {
		url: 'https://262.ecma-international.org/12.0/#sec-blockdeclarationinstantiation'
	},
	BoundFunctionCreate: {
		url: 'https://262.ecma-international.org/12.0/#sec-boundfunctioncreate'
	},
	ByteListBitwiseOp: {
		url: 'https://262.ecma-international.org/12.0/#sec-bytelistbitwiseop'
	},
	ByteListEqual: {
		url: 'https://262.ecma-international.org/12.0/#sec-bytelistequal'
	},
	Call: {
		url: 'https://262.ecma-international.org/12.0/#sec-call'
	},
	Canonicalize: {
		url: 'https://262.ecma-international.org/12.0/#sec-runtime-semantics-canonicalize-ch'
	},
	CanonicalNumericIndexString: {
		url: 'https://262.ecma-international.org/12.0/#sec-canonicalnumericindexstring'
	},
	CaseClauseIsSelected: {
		url: 'https://262.ecma-international.org/12.0/#sec-runtime-semantics-caseclauseisselected'
	},
	CharacterRange: {
		url: 'https://262.ecma-international.org/12.0/#sec-runtime-semantics-characterrange-abstract-operation'
	},
	CharacterRangeOrUnion: {
		url: 'https://262.ecma-international.org/12.0/#sec-runtime-semantics-characterrangeorunion-abstract-operation'
	},
	CharacterSetMatcher: {
		url: 'https://262.ecma-international.org/12.0/#sec-runtime-semantics-charactersetmatcher-abstract-operation'
	},
	clamp: {
		url: 'https://262.ecma-international.org/12.0/#clamping'
	},
	CleanupFinalizationRegistry: {
		url: 'https://262.ecma-international.org/12.0/#sec-cleanup-finalization-registry'
	},
	ClearKeptObjects: {
		url: 'https://262.ecma-international.org/12.0/#sec-clear-kept-objects'
	},
	CloneArrayBuffer: {
		url: 'https://262.ecma-international.org/12.0/#sec-clonearraybuffer'
	},
	CodePointAt: {
		url: 'https://262.ecma-international.org/12.0/#sec-codepointat'
	},
	CodePointsToString: {
		url: 'https://262.ecma-international.org/12.0/#sec-codepointstostring'
	},
	CompletePropertyDescriptor: {
		url: 'https://262.ecma-international.org/12.0/#sec-completepropertydescriptor'
	},
	Completion: {
		url: 'https://262.ecma-international.org/12.0/#sec-completion-record-specification-type'
	},
	CompletionRecord: {
		url: 'https://262.ecma-international.org/12.0/#sec-completion-record-specification-type'
	},
	ComposeWriteEventBytes: {
		url: 'https://262.ecma-international.org/12.0/#sec-composewriteeventbytes'
	},
	Construct: {
		url: 'https://262.ecma-international.org/12.0/#sec-construct'
	},
	CopyDataBlockBytes: {
		url: 'https://262.ecma-international.org/12.0/#sec-copydatablockbytes'
	},
	CopyDataProperties: {
		url: 'https://262.ecma-international.org/12.0/#sec-copydataproperties'
	},
	CreateArrayFromList: {
		url: 'https://262.ecma-international.org/12.0/#sec-createarrayfromlist'
	},
	CreateArrayIterator: {
		url: 'https://262.ecma-international.org/12.0/#sec-createarrayiterator'
	},
	CreateAsyncFromSyncIterator: {
		url: 'https://262.ecma-international.org/12.0/#sec-createasyncfromsynciterator'
	},
	CreateAsyncIteratorFromClosure: {
		url: 'https://262.ecma-international.org/12.0/#sec-createasynciteratorfromclosure'
	},
	CreateBuiltinFunction: {
		url: 'https://262.ecma-international.org/12.0/#sec-createbuiltinfunction'
	},
	CreateByteDataBlock: {
		url: 'https://262.ecma-international.org/12.0/#sec-createbytedatablock'
	},
	CreateDataProperty: {
		url: 'https://262.ecma-international.org/12.0/#sec-createdataproperty'
	},
	CreateDataPropertyOrThrow: {
		url: 'https://262.ecma-international.org/12.0/#sec-createdatapropertyorthrow'
	},
	CreateDynamicFunction: {
		url: 'https://262.ecma-international.org/12.0/#sec-createdynamicfunction'
	},
	CreateForInIterator: {
		url: 'https://262.ecma-international.org/12.0/#sec-createforiniterator'
	},
	CreateHTML: {
		url: 'https://262.ecma-international.org/12.0/#sec-createhtml'
	},
	CreateIntrinsics: {
		url: 'https://262.ecma-international.org/12.0/#sec-createintrinsics'
	},
	CreateIteratorFromClosure: {
		url: 'https://262.ecma-international.org/12.0/#sec-createiteratorfromclosure'
	},
	CreateIterResultObject: {
		url: 'https://262.ecma-international.org/12.0/#sec-createiterresultobject'
	},
	CreateListFromArrayLike: {
		url: 'https://262.ecma-international.org/12.0/#sec-createlistfromarraylike'
	},
	CreateListIteratorRecord: {
		url: 'https://262.ecma-international.org/12.0/#sec-createlistiteratorRecord'
	},
	CreateMapIterator: {
		url: 'https://262.ecma-international.org/12.0/#sec-createmapiterator'
	},
	CreateMappedArgumentsObject: {
		url: 'https://262.ecma-international.org/12.0/#sec-createmappedargumentsobject'
	},
	CreateMethodProperty: {
		url: 'https://262.ecma-international.org/12.0/#sec-createmethodproperty'
	},
	CreatePerIterationEnvironment: {
		url: 'https://262.ecma-international.org/12.0/#sec-createperiterationenvironment'
	},
	CreateRealm: {
		url: 'https://262.ecma-international.org/12.0/#sec-createrealm'
	},
	CreateRegExpStringIterator: {
		url: 'https://262.ecma-international.org/12.0/#sec-createregexpstringiterator'
	},
	CreateResolvingFunctions: {
		url: 'https://262.ecma-international.org/12.0/#sec-createresolvingfunctions'
	},
	CreateSetIterator: {
		url: 'https://262.ecma-international.org/12.0/#sec-createsetiterator'
	},
	CreateSharedByteDataBlock: {
		url: 'https://262.ecma-international.org/12.0/#sec-createsharedbytedatablock'
	},
	CreateUnmappedArgumentsObject: {
		url: 'https://262.ecma-international.org/12.0/#sec-createunmappedargumentsobject'
	},
	DateFromTime: {
		url: 'https://262.ecma-international.org/12.0/#sec-date-number'
	},
	DateString: {
		url: 'https://262.ecma-international.org/12.0/#sec-datestring'
	},
	Day: {
		url: 'https://262.ecma-international.org/12.0/#eqn-Day'
	},
	DayFromYear: {
		url: 'https://262.ecma-international.org/12.0/#eqn-DaysFromYear'
	},
	DaysInYear: {
		url: 'https://262.ecma-international.org/12.0/#eqn-DaysInYear'
	},
	DayWithinYear: {
		url: 'https://262.ecma-international.org/12.0/#eqn-DayWithinYear'
	},
	Decode: {
		url: 'https://262.ecma-international.org/12.0/#sec-decode'
	},
	DefinePropertyOrThrow: {
		url: 'https://262.ecma-international.org/12.0/#sec-definepropertyorthrow'
	},
	DeletePropertyOrThrow: {
		url: 'https://262.ecma-international.org/12.0/#sec-deletepropertyorthrow'
	},
	DetachArrayBuffer: {
		url: 'https://262.ecma-international.org/12.0/#sec-detacharraybuffer'
	},
	Encode: {
		url: 'https://262.ecma-international.org/12.0/#sec-encode'
	},
	EnterCriticalSection: {
		url: 'https://262.ecma-international.org/12.0/#sec-entercriticalsection'
	},
	EnumerableOwnPropertyNames: {
		url: 'https://262.ecma-international.org/12.0/#sec-enumerableownpropertynames'
	},
	EnumerateObjectProperties: {
		url: 'https://262.ecma-international.org/12.0/#sec-enumerate-object-properties'
	},
	EscapeRegExpPattern: {
		url: 'https://262.ecma-international.org/12.0/#sec-escaperegexppattern'
	},
	EvalDeclarationInstantiation: {
		url: 'https://262.ecma-international.org/12.0/#sec-evaldeclarationinstantiation'
	},
	EvaluateCall: {
		url: 'https://262.ecma-international.org/12.0/#sec-evaluatecall'
	},
	EvaluateNew: {
		url: 'https://262.ecma-international.org/12.0/#sec-evaluatenew'
	},
	EvaluatePropertyAccessWithExpressionKey: {
		url: 'https://262.ecma-international.org/12.0/#sec-evaluate-property-access-with-expression-key'
	},
	EvaluatePropertyAccessWithIdentifierKey: {
		url: 'https://262.ecma-international.org/12.0/#sec-evaluate-property-access-with-identifier-key'
	},
	EvaluateStringOrNumericBinaryExpression: {
		url: 'https://262.ecma-international.org/12.0/#sec-evaluatestringornumericbinaryexpression'
	},
	EventSet: {
		url: 'https://262.ecma-international.org/12.0/#sec-event-set'
	},
	ExecuteModule: {
		url: 'https://262.ecma-international.org/12.0/#sec-source-text-module-record-execute-module'
	},
	FinishDynamicImport: {
		url: 'https://262.ecma-international.org/12.0/#sec-finishdynamicimport'
	},
	FlattenIntoArray: {
		url: 'https://262.ecma-international.org/12.0/#sec-flattenintoarray'
	},
	floor: {
		url: 'https://262.ecma-international.org/12.0/#eqn-floor'
	},
	ForBodyEvaluation: {
		url: 'https://262.ecma-international.org/12.0/#sec-forbodyevaluation'
	},
	'ForIn/OfBodyEvaluation': {
		url: 'https://262.ecma-international.org/12.0/#sec-runtime-semantics-forin-div-ofbodyevaluation-lhs-stmt-iterator-lhskind-labelset'
	},
	'ForIn/OfHeadEvaluation': {
		url: 'https://262.ecma-international.org/12.0/#sec-runtime-semantics-forinofheadevaluation'
	},
	FromPropertyDescriptor: {
		url: 'https://262.ecma-international.org/12.0/#sec-frompropertydescriptor'
	},
	FulfillPromise: {
		url: 'https://262.ecma-international.org/12.0/#sec-fulfillpromise'
	},
	FunctionDeclarationInstantiation: {
		url: 'https://262.ecma-international.org/12.0/#sec-functiondeclarationinstantiation'
	},
	GeneratorResume: {
		url: 'https://262.ecma-international.org/12.0/#sec-generatorresume'
	},
	GeneratorResumeAbrupt: {
		url: 'https://262.ecma-international.org/12.0/#sec-generatorresumeabrupt'
	},
	GeneratorStart: {
		url: 'https://262.ecma-international.org/12.0/#sec-generatorstart'
	},
	GeneratorValidate: {
		url: 'https://262.ecma-international.org/12.0/#sec-generatorvalidate'
	},
	GeneratorYield: {
		url: 'https://262.ecma-international.org/12.0/#sec-generatoryield'
	},
	Get: {
		url: 'https://262.ecma-international.org/12.0/#sec-get-o-p'
	},
	GetActiveScriptOrModule: {
		url: 'https://262.ecma-international.org/12.0/#sec-getactivescriptormodule'
	},
	GetFunctionRealm: {
		url: 'https://262.ecma-international.org/12.0/#sec-getfunctionrealm'
	},
	GetGeneratorKind: {
		url: 'https://262.ecma-international.org/12.0/#sec-getgeneratorkind'
	},
	GetGlobalObject: {
		url: 'https://262.ecma-international.org/12.0/#sec-getglobalobject'
	},
	GetIdentifierReference: {
		url: 'https://262.ecma-international.org/12.0/#sec-getidentifierreference'
	},
	GetIterator: {
		url: 'https://262.ecma-international.org/12.0/#sec-getiterator'
	},
	GetMethod: {
		url: 'https://262.ecma-international.org/12.0/#sec-getmethod'
	},
	GetModifySetValueInBuffer: {
		url: 'https://262.ecma-international.org/12.0/#sec-getmodifysetvalueinbuffer'
	},
	GetModuleNamespace: {
		url: 'https://262.ecma-international.org/12.0/#sec-getmodulenamespace'
	},
	GetNewTarget: {
		url: 'https://262.ecma-international.org/12.0/#sec-getnewtarget'
	},
	GetOwnPropertyKeys: {
		url: 'https://262.ecma-international.org/12.0/#sec-getownpropertykeys'
	},
	GetPromiseResolve: {
		url: 'https://262.ecma-international.org/12.0/#sec-getpromiseresolve'
	},
	GetPrototypeFromConstructor: {
		url: 'https://262.ecma-international.org/12.0/#sec-getprototypefromconstructor'
	},
	GetSubstitution: {
		url: 'https://262.ecma-international.org/12.0/#sec-getsubstitution'
	},
	GetSuperConstructor: {
		url: 'https://262.ecma-international.org/12.0/#sec-getsuperconstructor'
	},
	GetTemplateObject: {
		url: 'https://262.ecma-international.org/12.0/#sec-gettemplateobject'
	},
	GetThisEnvironment: {
		url: 'https://262.ecma-international.org/12.0/#sec-getthisenvironment'
	},
	GetThisValue: {
		url: 'https://262.ecma-international.org/12.0/#sec-getthisvalue'
	},
	GetV: {
		url: 'https://262.ecma-international.org/12.0/#sec-getv'
	},
	GetValue: {
		url: 'https://262.ecma-international.org/12.0/#sec-getvalue'
	},
	GetValueFromBuffer: {
		url: 'https://262.ecma-international.org/12.0/#sec-getvaluefrombuffer'
	},
	GetViewValue: {
		url: 'https://262.ecma-international.org/12.0/#sec-getviewvalue'
	},
	GetWaiterList: {
		url: 'https://262.ecma-international.org/12.0/#sec-getwaiterlist'
	},
	GlobalDeclarationInstantiation: {
		url: 'https://262.ecma-international.org/12.0/#sec-globaldeclarationinstantiation'
	},
	'happens-before': {
		url: 'https://262.ecma-international.org/12.0/#sec-happens-before'
	},
	HasOwnProperty: {
		url: 'https://262.ecma-international.org/12.0/#sec-hasownproperty'
	},
	HasProperty: {
		url: 'https://262.ecma-international.org/12.0/#sec-hasproperty'
	},
	'host-synchronizes-with': {
		url: 'https://262.ecma-international.org/12.0/#sec-host-synchronizes-with'
	},
	HostEventSet: {
		url: 'https://262.ecma-international.org/12.0/#sec-hosteventset'
	},
	HourFromTime: {
		url: 'https://262.ecma-international.org/12.0/#eqn-HourFromTime'
	},
	IfAbruptRejectPromise: {
		url: 'https://262.ecma-international.org/12.0/#sec-ifabruptrejectpromise'
	},
	ImportedLocalNames: {
		url: 'https://262.ecma-international.org/12.0/#sec-importedlocalnames'
	},
	InitializeBoundName: {
		url: 'https://262.ecma-international.org/12.0/#sec-initializeboundname'
	},
	InitializeEnvironment: {
		url: 'https://262.ecma-international.org/12.0/#sec-source-text-module-record-initialize-environment'
	},
	InitializeHostDefinedRealm: {
		url: 'https://262.ecma-international.org/12.0/#sec-initializehostdefinedrealm'
	},
	InitializeReferencedBinding: {
		url: 'https://262.ecma-international.org/12.0/#sec-initializereferencedbinding'
	},
	InitializeTypedArrayFromArrayBuffer: {
		url: 'https://262.ecma-international.org/12.0/#sec-initializetypedarrayfromarraybuffer'
	},
	InitializeTypedArrayFromArrayLike: {
		url: 'https://262.ecma-international.org/12.0/#sec-initializetypedarrayfromarraylike'
	},
	InitializeTypedArrayFromList: {
		url: 'https://262.ecma-international.org/12.0/#sec-initializetypedarrayfromlist'
	},
	InitializeTypedArrayFromTypedArray: {
		url: 'https://262.ecma-international.org/12.0/#sec-initializetypedarrayfromtypedarray'
	},
	InLeapYear: {
		url: 'https://262.ecma-international.org/12.0/#eqn-InLeapYear'
	},
	InnerModuleEvaluation: {
		url: 'https://262.ecma-international.org/12.0/#sec-innermoduleevaluation'
	},
	InnerModuleLinking: {
		url: 'https://262.ecma-international.org/12.0/#sec-InnerModuleLinking'
	},
	InstanceofOperator: {
		url: 'https://262.ecma-international.org/12.0/#sec-instanceofoperator'
	},
	IntegerIndexedElementGet: {
		url: 'https://262.ecma-international.org/12.0/#sec-integerindexedelementget'
	},
	IntegerIndexedElementSet: {
		url: 'https://262.ecma-international.org/12.0/#sec-integerindexedelementset'
	},
	IntegerIndexedObjectCreate: {
		url: 'https://262.ecma-international.org/12.0/#sec-integerindexedobjectcreate'
	},
	InternalizeJSONProperty: {
		url: 'https://262.ecma-international.org/12.0/#sec-internalizejsonproperty'
	},
	Invoke: {
		url: 'https://262.ecma-international.org/12.0/#sec-invoke'
	},
	IsAccessorDescriptor: {
		url: 'https://262.ecma-international.org/12.0/#sec-isaccessordescriptor'
	},
	IsAnonymousFunctionDefinition: {
		url: 'https://262.ecma-international.org/12.0/#sec-isanonymousfunctiondefinition'
	},
	IsArray: {
		url: 'https://262.ecma-international.org/12.0/#sec-isarray'
	},
	IsBigIntElementType: {
		url: 'https://262.ecma-international.org/12.0/#sec-isbigintelementtype'
	},
	IsCallable: {
		url: 'https://262.ecma-international.org/12.0/#sec-iscallable'
	},
	IsCompatiblePropertyDescriptor: {
		url: 'https://262.ecma-international.org/12.0/#sec-iscompatiblepropertydescriptor'
	},
	IsConcatSpreadable: {
		url: 'https://262.ecma-international.org/12.0/#sec-isconcatspreadable'
	},
	IsConstructor: {
		url: 'https://262.ecma-international.org/12.0/#sec-isconstructor'
	},
	IsDataDescriptor: {
		url: 'https://262.ecma-international.org/12.0/#sec-isdatadescriptor'
	},
	IsDetachedBuffer: {
		url: 'https://262.ecma-international.org/12.0/#sec-isdetachedbuffer'
	},
	IsExtensible: {
		url: 'https://262.ecma-international.org/12.0/#sec-isextensible-o'
	},
	IsGenericDescriptor: {
		url: 'https://262.ecma-international.org/12.0/#sec-isgenericdescriptor'
	},
	IsInTailPosition: {
		url: 'https://262.ecma-international.org/12.0/#sec-isintailposition'
	},
	IsIntegralNumber: {
		url: 'https://262.ecma-international.org/12.0/#sec-isintegralnumber'
	},
	IsLabelledFunction: {
		url: 'https://262.ecma-international.org/12.0/#sec-islabelledfunction'
	},
	IsNoTearConfiguration: {
		url: 'https://262.ecma-international.org/12.0/#sec-isnotearconfiguration'
	},
	IsPromise: {
		url: 'https://262.ecma-international.org/12.0/#sec-ispromise'
	},
	IsPropertyKey: {
		url: 'https://262.ecma-international.org/12.0/#sec-ispropertykey'
	},
	IsPropertyReference: {
		url: 'https://262.ecma-international.org/12.0/#sec-ispropertyreference'
	},
	IsRegExp: {
		url: 'https://262.ecma-international.org/12.0/#sec-isregexp'
	},
	IsSharedArrayBuffer: {
		url: 'https://262.ecma-international.org/12.0/#sec-issharedarraybuffer'
	},
	IsStringPrefix: {
		url: 'https://262.ecma-international.org/12.0/#sec-isstringprefix'
	},
	IsSuperReference: {
		url: 'https://262.ecma-international.org/12.0/#sec-issuperreference'
	},
	IsUnclampedIntegerElementType: {
		url: 'https://262.ecma-international.org/12.0/#sec-isunclampedintegerelementtype'
	},
	IsUnresolvableReference: {
		url: 'https://262.ecma-international.org/12.0/#sec-isunresolvablereference'
	},
	IsUnsignedElementType: {
		url: 'https://262.ecma-international.org/12.0/#sec-isunsignedelementtype'
	},
	IsValidIntegerIndex: {
		url: 'https://262.ecma-international.org/12.0/#sec-isvalidintegerindex'
	},
	IsValidRegularExpressionLiteral: {
		url: 'https://262.ecma-international.org/12.0/#sec-isvalidregularexpressionliteral'
	},
	IsWordChar: {
		url: 'https://262.ecma-international.org/12.0/#sec-runtime-semantics-iswordchar-abstract-operation'
	},
	IterableToList: {
		url: 'https://262.ecma-international.org/12.0/#sec-iterabletolist'
	},
	IteratorClose: {
		url: 'https://262.ecma-international.org/12.0/#sec-iteratorclose'
	},
	IteratorComplete: {
		url: 'https://262.ecma-international.org/12.0/#sec-iteratorcomplete'
	},
	IteratorNext: {
		url: 'https://262.ecma-international.org/12.0/#sec-iteratornext'
	},
	IteratorStep: {
		url: 'https://262.ecma-international.org/12.0/#sec-iteratorstep'
	},
	IteratorValue: {
		url: 'https://262.ecma-international.org/12.0/#sec-iteratorvalue'
	},
	LeaveCriticalSection: {
		url: 'https://262.ecma-international.org/12.0/#sec-leavecriticalsection'
	},
	LengthOfArrayLike: {
		url: 'https://262.ecma-international.org/12.0/#sec-lengthofarraylike'
	},
	LocalTime: {
		url: 'https://262.ecma-international.org/12.0/#sec-localtime'
	},
	LocalTZA: {
		url: 'https://262.ecma-international.org/12.0/#sec-local-time-zone-adjustment'
	},
	LoopContinues: {
		url: 'https://262.ecma-international.org/12.0/#sec-loopcontinues'
	},
	MakeArgGetter: {
		url: 'https://262.ecma-international.org/12.0/#sec-makearggetter'
	},
	MakeArgSetter: {
		url: 'https://262.ecma-international.org/12.0/#sec-makeargsetter'
	},
	MakeBasicObject: {
		url: 'https://262.ecma-international.org/12.0/#sec-makebasicobject'
	},
	MakeClassConstructor: {
		url: 'https://262.ecma-international.org/12.0/#sec-makeclassconstructor'
	},
	MakeConstructor: {
		url: 'https://262.ecma-international.org/12.0/#sec-makeconstructor'
	},
	MakeDate: {
		url: 'https://262.ecma-international.org/12.0/#sec-makedate'
	},
	MakeDay: {
		url: 'https://262.ecma-international.org/12.0/#sec-makeday'
	},
	MakeMethod: {
		url: 'https://262.ecma-international.org/12.0/#sec-makemethod'
	},
	MakeSuperPropertyReference: {
		url: 'https://262.ecma-international.org/12.0/#sec-makesuperpropertyreference'
	},
	MakeTime: {
		url: 'https://262.ecma-international.org/12.0/#sec-maketime'
	},
	max: {
		url: 'https://262.ecma-international.org/12.0/#eqn-max'
	},
	'memory-order': {
		url: 'https://262.ecma-international.org/12.0/#sec-memory-order'
	},
	min: {
		url: 'https://262.ecma-international.org/12.0/#eqn-min'
	},
	MinFromTime: {
		url: 'https://262.ecma-international.org/12.0/#eqn-MinFromTime'
	},
	ModuleNamespaceCreate: {
		url: 'https://262.ecma-international.org/12.0/#sec-modulenamespacecreate'
	},
	modulo: {
		url: 'https://262.ecma-international.org/12.0/#eqn-modulo'
	},
	MonthFromTime: {
		url: 'https://262.ecma-international.org/12.0/#eqn-MonthFromTime'
	},
	msFromTime: {
		url: 'https://262.ecma-international.org/12.0/#eqn-msFromTime'
	},
	NewDeclarativeEnvironment: {
		url: 'https://262.ecma-international.org/12.0/#sec-newdeclarativeenvironment'
	},
	NewFunctionEnvironment: {
		url: 'https://262.ecma-international.org/12.0/#sec-newfunctionenvironment'
	},
	NewGlobalEnvironment: {
		url: 'https://262.ecma-international.org/12.0/#sec-newglobalenvironment'
	},
	NewModuleEnvironment: {
		url: 'https://262.ecma-international.org/12.0/#sec-newmoduleenvironment'
	},
	NewObjectEnvironment: {
		url: 'https://262.ecma-international.org/12.0/#sec-newobjectenvironment'
	},
	NewPromiseCapability: {
		url: 'https://262.ecma-international.org/12.0/#sec-newpromisecapability'
	},
	NewPromiseReactionJob: {
		url: 'https://262.ecma-international.org/12.0/#sec-newpromisereactionjob'
	},
	NewPromiseResolveThenableJob: {
		url: 'https://262.ecma-international.org/12.0/#sec-newpromiseresolvethenablejob'
	},
	NormalCompletion: {
		url: 'https://262.ecma-international.org/12.0/#sec-normalcompletion'
	},
	NotifyWaiter: {
		url: 'https://262.ecma-international.org/12.0/#sec-notifywaiter'
	},
	'Number::add': {
		url: 'https://262.ecma-international.org/12.0/#sec-numeric-types-number-add'
	},
	'Number::bitwiseAND': {
		url: 'https://262.ecma-international.org/12.0/#sec-numeric-types-number-bitwiseAND'
	},
	'Number::bitwiseNOT': {
		url: 'https://262.ecma-international.org/12.0/#sec-numeric-types-number-bitwiseNOT'
	},
	'Number::bitwiseOR': {
		url: 'https://262.ecma-international.org/12.0/#sec-numeric-types-number-bitwiseOR'
	},
	'Number::bitwiseXOR': {
		url: 'https://262.ecma-international.org/12.0/#sec-numeric-types-number-bitwiseXOR'
	},
	'Number::divide': {
		url: 'https://262.ecma-international.org/12.0/#sec-numeric-types-number-divide'
	},
	'Number::equal': {
		url: 'https://262.ecma-international.org/12.0/#sec-numeric-types-number-equal'
	},
	'Number::exponentiate': {
		url: 'https://262.ecma-international.org/12.0/#sec-numeric-types-number-exponentiate'
	},
	'Number::leftShift': {
		url: 'https://262.ecma-international.org/12.0/#sec-numeric-types-number-leftShift'
	},
	'Number::lessThan': {
		url: 'https://262.ecma-international.org/12.0/#sec-numeric-types-number-lessThan'
	},
	'Number::multiply': {
		url: 'https://262.ecma-international.org/12.0/#sec-numeric-types-number-multiply'
	},
	'Number::remainder': {
		url: 'https://262.ecma-international.org/12.0/#sec-numeric-types-number-remainder'
	},
	'Number::sameValue': {
		url: 'https://262.ecma-international.org/12.0/#sec-numeric-types-number-sameValue'
	},
	'Number::sameValueZero': {
		url: 'https://262.ecma-international.org/12.0/#sec-numeric-types-number-sameValueZero'
	},
	'Number::signedRightShift': {
		url: 'https://262.ecma-international.org/12.0/#sec-numeric-types-number-signedRightShift'
	},
	'Number::subtract': {
		url: 'https://262.ecma-international.org/12.0/#sec-numeric-types-number-subtract'
	},
	'Number::toString': {
		url: 'https://262.ecma-international.org/12.0/#sec-numeric-types-number-tostring'
	},
	'Number::unaryMinus': {
		url: 'https://262.ecma-international.org/12.0/#sec-numeric-types-number-unaryMinus'
	},
	'Number::unsignedRightShift': {
		url: 'https://262.ecma-international.org/12.0/#sec-numeric-types-number-unsignedRightShift'
	},
	NumberBitwiseOp: {
		url: 'https://262.ecma-international.org/12.0/#sec-numberbitwiseop'
	},
	NumberToBigInt: {
		url: 'https://262.ecma-international.org/12.0/#sec-numbertobigint'
	},
	NumericToRawBytes: {
		url: 'https://262.ecma-international.org/12.0/#sec-numerictorawbytes'
	},
	ObjectDefineProperties: {
		url: 'https://262.ecma-international.org/12.0/#sec-objectdefineproperties'
	},
	OrdinaryCallBindThis: {
		url: 'https://262.ecma-international.org/12.0/#sec-ordinarycallbindthis'
	},
	OrdinaryCallEvaluateBody: {
		url: 'https://262.ecma-international.org/12.0/#sec-ordinarycallevaluatebody'
	},
	OrdinaryCreateFromConstructor: {
		url: 'https://262.ecma-international.org/12.0/#sec-ordinarycreatefromconstructor'
	},
	OrdinaryDefineOwnProperty: {
		url: 'https://262.ecma-international.org/12.0/#sec-ordinarydefineownproperty'
	},
	OrdinaryDelete: {
		url: 'https://262.ecma-international.org/12.0/#sec-ordinarydelete'
	},
	OrdinaryFunctionCreate: {
		url: 'https://262.ecma-international.org/12.0/#sec-ordinaryfunctioncreate'
	},
	OrdinaryGet: {
		url: 'https://262.ecma-international.org/12.0/#sec-ordinaryget'
	},
	OrdinaryGetOwnProperty: {
		url: 'https://262.ecma-international.org/12.0/#sec-ordinarygetownproperty'
	},
	OrdinaryGetPrototypeOf: {
		url: 'https://262.ecma-international.org/12.0/#sec-ordinarygetprototypeof'
	},
	OrdinaryHasInstance: {
		url: 'https://262.ecma-international.org/12.0/#sec-ordinaryhasinstance'
	},
	OrdinaryHasProperty: {
		url: 'https://262.ecma-international.org/12.0/#sec-ordinaryhasproperty'
	},
	OrdinaryIsExtensible: {
		url: 'https://262.ecma-international.org/12.0/#sec-ordinaryisextensible'
	},
	OrdinaryObjectCreate: {
		url: 'https://262.ecma-international.org/12.0/#sec-ordinaryobjectcreate'
	},
	OrdinaryOwnPropertyKeys: {
		url: 'https://262.ecma-international.org/12.0/#sec-ordinaryownpropertykeys'
	},
	OrdinaryPreventExtensions: {
		url: 'https://262.ecma-international.org/12.0/#sec-ordinarypreventextensions'
	},
	OrdinarySet: {
		url: 'https://262.ecma-international.org/12.0/#sec-ordinaryset'
	},
	OrdinarySetPrototypeOf: {
		url: 'https://262.ecma-international.org/12.0/#sec-ordinarysetprototypeof'
	},
	OrdinarySetWithOwnDescriptor: {
		url: 'https://262.ecma-international.org/12.0/#sec-ordinarysetwithowndescriptor'
	},
	OrdinaryToPrimitive: {
		url: 'https://262.ecma-international.org/12.0/#sec-ordinarytoprimitive'
	},
	ParseModule: {
		url: 'https://262.ecma-international.org/12.0/#sec-parsemodule'
	},
	ParsePattern: {
		url: 'https://262.ecma-international.org/12.0/#sec-parsepattern'
	},
	ParseScript: {
		url: 'https://262.ecma-international.org/12.0/#sec-parse-script'
	},
	ParseText: {
		url: 'https://262.ecma-international.org/12.0/#sec-parsetext'
	},
	PerformEval: {
		url: 'https://262.ecma-international.org/12.0/#sec-performeval'
	},
	PerformPromiseAll: {
		url: 'https://262.ecma-international.org/12.0/#sec-performpromiseall'
	},
	PerformPromiseAllSettled: {
		url: 'https://262.ecma-international.org/12.0/#sec-performpromiseallsettled'
	},
	PerformPromiseAny: {
		url: 'https://262.ecma-international.org/12.0/#sec-performpromiseany'
	},
	PerformPromiseRace: {
		url: 'https://262.ecma-international.org/12.0/#sec-performpromiserace'
	},
	PerformPromiseThen: {
		url: 'https://262.ecma-international.org/12.0/#sec-performpromisethen'
	},
	PrepareForOrdinaryCall: {
		url: 'https://262.ecma-international.org/12.0/#sec-prepareforordinarycall'
	},
	PrepareForTailCall: {
		url: 'https://262.ecma-international.org/12.0/#sec-preparefortailcall'
	},
	PromiseResolve: {
		url: 'https://262.ecma-international.org/12.0/#sec-promise-resolve'
	},
	ProxyCreate: {
		url: 'https://262.ecma-international.org/12.0/#sec-proxycreate'
	},
	PutValue: {
		url: 'https://262.ecma-international.org/12.0/#sec-putvalue'
	},
	QuoteJSONString: {
		url: 'https://262.ecma-international.org/12.0/#sec-quotejsonstring'
	},
	RawBytesToNumeric: {
		url: 'https://262.ecma-international.org/12.0/#sec-rawbytestonumeric'
	},
	'reads-bytes-from': {
		url: 'https://262.ecma-international.org/12.0/#sec-reads-bytes-from'
	},
	'reads-from': {
		url: 'https://262.ecma-international.org/12.0/#sec-reads-from'
	},
	RegExpAlloc: {
		url: 'https://262.ecma-international.org/12.0/#sec-regexpalloc'
	},
	RegExpBuiltinExec: {
		url: 'https://262.ecma-international.org/12.0/#sec-regexpbuiltinexec'
	},
	RegExpCreate: {
		url: 'https://262.ecma-international.org/12.0/#sec-regexpcreate'
	},
	RegExpExec: {
		url: 'https://262.ecma-international.org/12.0/#sec-regexpexec'
	},
	RegExpInitialize: {
		url: 'https://262.ecma-international.org/12.0/#sec-regexpinitialize'
	},
	RejectPromise: {
		url: 'https://262.ecma-international.org/12.0/#sec-rejectpromise'
	},
	RemoveWaiter: {
		url: 'https://262.ecma-international.org/12.0/#sec-removewaiter'
	},
	RemoveWaiters: {
		url: 'https://262.ecma-international.org/12.0/#sec-removewaiters'
	},
	RepeatMatcher: {
		url: 'https://262.ecma-international.org/12.0/#sec-runtime-semantics-repeatmatcher-abstract-operation'
	},
	RequireInternalSlot: {
		url: 'https://262.ecma-international.org/12.0/#sec-requireinternalslot'
	},
	RequireObjectCoercible: {
		url: 'https://262.ecma-international.org/12.0/#sec-requireobjectcoercible'
	},
	ResolveBinding: {
		url: 'https://262.ecma-international.org/12.0/#sec-resolvebinding'
	},
	ResolveThisBinding: {
		url: 'https://262.ecma-international.org/12.0/#sec-resolvethisbinding'
	},
	ReturnIfAbrupt: {
		url: 'https://262.ecma-international.org/12.0/#sec-returnifabrupt'
	},
	SameValue: {
		url: 'https://262.ecma-international.org/12.0/#sec-samevalue'
	},
	SameValueNonNumeric: {
		url: 'https://262.ecma-international.org/12.0/#sec-samevaluenonnumeric'
	},
	SameValueZero: {
		url: 'https://262.ecma-international.org/12.0/#sec-samevaluezero'
	},
	ScriptEvaluation: {
		url: 'https://262.ecma-international.org/12.0/#sec-runtime-semantics-scriptevaluation'
	},
	SecFromTime: {
		url: 'https://262.ecma-international.org/12.0/#eqn-SecFromTime'
	},
	SerializeJSONArray: {
		url: 'https://262.ecma-international.org/12.0/#sec-serializejsonarray'
	},
	SerializeJSONObject: {
		url: 'https://262.ecma-international.org/12.0/#sec-serializejsonobject'
	},
	SerializeJSONProperty: {
		url: 'https://262.ecma-international.org/12.0/#sec-serializejsonproperty'
	},
	Set: {
		url: 'https://262.ecma-international.org/12.0/#sec-set-o-p-v-throw'
	},
	SetDefaultGlobalBindings: {
		url: 'https://262.ecma-international.org/12.0/#sec-setdefaultglobalbindings'
	},
	SetFunctionLength: {
		url: 'https://262.ecma-international.org/12.0/#sec-setfunctionlength'
	},
	SetFunctionName: {
		url: 'https://262.ecma-international.org/12.0/#sec-setfunctionname'
	},
	SetImmutablePrototype: {
		url: 'https://262.ecma-international.org/12.0/#sec-set-immutable-prototype'
	},
	SetIntegrityLevel: {
		url: 'https://262.ecma-international.org/12.0/#sec-setintegritylevel'
	},
	SetRealmGlobalObject: {
		url: 'https://262.ecma-international.org/12.0/#sec-setrealmglobalobject'
	},
	SetTypedArrayFromArrayLike: {
		url: 'https://262.ecma-international.org/12.0/#sec-settypedarrayfromarraylike'
	},
	SetTypedArrayFromTypedArray: {
		url: 'https://262.ecma-international.org/12.0/#sec-settypedarrayfromtypedarray'
	},
	SetValueInBuffer: {
		url: 'https://262.ecma-international.org/12.0/#sec-setvalueinbuffer'
	},
	SetViewValue: {
		url: 'https://262.ecma-international.org/12.0/#sec-setviewvalue'
	},
	SharedDataBlockEventSet: {
		url: 'https://262.ecma-international.org/12.0/#sec-sharedatablockeventset'
	},
	SortCompare: {
		url: 'https://262.ecma-international.org/12.0/#sec-sortcompare'
	},
	SpeciesConstructor: {
		url: 'https://262.ecma-international.org/12.0/#sec-speciesconstructor'
	},
	SplitMatch: {
		url: 'https://262.ecma-international.org/12.0/#sec-splitmatch'
	},
	'Strict Equality Comparison': {
		url: 'https://262.ecma-international.org/12.0/#sec-strict-equality-comparison'
	},
	StringCreate: {
		url: 'https://262.ecma-international.org/12.0/#sec-stringcreate'
	},
	StringGetOwnProperty: {
		url: 'https://262.ecma-international.org/12.0/#sec-stringgetownproperty'
	},
	StringIndexOf: {
		url: 'https://262.ecma-international.org/12.0/#sec-stringindexof'
	},
	StringPad: {
		url: 'https://262.ecma-international.org/12.0/#sec-stringpad'
	},
	StringToBigInt: {
		url: 'https://262.ecma-international.org/12.0/#sec-stringtobigint'
	},
	StringToCodePoints: {
		url: 'https://262.ecma-international.org/12.0/#sec-stringtocodepoints'
	},
	substring: {
		url: 'https://262.ecma-international.org/12.0/#substring'
	},
	SuspendAgent: {
		url: 'https://262.ecma-international.org/12.0/#sec-suspendagent'
	},
	SymbolDescriptiveString: {
		url: 'https://262.ecma-international.org/12.0/#sec-symboldescriptivestring'
	},
	'synchronizes-with': {
		url: 'https://262.ecma-international.org/12.0/#sec-synchronizes-with'
	},
	TestIntegrityLevel: {
		url: 'https://262.ecma-international.org/12.0/#sec-testintegritylevel'
	},
	thisBigIntValue: {
		url: 'https://262.ecma-international.org/12.0/#thisbigintvalue'
	},
	thisBooleanValue: {
		url: 'https://262.ecma-international.org/12.0/#thisbooleanvalue'
	},
	thisNumberValue: {
		url: 'https://262.ecma-international.org/12.0/#thisnumbervalue'
	},
	thisStringValue: {
		url: 'https://262.ecma-international.org/12.0/#thisstringvalue'
	},
	thisSymbolValue: {
		url: 'https://262.ecma-international.org/12.0/#thissymbolvalue'
	},
	thisTimeValue: {
		url: 'https://262.ecma-international.org/12.0/#thistimevalue'
	},
	ThrowCompletion: {
		url: 'https://262.ecma-international.org/12.0/#sec-throwcompletion'
	},
	TimeClip: {
		url: 'https://262.ecma-international.org/12.0/#sec-timeclip'
	},
	TimeFromYear: {
		url: 'https://262.ecma-international.org/12.0/#eqn-TimeFromYear'
	},
	TimeString: {
		url: 'https://262.ecma-international.org/12.0/#sec-timestring'
	},
	TimeWithinDay: {
		url: 'https://262.ecma-international.org/12.0/#eqn-TimeWithinDay'
	},
	TimeZoneString: {
		url: 'https://262.ecma-international.org/12.0/#sec-timezoneestring'
	},
	ToBigInt: {
		url: 'https://262.ecma-international.org/12.0/#sec-tobigint'
	},
	ToBigInt64: {
		url: 'https://262.ecma-international.org/12.0/#sec-tobigint64'
	},
	ToBigUint64: {
		url: 'https://262.ecma-international.org/12.0/#sec-tobiguint64'
	},
	ToBoolean: {
		url: 'https://262.ecma-international.org/12.0/#sec-toboolean'
	},
	ToDateString: {
		url: 'https://262.ecma-international.org/12.0/#sec-todatestring'
	},
	ToIndex: {
		url: 'https://262.ecma-international.org/12.0/#sec-toindex'
	},
	ToInt16: {
		url: 'https://262.ecma-international.org/12.0/#sec-toint16'
	},
	ToInt32: {
		url: 'https://262.ecma-international.org/12.0/#sec-toint32'
	},
	ToInt8: {
		url: 'https://262.ecma-international.org/12.0/#sec-toint8'
	},
	ToIntegerOrInfinity: {
		url: 'https://262.ecma-international.org/12.0/#sec-tointegerorinfinity'
	},
	ToLength: {
		url: 'https://262.ecma-international.org/12.0/#sec-tolength'
	},
	ToNumber: {
		url: 'https://262.ecma-international.org/12.0/#sec-tonumber'
	},
	ToNumeric: {
		url: 'https://262.ecma-international.org/12.0/#sec-tonumeric'
	},
	ToObject: {
		url: 'https://262.ecma-international.org/12.0/#sec-toobject'
	},
	ToPrimitive: {
		url: 'https://262.ecma-international.org/12.0/#sec-toprimitive'
	},
	ToPropertyDescriptor: {
		url: 'https://262.ecma-international.org/12.0/#sec-topropertydescriptor'
	},
	ToPropertyKey: {
		url: 'https://262.ecma-international.org/12.0/#sec-topropertykey'
	},
	ToString: {
		url: 'https://262.ecma-international.org/12.0/#sec-tostring'
	},
	ToUint16: {
		url: 'https://262.ecma-international.org/12.0/#sec-touint16'
	},
	ToUint32: {
		url: 'https://262.ecma-international.org/12.0/#sec-touint32'
	},
	ToUint8: {
		url: 'https://262.ecma-international.org/12.0/#sec-touint8'
	},
	ToUint8Clamp: {
		url: 'https://262.ecma-international.org/12.0/#sec-touint8clamp'
	},
	TriggerPromiseReactions: {
		url: 'https://262.ecma-international.org/12.0/#sec-triggerpromisereactions'
	},
	TrimString: {
		url: 'https://262.ecma-international.org/12.0/#sec-trimstring'
	},
	Type: {
		url: 'https://262.ecma-international.org/12.0/#sec-ecmascript-data-types-and-values'
	},
	TypedArrayCreate: {
		url: 'https://262.ecma-international.org/12.0/#typedarray-create'
	},
	TypedArraySpeciesCreate: {
		url: 'https://262.ecma-international.org/12.0/#typedarray-species-create'
	},
	UnicodeEscape: {
		url: 'https://262.ecma-international.org/12.0/#sec-unicodeescape'
	},
	UnicodeMatchProperty: {
		url: 'https://262.ecma-international.org/12.0/#sec-runtime-semantics-unicodematchproperty-p'
	},
	UnicodeMatchPropertyValue: {
		url: 'https://262.ecma-international.org/12.0/#sec-runtime-semantics-unicodematchpropertyvalue-p-v'
	},
	UpdateEmpty: {
		url: 'https://262.ecma-international.org/12.0/#sec-updateempty'
	},
	UTC: {
		url: 'https://262.ecma-international.org/12.0/#sec-utc-t'
	},
	UTF16EncodeCodePoint: {
		url: 'https://262.ecma-international.org/12.0/#sec-utf16encodecodepoint'
	},
	UTF16SurrogatePairToCodePoint: {
		url: 'https://262.ecma-international.org/12.0/#sec-utf16decodesurrogatepair'
	},
	ValidateAndApplyPropertyDescriptor: {
		url: 'https://262.ecma-international.org/12.0/#sec-validateandapplypropertydescriptor'
	},
	ValidateAtomicAccess: {
		url: 'https://262.ecma-international.org/12.0/#sec-validateatomicaccess'
	},
	ValidateIntegerTypedArray: {
		url: 'https://262.ecma-international.org/12.0/#sec-validateintegertypedarray'
	},
	ValidateTypedArray: {
		url: 'https://262.ecma-international.org/12.0/#sec-validatetypedarray'
	},
	ValueOfReadEvent: {
		url: 'https://262.ecma-international.org/12.0/#sec-valueofreadevent'
	},
	WeakRefDeref: {
		url: 'https://262.ecma-international.org/12.0/#sec-weakrefderef'
	},
	WeekDay: {
		url: 'https://262.ecma-international.org/12.0/#sec-week-day'
	},
	WordCharacters: {
		url: 'https://262.ecma-international.org/12.0/#sec-runtime-semantics-wordcharacters-abstract-operation'
	},
	YearFromTime: {
		url: 'https://262.ecma-international.org/12.0/#eqn-YearFromTime'
	},
	Yield: {
		url: 'https://262.ecma-international.org/12.0/#sec-yield'
	}
};
'use strict';

module.exports = {
	abs: {
		url: 'https://262.ecma-international.org/13.0/#eqn-abs'
	},
	AddEntriesFromIterable: {
		url: 'https://262.ecma-international.org/13.0/#sec-add-entries-from-iterable'
	},
	AddRestrictedFunctionProperties: {
		url: 'https://262.ecma-international.org/13.0/#sec-addrestrictedfunctionproperties'
	},
	AddToKeptObjects: {
		url: 'https://262.ecma-international.org/13.0/#sec-addtokeptobjects'
	},
	AddWaiter: {
		url: 'https://262.ecma-international.org/13.0/#sec-addwaiter'
	},
	AdvanceStringIndex: {
		url: 'https://262.ecma-international.org/13.0/#sec-advancestringindex'
	},
	'agent-order': {
		url: 'https://262.ecma-international.org/13.0/#sec-agent-order'
	},
	AgentCanSuspend: {
		url: 'https://262.ecma-international.org/13.0/#sec-agentcansuspend'
	},
	AgentSignifier: {
		url: 'https://262.ecma-international.org/13.0/#sec-agentsignifier'
	},
	AllocateArrayBuffer: {
		url: 'https://262.ecma-international.org/13.0/#sec-allocatearraybuffer'
	},
	AllocateSharedArrayBuffer: {
		url: 'https://262.ecma-international.org/13.0/#sec-allocatesharedarraybuffer'
	},
	AllocateTypedArray: {
		url: 'https://262.ecma-international.org/13.0/#sec-allocatetypedarray'
	},
	AllocateTypedArrayBuffer: {
		url: 'https://262.ecma-international.org/13.0/#sec-allocatetypedarraybuffer'
	},
	ApplyStringOrNumericBinaryOperator: {
		url: 'https://262.ecma-international.org/13.0/#sec-applystringornumericbinaryoperator'
	},
	ArrayCreate: {
		url: 'https://262.ecma-international.org/13.0/#sec-arraycreate'
	},
	ArraySetLength: {
		url: 'https://262.ecma-international.org/13.0/#sec-arraysetlength'
	},
	ArraySpeciesCreate: {
		url: 'https://262.ecma-international.org/13.0/#sec-arrayspeciescreate'
	},
	AsyncBlockStart: {
		url: 'https://262.ecma-international.org/13.0/#sec-asyncblockstart'
	},
	AsyncFromSyncIteratorContinuation: {
		url: 'https://262.ecma-international.org/13.0/#sec-asyncfromsynciteratorcontinuation'
	},
	AsyncFunctionStart: {
		url: 'https://262.ecma-international.org/13.0/#sec-async-functions-abstract-operations-async-function-start'
	},
	AsyncGeneratorAwaitReturn: {
		url: 'https://262.ecma-international.org/13.0/#sec-asyncgeneratorawaitreturn'
	},
	AsyncGeneratorCompleteStep: {
		url: 'https://262.ecma-international.org/13.0/#sec-asyncgeneratorcompletestep'
	},
	AsyncGeneratorDrainQueue: {
		url: 'https://262.ecma-international.org/13.0/#sec-asyncgeneratordrainqueue'
	},
	AsyncGeneratorEnqueue: {
		url: 'https://262.ecma-international.org/13.0/#sec-asyncgeneratorenqueue'
	},
	AsyncGeneratorResume: {
		url: 'https://262.ecma-international.org/13.0/#sec-asyncgeneratorresume'
	},
	AsyncGeneratorStart: {
		url: 'https://262.ecma-international.org/13.0/#sec-asyncgeneratorstart'
	},
	AsyncGeneratorUnwrapYieldResumption: {
		url: 'https://262.ecma-international.org/13.0/#sec-asyncgeneratorunwrapyieldresumption'
	},
	AsyncGeneratorValidate: {
		url: 'https://262.ecma-international.org/13.0/#sec-asyncgeneratorvalidate'
	},
	AsyncGeneratorYield: {
		url: 'https://262.ecma-international.org/13.0/#sec-asyncgeneratoryield'
	},
	AsyncIteratorClose: {
		url: 'https://262.ecma-international.org/13.0/#sec-asynciteratorclose'
	},
	AsyncModuleExecutionFulfilled: {
		url: 'https://262.ecma-international.org/13.0/#sec-async-module-execution-fulfilled'
	},
	AsyncModuleExecutionRejected: {
		url: 'https://262.ecma-international.org/13.0/#sec-async-module-execution-rejected'
	},
	AtomicReadModifyWrite: {
		url: 'https://262.ecma-international.org/13.0/#sec-atomicreadmodifywrite'
	},
	Await: {
		url: 'https://262.ecma-international.org/13.0/#await'
	},
	BackreferenceMatcher: {
		url: 'https://262.ecma-international.org/13.0/#sec-backreference-matcher'
	},
	'BigInt::add': {
		url: 'https://262.ecma-international.org/13.0/#sec-numeric-types-bigint-add'
	},
	'BigInt::bitwiseAND': {
		url: 'https://262.ecma-international.org/13.0/#sec-numeric-types-bigint-bitwiseAND'
	},
	'BigInt::bitwiseNOT': {
		url: 'https://262.ecma-international.org/13.0/#sec-numeric-types-bigint-bitwiseNOT'
	},
	'BigInt::bitwiseOR': {
		url: 'https://262.ecma-international.org/13.0/#sec-numeric-types-bigint-bitwiseOR'
	},
	'BigInt::bitwiseXOR': {
		url: 'https://262.ecma-international.org/13.0/#sec-numeric-types-bigint-bitwiseXOR'
	},
	'BigInt::divide': {
		url: 'https://262.ecma-international.org/13.0/#sec-numeric-types-bigint-divide'
	},
	'BigInt::equal': {
		url: 'https://262.ecma-international.org/13.0/#sec-numeric-types-bigint-equal'
	},
	'BigInt::exponentiate': {
		url: 'https://262.ecma-international.org/13.0/#sec-numeric-types-bigint-exponentiate'
	},
	'BigInt::leftShift': {
		url: 'https://262.ecma-international.org/13.0/#sec-numeric-types-bigint-leftShift'
	},
	'BigInt::lessThan': {
		url: 'https://262.ecma-international.org/13.0/#sec-numeric-types-bigint-lessThan'
	},
	'BigInt::multiply': {
		url: 'https://262.ecma-international.org/13.0/#sec-numeric-types-bigint-multiply'
	},
	'BigInt::remainder': {
		url: 'https://262.ecma-international.org/13.0/#sec-numeric-types-bigint-remainder'
	},
	'BigInt::sameValue': {
		url: 'https://262.ecma-international.org/13.0/#sec-numeric-types-bigint-sameValue'
	},
	'BigInt::sameValueZero': {
		url: 'https://262.ecma-international.org/13.0/#sec-numeric-types-bigint-sameValueZero'
	},
	'BigInt::signedRightShift': {
		url: 'https://262.ecma-international.org/13.0/#sec-numeric-types-bigint-signedRightShift'
	},
	'BigInt::subtract': {
		url: 'https://262.ecma-international.org/13.0/#sec-numeric-types-bigint-subtract'
	},
	'BigInt::toString': {
		url: 'https://262.ecma-international.org/13.0/#sec-numeric-types-bigint-tostring'
	},
	'BigInt::unaryMinus': {
		url: 'https://262.ecma-international.org/13.0/#sec-numeric-types-bigint-unaryMinus'
	},
	'BigInt::unsignedRightShift': {
		url: 'https://262.ecma-international.org/13.0/#sec-numeric-types-bigint-unsignedRightShift'
	},
	BigIntBitwiseOp: {
		url: 'https://262.ecma-international.org/13.0/#sec-bigintbitwiseop'
	},
	BinaryAnd: {
		url: 'https://262.ecma-international.org/13.0/#sec-binaryand'
	},
	BinaryOr: {
		url: 'https://262.ecma-international.org/13.0/#sec-binaryor'
	},
	BinaryXor: {
		url: 'https://262.ecma-international.org/13.0/#sec-binaryxor'
	},
	BlockDeclarationInstantiation: {
		url: 'https://262.ecma-international.org/13.0/#sec-blockdeclarationinstantiation'
	},
	BoundFunctionCreate: {
		url: 'https://262.ecma-international.org/13.0/#sec-boundfunctioncreate'
	},
	ByteListBitwiseOp: {
		url: 'https://262.ecma-international.org/13.0/#sec-bytelistbitwiseop'
	},
	ByteListEqual: {
		url: 'https://262.ecma-international.org/13.0/#sec-bytelistequal'
	},
	Call: {
		url: 'https://262.ecma-international.org/13.0/#sec-call'
	},
	Canonicalize: {
		url: 'https://262.ecma-international.org/13.0/#sec-runtime-semantics-canonicalize-ch'
	},
	CanonicalNumericIndexString: {
		url: 'https://262.ecma-international.org/13.0/#sec-canonicalnumericindexstring'
	},
	CaseClauseIsSelected: {
		url: 'https://262.ecma-international.org/13.0/#sec-runtime-semantics-caseclauseisselected'
	},
	CharacterRange: {
		url: 'https://262.ecma-international.org/13.0/#sec-runtime-semantics-characterrange-abstract-operation'
	},
	CharacterRangeOrUnion: {
		url: 'https://262.ecma-international.org/13.0/#sec-runtime-semantics-characterrangeorunion-abstract-operation'
	},
	CharacterSetMatcher: {
		url: 'https://262.ecma-international.org/13.0/#sec-runtime-semantics-charactersetmatcher-abstract-operation'
	},
	clamp: {
		url: 'https://262.ecma-international.org/13.0/#clamping'
	},
	CleanupFinalizationRegistry: {
		url: 'https://262.ecma-international.org/13.0/#sec-cleanup-finalization-registry'
	},
	ClearKeptObjects: {
		url: 'https://262.ecma-international.org/13.0/#sec-clear-kept-objects'
	},
	CloneArrayBuffer: {
		url: 'https://262.ecma-international.org/13.0/#sec-clonearraybuffer'
	},
	CodePointAt: {
		url: 'https://262.ecma-international.org/13.0/#sec-codepointat'
	},
	CodePointsToString: {
		url: 'https://262.ecma-international.org/13.0/#sec-codepointstostring'
	},
	CompletePropertyDescriptor: {
		url: 'https://262.ecma-international.org/13.0/#sec-completepropertydescriptor'
	},
	Completion: {
		url: 'https://262.ecma-international.org/13.0/#sec-completion-ao'
	},
	CompletionRecord: {
		url: 'https://262.ecma-international.org/13.0/#sec-completion-record-specification-type'
	},
	ComposeWriteEventBytes: {
		url: 'https://262.ecma-international.org/13.0/#sec-composewriteeventbytes'
	},
	Construct: {
		url: 'https://262.ecma-international.org/13.0/#sec-construct'
	},
	CopyDataBlockBytes: {
		url: 'https://262.ecma-international.org/13.0/#sec-copydatablockbytes'
	},
	CopyDataProperties: {
		url: 'https://262.ecma-international.org/13.0/#sec-copydataproperties'
	},
	CreateArrayFromList: {
		url: 'https://262.ecma-international.org/13.0/#sec-createarrayfromlist'
	},
	CreateArrayIterator: {
		url: 'https://262.ecma-international.org/13.0/#sec-createarrayiterator'
	},
	CreateAsyncFromSyncIterator: {
		url: 'https://262.ecma-international.org/13.0/#sec-createasyncfromsynciterator'
	},
	CreateAsyncIteratorFromClosure: {
		url: 'https://262.ecma-international.org/13.0/#sec-createasynciteratorfromclosure'
	},
	CreateBuiltinFunction: {
		url: 'https://262.ecma-international.org/13.0/#sec-createbuiltinfunction'
	},
	CreateByteDataBlock: {
		url: 'https://262.ecma-international.org/13.0/#sec-createbytedatablock'
	},
	CreateDataProperty: {
		url: 'https://262.ecma-international.org/13.0/#sec-createdataproperty'
	},
	CreateDataPropertyOrThrow: {
		url: 'https://262.ecma-international.org/13.0/#sec-createdatapropertyorthrow'
	},
	CreateDynamicFunction: {
		url: 'https://262.ecma-international.org/13.0/#sec-createdynamicfunction'
	},
	CreateForInIterator: {
		url: 'https://262.ecma-international.org/13.0/#sec-createforiniterator'
	},
	CreateHTML: {
		url: 'https://262.ecma-international.org/13.0/#sec-createhtml'
	},
	CreateIntrinsics: {
		url: 'https://262.ecma-international.org/13.0/#sec-createintrinsics'
	},
	CreateIteratorFromClosure: {
		url: 'https://262.ecma-international.org/13.0/#sec-createiteratorfromclosure'
	},
	CreateIterResultObject: {
		url: 'https://262.ecma-international.org/13.0/#sec-createiterresultobject'
	},
	CreateListFromArrayLike: {
		url: 'https://262.ecma-international.org/13.0/#sec-createlistfromarraylike'
	},
	CreateListIteratorRecord: {
		url: 'https://262.ecma-international.org/13.0/#sec-createlistiteratorRecord'
	},
	CreateMapIterator: {
		url: 'https://262.ecma-international.org/13.0/#sec-createmapiterator'
	},
	CreateMappedArgumentsObject: {
		url: 'https://262.ecma-international.org/13.0/#sec-createmappedargumentsobject'
	},
	CreateMethodProperty: {
		url: 'https://262.ecma-international.org/13.0/#sec-createmethodproperty'
	},
	CreateNonEnumerableDataPropertyOrThrow: {
		url: 'https://262.ecma-international.org/13.0/#sec-createnonenumerabledatapropertyorthrow'
	},
	CreatePerIterationEnvironment: {
		url: 'https://262.ecma-international.org/13.0/#sec-createperiterationenvironment'
	},
	CreateRealm: {
		url: 'https://262.ecma-international.org/13.0/#sec-createrealm'
	},
	CreateRegExpStringIterator: {
		url: 'https://262.ecma-international.org/13.0/#sec-createregexpstringiterator'
	},
	CreateResolvingFunctions: {
		url: 'https://262.ecma-international.org/13.0/#sec-createresolvingfunctions'
	},
	CreateSetIterator: {
		url: 'https://262.ecma-international.org/13.0/#sec-createsetiterator'
	},
	CreateSharedByteDataBlock: {
		url: 'https://262.ecma-international.org/13.0/#sec-createsharedbytedatablock'
	},
	CreateUnmappedArgumentsObject: {
		url: 'https://262.ecma-international.org/13.0/#sec-createunmappedargumentsobject'
	},
	DateFromTime: {
		url: 'https://262.ecma-international.org/13.0/#sec-date-number'
	},
	DateString: {
		url: 'https://262.ecma-international.org/13.0/#sec-datestring'
	},
	Day: {
		url: 'https://262.ecma-international.org/13.0/#eqn-Day'
	},
	DayFromYear: {
		url: 'https://262.ecma-international.org/13.0/#eqn-DaysFromYear'
	},
	DaysInYear: {
		url: 'https://262.ecma-international.org/13.0/#eqn-DaysInYear'
	},
	DayWithinYear: {
		url: 'https://262.ecma-international.org/13.0/#eqn-DayWithinYear'
	},
	Decode: {
		url: 'https://262.ecma-international.org/13.0/#sec-decode'
	},
	DefineField: {
		url: 'https://262.ecma-international.org/13.0/#sec-definefield'
	},
	DefineMethodProperty: {
		url: 'https://262.ecma-international.org/13.0/#sec-definemethodproperty'
	},
	DefinePropertyOrThrow: {
		url: 'https://262.ecma-international.org/13.0/#sec-definepropertyorthrow'
	},
	DeletePropertyOrThrow: {
		url: 'https://262.ecma-international.org/13.0/#sec-deletepropertyorthrow'
	},
	DetachArrayBuffer: {
		url: 'https://262.ecma-international.org/13.0/#sec-detacharraybuffer'
	},
	Encode: {
		url: 'https://262.ecma-international.org/13.0/#sec-encode'
	},
	EnterCriticalSection: {
		url: 'https://262.ecma-international.org/13.0/#sec-entercriticalsection'
	},
	EnumerableOwnPropertyNames: {
		url: 'https://262.ecma-international.org/13.0/#sec-enumerableownpropertynames'
	},
	EnumerateObjectProperties: {
		url: 'https://262.ecma-international.org/13.0/#sec-enumerate-object-properties'
	},
	EscapeRegExpPattern: {
		url: 'https://262.ecma-international.org/13.0/#sec-escaperegexppattern'
	},
	EvalDeclarationInstantiation: {
		url: 'https://262.ecma-international.org/13.0/#sec-evaldeclarationinstantiation'
	},
	EvaluateCall: {
		url: 'https://262.ecma-international.org/13.0/#sec-evaluatecall'
	},
	EvaluateNew: {
		url: 'https://262.ecma-international.org/13.0/#sec-evaluatenew'
	},
	EvaluatePropertyAccessWithExpressionKey: {
		url: 'https://262.ecma-international.org/13.0/#sec-evaluate-property-access-with-expression-key'
	},
	EvaluatePropertyAccessWithIdentifierKey: {
		url: 'https://262.ecma-international.org/13.0/#sec-evaluate-property-access-with-identifier-key'
	},
	EvaluateStringOrNumericBinaryExpression: {
		url: 'https://262.ecma-international.org/13.0/#sec-evaluatestringornumericbinaryexpression'
	},
	EventSet: {
		url: 'https://262.ecma-international.org/13.0/#sec-event-set'
	},
	ExecuteAsyncModule: {
		url: 'https://262.ecma-international.org/13.0/#sec-execute-async-module'
	},
	FinishDynamicImport: {
		url: 'https://262.ecma-international.org/13.0/#sec-finishdynamicimport'
	},
	FlattenIntoArray: {
		url: 'https://262.ecma-international.org/13.0/#sec-flattenintoarray'
	},
	floor: {
		url: 'https://262.ecma-international.org/13.0/#eqn-floor'
	},
	ForBodyEvaluation: {
		url: 'https://262.ecma-international.org/13.0/#sec-forbodyevaluation'
	},
	'ForIn/OfBodyEvaluation': {
		url: 'https://262.ecma-international.org/13.0/#sec-runtime-semantics-forin-div-ofbodyevaluation-lhs-stmt-iterator-lhskind-labelset'
	},
	'ForIn/OfHeadEvaluation': {
		url: 'https://262.ecma-international.org/13.0/#sec-runtime-semantics-forinofheadevaluation'
	},
	FromPropertyDescriptor: {
		url: 'https://262.ecma-international.org/13.0/#sec-frompropertydescriptor'
	},
	FulfillPromise: {
		url: 'https://262.ecma-international.org/13.0/#sec-fulfillpromise'
	},
	FunctionDeclarationInstantiation: {
		url: 'https://262.ecma-international.org/13.0/#sec-functiondeclarationinstantiation'
	},
	GatherAvailableAncestors: {
		url: 'https://262.ecma-international.org/13.0/#sec-gather-available-ancestors'
	},
	GeneratorResume: {
		url: 'https://262.ecma-international.org/13.0/#sec-generatorresume'
	},
	GeneratorResumeAbrupt: {
		url: 'https://262.ecma-international.org/13.0/#sec-generatorresumeabrupt'
	},
	GeneratorStart: {
		url: 'https://262.ecma-international.org/13.0/#sec-generatorstart'
	},
	GeneratorValidate: {
		url: 'https://262.ecma-international.org/13.0/#sec-generatorvalidate'
	},
	GeneratorYield: {
		url: 'https://262.ecma-international.org/13.0/#sec-generatoryield'
	},
	Get: {
		url: 'https://262.ecma-international.org/13.0/#sec-get-o-p'
	},
	GetActiveScriptOrModule: {
		url: 'https://262.ecma-international.org/13.0/#sec-getactivescriptormodule'
	},
	GetFunctionRealm: {
		url: 'https://262.ecma-international.org/13.0/#sec-getfunctionrealm'
	},
	GetGeneratorKind: {
		url: 'https://262.ecma-international.org/13.0/#sec-getgeneratorkind'
	},
	GetGlobalObject: {
		url: 'https://262.ecma-international.org/13.0/#sec-getglobalobject'
	},
	GetIdentifierReference: {
		url: 'https://262.ecma-international.org/13.0/#sec-getidentifierreference'
	},
	GetIterator: {
		url: 'https://262.ecma-international.org/13.0/#sec-getiterator'
	},
	GetMatchIndexPair: {
		url: 'https://262.ecma-international.org/13.0/#sec-getmatchindexpair'
	},
	GetMatchString: {
		url: 'https://262.ecma-international.org/13.0/#sec-getmatchstring'
	},
	GetMethod: {
		url: 'https://262.ecma-international.org/13.0/#sec-getmethod'
	},
	GetModifySetValueInBuffer: {
		url: 'https://262.ecma-international.org/13.0/#sec-getmodifysetvalueinbuffer'
	},
	GetModuleNamespace: {
		url: 'https://262.ecma-international.org/13.0/#sec-getmodulenamespace'
	},
	GetNewTarget: {
		url: 'https://262.ecma-international.org/13.0/#sec-getnewtarget'
	},
	GetOwnPropertyKeys: {
		url: 'https://262.ecma-international.org/13.0/#sec-getownpropertykeys'
	},
	GetPromiseResolve: {
		url: 'https://262.ecma-international.org/13.0/#sec-getpromiseresolve'
	},
	GetPrototypeFromConstructor: {
		url: 'https://262.ecma-international.org/13.0/#sec-getprototypefromconstructor'
	},
	GetStringIndex: {
		url: 'https://262.ecma-international.org/13.0/#sec-getstringindex'
	},
	GetSubstitution: {
		url: 'https://262.ecma-international.org/13.0/#sec-getsubstitution'
	},
	GetSuperConstructor: {
		url: 'https://262.ecma-international.org/13.0/#sec-getsuperconstructor'
	},
	GetTemplateObject: {
		url: 'https://262.ecma-international.org/13.0/#sec-gettemplateobject'
	},
	GetThisEnvironment: {
		url: 'https://262.ecma-international.org/13.0/#sec-getthisenvironment'
	},
	GetThisValue: {
		url: 'https://262.ecma-international.org/13.0/#sec-getthisvalue'
	},
	GetV: {
		url: 'https://262.ecma-international.org/13.0/#sec-getv'
	},
	GetValue: {
		url: 'https://262.ecma-international.org/13.0/#sec-getvalue'
	},
	GetValueFromBuffer: {
		url: 'https://262.ecma-international.org/13.0/#sec-getvaluefrombuffer'
	},
	GetViewValue: {
		url: 'https://262.ecma-international.org/13.0/#sec-getviewvalue'
	},
	GetWaiterList: {
		url: 'https://262.ecma-international.org/13.0/#sec-getwaiterlist'
	},
	GlobalDeclarationInstantiation: {
		url: 'https://262.ecma-international.org/13.0/#sec-globaldeclarationinstantiation'
	},
	'happens-before': {
		url: 'https://262.ecma-international.org/13.0/#sec-happens-before'
	},
	HasOwnProperty: {
		url: 'https://262.ecma-international.org/13.0/#sec-hasownproperty'
	},
	HasProperty: {
		url: 'https://262.ecma-international.org/13.0/#sec-hasproperty'
	},
	'host-synchronizes-with': {
		url: 'https://262.ecma-international.org/13.0/#sec-host-synchronizes-with'
	},
	HostEventSet: {
		url: 'https://262.ecma-international.org/13.0/#sec-hosteventset'
	},
	HourFromTime: {
		url: 'https://262.ecma-international.org/13.0/#eqn-HourFromTime'
	},
	IfAbruptCloseIterator: {
		url: 'https://262.ecma-international.org/13.0/#sec-ifabruptcloseiterator'
	},
	IfAbruptRejectPromise: {
		url: 'https://262.ecma-international.org/13.0/#sec-ifabruptrejectpromise'
	},
	ImportedLocalNames: {
		url: 'https://262.ecma-international.org/13.0/#sec-importedlocalnames'
	},
	InitializeBoundName: {
		url: 'https://262.ecma-international.org/13.0/#sec-initializeboundname'
	},
	InitializeHostDefinedRealm: {
		url: 'https://262.ecma-international.org/13.0/#sec-initializehostdefinedrealm'
	},
	InitializeInstanceElements: {
		url: 'https://262.ecma-international.org/13.0/#sec-initializeinstanceelements'
	},
	InitializeReferencedBinding: {
		url: 'https://262.ecma-international.org/13.0/#sec-initializereferencedbinding'
	},
	InitializeTypedArrayFromArrayBuffer: {
		url: 'https://262.ecma-international.org/13.0/#sec-initializetypedarrayfromarraybuffer'
	},
	InitializeTypedArrayFromArrayLike: {
		url: 'https://262.ecma-international.org/13.0/#sec-initializetypedarrayfromarraylike'
	},
	InitializeTypedArrayFromList: {
		url: 'https://262.ecma-international.org/13.0/#sec-initializetypedarrayfromlist'
	},
	InitializeTypedArrayFromTypedArray: {
		url: 'https://262.ecma-international.org/13.0/#sec-initializetypedarrayfromtypedarray'
	},
	InLeapYear: {
		url: 'https://262.ecma-international.org/13.0/#eqn-InLeapYear'
	},
	InnerModuleEvaluation: {
		url: 'https://262.ecma-international.org/13.0/#sec-innermoduleevaluation'
	},
	InnerModuleLinking: {
		url: 'https://262.ecma-international.org/13.0/#sec-InnerModuleLinking'
	},
	InstallErrorCause: {
		url: 'https://262.ecma-international.org/13.0/#sec-installerrorcause'
	},
	InstanceofOperator: {
		url: 'https://262.ecma-international.org/13.0/#sec-instanceofoperator'
	},
	IntegerIndexedElementGet: {
		url: 'https://262.ecma-international.org/13.0/#sec-integerindexedelementget'
	},
	IntegerIndexedElementSet: {
		url: 'https://262.ecma-international.org/13.0/#sec-integerindexedelementset'
	},
	IntegerIndexedObjectCreate: {
		url: 'https://262.ecma-international.org/13.0/#sec-integerindexedobjectcreate'
	},
	InternalizeJSONProperty: {
		url: 'https://262.ecma-international.org/13.0/#sec-internalizejsonproperty'
	},
	Invoke: {
		url: 'https://262.ecma-international.org/13.0/#sec-invoke'
	},
	IsAccessorDescriptor: {
		url: 'https://262.ecma-international.org/13.0/#sec-isaccessordescriptor'
	},
	IsAnonymousFunctionDefinition: {
		url: 'https://262.ecma-international.org/13.0/#sec-isanonymousfunctiondefinition'
	},
	IsArray: {
		url: 'https://262.ecma-international.org/13.0/#sec-isarray'
	},
	IsBigIntElementType: {
		url: 'https://262.ecma-international.org/13.0/#sec-isbigintelementtype'
	},
	IsCallable: {
		url: 'https://262.ecma-international.org/13.0/#sec-iscallable'
	},
	IsCompatiblePropertyDescriptor: {
		url: 'https://262.ecma-international.org/13.0/#sec-iscompatiblepropertydescriptor'
	},
	IsConcatSpreadable: {
		url: 'https://262.ecma-international.org/13.0/#sec-isconcatspreadable'
	},
	IsConstructor: {
		url: 'https://262.ecma-international.org/13.0/#sec-isconstructor'
	},
	IsDataDescriptor: {
		url: 'https://262.ecma-international.org/13.0/#sec-isdatadescriptor'
	},
	IsDetachedBuffer: {
		url: 'https://262.ecma-international.org/13.0/#sec-isdetachedbuffer'
	},
	IsExtensible: {
		url: 'https://262.ecma-international.org/13.0/#sec-isextensible-o'
	},
	IsGenericDescriptor: {
		url: 'https://262.ecma-international.org/13.0/#sec-isgenericdescriptor'
	},
	IsInTailPosition: {
		url: 'https://262.ecma-international.org/13.0/#sec-isintailposition'
	},
	IsIntegralNumber: {
		url: 'https://262.ecma-international.org/13.0/#sec-isintegralnumber'
	},
	IsLabelledFunction: {
		url: 'https://262.ecma-international.org/13.0/#sec-islabelledfunction'
	},
	IsLessThan: {
		url: 'https://262.ecma-international.org/13.0/#sec-islessthan'
	},
	IsLooselyEqual: {
		url: 'https://262.ecma-international.org/13.0/#sec-islooselyequal'
	},
	IsNoTearConfiguration: {
		url: 'https://262.ecma-international.org/13.0/#sec-isnotearconfiguration'
	},
	IsPrivateReference: {
		url: 'https://262.ecma-international.org/13.0/#sec-isprivatereference'
	},
	IsPromise: {
		url: 'https://262.ecma-international.org/13.0/#sec-ispromise'
	},
	IsPropertyKey: {
		url: 'https://262.ecma-international.org/13.0/#sec-ispropertykey'
	},
	IsPropertyReference: {
		url: 'https://262.ecma-international.org/13.0/#sec-ispropertyreference'
	},
	IsRegExp: {
		url: 'https://262.ecma-international.org/13.0/#sec-isregexp'
	},
	IsSharedArrayBuffer: {
		url: 'https://262.ecma-international.org/13.0/#sec-issharedarraybuffer'
	},
	IsStrictlyEqual: {
		url: 'https://262.ecma-international.org/13.0/#sec-isstrictlyequal'
	},
	IsStringPrefix: {
		url: 'https://262.ecma-international.org/13.0/#sec-isstringprefix'
	},
	IsStringWellFormedUnicode: {
		url: 'https://262.ecma-international.org/13.0/#sec-isstringwellformedunicode'
	},
	IsSuperReference: {
		url: 'https://262.ecma-international.org/13.0/#sec-issuperreference'
	},
	IsUnclampedIntegerElementType: {
		url: 'https://262.ecma-international.org/13.0/#sec-isunclampedintegerelementtype'
	},
	IsUnresolvableReference: {
		url: 'https://262.ecma-international.org/13.0/#sec-isunresolvablereference'
	},
	IsUnsignedElementType: {
		url: 'https://262.ecma-international.org/13.0/#sec-isunsignedelementtype'
	},
	IsValidIntegerIndex: {
		url: 'https://262.ecma-international.org/13.0/#sec-isvalidintegerindex'
	},
	IsValidRegularExpressionLiteral: {
		url: 'https://262.ecma-international.org/13.0/#sec-isvalidregularexpressionliteral'
	},
	IsWordChar: {
		url: 'https://262.ecma-international.org/13.0/#sec-runtime-semantics-iswordchar-abstract-operation'
	},
	IterableToList: {
		url: 'https://262.ecma-international.org/13.0/#sec-iterabletolist'
	},
	IteratorClose: {
		url: 'https://262.ecma-international.org/13.0/#sec-iteratorclose'
	},
	IteratorComplete: {
		url: 'https://262.ecma-international.org/13.0/#sec-iteratorcomplete'
	},
	IteratorNext: {
		url: 'https://262.ecma-international.org/13.0/#sec-iteratornext'
	},
	IteratorStep: {
		url: 'https://262.ecma-international.org/13.0/#sec-iteratorstep'
	},
	IteratorValue: {
		url: 'https://262.ecma-international.org/13.0/#sec-iteratorvalue'
	},
	LeaveCriticalSection: {
		url: 'https://262.ecma-international.org/13.0/#sec-leavecriticalsection'
	},
	LengthOfArrayLike: {
		url: 'https://262.ecma-international.org/13.0/#sec-lengthofarraylike'
	},
	LocalTime: {
		url: 'https://262.ecma-international.org/13.0/#sec-localtime'
	},
	LocalTZA: {
		url: 'https://262.ecma-international.org/13.0/#sec-local-time-zone-adjustment'
	},
	LoopContinues: {
		url: 'https://262.ecma-international.org/13.0/#sec-loopcontinues'
	},
	MakeArgGetter: {
		url: 'https://262.ecma-international.org/13.0/#sec-makearggetter'
	},
	MakeArgSetter: {
		url: 'https://262.ecma-international.org/13.0/#sec-makeargsetter'
	},
	MakeBasicObject: {
		url: 'https://262.ecma-international.org/13.0/#sec-makebasicobject'
	},
	MakeClassConstructor: {
		url: 'https://262.ecma-international.org/13.0/#sec-makeclassconstructor'
	},
	MakeConstructor: {
		url: 'https://262.ecma-international.org/13.0/#sec-makeconstructor'
	},
	MakeDate: {
		url: 'https://262.ecma-international.org/13.0/#sec-makedate'
	},
	MakeDay: {
		url: 'https://262.ecma-international.org/13.0/#sec-makeday'
	},
	MakeMatchIndicesIndexPairArray: {
		url: 'https://262.ecma-international.org/13.0/#sec-makematchindicesindexpairarray'
	},
	MakeMethod: {
		url: 'https://262.ecma-international.org/13.0/#sec-makemethod'
	},
	MakePrivateReference: {
		url: 'https://262.ecma-international.org/13.0/#sec-makeprivatereference'
	},
	MakeSuperPropertyReference: {
		url: 'https://262.ecma-international.org/13.0/#sec-makesuperpropertyreference'
	},
	MakeTime: {
		url: 'https://262.ecma-international.org/13.0/#sec-maketime'
	},
	max: {
		url: 'https://262.ecma-international.org/13.0/#eqn-max'
	},
	'memory-order': {
		url: 'https://262.ecma-international.org/13.0/#sec-memory-order'
	},
	min: {
		url: 'https://262.ecma-international.org/13.0/#eqn-min'
	},
	MinFromTime: {
		url: 'https://262.ecma-international.org/13.0/#eqn-MinFromTime'
	},
	ModuleNamespaceCreate: {
		url: 'https://262.ecma-international.org/13.0/#sec-modulenamespacecreate'
	},
	modulo: {
		url: 'https://262.ecma-international.org/13.0/#eqn-modulo'
	},
	MonthFromTime: {
		url: 'https://262.ecma-international.org/13.0/#eqn-MonthFromTime'
	},
	msFromTime: {
		url: 'https://262.ecma-international.org/13.0/#eqn-msFromTime'
	},
	NewDeclarativeEnvironment: {
		url: 'https://262.ecma-international.org/13.0/#sec-newdeclarativeenvironment'
	},
	NewFunctionEnvironment: {
		url: 'https://262.ecma-international.org/13.0/#sec-newfunctionenvironment'
	},
	NewGlobalEnvironment: {
		url: 'https://262.ecma-international.org/13.0/#sec-newglobalenvironment'
	},
	NewModuleEnvironment: {
		url: 'https://262.ecma-international.org/13.0/#sec-newmoduleenvironment'
	},
	NewObjectEnvironment: {
		url: 'https://262.ecma-international.org/13.0/#sec-newobjectenvironment'
	},
	NewPrivateEnvironment: {
		url: 'https://262.ecma-international.org/13.0/#sec-newprivateenvironment'
	},
	NewPromiseCapability: {
		url: 'https://262.ecma-international.org/13.0/#sec-newpromisecapability'
	},
	NewPromiseReactionJob: {
		url: 'https://262.ecma-international.org/13.0/#sec-newpromisereactionjob'
	},
	NewPromiseResolveThenableJob: {
		url: 'https://262.ecma-international.org/13.0/#sec-newpromiseresolvethenablejob'
	},
	NormalCompletion: {
		url: 'https://262.ecma-international.org/13.0/#sec-normalcompletion'
	},
	NotifyWaiter: {
		url: 'https://262.ecma-international.org/13.0/#sec-notifywaiter'
	},
	'Number::add': {
		url: 'https://262.ecma-international.org/13.0/#sec-numeric-types-number-add'
	},
	'Number::bitwiseAND': {
		url: 'https://262.ecma-international.org/13.0/#sec-numeric-types-number-bitwiseAND'
	},
	'Number::bitwiseNOT': {
		url: 'https://262.ecma-international.org/13.0/#sec-numeric-types-number-bitwiseNOT'
	},
	'Number::bitwiseOR': {
		url: 'https://262.ecma-international.org/13.0/#sec-numeric-types-number-bitwiseOR'
	},
	'Number::bitwiseXOR': {
		url: 'https://262.ecma-international.org/13.0/#sec-numeric-types-number-bitwiseXOR'
	},
	'Number::divide': {
		url: 'https://262.ecma-international.org/13.0/#sec-numeric-types-number-divide'
	},
	'Number::equal': {
		url: 'https://262.ecma-international.org/13.0/#sec-numeric-types-number-equal'
	},
	'Number::exponentiate': {
		url: 'https://262.ecma-international.org/13.0/#sec-numeric-types-number-exponentiate'
	},
	'Number::leftShift': {
		url: 'https://262.ecma-international.org/13.0/#sec-numeric-types-number-leftShift'
	},
	'Number::lessThan': {
		url: 'https://262.ecma-international.org/13.0/#sec-numeric-types-number-lessThan'
	},
	'Number::multiply': {
		url: 'https://262.ecma-international.org/13.0/#sec-numeric-types-number-multiply'
	},
	'Number::remainder': {
		url: 'https://262.ecma-international.org/13.0/#sec-numeric-types-number-remainder'
	},
	'Number::sameValue': {
		url: 'https://262.ecma-international.org/13.0/#sec-numeric-types-number-sameValue'
	},
	'Number::sameValueZero': {
		url: 'https://262.ecma-international.org/13.0/#sec-numeric-types-number-sameValueZero'
	},
	'Number::signedRightShift': {
		url: 'https://262.ecma-international.org/13.0/#sec-numeric-types-number-signedRightShift'
	},
	'Number::subtract': {
		url: 'https://262.ecma-international.org/13.0/#sec-numeric-types-number-subtract'
	},
	'Number::toString': {
		url: 'https://262.ecma-international.org/13.0/#sec-numeric-types-number-tostring'
	},
	'Number::unaryMinus': {
		url: 'https://262.ecma-international.org/13.0/#sec-numeric-types-number-unaryMinus'
	},
	'Number::unsignedRightShift': {
		url: 'https://262.ecma-international.org/13.0/#sec-numeric-types-number-unsignedRightShift'
	},
	NumberBitwiseOp: {
		url: 'https://262.ecma-international.org/13.0/#sec-numberbitwiseop'
	},
	NumberToBigInt: {
		url: 'https://262.ecma-international.org/13.0/#sec-numbertobigint'
	},
	NumericToRawBytes: {
		url: 'https://262.ecma-international.org/13.0/#sec-numerictorawbytes'
	},
	ObjectDefineProperties: {
		url: 'https://262.ecma-international.org/13.0/#sec-objectdefineproperties'
	},
	OrdinaryCallBindThis: {
		url: 'https://262.ecma-international.org/13.0/#sec-ordinarycallbindthis'
	},
	OrdinaryCallEvaluateBody: {
		url: 'https://262.ecma-international.org/13.0/#sec-ordinarycallevaluatebody'
	},
	OrdinaryCreateFromConstructor: {
		url: 'https://262.ecma-international.org/13.0/#sec-ordinarycreatefromconstructor'
	},
	OrdinaryDefineOwnProperty: {
		url: 'https://262.ecma-international.org/13.0/#sec-ordinarydefineownproperty'
	},
	OrdinaryDelete: {
		url: 'https://262.ecma-international.org/13.0/#sec-ordinarydelete'
	},
	OrdinaryFunctionCreate: {
		url: 'https://262.ecma-international.org/13.0/#sec-ordinaryfunctioncreate'
	},
	OrdinaryGet: {
		url: 'https://262.ecma-international.org/13.0/#sec-ordinaryget'
	},
	OrdinaryGetOwnProperty: {
		url: 'https://262.ecma-international.org/13.0/#sec-ordinarygetownproperty'
	},
	OrdinaryGetPrototypeOf: {
		url: 'https://262.ecma-international.org/13.0/#sec-ordinarygetprototypeof'
	},
	OrdinaryHasInstance: {
		url: 'https://262.ecma-international.org/13.0/#sec-ordinaryhasinstance'
	},
	OrdinaryHasProperty: {
		url: 'https://262.ecma-international.org/13.0/#sec-ordinaryhasproperty'
	},
	OrdinaryIsExtensible: {
		url: 'https://262.ecma-international.org/13.0/#sec-ordinaryisextensible'
	},
	OrdinaryObjectCreate: {
		url: 'https://262.ecma-international.org/13.0/#sec-ordinaryobjectcreate'
	},
	OrdinaryOwnPropertyKeys: {
		url: 'https://262.ecma-international.org/13.0/#sec-ordinaryownpropertykeys'
	},
	OrdinaryPreventExtensions: {
		url: 'https://262.ecma-international.org/13.0/#sec-ordinarypreventextensions'
	},
	OrdinarySet: {
		url: 'https://262.ecma-international.org/13.0/#sec-ordinaryset'
	},
	OrdinarySetPrototypeOf: {
		url: 'https://262.ecma-international.org/13.0/#sec-ordinarysetprototypeof'
	},
	OrdinarySetWithOwnDescriptor: {
		url: 'https://262.ecma-international.org/13.0/#sec-ordinarysetwithowndescriptor'
	},
	OrdinaryToPrimitive: {
		url: 'https://262.ecma-international.org/13.0/#sec-ordinarytoprimitive'
	},
	ParseModule: {
		url: 'https://262.ecma-international.org/13.0/#sec-parsemodule'
	},
	ParsePattern: {
		url: 'https://262.ecma-international.org/13.0/#sec-parsepattern'
	},
	ParseScript: {
		url: 'https://262.ecma-international.org/13.0/#sec-parse-script'
	},
	ParseText: {
		url: 'https://262.ecma-international.org/13.0/#sec-parsetext'
	},
	PerformEval: {
		url: 'https://262.ecma-international.org/13.0/#sec-performeval'
	},
	PerformPromiseAll: {
		url: 'https://262.ecma-international.org/13.0/#sec-performpromiseall'
	},
	PerformPromiseAllSettled: {
		url: 'https://262.ecma-international.org/13.0/#sec-performpromiseallsettled'
	},
	PerformPromiseAny: {
		url: 'https://262.ecma-international.org/13.0/#sec-performpromiseany'
	},
	PerformPromiseRace: {
		url: 'https://262.ecma-international.org/13.0/#sec-performpromiserace'
	},
	PerformPromiseThen: {
		url: 'https://262.ecma-international.org/13.0/#sec-performpromisethen'
	},
	PrepareForOrdinaryCall: {
		url: 'https://262.ecma-international.org/13.0/#sec-prepareforordinarycall'
	},
	PrepareForTailCall: {
		url: 'https://262.ecma-international.org/13.0/#sec-preparefortailcall'
	},
	PrivateElementFind: {
		url: 'https://262.ecma-international.org/13.0/#sec-privateelementfind'
	},
	PrivateFieldAdd: {
		url: 'https://262.ecma-international.org/13.0/#sec-privatefieldadd'
	},
	PrivateGet: {
		url: 'https://262.ecma-international.org/13.0/#sec-privateget'
	},
	PrivateMethodOrAccessorAdd: {
		url: 'https://262.ecma-international.org/13.0/#sec-privatemethodoraccessoradd'
	},
	PrivateSet: {
		url: 'https://262.ecma-international.org/13.0/#sec-privateset'
	},
	PromiseResolve: {
		url: 'https://262.ecma-international.org/13.0/#sec-promise-resolve'
	},
	ProxyCreate: {
		url: 'https://262.ecma-international.org/13.0/#sec-proxycreate'
	},
	PutValue: {
		url: 'https://262.ecma-international.org/13.0/#sec-putvalue'
	},
	QuoteJSONString: {
		url: 'https://262.ecma-international.org/13.0/#sec-quotejsonstring'
	},
	RawBytesToNumeric: {
		url: 'https://262.ecma-international.org/13.0/#sec-rawbytestonumeric'
	},
	'reads-bytes-from': {
		url: 'https://262.ecma-international.org/13.0/#sec-reads-bytes-from'
	},
	'reads-from': {
		url: 'https://262.ecma-international.org/13.0/#sec-reads-from'
	},
	RegExpAlloc: {
		url: 'https://262.ecma-international.org/13.0/#sec-regexpalloc'
	},
	RegExpBuiltinExec: {
		url: 'https://262.ecma-international.org/13.0/#sec-regexpbuiltinexec'
	},
	RegExpCreate: {
		url: 'https://262.ecma-international.org/13.0/#sec-regexpcreate'
	},
	RegExpExec: {
		url: 'https://262.ecma-international.org/13.0/#sec-regexpexec'
	},
	RegExpHasFlag: {
		url: 'https://262.ecma-international.org/13.0/#sec-regexphasflag'
	},
	RegExpInitialize: {
		url: 'https://262.ecma-international.org/13.0/#sec-regexpinitialize'
	},
	RejectPromise: {
		url: 'https://262.ecma-international.org/13.0/#sec-rejectpromise'
	},
	RemoveWaiter: {
		url: 'https://262.ecma-international.org/13.0/#sec-removewaiter'
	},
	RemoveWaiters: {
		url: 'https://262.ecma-international.org/13.0/#sec-removewaiters'
	},
	RepeatMatcher: {
		url: 'https://262.ecma-international.org/13.0/#sec-runtime-semantics-repeatmatcher-abstract-operation'
	},
	RequireInternalSlot: {
		url: 'https://262.ecma-international.org/13.0/#sec-requireinternalslot'
	},
	RequireObjectCoercible: {
		url: 'https://262.ecma-international.org/13.0/#sec-requireobjectcoercible'
	},
	ResolveBinding: {
		url: 'https://262.ecma-international.org/13.0/#sec-resolvebinding'
	},
	ResolvePrivateIdentifier: {
		url: 'https://262.ecma-international.org/13.0/#sec-resolve-private-identifier'
	},
	ResolveThisBinding: {
		url: 'https://262.ecma-international.org/13.0/#sec-resolvethisbinding'
	},
	ReturnIfAbrupt: {
		url: 'https://262.ecma-international.org/13.0/#sec-returnifabrupt'
	},
	RoundMVResult: {
		url: 'https://262.ecma-international.org/13.0/#sec-roundmvresult'
	},
	SameValue: {
		url: 'https://262.ecma-international.org/13.0/#sec-samevalue'
	},
	SameValueNonNumeric: {
		url: 'https://262.ecma-international.org/13.0/#sec-samevaluenonnumeric'
	},
	SameValueZero: {
		url: 'https://262.ecma-international.org/13.0/#sec-samevaluezero'
	},
	ScriptEvaluation: {
		url: 'https://262.ecma-international.org/13.0/#sec-runtime-semantics-scriptevaluation'
	},
	SecFromTime: {
		url: 'https://262.ecma-international.org/13.0/#eqn-SecFromTime'
	},
	SerializeJSONArray: {
		url: 'https://262.ecma-international.org/13.0/#sec-serializejsonarray'
	},
	SerializeJSONObject: {
		url: 'https://262.ecma-international.org/13.0/#sec-serializejsonobject'
	},
	SerializeJSONProperty: {
		url: 'https://262.ecma-international.org/13.0/#sec-serializejsonproperty'
	},
	Set: {
		url: 'https://262.ecma-international.org/13.0/#sec-set-o-p-v-throw'
	},
	SetDefaultGlobalBindings: {
		url: 'https://262.ecma-international.org/13.0/#sec-setdefaultglobalbindings'
	},
	SetFunctionLength: {
		url: 'https://262.ecma-international.org/13.0/#sec-setfunctionlength'
	},
	SetFunctionName: {
		url: 'https://262.ecma-international.org/13.0/#sec-setfunctionname'
	},
	SetImmutablePrototype: {
		url: 'https://262.ecma-international.org/13.0/#sec-set-immutable-prototype'
	},
	SetIntegrityLevel: {
		url: 'https://262.ecma-international.org/13.0/#sec-setintegritylevel'
	},
	SetRealmGlobalObject: {
		url: 'https://262.ecma-international.org/13.0/#sec-setrealmglobalobject'
	},
	SetTypedArrayFromArrayLike: {
		url: 'https://262.ecma-international.org/13.0/#sec-settypedarrayfromarraylike'
	},
	SetTypedArrayFromTypedArray: {
		url: 'https://262.ecma-international.org/13.0/#sec-settypedarrayfromtypedarray'
	},
	SetValueInBuffer: {
		url: 'https://262.ecma-international.org/13.0/#sec-setvalueinbuffer'
	},
	SetViewValue: {
		url: 'https://262.ecma-international.org/13.0/#sec-setviewvalue'
	},
	SharedDataBlockEventSet: {
		url: 'https://262.ecma-international.org/13.0/#sec-sharedatablockeventset'
	},
	SortIndexedProperties: {
		url: 'https://262.ecma-international.org/13.0/#sec-sortindexedproperties'
	},
	SpeciesConstructor: {
		url: 'https://262.ecma-international.org/13.0/#sec-speciesconstructor'
	},
	StringCreate: {
		url: 'https://262.ecma-international.org/13.0/#sec-stringcreate'
	},
	StringGetOwnProperty: {
		url: 'https://262.ecma-international.org/13.0/#sec-stringgetownproperty'
	},
	StringIndexOf: {
		url: 'https://262.ecma-international.org/13.0/#sec-stringindexof'
	},
	StringPad: {
		url: 'https://262.ecma-international.org/13.0/#sec-stringpad'
	},
	StringToBigInt: {
		url: 'https://262.ecma-international.org/13.0/#sec-stringtobigint'
	},
	StringToCodePoints: {
		url: 'https://262.ecma-international.org/13.0/#sec-stringtocodepoints'
	},
	StringToNumber: {
		url: 'https://262.ecma-international.org/13.0/#sec-stringtonumber'
	},
	substring: {
		url: 'https://262.ecma-international.org/13.0/#substring'
	},
	SuspendAgent: {
		url: 'https://262.ecma-international.org/13.0/#sec-suspendagent'
	},
	SymbolDescriptiveString: {
		url: 'https://262.ecma-international.org/13.0/#sec-symboldescriptivestring'
	},
	'synchronizes-with': {
		url: 'https://262.ecma-international.org/13.0/#sec-synchronizes-with'
	},
	TestIntegrityLevel: {
		url: 'https://262.ecma-international.org/13.0/#sec-testintegritylevel'
	},
	thisBigIntValue: {
		url: 'https://262.ecma-international.org/13.0/#thisbigintvalue'
	},
	thisBooleanValue: {
		url: 'https://262.ecma-international.org/13.0/#thisbooleanvalue'
	},
	thisNumberValue: {
		url: 'https://262.ecma-international.org/13.0/#thisnumbervalue'
	},
	thisStringValue: {
		url: 'https://262.ecma-international.org/13.0/#thisstringvalue'
	},
	thisSymbolValue: {
		url: 'https://262.ecma-international.org/13.0/#thissymbolvalue'
	},
	thisTimeValue: {
		url: 'https://262.ecma-international.org/13.0/#thistimevalue'
	},
	ThrowCompletion: {
		url: 'https://262.ecma-international.org/13.0/#sec-throwcompletion'
	},
	TimeClip: {
		url: 'https://262.ecma-international.org/13.0/#sec-timeclip'
	},
	TimeFromYear: {
		url: 'https://262.ecma-international.org/13.0/#eqn-TimeFromYear'
	},
	TimeString: {
		url: 'https://262.ecma-international.org/13.0/#sec-timestring'
	},
	TimeWithinDay: {
		url: 'https://262.ecma-international.org/13.0/#eqn-TimeWithinDay'
	},
	TimeZoneString: {
		url: 'https://262.ecma-international.org/13.0/#sec-timezoneestring'
	},
	ToBigInt: {
		url: 'https://262.ecma-international.org/13.0/#sec-tobigint'
	},
	ToBigInt64: {
		url: 'https://262.ecma-international.org/13.0/#sec-tobigint64'
	},
	ToBigUint64: {
		url: 'https://262.ecma-international.org/13.0/#sec-tobiguint64'
	},
	ToBoolean: {
		url: 'https://262.ecma-international.org/13.0/#sec-toboolean'
	},
	ToDateString: {
		url: 'https://262.ecma-international.org/13.0/#sec-todatestring'
	},
	ToIndex: {
		url: 'https://262.ecma-international.org/13.0/#sec-toindex'
	},
	ToInt16: {
		url: 'https://262.ecma-international.org/13.0/#sec-toint16'
	},
	ToInt32: {
		url: 'https://262.ecma-international.org/13.0/#sec-toint32'
	},
	ToInt8: {
		url: 'https://262.ecma-international.org/13.0/#sec-toint8'
	},
	ToIntegerOrInfinity: {
		url: 'https://262.ecma-international.org/13.0/#sec-tointegerorinfinity'
	},
	ToLength: {
		url: 'https://262.ecma-international.org/13.0/#sec-tolength'
	},
	ToNumber: {
		url: 'https://262.ecma-international.org/13.0/#sec-tonumber'
	},
	ToNumeric: {
		url: 'https://262.ecma-international.org/13.0/#sec-tonumeric'
	},
	ToObject: {
		url: 'https://262.ecma-international.org/13.0/#sec-toobject'
	},
	ToPrimitive: {
		url: 'https://262.ecma-international.org/13.0/#sec-toprimitive'
	},
	ToPropertyDescriptor: {
		url: 'https://262.ecma-international.org/13.0/#sec-topropertydescriptor'
	},
	ToPropertyKey: {
		url: 'https://262.ecma-international.org/13.0/#sec-topropertykey'
	},
	ToString: {
		url: 'https://262.ecma-international.org/13.0/#sec-tostring'
	},
	ToUint16: {
		url: 'https://262.ecma-international.org/13.0/#sec-touint16'
	},
	ToUint32: {
		url: 'https://262.ecma-international.org/13.0/#sec-touint32'
	},
	ToUint8: {
		url: 'https://262.ecma-international.org/13.0/#sec-touint8'
	},
	ToUint8Clamp: {
		url: 'https://262.ecma-international.org/13.0/#sec-touint8clamp'
	},
	ToZeroPaddedDecimalString: {
		url: 'https://262.ecma-international.org/13.0/#sec-tozeropaddeddecimalstring'
	},
	TriggerPromiseReactions: {
		url: 'https://262.ecma-international.org/13.0/#sec-triggerpromisereactions'
	},
	TrimString: {
		url: 'https://262.ecma-international.org/13.0/#sec-trimstring'
	},
	Type: {
		url: 'https://262.ecma-international.org/13.0/#sec-ecmascript-data-types-and-values'
	},
	TypedArrayCreate: {
		url: 'https://262.ecma-international.org/13.0/#typedarray-create'
	},
	TypedArrayElementSize: {
		url: 'https://262.ecma-international.org/13.0/#sec-typedarrayelementsize'
	},
	TypedArrayElementType: {
		url: 'https://262.ecma-international.org/13.0/#sec-typedarrayelementtype'
	},
	TypedArraySpeciesCreate: {
		url: 'https://262.ecma-international.org/13.0/#typedarray-species-create'
	},
	UnicodeEscape: {
		url: 'https://262.ecma-international.org/13.0/#sec-unicodeescape'
	},
	UnicodeMatchProperty: {
		url: 'https://262.ecma-international.org/13.0/#sec-runtime-semantics-unicodematchproperty-p'
	},
	UnicodeMatchPropertyValue: {
		url: 'https://262.ecma-international.org/13.0/#sec-runtime-semantics-unicodematchpropertyvalue-p-v'
	},
	UpdateEmpty: {
		url: 'https://262.ecma-international.org/13.0/#sec-updateempty'
	},
	UTC: {
		url: 'https://262.ecma-international.org/13.0/#sec-utc-t'
	},
	UTF16EncodeCodePoint: {
		url: 'https://262.ecma-international.org/13.0/#sec-utf16encodecodepoint'
	},
	UTF16SurrogatePairToCodePoint: {
		url: 'https://262.ecma-international.org/13.0/#sec-utf16decodesurrogatepair'
	},
	ValidateAndApplyPropertyDescriptor: {
		url: 'https://262.ecma-international.org/13.0/#sec-validateandapplypropertydescriptor'
	},
	ValidateAtomicAccess: {
		url: 'https://262.ecma-international.org/13.0/#sec-validateatomicaccess'
	},
	ValidateIntegerTypedArray: {
		url: 'https://262.ecma-international.org/13.0/#sec-validateintegertypedarray'
	},
	ValidateTypedArray: {
		url: 'https://262.ecma-international.org/13.0/#sec-validatetypedarray'
	},
	ValueOfReadEvent: {
		url: 'https://262.ecma-international.org/13.0/#sec-valueofreadevent'
	},
	WeakRefDeref: {
		url: 'https://262.ecma-international.org/13.0/#sec-weakrefderef'
	},
	WeekDay: {
		url: 'https://262.ecma-international.org/13.0/#sec-week-day'
	},
	WordCharacters: {
		url: 'https://262.ecma-international.org/13.0/#sec-runtime-semantics-wordcharacters-abstract-operation'
	},
	YearFromTime: {
		url: 'https://262.ecma-international.org/13.0/#eqn-YearFromTime'
	},
	Yield: {
		url: 'https://262.ecma-international.org/13.0/#sec-yield'
	}
};
'use strict';

module.exports = {
	abs: {
		url: 'https://262.ecma-international.org/14.0/#eqn-abs'
	},
	AddEntriesFromIterable: {
		url: 'https://262.ecma-international.org/14.0/#sec-add-entries-from-iterable'
	},
	AddRestrictedFunctionProperties: {
		url: 'https://262.ecma-international.org/14.0/#sec-addrestrictedfunctionproperties'
	},
	AddToKeptObjects: {
		url: 'https://262.ecma-international.org/14.0/#sec-addtokeptobjects'
	},
	AddWaiter: {
		url: 'https://262.ecma-international.org/14.0/#sec-addwaiter'
	},
	AdvanceStringIndex: {
		url: 'https://262.ecma-international.org/14.0/#sec-advancestringindex'
	},
	'agent-order': {
		url: 'https://262.ecma-international.org/14.0/#sec-agent-order'
	},
	AgentCanSuspend: {
		url: 'https://262.ecma-international.org/14.0/#sec-agentcansuspend'
	},
	AgentSignifier: {
		url: 'https://262.ecma-international.org/14.0/#sec-agentsignifier'
	},
	AllocateArrayBuffer: {
		url: 'https://262.ecma-international.org/14.0/#sec-allocatearraybuffer'
	},
	AllocateSharedArrayBuffer: {
		url: 'https://262.ecma-international.org/14.0/#sec-allocatesharedarraybuffer'
	},
	AllocateTypedArray: {
		url: 'https://262.ecma-international.org/14.0/#sec-allocatetypedarray'
	},
	AllocateTypedArrayBuffer: {
		url: 'https://262.ecma-international.org/14.0/#sec-allocatetypedarraybuffer'
	},
	ApplyStringOrNumericBinaryOperator: {
		url: 'https://262.ecma-international.org/14.0/#sec-applystringornumericbinaryoperator'
	},
	ArrayCreate: {
		url: 'https://262.ecma-international.org/14.0/#sec-arraycreate'
	},
	ArraySetLength: {
		url: 'https://262.ecma-international.org/14.0/#sec-arraysetlength'
	},
	ArraySpeciesCreate: {
		url: 'https://262.ecma-international.org/14.0/#sec-arrayspeciescreate'
	},
	AsyncBlockStart: {
		url: 'https://262.ecma-international.org/14.0/#sec-asyncblockstart'
	},
	AsyncFromSyncIteratorContinuation: {
		url: 'https://262.ecma-international.org/14.0/#sec-asyncfromsynciteratorcontinuation'
	},
	AsyncFunctionStart: {
		url: 'https://262.ecma-international.org/14.0/#sec-async-functions-abstract-operations-async-function-start'
	},
	AsyncGeneratorAwaitReturn: {
		url: 'https://262.ecma-international.org/14.0/#sec-asyncgeneratorawaitreturn'
	},
	AsyncGeneratorCompleteStep: {
		url: 'https://262.ecma-international.org/14.0/#sec-asyncgeneratorcompletestep'
	},
	AsyncGeneratorDrainQueue: {
		url: 'https://262.ecma-international.org/14.0/#sec-asyncgeneratordrainqueue'
	},
	AsyncGeneratorEnqueue: {
		url: 'https://262.ecma-international.org/14.0/#sec-asyncgeneratorenqueue'
	},
	AsyncGeneratorResume: {
		url: 'https://262.ecma-international.org/14.0/#sec-asyncgeneratorresume'
	},
	AsyncGeneratorStart: {
		url: 'https://262.ecma-international.org/14.0/#sec-asyncgeneratorstart'
	},
	AsyncGeneratorUnwrapYieldResumption: {
		url: 'https://262.ecma-international.org/14.0/#sec-asyncgeneratorunwrapyieldresumption'
	},
	AsyncGeneratorValidate: {
		url: 'https://262.ecma-international.org/14.0/#sec-asyncgeneratorvalidate'
	},
	AsyncGeneratorYield: {
		url: 'https://262.ecma-international.org/14.0/#sec-asyncgeneratoryield'
	},
	AsyncIteratorClose: {
		url: 'https://262.ecma-international.org/14.0/#sec-asynciteratorclose'
	},
	AsyncModuleExecutionFulfilled: {
		url: 'https://262.ecma-international.org/14.0/#sec-async-module-execution-fulfilled'
	},
	AsyncModuleExecutionRejected: {
		url: 'https://262.ecma-international.org/14.0/#sec-async-module-execution-rejected'
	},
	AtomicReadModifyWrite: {
		url: 'https://262.ecma-international.org/14.0/#sec-atomicreadmodifywrite'
	},
	Await: {
		url: 'https://262.ecma-international.org/14.0/#await'
	},
	BackreferenceMatcher: {
		url: 'https://262.ecma-international.org/14.0/#sec-backreference-matcher'
	},
	'BigInt::add': {
		url: 'https://262.ecma-international.org/14.0/#sec-numeric-types-bigint-add'
	},
	'BigInt::bitwiseAND': {
		url: 'https://262.ecma-international.org/14.0/#sec-numeric-types-bigint-bitwiseAND'
	},
	'BigInt::bitwiseNOT': {
		url: 'https://262.ecma-international.org/14.0/#sec-numeric-types-bigint-bitwiseNOT'
	},
	'BigInt::bitwiseOR': {
		url: 'https://262.ecma-international.org/14.0/#sec-numeric-types-bigint-bitwiseOR'
	},
	'BigInt::bitwiseXOR': {
		url: 'https://262.ecma-international.org/14.0/#sec-numeric-types-bigint-bitwiseXOR'
	},
	'BigInt::divide': {
		url: 'https://262.ecma-international.org/14.0/#sec-numeric-types-bigint-divide'
	},
	'BigInt::equal': {
		url: 'https://262.ecma-international.org/14.0/#sec-numeric-types-bigint-equal'
	},
	'BigInt::exponentiate': {
		url: 'https://262.ecma-international.org/14.0/#sec-numeric-types-bigint-exponentiate'
	},
	'BigInt::leftShift': {
		url: 'https://262.ecma-international.org/14.0/#sec-numeric-types-bigint-leftShift'
	},
	'BigInt::lessThan': {
		url: 'https://262.ecma-international.org/14.0/#sec-numeric-types-bigint-lessThan'
	},
	'BigInt::multiply': {
		url: 'https://262.ecma-international.org/14.0/#sec-numeric-types-bigint-multiply'
	},
	'BigInt::remainder': {
		url: 'https://262.ecma-international.org/14.0/#sec-numeric-types-bigint-remainder'
	},
	'BigInt::signedRightShift': {
		url: 'https://262.ecma-international.org/14.0/#sec-numeric-types-bigint-signedRightShift'
	},
	'BigInt::subtract': {
		url: 'https://262.ecma-international.org/14.0/#sec-numeric-types-bigint-subtract'
	},
	'BigInt::toString': {
		url: 'https://262.ecma-international.org/14.0/#sec-numeric-types-bigint-tostring'
	},
	'BigInt::unaryMinus': {
		url: 'https://262.ecma-international.org/14.0/#sec-numeric-types-bigint-unaryMinus'
	},
	'BigInt::unsignedRightShift': {
		url: 'https://262.ecma-international.org/14.0/#sec-numeric-types-bigint-unsignedRightShift'
	},
	BigIntBitwiseOp: {
		url: 'https://262.ecma-international.org/14.0/#sec-bigintbitwiseop'
	},
	BinaryAnd: {
		url: 'https://262.ecma-international.org/14.0/#sec-binaryand'
	},
	BinaryOr: {
		url: 'https://262.ecma-international.org/14.0/#sec-binaryor'
	},
	BinaryXor: {
		url: 'https://262.ecma-international.org/14.0/#sec-binaryxor'
	},
	BlockDeclarationInstantiation: {
		url: 'https://262.ecma-international.org/14.0/#sec-blockdeclarationinstantiation'
	},
	BoundFunctionCreate: {
		url: 'https://262.ecma-international.org/14.0/#sec-boundfunctioncreate'
	},
	ByteListBitwiseOp: {
		url: 'https://262.ecma-international.org/14.0/#sec-bytelistbitwiseop'
	},
	ByteListEqual: {
		url: 'https://262.ecma-international.org/14.0/#sec-bytelistequal'
	},
	Call: {
		url: 'https://262.ecma-international.org/14.0/#sec-call'
	},
	CanBeHeldWeakly: {
		url: 'https://262.ecma-international.org/14.0/#sec-canbeheldweakly'
	},
	Canonicalize: {
		url: 'https://262.ecma-international.org/14.0/#sec-runtime-semantics-canonicalize-ch'
	},
	CanonicalNumericIndexString: {
		url: 'https://262.ecma-international.org/14.0/#sec-canonicalnumericindexstring'
	},
	CaseClauseIsSelected: {
		url: 'https://262.ecma-international.org/14.0/#sec-runtime-semantics-caseclauseisselected'
	},
	CharacterRange: {
		url: 'https://262.ecma-international.org/14.0/#sec-runtime-semantics-characterrange-abstract-operation'
	},
	CharacterRangeOrUnion: {
		url: 'https://262.ecma-international.org/14.0/#sec-runtime-semantics-characterrangeorunion-abstract-operation'
	},
	CharacterSetMatcher: {
		url: 'https://262.ecma-international.org/14.0/#sec-runtime-semantics-charactersetmatcher-abstract-operation'
	},
	clamp: {
		url: 'https://262.ecma-international.org/14.0/#clamping'
	},
	CleanupFinalizationRegistry: {
		url: 'https://262.ecma-international.org/14.0/#sec-cleanup-finalization-registry'
	},
	ClearKeptObjects: {
		url: 'https://262.ecma-international.org/14.0/#sec-clear-kept-objects'
	},
	CloneArrayBuffer: {
		url: 'https://262.ecma-international.org/14.0/#sec-clonearraybuffer'
	},
	CodePointAt: {
		url: 'https://262.ecma-international.org/14.0/#sec-codepointat'
	},
	CodePointsToString: {
		url: 'https://262.ecma-international.org/14.0/#sec-codepointstostring'
	},
	CompareArrayElements: {
		url: 'https://262.ecma-international.org/14.0/#sec-comparearrayelements'
	},
	CompareTypedArrayElements: {
		url: 'https://262.ecma-international.org/14.0/#sec-comparetypedarrayelements'
	},
	CompletePropertyDescriptor: {
		url: 'https://262.ecma-international.org/14.0/#sec-completepropertydescriptor'
	},
	Completion: {
		url: 'https://262.ecma-international.org/14.0/#sec-completion-ao'
	},
	CompletionRecord: {
		url: 'https://262.ecma-international.org/14.0/#sec-completion-record-specification-type'
	},
	ComposeWriteEventBytes: {
		url: 'https://262.ecma-international.org/14.0/#sec-composewriteeventbytes'
	},
	Construct: {
		url: 'https://262.ecma-international.org/14.0/#sec-construct'
	},
	ContinueDynamicImport: {
		url: 'https://262.ecma-international.org/14.0/#sec-ContinueDynamicImport'
	},
	ContinueModuleLoading: {
		url: 'https://262.ecma-international.org/14.0/#sec-ContinueModuleLoading'
	},
	CopyDataBlockBytes: {
		url: 'https://262.ecma-international.org/14.0/#sec-copydatablockbytes'
	},
	CopyDataProperties: {
		url: 'https://262.ecma-international.org/14.0/#sec-copydataproperties'
	},
	CountLeftCapturingParensBefore: {
		url: 'https://262.ecma-international.org/14.0/#sec-countleftcapturingparensbefore'
	},
	CountLeftCapturingParensWithin: {
		url: 'https://262.ecma-international.org/14.0/#sec-countleftcapturingparenswithin'
	},
	CreateArrayFromList: {
		url: 'https://262.ecma-international.org/14.0/#sec-createarrayfromlist'
	},
	CreateArrayIterator: {
		url: 'https://262.ecma-international.org/14.0/#sec-createarrayiterator'
	},
	CreateAsyncFromSyncIterator: {
		url: 'https://262.ecma-international.org/14.0/#sec-createasyncfromsynciterator'
	},
	CreateAsyncIteratorFromClosure: {
		url: 'https://262.ecma-international.org/14.0/#sec-createasynciteratorfromclosure'
	},
	CreateBuiltinFunction: {
		url: 'https://262.ecma-international.org/14.0/#sec-createbuiltinfunction'
	},
	CreateByteDataBlock: {
		url: 'https://262.ecma-international.org/14.0/#sec-createbytedatablock'
	},
	CreateDataProperty: {
		url: 'https://262.ecma-international.org/14.0/#sec-createdataproperty'
	},
	CreateDataPropertyOrThrow: {
		url: 'https://262.ecma-international.org/14.0/#sec-createdatapropertyorthrow'
	},
	CreateDynamicFunction: {
		url: 'https://262.ecma-international.org/14.0/#sec-createdynamicfunction'
	},
	CreateForInIterator: {
		url: 'https://262.ecma-international.org/14.0/#sec-createforiniterator'
	},
	CreateHTML: {
		url: 'https://262.ecma-international.org/14.0/#sec-createhtml'
	},
	CreateIntrinsics: {
		url: 'https://262.ecma-international.org/14.0/#sec-createintrinsics'
	},
	CreateIteratorFromClosure: {
		url: 'https://262.ecma-international.org/14.0/#sec-createiteratorfromclosure'
	},
	CreateIterResultObject: {
		url: 'https://262.ecma-international.org/14.0/#sec-createiterresultobject'
	},
	CreateListFromArrayLike: {
		url: 'https://262.ecma-international.org/14.0/#sec-createlistfromarraylike'
	},
	CreateListIteratorRecord: {
		url: 'https://262.ecma-international.org/14.0/#sec-createlistiteratorRecord'
	},
	CreateMapIterator: {
		url: 'https://262.ecma-international.org/14.0/#sec-createmapiterator'
	},
	CreateMappedArgumentsObject: {
		url: 'https://262.ecma-international.org/14.0/#sec-createmappedargumentsobject'
	},
	CreateMethodProperty: {
		url: 'https://262.ecma-international.org/14.0/#sec-createmethodproperty'
	},
	CreateNonEnumerableDataPropertyOrThrow: {
		url: 'https://262.ecma-international.org/14.0/#sec-createnonenumerabledatapropertyorthrow'
	},
	CreatePerIterationEnvironment: {
		url: 'https://262.ecma-international.org/14.0/#sec-createperiterationenvironment'
	},
	CreateRealm: {
		url: 'https://262.ecma-international.org/14.0/#sec-createrealm'
	},
	CreateRegExpStringIterator: {
		url: 'https://262.ecma-international.org/14.0/#sec-createregexpstringiterator'
	},
	CreateResolvingFunctions: {
		url: 'https://262.ecma-international.org/14.0/#sec-createresolvingfunctions'
	},
	CreateSetIterator: {
		url: 'https://262.ecma-international.org/14.0/#sec-createsetiterator'
	},
	CreateSharedByteDataBlock: {
		url: 'https://262.ecma-international.org/14.0/#sec-createsharedbytedatablock'
	},
	CreateUnmappedArgumentsObject: {
		url: 'https://262.ecma-international.org/14.0/#sec-createunmappedargumentsobject'
	},
	DateFromTime: {
		url: 'https://262.ecma-international.org/14.0/#sec-date-number'
	},
	DateString: {
		url: 'https://262.ecma-international.org/14.0/#sec-datestring'
	},
	Day: {
		url: 'https://262.ecma-international.org/14.0/#eqn-Day'
	},
	DayFromYear: {
		url: 'https://262.ecma-international.org/14.0/#eqn-DaysFromYear'
	},
	DaysInYear: {
		url: 'https://262.ecma-international.org/14.0/#eqn-DaysInYear'
	},
	DayWithinYear: {
		url: 'https://262.ecma-international.org/14.0/#eqn-DayWithinYear'
	},
	Decode: {
		url: 'https://262.ecma-international.org/14.0/#sec-decode'
	},
	DefaultTimeZone: {
		url: 'https://262.ecma-international.org/14.0/#sec-defaulttimezone'
	},
	DefineField: {
		url: 'https://262.ecma-international.org/14.0/#sec-definefield'
	},
	DefineMethodProperty: {
		url: 'https://262.ecma-international.org/14.0/#sec-definemethodproperty'
	},
	DefinePropertyOrThrow: {
		url: 'https://262.ecma-international.org/14.0/#sec-definepropertyorthrow'
	},
	DeletePropertyOrThrow: {
		url: 'https://262.ecma-international.org/14.0/#sec-deletepropertyorthrow'
	},
	DetachArrayBuffer: {
		url: 'https://262.ecma-international.org/14.0/#sec-detacharraybuffer'
	},
	Encode: {
		url: 'https://262.ecma-international.org/14.0/#sec-encode'
	},
	EnterCriticalSection: {
		url: 'https://262.ecma-international.org/14.0/#sec-entercriticalsection'
	},
	EnumerableOwnProperties: {
		url: 'https://262.ecma-international.org/14.0/#sec-enumerableownproperties'
	},
	EnumerateObjectProperties: {
		url: 'https://262.ecma-international.org/14.0/#sec-enumerate-object-properties'
	},
	EscapeRegExpPattern: {
		url: 'https://262.ecma-international.org/14.0/#sec-escaperegexppattern'
	},
	EvalDeclarationInstantiation: {
		url: 'https://262.ecma-international.org/14.0/#sec-evaldeclarationinstantiation'
	},
	EvaluateCall: {
		url: 'https://262.ecma-international.org/14.0/#sec-evaluatecall'
	},
	EvaluateNew: {
		url: 'https://262.ecma-international.org/14.0/#sec-evaluatenew'
	},
	EvaluatePropertyAccessWithExpressionKey: {
		url: 'https://262.ecma-international.org/14.0/#sec-evaluate-property-access-with-expression-key'
	},
	EvaluatePropertyAccessWithIdentifierKey: {
		url: 'https://262.ecma-international.org/14.0/#sec-evaluate-property-access-with-identifier-key'
	},
	EvaluateStringOrNumericBinaryExpression: {
		url: 'https://262.ecma-international.org/14.0/#sec-evaluatestringornumericbinaryexpression'
	},
	EventSet: {
		url: 'https://262.ecma-international.org/14.0/#sec-event-set'
	},
	ExecuteAsyncModule: {
		url: 'https://262.ecma-international.org/14.0/#sec-execute-async-module'
	},
	'𝔽': {
		url: 'https://262.ecma-international.org/14.0/#𝔽'
	},
	FindViaPredicate: {
		url: 'https://262.ecma-international.org/14.0/#sec-findviapredicate'
	},
	FinishLoadingImportedModule: {
		url: 'https://262.ecma-international.org/14.0/#sec-FinishLoadingImportedModule'
	},
	FlattenIntoArray: {
		url: 'https://262.ecma-international.org/14.0/#sec-flattenintoarray'
	},
	floor: {
		url: 'https://262.ecma-international.org/14.0/#eqn-floor'
	},
	ForBodyEvaluation: {
		url: 'https://262.ecma-international.org/14.0/#sec-forbodyevaluation'
	},
	'ForIn/OfBodyEvaluation': {
		url: 'https://262.ecma-international.org/14.0/#sec-runtime-semantics-forin-div-ofbodyevaluation-lhs-stmt-iterator-lhskind-labelset'
	},
	'ForIn/OfHeadEvaluation': {
		url: 'https://262.ecma-international.org/14.0/#sec-runtime-semantics-forinofheadevaluation'
	},
	FromPropertyDescriptor: {
		url: 'https://262.ecma-international.org/14.0/#sec-frompropertydescriptor'
	},
	FulfillPromise: {
		url: 'https://262.ecma-international.org/14.0/#sec-fulfillpromise'
	},
	FunctionDeclarationInstantiation: {
		url: 'https://262.ecma-international.org/14.0/#sec-functiondeclarationinstantiation'
	},
	GatherAvailableAncestors: {
		url: 'https://262.ecma-international.org/14.0/#sec-gather-available-ancestors'
	},
	GeneratorResume: {
		url: 'https://262.ecma-international.org/14.0/#sec-generatorresume'
	},
	GeneratorResumeAbrupt: {
		url: 'https://262.ecma-international.org/14.0/#sec-generatorresumeabrupt'
	},
	GeneratorStart: {
		url: 'https://262.ecma-international.org/14.0/#sec-generatorstart'
	},
	GeneratorValidate: {
		url: 'https://262.ecma-international.org/14.0/#sec-generatorvalidate'
	},
	GeneratorYield: {
		url: 'https://262.ecma-international.org/14.0/#sec-generatoryield'
	},
	Get: {
		url: 'https://262.ecma-international.org/14.0/#sec-get-o-p'
	},
	GetActiveScriptOrModule: {
		url: 'https://262.ecma-international.org/14.0/#sec-getactivescriptormodule'
	},
	GetFunctionRealm: {
		url: 'https://262.ecma-international.org/14.0/#sec-getfunctionrealm'
	},
	GetGeneratorKind: {
		url: 'https://262.ecma-international.org/14.0/#sec-getgeneratorkind'
	},
	GetGlobalObject: {
		url: 'https://262.ecma-international.org/14.0/#sec-getglobalobject'
	},
	GetIdentifierReference: {
		url: 'https://262.ecma-international.org/14.0/#sec-getidentifierreference'
	},
	GetImportedModule: {
		url: 'https://262.ecma-international.org/14.0/#sec-GetImportedModule'
	},
	GetIterator: {
		url: 'https://262.ecma-international.org/14.0/#sec-getiterator'
	},
	GetIteratorFromMethod: {
		url: 'https://262.ecma-international.org/14.0/#sec-getiteratorfrommethod'
	},
	GetMatchIndexPair: {
		url: 'https://262.ecma-international.org/14.0/#sec-getmatchindexpair'
	},
	GetMatchString: {
		url: 'https://262.ecma-international.org/14.0/#sec-getmatchstring'
	},
	GetMethod: {
		url: 'https://262.ecma-international.org/14.0/#sec-getmethod'
	},
	GetModifySetValueInBuffer: {
		url: 'https://262.ecma-international.org/14.0/#sec-getmodifysetvalueinbuffer'
	},
	GetModuleNamespace: {
		url: 'https://262.ecma-international.org/14.0/#sec-getmodulenamespace'
	},
	GetNamedTimeZoneEpochNanoseconds: {
		url: 'https://262.ecma-international.org/14.0/#sec-getnamedtimezoneepochnanoseconds'
	},
	GetNamedTimeZoneOffsetNanoseconds: {
		url: 'https://262.ecma-international.org/14.0/#sec-getnamedtimezoneoffsetnanoseconds'
	},
	GetNewTarget: {
		url: 'https://262.ecma-international.org/14.0/#sec-getnewtarget'
	},
	GetOwnPropertyKeys: {
		url: 'https://262.ecma-international.org/14.0/#sec-getownpropertykeys'
	},
	GetPromiseResolve: {
		url: 'https://262.ecma-international.org/14.0/#sec-getpromiseresolve'
	},
	GetPrototypeFromConstructor: {
		url: 'https://262.ecma-international.org/14.0/#sec-getprototypefromconstructor'
	},
	GetStringIndex: {
		url: 'https://262.ecma-international.org/14.0/#sec-getstringindex'
	},
	GetSubstitution: {
		url: 'https://262.ecma-international.org/14.0/#sec-getsubstitution'
	},
	GetSuperConstructor: {
		url: 'https://262.ecma-international.org/14.0/#sec-getsuperconstructor'
	},
	GetTemplateObject: {
		url: 'https://262.ecma-international.org/14.0/#sec-gettemplateobject'
	},
	GetThisEnvironment: {
		url: 'https://262.ecma-international.org/14.0/#sec-getthisenvironment'
	},
	GetThisValue: {
		url: 'https://262.ecma-international.org/14.0/#sec-getthisvalue'
	},
	GetUTCEpochNanoseconds: {
		url: 'https://262.ecma-international.org/14.0/#sec-getutcepochnanoseconds'
	},
	GetV: {
		url: 'https://262.ecma-international.org/14.0/#sec-getv'
	},
	GetValue: {
		url: 'https://262.ecma-international.org/14.0/#sec-getvalue'
	},
	GetValueFromBuffer: {
		url: 'https://262.ecma-international.org/14.0/#sec-getvaluefrombuffer'
	},
	GetViewValue: {
		url: 'https://262.ecma-international.org/14.0/#sec-getviewvalue'
	},
	GetWaiterList: {
		url: 'https://262.ecma-international.org/14.0/#sec-getwaiterlist'
	},
	GlobalDeclarationInstantiation: {
		url: 'https://262.ecma-international.org/14.0/#sec-globaldeclarationinstantiation'
	},
	GroupSpecifiersThatMatch: {
		url: 'https://262.ecma-international.org/14.0/#sec-groupspecifiersthatmatch'
	},
	'happens-before': {
		url: 'https://262.ecma-international.org/14.0/#sec-happens-before'
	},
	HasOwnProperty: {
		url: 'https://262.ecma-international.org/14.0/#sec-hasownproperty'
	},
	HasProperty: {
		url: 'https://262.ecma-international.org/14.0/#sec-hasproperty'
	},
	'host-synchronizes-with': {
		url: 'https://262.ecma-international.org/14.0/#sec-host-synchronizes-with'
	},
	HostEventSet: {
		url: 'https://262.ecma-international.org/14.0/#sec-hosteventset'
	},
	HourFromTime: {
		url: 'https://262.ecma-international.org/14.0/#eqn-HourFromTime'
	},
	IfAbruptCloseIterator: {
		url: 'https://262.ecma-international.org/14.0/#sec-ifabruptcloseiterator'
	},
	IfAbruptRejectPromise: {
		url: 'https://262.ecma-international.org/14.0/#sec-ifabruptrejectpromise'
	},
	ImportedLocalNames: {
		url: 'https://262.ecma-international.org/14.0/#sec-importedlocalnames'
	},
	InitializeBoundName: {
		url: 'https://262.ecma-international.org/14.0/#sec-initializeboundname'
	},
	InitializeHostDefinedRealm: {
		url: 'https://262.ecma-international.org/14.0/#sec-initializehostdefinedrealm'
	},
	InitializeInstanceElements: {
		url: 'https://262.ecma-international.org/14.0/#sec-initializeinstanceelements'
	},
	InitializeReferencedBinding: {
		url: 'https://262.ecma-international.org/14.0/#sec-initializereferencedbinding'
	},
	InitializeTypedArrayFromArrayBuffer: {
		url: 'https://262.ecma-international.org/14.0/#sec-initializetypedarrayfromarraybuffer'
	},
	InitializeTypedArrayFromArrayLike: {
		url: 'https://262.ecma-international.org/14.0/#sec-initializetypedarrayfromarraylike'
	},
	InitializeTypedArrayFromList: {
		url: 'https://262.ecma-international.org/14.0/#sec-initializetypedarrayfromlist'
	},
	InitializeTypedArrayFromTypedArray: {
		url: 'https://262.ecma-international.org/14.0/#sec-initializetypedarrayfromtypedarray'
	},
	InLeapYear: {
		url: 'https://262.ecma-international.org/14.0/#eqn-InLeapYear'
	},
	InnerModuleEvaluation: {
		url: 'https://262.ecma-international.org/14.0/#sec-innermoduleevaluation'
	},
	InnerModuleLinking: {
		url: 'https://262.ecma-international.org/14.0/#sec-InnerModuleLinking'
	},
	InnerModuleLoading: {
		url: 'https://262.ecma-international.org/14.0/#sec-InnerModuleLoading'
	},
	InstallErrorCause: {
		url: 'https://262.ecma-international.org/14.0/#sec-installerrorcause'
	},
	InstanceofOperator: {
		url: 'https://262.ecma-international.org/14.0/#sec-instanceofoperator'
	},
	IntegerIndexedElementGet: {
		url: 'https://262.ecma-international.org/14.0/#sec-integerindexedelementget'
	},
	IntegerIndexedElementSet: {
		url: 'https://262.ecma-international.org/14.0/#sec-integerindexedelementset'
	},
	IntegerIndexedObjectCreate: {
		url: 'https://262.ecma-international.org/14.0/#sec-integerindexedobjectcreate'
	},
	InternalizeJSONProperty: {
		url: 'https://262.ecma-international.org/14.0/#sec-internalizejsonproperty'
	},
	Invoke: {
		url: 'https://262.ecma-international.org/14.0/#sec-invoke'
	},
	IsAccessorDescriptor: {
		url: 'https://262.ecma-international.org/14.0/#sec-isaccessordescriptor'
	},
	IsAnonymousFunctionDefinition: {
		url: 'https://262.ecma-international.org/14.0/#sec-isanonymousfunctiondefinition'
	},
	IsArray: {
		url: 'https://262.ecma-international.org/14.0/#sec-isarray'
	},
	IsBigIntElementType: {
		url: 'https://262.ecma-international.org/14.0/#sec-isbigintelementtype'
	},
	IsCallable: {
		url: 'https://262.ecma-international.org/14.0/#sec-iscallable'
	},
	IsCompatiblePropertyDescriptor: {
		url: 'https://262.ecma-international.org/14.0/#sec-iscompatiblepropertydescriptor'
	},
	IsConcatSpreadable: {
		url: 'https://262.ecma-international.org/14.0/#sec-isconcatspreadable'
	},
	IsConstructor: {
		url: 'https://262.ecma-international.org/14.0/#sec-isconstructor'
	},
	IsDataDescriptor: {
		url: 'https://262.ecma-international.org/14.0/#sec-isdatadescriptor'
	},
	IsDetachedBuffer: {
		url: 'https://262.ecma-international.org/14.0/#sec-isdetachedbuffer'
	},
	IsExtensible: {
		url: 'https://262.ecma-international.org/14.0/#sec-isextensible-o'
	},
	IsGenericDescriptor: {
		url: 'https://262.ecma-international.org/14.0/#sec-isgenericdescriptor'
	},
	IsInTailPosition: {
		url: 'https://262.ecma-international.org/14.0/#sec-isintailposition'
	},
	IsIntegralNumber: {
		url: 'https://262.ecma-international.org/14.0/#sec-isintegralnumber'
	},
	IsLabelledFunction: {
		url: 'https://262.ecma-international.org/14.0/#sec-islabelledfunction'
	},
	IsLessThan: {
		url: 'https://262.ecma-international.org/14.0/#sec-islessthan'
	},
	IsLooselyEqual: {
		url: 'https://262.ecma-international.org/14.0/#sec-islooselyequal'
	},
	IsNoTearConfiguration: {
		url: 'https://262.ecma-international.org/14.0/#sec-isnotearconfiguration'
	},
	IsPrivateReference: {
		url: 'https://262.ecma-international.org/14.0/#sec-isprivatereference'
	},
	IsPromise: {
		url: 'https://262.ecma-international.org/14.0/#sec-ispromise'
	},
	IsPropertyKey: {
		url: 'https://262.ecma-international.org/14.0/#sec-ispropertykey'
	},
	IsPropertyReference: {
		url: 'https://262.ecma-international.org/14.0/#sec-ispropertyreference'
	},
	IsRegExp: {
		url: 'https://262.ecma-international.org/14.0/#sec-isregexp'
	},
	IsSharedArrayBuffer: {
		url: 'https://262.ecma-international.org/14.0/#sec-issharedarraybuffer'
	},
	IsStrictlyEqual: {
		url: 'https://262.ecma-international.org/14.0/#sec-isstrictlyequal'
	},
	IsStringWellFormedUnicode: {
		url: 'https://262.ecma-international.org/14.0/#sec-isstringwellformedunicode'
	},
	IsSuperReference: {
		url: 'https://262.ecma-international.org/14.0/#sec-issuperreference'
	},
	IsTimeZoneOffsetString: {
		url: 'https://262.ecma-international.org/14.0/#sec-istimezoneoffsetstring'
	},
	IsUnclampedIntegerElementType: {
		url: 'https://262.ecma-international.org/14.0/#sec-isunclampedintegerelementtype'
	},
	IsUnresolvableReference: {
		url: 'https://262.ecma-international.org/14.0/#sec-isunresolvablereference'
	},
	IsUnsignedElementType: {
		url: 'https://262.ecma-international.org/14.0/#sec-isunsignedelementtype'
	},
	IsValidIntegerIndex: {
		url: 'https://262.ecma-international.org/14.0/#sec-isvalidintegerindex'
	},
	IsValidRegularExpressionLiteral: {
		url: 'https://262.ecma-international.org/14.0/#sec-isvalidregularexpressionliteral'
	},
	IsWordChar: {
		url: 'https://262.ecma-international.org/14.0/#sec-runtime-semantics-iswordchar-abstract-operation'
	},
	IteratorClose: {
		url: 'https://262.ecma-international.org/14.0/#sec-iteratorclose'
	},
	IteratorComplete: {
		url: 'https://262.ecma-international.org/14.0/#sec-iteratorcomplete'
	},
	IteratorNext: {
		url: 'https://262.ecma-international.org/14.0/#sec-iteratornext'
	},
	IteratorStep: {
		url: 'https://262.ecma-international.org/14.0/#sec-iteratorstep'
	},
	IteratorToList: {
		url: 'https://262.ecma-international.org/14.0/#sec-iteratortolist'
	},
	IteratorValue: {
		url: 'https://262.ecma-international.org/14.0/#sec-iteratorvalue'
	},
	KeyForSymbol: {
		url: 'https://262.ecma-international.org/14.0/#sec-keyforsymbol'
	},
	LeaveCriticalSection: {
		url: 'https://262.ecma-international.org/14.0/#sec-leavecriticalsection'
	},
	LengthOfArrayLike: {
		url: 'https://262.ecma-international.org/14.0/#sec-lengthofarraylike'
	},
	LocalTime: {
		url: 'https://262.ecma-international.org/14.0/#sec-localtime'
	},
	LoopContinues: {
		url: 'https://262.ecma-international.org/14.0/#sec-loopcontinues'
	},
	MakeArgGetter: {
		url: 'https://262.ecma-international.org/14.0/#sec-makearggetter'
	},
	MakeArgSetter: {
		url: 'https://262.ecma-international.org/14.0/#sec-makeargsetter'
	},
	MakeBasicObject: {
		url: 'https://262.ecma-international.org/14.0/#sec-makebasicobject'
	},
	MakeClassConstructor: {
		url: 'https://262.ecma-international.org/14.0/#sec-makeclassconstructor'
	},
	MakeConstructor: {
		url: 'https://262.ecma-international.org/14.0/#sec-makeconstructor'
	},
	MakeDate: {
		url: 'https://262.ecma-international.org/14.0/#sec-makedate'
	},
	MakeDay: {
		url: 'https://262.ecma-international.org/14.0/#sec-makeday'
	},
	MakeMatchIndicesIndexPairArray: {
		url: 'https://262.ecma-international.org/14.0/#sec-makematchindicesindexpairarray'
	},
	MakeMethod: {
		url: 'https://262.ecma-international.org/14.0/#sec-makemethod'
	},
	MakePrivateReference: {
		url: 'https://262.ecma-international.org/14.0/#sec-makeprivatereference'
	},
	MakeSuperPropertyReference: {
		url: 'https://262.ecma-international.org/14.0/#sec-makesuperpropertyreference'
	},
	MakeTime: {
		url: 'https://262.ecma-international.org/14.0/#sec-maketime'
	},
	max: {
		url: 'https://262.ecma-international.org/14.0/#eqn-max'
	},
	'memory-order': {
		url: 'https://262.ecma-international.org/14.0/#sec-memory-order'
	},
	min: {
		url: 'https://262.ecma-international.org/14.0/#eqn-min'
	},
	MinFromTime: {
		url: 'https://262.ecma-international.org/14.0/#eqn-MinFromTime'
	},
	ModuleNamespaceCreate: {
		url: 'https://262.ecma-international.org/14.0/#sec-modulenamespacecreate'
	},
	modulo: {
		url: 'https://262.ecma-international.org/14.0/#eqn-modulo'
	},
	MonthFromTime: {
		url: 'https://262.ecma-international.org/14.0/#eqn-MonthFromTime'
	},
	msFromTime: {
		url: 'https://262.ecma-international.org/14.0/#eqn-msFromTime'
	},
	NewDeclarativeEnvironment: {
		url: 'https://262.ecma-international.org/14.0/#sec-newdeclarativeenvironment'
	},
	NewFunctionEnvironment: {
		url: 'https://262.ecma-international.org/14.0/#sec-newfunctionenvironment'
	},
	NewGlobalEnvironment: {
		url: 'https://262.ecma-international.org/14.0/#sec-newglobalenvironment'
	},
	NewModuleEnvironment: {
		url: 'https://262.ecma-international.org/14.0/#sec-newmoduleenvironment'
	},
	NewObjectEnvironment: {
		url: 'https://262.ecma-international.org/14.0/#sec-newobjectenvironment'
	},
	NewPrivateEnvironment: {
		url: 'https://262.ecma-international.org/14.0/#sec-newprivateenvironment'
	},
	NewPromiseCapability: {
		url: 'https://262.ecma-international.org/14.0/#sec-newpromisecapability'
	},
	NewPromiseReactionJob: {
		url: 'https://262.ecma-international.org/14.0/#sec-newpromisereactionjob'
	},
	NewPromiseResolveThenableJob: {
		url: 'https://262.ecma-international.org/14.0/#sec-newpromiseresolvethenablejob'
	},
	NormalCompletion: {
		url: 'https://262.ecma-international.org/14.0/#sec-normalcompletion'
	},
	NotifyWaiter: {
		url: 'https://262.ecma-international.org/14.0/#sec-notifywaiter'
	},
	'Number::add': {
		url: 'https://262.ecma-international.org/14.0/#sec-numeric-types-number-add'
	},
	'Number::bitwiseAND': {
		url: 'https://262.ecma-international.org/14.0/#sec-numeric-types-number-bitwiseAND'
	},
	'Number::bitwiseNOT': {
		url: 'https://262.ecma-international.org/14.0/#sec-numeric-types-number-bitwiseNOT'
	},
	'Number::bitwiseOR': {
		url: 'https://262.ecma-international.org/14.0/#sec-numeric-types-number-bitwiseOR'
	},
	'Number::bitwiseXOR': {
		url: 'https://262.ecma-international.org/14.0/#sec-numeric-types-number-bitwiseXOR'
	},
	'Number::divide': {
		url: 'https://262.ecma-international.org/14.0/#sec-numeric-types-number-divide'
	},
	'Number::equal': {
		url: 'https://262.ecma-international.org/14.0/#sec-numeric-types-number-equal'
	},
	'Number::exponentiate': {
		url: 'https://262.ecma-international.org/14.0/#sec-numeric-types-number-exponentiate'
	},
	'Number::leftShift': {
		url: 'https://262.ecma-international.org/14.0/#sec-numeric-types-number-leftShift'
	},
	'Number::lessThan': {
		url: 'https://262.ecma-international.org/14.0/#sec-numeric-types-number-lessThan'
	},
	'Number::multiply': {
		url: 'https://262.ecma-international.org/14.0/#sec-numeric-types-number-multiply'
	},
	'Number::remainder': {
		url: 'https://262.ecma-international.org/14.0/#sec-numeric-types-number-remainder'
	},
	'Number::sameValue': {
		url: 'https://262.ecma-international.org/14.0/#sec-numeric-types-number-sameValue'
	},
	'Number::sameValueZero': {
		url: 'https://262.ecma-international.org/14.0/#sec-numeric-types-number-sameValueZero'
	},
	'Number::signedRightShift': {
		url: 'https://262.ecma-international.org/14.0/#sec-numeric-types-number-signedRightShift'
	},
	'Number::subtract': {
		url: 'https://262.ecma-international.org/14.0/#sec-numeric-types-number-subtract'
	},
	'Number::toString': {
		url: 'https://262.ecma-international.org/14.0/#sec-numeric-types-number-tostring'
	},
	'Number::unaryMinus': {
		url: 'https://262.ecma-international.org/14.0/#sec-numeric-types-number-unaryMinus'
	},
	'Number::unsignedRightShift': {
		url: 'https://262.ecma-international.org/14.0/#sec-numeric-types-number-unsignedRightShift'
	},
	NumberBitwiseOp: {
		url: 'https://262.ecma-international.org/14.0/#sec-numberbitwiseop'
	},
	NumberToBigInt: {
		url: 'https://262.ecma-international.org/14.0/#sec-numbertobigint'
	},
	NumericToRawBytes: {
		url: 'https://262.ecma-international.org/14.0/#sec-numerictorawbytes'
	},
	ObjectDefineProperties: {
		url: 'https://262.ecma-international.org/14.0/#sec-objectdefineproperties'
	},
	OrdinaryCallBindThis: {
		url: 'https://262.ecma-international.org/14.0/#sec-ordinarycallbindthis'
	},
	OrdinaryCallEvaluateBody: {
		url: 'https://262.ecma-international.org/14.0/#sec-ordinarycallevaluatebody'
	},
	OrdinaryCreateFromConstructor: {
		url: 'https://262.ecma-international.org/14.0/#sec-ordinarycreatefromconstructor'
	},
	OrdinaryDefineOwnProperty: {
		url: 'https://262.ecma-international.org/14.0/#sec-ordinarydefineownproperty'
	},
	OrdinaryDelete: {
		url: 'https://262.ecma-international.org/14.0/#sec-ordinarydelete'
	},
	OrdinaryFunctionCreate: {
		url: 'https://262.ecma-international.org/14.0/#sec-ordinaryfunctioncreate'
	},
	OrdinaryGet: {
		url: 'https://262.ecma-international.org/14.0/#sec-ordinaryget'
	},
	OrdinaryGetOwnProperty: {
		url: 'https://262.ecma-international.org/14.0/#sec-ordinarygetownproperty'
	},
	OrdinaryGetPrototypeOf: {
		url: 'https://262.ecma-international.org/14.0/#sec-ordinarygetprototypeof'
	},
	OrdinaryHasInstance: {
		url: 'https://262.ecma-international.org/14.0/#sec-ordinaryhasinstance'
	},
	OrdinaryHasProperty: {
		url: 'https://262.ecma-international.org/14.0/#sec-ordinaryhasproperty'
	},
	OrdinaryIsExtensible: {
		url: 'https://262.ecma-international.org/14.0/#sec-ordinaryisextensible'
	},
	OrdinaryObjectCreate: {
		url: 'https://262.ecma-international.org/14.0/#sec-ordinaryobjectcreate'
	},
	OrdinaryOwnPropertyKeys: {
		url: 'https://262.ecma-international.org/14.0/#sec-ordinaryownpropertykeys'
	},
	OrdinaryPreventExtensions: {
		url: 'https://262.ecma-international.org/14.0/#sec-ordinarypreventextensions'
	},
	OrdinarySet: {
		url: 'https://262.ecma-international.org/14.0/#sec-ordinaryset'
	},
	OrdinarySetPrototypeOf: {
		url: 'https://262.ecma-international.org/14.0/#sec-ordinarysetprototypeof'
	},
	OrdinarySetWithOwnDescriptor: {
		url: 'https://262.ecma-international.org/14.0/#sec-ordinarysetwithowndescriptor'
	},
	OrdinaryToPrimitive: {
		url: 'https://262.ecma-international.org/14.0/#sec-ordinarytoprimitive'
	},
	ParseHexOctet: {
		url: 'https://262.ecma-international.org/14.0/#sec-parsehexoctet'
	},
	ParseModule: {
		url: 'https://262.ecma-international.org/14.0/#sec-parsemodule'
	},
	ParsePattern: {
		url: 'https://262.ecma-international.org/14.0/#sec-parsepattern'
	},
	ParseScript: {
		url: 'https://262.ecma-international.org/14.0/#sec-parse-script'
	},
	ParseText: {
		url: 'https://262.ecma-international.org/14.0/#sec-parsetext'
	},
	ParseTimeZoneOffsetString: {
		url: 'https://262.ecma-international.org/14.0/#sec-parsetimezoneoffsetstring'
	},
	PerformEval: {
		url: 'https://262.ecma-international.org/14.0/#sec-performeval'
	},
	PerformPromiseAll: {
		url: 'https://262.ecma-international.org/14.0/#sec-performpromiseall'
	},
	PerformPromiseAllSettled: {
		url: 'https://262.ecma-international.org/14.0/#sec-performpromiseallsettled'
	},
	PerformPromiseAny: {
		url: 'https://262.ecma-international.org/14.0/#sec-performpromiseany'
	},
	PerformPromiseRace: {
		url: 'https://262.ecma-international.org/14.0/#sec-performpromiserace'
	},
	PerformPromiseThen: {
		url: 'https://262.ecma-international.org/14.0/#sec-performpromisethen'
	},
	PrepareForOrdinaryCall: {
		url: 'https://262.ecma-international.org/14.0/#sec-prepareforordinarycall'
	},
	PrepareForTailCall: {
		url: 'https://262.ecma-international.org/14.0/#sec-preparefortailcall'
	},
	PrivateElementFind: {
		url: 'https://262.ecma-international.org/14.0/#sec-privateelementfind'
	},
	PrivateFieldAdd: {
		url: 'https://262.ecma-international.org/14.0/#sec-privatefieldadd'
	},
	PrivateGet: {
		url: 'https://262.ecma-international.org/14.0/#sec-privateget'
	},
	PrivateMethodOrAccessorAdd: {
		url: 'https://262.ecma-international.org/14.0/#sec-privatemethodoraccessoradd'
	},
	PrivateSet: {
		url: 'https://262.ecma-international.org/14.0/#sec-privateset'
	},
	PromiseResolve: {
		url: 'https://262.ecma-international.org/14.0/#sec-promise-resolve'
	},
	ProxyCreate: {
		url: 'https://262.ecma-international.org/14.0/#sec-proxycreate'
	},
	PutValue: {
		url: 'https://262.ecma-international.org/14.0/#sec-putvalue'
	},
	QuoteJSONString: {
		url: 'https://262.ecma-international.org/14.0/#sec-quotejsonstring'
	},
	ℝ: {
		url: 'https://262.ecma-international.org/14.0/#ℝ'
	},
	RawBytesToNumeric: {
		url: 'https://262.ecma-international.org/14.0/#sec-rawbytestonumeric'
	},
	'reads-bytes-from': {
		url: 'https://262.ecma-international.org/14.0/#sec-reads-bytes-from'
	},
	'reads-from': {
		url: 'https://262.ecma-international.org/14.0/#sec-reads-from'
	},
	RegExpAlloc: {
		url: 'https://262.ecma-international.org/14.0/#sec-regexpalloc'
	},
	RegExpBuiltinExec: {
		url: 'https://262.ecma-international.org/14.0/#sec-regexpbuiltinexec'
	},
	RegExpCreate: {
		url: 'https://262.ecma-international.org/14.0/#sec-regexpcreate'
	},
	RegExpExec: {
		url: 'https://262.ecma-international.org/14.0/#sec-regexpexec'
	},
	RegExpHasFlag: {
		url: 'https://262.ecma-international.org/14.0/#sec-regexphasflag'
	},
	RegExpInitialize: {
		url: 'https://262.ecma-international.org/14.0/#sec-regexpinitialize'
	},
	RejectPromise: {
		url: 'https://262.ecma-international.org/14.0/#sec-rejectpromise'
	},
	RemoveWaiter: {
		url: 'https://262.ecma-international.org/14.0/#sec-removewaiter'
	},
	RemoveWaiters: {
		url: 'https://262.ecma-international.org/14.0/#sec-removewaiters'
	},
	RepeatMatcher: {
		url: 'https://262.ecma-international.org/14.0/#sec-runtime-semantics-repeatmatcher-abstract-operation'
	},
	RequireInternalSlot: {
		url: 'https://262.ecma-international.org/14.0/#sec-requireinternalslot'
	},
	RequireObjectCoercible: {
		url: 'https://262.ecma-international.org/14.0/#sec-requireobjectcoercible'
	},
	ResolveBinding: {
		url: 'https://262.ecma-international.org/14.0/#sec-resolvebinding'
	},
	ResolvePrivateIdentifier: {
		url: 'https://262.ecma-international.org/14.0/#sec-resolve-private-identifier'
	},
	ResolveThisBinding: {
		url: 'https://262.ecma-international.org/14.0/#sec-resolvethisbinding'
	},
	ReturnIfAbrupt: {
		url: 'https://262.ecma-international.org/14.0/#sec-returnifabrupt'
	},
	RoundMVResult: {
		url: 'https://262.ecma-international.org/14.0/#sec-roundmvresult'
	},
	SameValue: {
		url: 'https://262.ecma-international.org/14.0/#sec-samevalue'
	},
	SameValueNonNumber: {
		url: 'https://262.ecma-international.org/14.0/#sec-samevaluenonnumber'
	},
	SameValueZero: {
		url: 'https://262.ecma-international.org/14.0/#sec-samevaluezero'
	},
	ScriptEvaluation: {
		url: 'https://262.ecma-international.org/14.0/#sec-runtime-semantics-scriptevaluation'
	},
	SecFromTime: {
		url: 'https://262.ecma-international.org/14.0/#eqn-SecFromTime'
	},
	SerializeJSONArray: {
		url: 'https://262.ecma-international.org/14.0/#sec-serializejsonarray'
	},
	SerializeJSONObject: {
		url: 'https://262.ecma-international.org/14.0/#sec-serializejsonobject'
	},
	SerializeJSONProperty: {
		url: 'https://262.ecma-international.org/14.0/#sec-serializejsonproperty'
	},
	Set: {
		url: 'https://262.ecma-international.org/14.0/#sec-set-o-p-v-throw'
	},
	SetDefaultGlobalBindings: {
		url: 'https://262.ecma-international.org/14.0/#sec-setdefaultglobalbindings'
	},
	SetFunctionLength: {
		url: 'https://262.ecma-international.org/14.0/#sec-setfunctionlength'
	},
	SetFunctionName: {
		url: 'https://262.ecma-international.org/14.0/#sec-setfunctionname'
	},
	SetImmutablePrototype: {
		url: 'https://262.ecma-international.org/14.0/#sec-set-immutable-prototype'
	},
	SetIntegrityLevel: {
		url: 'https://262.ecma-international.org/14.0/#sec-setintegritylevel'
	},
	SetRealmGlobalObject: {
		url: 'https://262.ecma-international.org/14.0/#sec-setrealmglobalobject'
	},
	SetTypedArrayFromArrayLike: {
		url: 'https://262.ecma-international.org/14.0/#sec-settypedarrayfromarraylike'
	},
	SetTypedArrayFromTypedArray: {
		url: 'https://262.ecma-international.org/14.0/#sec-settypedarrayfromtypedarray'
	},
	SetValueInBuffer: {
		url: 'https://262.ecma-international.org/14.0/#sec-setvalueinbuffer'
	},
	SetViewValue: {
		url: 'https://262.ecma-international.org/14.0/#sec-setviewvalue'
	},
	SharedDataBlockEventSet: {
		url: 'https://262.ecma-international.org/14.0/#sec-sharedatablockeventset'
	},
	SortIndexedProperties: {
		url: 'https://262.ecma-international.org/14.0/#sec-sortindexedproperties'
	},
	SpeciesConstructor: {
		url: 'https://262.ecma-international.org/14.0/#sec-speciesconstructor'
	},
	StringCreate: {
		url: 'https://262.ecma-international.org/14.0/#sec-stringcreate'
	},
	StringGetOwnProperty: {
		url: 'https://262.ecma-international.org/14.0/#sec-stringgetownproperty'
	},
	StringIndexOf: {
		url: 'https://262.ecma-international.org/14.0/#sec-stringindexof'
	},
	StringPad: {
		url: 'https://262.ecma-international.org/14.0/#sec-stringpad'
	},
	StringToBigInt: {
		url: 'https://262.ecma-international.org/14.0/#sec-stringtobigint'
	},
	StringToCodePoints: {
		url: 'https://262.ecma-international.org/14.0/#sec-stringtocodepoints'
	},
	StringToNumber: {
		url: 'https://262.ecma-international.org/14.0/#sec-stringtonumber'
	},
	substring: {
		url: 'https://262.ecma-international.org/14.0/#substring'
	},
	SuspendAgent: {
		url: 'https://262.ecma-international.org/14.0/#sec-suspendagent'
	},
	SymbolDescriptiveString: {
		url: 'https://262.ecma-international.org/14.0/#sec-symboldescriptivestring'
	},
	'synchronizes-with': {
		url: 'https://262.ecma-international.org/14.0/#sec-synchronizes-with'
	},
	TemplateString: {
		url: 'https://262.ecma-international.org/14.0/#sec-templatestring'
	},
	TestIntegrityLevel: {
		url: 'https://262.ecma-international.org/14.0/#sec-testintegritylevel'
	},
	thisBigIntValue: {
		url: 'https://262.ecma-international.org/14.0/#thisbigintvalue'
	},
	thisBooleanValue: {
		url: 'https://262.ecma-international.org/14.0/#thisbooleanvalue'
	},
	thisNumberValue: {
		url: 'https://262.ecma-international.org/14.0/#thisnumbervalue'
	},
	thisStringValue: {
		url: 'https://262.ecma-international.org/14.0/#thisstringvalue'
	},
	thisSymbolValue: {
		url: 'https://262.ecma-international.org/14.0/#thissymbolvalue'
	},
	thisTimeValue: {
		url: 'https://262.ecma-international.org/14.0/#thistimevalue'
	},
	ThrowCompletion: {
		url: 'https://262.ecma-international.org/14.0/#sec-throwcompletion'
	},
	TimeClip: {
		url: 'https://262.ecma-international.org/14.0/#sec-timeclip'
	},
	TimeFromYear: {
		url: 'https://262.ecma-international.org/14.0/#eqn-TimeFromYear'
	},
	TimeString: {
		url: 'https://262.ecma-international.org/14.0/#sec-timestring'
	},
	TimeWithinDay: {
		url: 'https://262.ecma-international.org/14.0/#eqn-TimeWithinDay'
	},
	TimeZoneString: {
		url: 'https://262.ecma-international.org/14.0/#sec-timezoneestring'
	},
	ToBigInt: {
		url: 'https://262.ecma-international.org/14.0/#sec-tobigint'
	},
	ToBigInt64: {
		url: 'https://262.ecma-international.org/14.0/#sec-tobigint64'
	},
	ToBigUint64: {
		url: 'https://262.ecma-international.org/14.0/#sec-tobiguint64'
	},
	ToBoolean: {
		url: 'https://262.ecma-international.org/14.0/#sec-toboolean'
	},
	ToDateString: {
		url: 'https://262.ecma-international.org/14.0/#sec-todatestring'
	},
	ToIndex: {
		url: 'https://262.ecma-international.org/14.0/#sec-toindex'
	},
	ToInt16: {
		url: 'https://262.ecma-international.org/14.0/#sec-toint16'
	},
	ToInt32: {
		url: 'https://262.ecma-international.org/14.0/#sec-toint32'
	},
	ToInt8: {
		url: 'https://262.ecma-international.org/14.0/#sec-toint8'
	},
	ToIntegerOrInfinity: {
		url: 'https://262.ecma-international.org/14.0/#sec-tointegerorinfinity'
	},
	ToLength: {
		url: 'https://262.ecma-international.org/14.0/#sec-tolength'
	},
	ToNumber: {
		url: 'https://262.ecma-international.org/14.0/#sec-tonumber'
	},
	ToNumeric: {
		url: 'https://262.ecma-international.org/14.0/#sec-tonumeric'
	},
	ToObject: {
		url: 'https://262.ecma-international.org/14.0/#sec-toobject'
	},
	ToPrimitive: {
		url: 'https://262.ecma-international.org/14.0/#sec-toprimitive'
	},
	ToPropertyDescriptor: {
		url: 'https://262.ecma-international.org/14.0/#sec-topropertydescriptor'
	},
	ToPropertyKey: {
		url: 'https://262.ecma-international.org/14.0/#sec-topropertykey'
	},
	ToString: {
		url: 'https://262.ecma-international.org/14.0/#sec-tostring'
	},
	ToUint16: {
		url: 'https://262.ecma-international.org/14.0/#sec-touint16'
	},
	ToUint32: {
		url: 'https://262.ecma-international.org/14.0/#sec-touint32'
	},
	ToUint8: {
		url: 'https://262.ecma-international.org/14.0/#sec-touint8'
	},
	ToUint8Clamp: {
		url: 'https://262.ecma-international.org/14.0/#sec-touint8clamp'
	},
	ToZeroPaddedDecimalString: {
		url: 'https://262.ecma-international.org/14.0/#sec-tozeropaddeddecimalstring'
	},
	TriggerPromiseReactions: {
		url: 'https://262.ecma-international.org/14.0/#sec-triggerpromisereactions'
	},
	TrimString: {
		url: 'https://262.ecma-international.org/14.0/#sec-trimstring'
	},
	truncate: {
		url: 'https://262.ecma-international.org/14.0/#eqn-truncate'
	},
	Type: {
		url: 'https://262.ecma-international.org/14.0/#sec-ecmascript-data-types-and-values'
	},
	TypedArrayCreate: {
		url: 'https://262.ecma-international.org/14.0/#typedarray-create'
	},
	TypedArrayCreateSameType: {
		url: 'https://262.ecma-international.org/14.0/#sec-typedarray-create-same-type'
	},
	TypedArrayElementSize: {
		url: 'https://262.ecma-international.org/14.0/#sec-typedarrayelementsize'
	},
	TypedArrayElementType: {
		url: 'https://262.ecma-international.org/14.0/#sec-typedarrayelementtype'
	},
	TypedArraySpeciesCreate: {
		url: 'https://262.ecma-international.org/14.0/#typedarray-species-create'
	},
	UnicodeEscape: {
		url: 'https://262.ecma-international.org/14.0/#sec-unicodeescape'
	},
	UnicodeMatchProperty: {
		url: 'https://262.ecma-international.org/14.0/#sec-runtime-semantics-unicodematchproperty-p'
	},
	UnicodeMatchPropertyValue: {
		url: 'https://262.ecma-international.org/14.0/#sec-runtime-semantics-unicodematchpropertyvalue-p-v'
	},
	UpdateEmpty: {
		url: 'https://262.ecma-international.org/14.0/#sec-updateempty'
	},
	UTC: {
		url: 'https://262.ecma-international.org/14.0/#sec-utc-t'
	},
	UTF16EncodeCodePoint: {
		url: 'https://262.ecma-international.org/14.0/#sec-utf16encodecodepoint'
	},
	UTF16SurrogatePairToCodePoint: {
		url: 'https://262.ecma-international.org/14.0/#sec-utf16decodesurrogatepair'
	},
	ValidateAndApplyPropertyDescriptor: {
		url: 'https://262.ecma-international.org/14.0/#sec-validateandapplypropertydescriptor'
	},
	ValidateAtomicAccess: {
		url: 'https://262.ecma-international.org/14.0/#sec-validateatomicaccess'
	},
	ValidateIntegerTypedArray: {
		url: 'https://262.ecma-international.org/14.0/#sec-validateintegertypedarray'
	},
	ValidateNonRevokedProxy: {
		url: 'https://262.ecma-international.org/14.0/#sec-validatenonrevokedproxy'
	},
	ValidateTypedArray: {
		url: 'https://262.ecma-international.org/14.0/#sec-validatetypedarray'
	},
	ValueOfReadEvent: {
		url: 'https://262.ecma-international.org/14.0/#sec-valueofreadevent'
	},
	WeakRefDeref: {
		url: 'https://262.ecma-international.org/14.0/#sec-weakrefderef'
	},
	WeekDay: {
		url: 'https://262.ecma-international.org/14.0/#sec-week-day'
	},
	WordCharacters: {
		url: 'https://262.ecma-international.org/14.0/#sec-wordcharacters'
	},
	YearFromTime: {
		url: 'https://262.ecma-international.org/14.0/#eqn-YearFromTime'
	},
	Yield: {
		url: 'https://262.ecma-international.org/14.0/#sec-yield'
	},
	ℤ: {
		url: 'https://262.ecma-international.org/14.0/#ℤ'
	}
};
'use strict';

module.exports = {
	abs: {
		url: 'https://262.ecma-international.org/15.0/#eqn-abs'
	},
	AddEntriesFromIterable: {
		url: 'https://262.ecma-international.org/15.0/#sec-add-entries-from-iterable'
	},
	AddRestrictedFunctionProperties: {
		url: 'https://262.ecma-international.org/15.0/#sec-addrestrictedfunctionproperties'
	},
	AddToKeptObjects: {
		url: 'https://262.ecma-international.org/15.0/#sec-addtokeptobjects'
	},
	AddValueToKeyedGroup: {
		url: 'https://262.ecma-international.org/15.0/#sec-add-value-to-keyed-group'
	},
	AddWaiter: {
		url: 'https://262.ecma-international.org/15.0/#sec-addwaiter'
	},
	AdvanceStringIndex: {
		url: 'https://262.ecma-international.org/15.0/#sec-advancestringindex'
	},
	'agent-order': {
		url: 'https://262.ecma-international.org/15.0/#sec-agent-order'
	},
	AgentCanSuspend: {
		url: 'https://262.ecma-international.org/15.0/#sec-agentcansuspend'
	},
	AgentSignifier: {
		url: 'https://262.ecma-international.org/15.0/#sec-agentsignifier'
	},
	AllCharacters: {
		url: 'https://262.ecma-international.org/15.0/#sec-allcharacters'
	},
	AllocateArrayBuffer: {
		url: 'https://262.ecma-international.org/15.0/#sec-allocatearraybuffer'
	},
	AllocateSharedArrayBuffer: {
		url: 'https://262.ecma-international.org/15.0/#sec-allocatesharedarraybuffer'
	},
	AllocateTypedArray: {
		url: 'https://262.ecma-international.org/15.0/#sec-allocatetypedarray'
	},
	AllocateTypedArrayBuffer: {
		url: 'https://262.ecma-international.org/15.0/#sec-allocatetypedarraybuffer'
	},
	ApplyStringOrNumericBinaryOperator: {
		url: 'https://262.ecma-international.org/15.0/#sec-applystringornumericbinaryoperator'
	},
	ArrayBufferByteLength: {
		url: 'https://262.ecma-international.org/15.0/#sec-arraybufferbytelength'
	},
	ArrayBufferCopyAndDetach: {
		url: 'https://262.ecma-international.org/15.0/#sec-arraybuffercopyanddetach'
	},
	ArrayCreate: {
		url: 'https://262.ecma-international.org/15.0/#sec-arraycreate'
	},
	ArraySetLength: {
		url: 'https://262.ecma-international.org/15.0/#sec-arraysetlength'
	},
	ArraySpeciesCreate: {
		url: 'https://262.ecma-international.org/15.0/#sec-arrayspeciescreate'
	},
	AsyncBlockStart: {
		url: 'https://262.ecma-international.org/15.0/#sec-asyncblockstart'
	},
	AsyncFromSyncIteratorContinuation: {
		url: 'https://262.ecma-international.org/15.0/#sec-asyncfromsynciteratorcontinuation'
	},
	AsyncFunctionStart: {
		url: 'https://262.ecma-international.org/15.0/#sec-async-functions-abstract-operations-async-function-start'
	},
	AsyncGeneratorAwaitReturn: {
		url: 'https://262.ecma-international.org/15.0/#sec-asyncgeneratorawaitreturn'
	},
	AsyncGeneratorCompleteStep: {
		url: 'https://262.ecma-international.org/15.0/#sec-asyncgeneratorcompletestep'
	},
	AsyncGeneratorDrainQueue: {
		url: 'https://262.ecma-international.org/15.0/#sec-asyncgeneratordrainqueue'
	},
	AsyncGeneratorEnqueue: {
		url: 'https://262.ecma-international.org/15.0/#sec-asyncgeneratorenqueue'
	},
	AsyncGeneratorResume: {
		url: 'https://262.ecma-international.org/15.0/#sec-asyncgeneratorresume'
	},
	AsyncGeneratorStart: {
		url: 'https://262.ecma-international.org/15.0/#sec-asyncgeneratorstart'
	},
	AsyncGeneratorUnwrapYieldResumption: {
		url: 'https://262.ecma-international.org/15.0/#sec-asyncgeneratorunwrapyieldresumption'
	},
	AsyncGeneratorValidate: {
		url: 'https://262.ecma-international.org/15.0/#sec-asyncgeneratorvalidate'
	},
	AsyncGeneratorYield: {
		url: 'https://262.ecma-international.org/15.0/#sec-asyncgeneratoryield'
	},
	AsyncIteratorClose: {
		url: 'https://262.ecma-international.org/15.0/#sec-asynciteratorclose'
	},
	AsyncModuleExecutionFulfilled: {
		url: 'https://262.ecma-international.org/15.0/#sec-async-module-execution-fulfilled'
	},
	AsyncModuleExecutionRejected: {
		url: 'https://262.ecma-international.org/15.0/#sec-async-module-execution-rejected'
	},
	AtomicCompareExchangeInSharedBlock: {
		url: 'https://262.ecma-international.org/15.0/#sec-atomiccompareexchangeinsharedblock'
	},
	AtomicReadModifyWrite: {
		url: 'https://262.ecma-international.org/15.0/#sec-atomicreadmodifywrite'
	},
	AvailableNamedTimeZoneIdentifiers: {
		url: 'https://262.ecma-international.org/15.0/#sec-availablenamedtimezoneidentifiers'
	},
	Await: {
		url: 'https://262.ecma-international.org/15.0/#await'
	},
	BackreferenceMatcher: {
		url: 'https://262.ecma-international.org/15.0/#sec-backreference-matcher'
	},
	'BigInt::add': {
		url: 'https://262.ecma-international.org/15.0/#sec-numeric-types-bigint-add'
	},
	'BigInt::bitwiseAND': {
		url: 'https://262.ecma-international.org/15.0/#sec-numeric-types-bigint-bitwiseAND'
	},
	'BigInt::bitwiseNOT': {
		url: 'https://262.ecma-international.org/15.0/#sec-numeric-types-bigint-bitwiseNOT'
	},
	'BigInt::bitwiseOR': {
		url: 'https://262.ecma-international.org/15.0/#sec-numeric-types-bigint-bitwiseOR'
	},
	'BigInt::bitwiseXOR': {
		url: 'https://262.ecma-international.org/15.0/#sec-numeric-types-bigint-bitwiseXOR'
	},
	'BigInt::divide': {
		url: 'https://262.ecma-international.org/15.0/#sec-numeric-types-bigint-divide'
	},
	'BigInt::equal': {
		url: 'https://262.ecma-international.org/15.0/#sec-numeric-types-bigint-equal'
	},
	'BigInt::exponentiate': {
		url: 'https://262.ecma-international.org/15.0/#sec-numeric-types-bigint-exponentiate'
	},
	'BigInt::leftShift': {
		url: 'https://262.ecma-international.org/15.0/#sec-numeric-types-bigint-leftShift'
	},
	'BigInt::lessThan': {
		url: 'https://262.ecma-international.org/15.0/#sec-numeric-types-bigint-lessThan'
	},
	'BigInt::multiply': {
		url: 'https://262.ecma-international.org/15.0/#sec-numeric-types-bigint-multiply'
	},
	'BigInt::remainder': {
		url: 'https://262.ecma-international.org/15.0/#sec-numeric-types-bigint-remainder'
	},
	'BigInt::signedRightShift': {
		url: 'https://262.ecma-international.org/15.0/#sec-numeric-types-bigint-signedRightShift'
	},
	'BigInt::subtract': {
		url: 'https://262.ecma-international.org/15.0/#sec-numeric-types-bigint-subtract'
	},
	'BigInt::toString': {
		url: 'https://262.ecma-international.org/15.0/#sec-numeric-types-bigint-tostring'
	},
	'BigInt::unaryMinus': {
		url: 'https://262.ecma-international.org/15.0/#sec-numeric-types-bigint-unaryMinus'
	},
	'BigInt::unsignedRightShift': {
		url: 'https://262.ecma-international.org/15.0/#sec-numeric-types-bigint-unsignedRightShift'
	},
	BigIntBitwiseOp: {
		url: 'https://262.ecma-international.org/15.0/#sec-bigintbitwiseop'
	},
	BinaryAnd: {
		url: 'https://262.ecma-international.org/15.0/#sec-binaryand'
	},
	BinaryOr: {
		url: 'https://262.ecma-international.org/15.0/#sec-binaryor'
	},
	BinaryXor: {
		url: 'https://262.ecma-international.org/15.0/#sec-binaryxor'
	},
	BlockDeclarationInstantiation: {
		url: 'https://262.ecma-international.org/15.0/#sec-blockdeclarationinstantiation'
	},
	BoundFunctionCreate: {
		url: 'https://262.ecma-international.org/15.0/#sec-boundfunctioncreate'
	},
	BuiltinCallOrConstruct: {
		url: 'https://262.ecma-international.org/15.0/#sec-builtincallorconstruct'
	},
	ByteListBitwiseOp: {
		url: 'https://262.ecma-international.org/15.0/#sec-bytelistbitwiseop'
	},
	ByteListEqual: {
		url: 'https://262.ecma-international.org/15.0/#sec-bytelistequal'
	},
	Call: {
		url: 'https://262.ecma-international.org/15.0/#sec-call'
	},
	CanBeHeldWeakly: {
		url: 'https://262.ecma-international.org/15.0/#sec-canbeheldweakly'
	},
	Canonicalize: {
		url: 'https://262.ecma-international.org/15.0/#sec-runtime-semantics-canonicalize-ch'
	},
	CanonicalNumericIndexString: {
		url: 'https://262.ecma-international.org/15.0/#sec-canonicalnumericindexstring'
	},
	CaseClauseIsSelected: {
		url: 'https://262.ecma-international.org/15.0/#sec-runtime-semantics-caseclauseisselected'
	},
	CharacterComplement: {
		url: 'https://262.ecma-international.org/15.0/#sec-charactercomplement'
	},
	CharacterRange: {
		url: 'https://262.ecma-international.org/15.0/#sec-runtime-semantics-characterrange-abstract-operation'
	},
	CharacterRangeOrUnion: {
		url: 'https://262.ecma-international.org/15.0/#sec-runtime-semantics-characterrangeorunion-abstract-operation'
	},
	CharacterSetMatcher: {
		url: 'https://262.ecma-international.org/15.0/#sec-runtime-semantics-charactersetmatcher-abstract-operation'
	},
	clamp: {
		url: 'https://262.ecma-international.org/15.0/#clamping'
	},
	CleanupFinalizationRegistry: {
		url: 'https://262.ecma-international.org/15.0/#sec-cleanup-finalization-registry'
	},
	ClearKeptObjects: {
		url: 'https://262.ecma-international.org/15.0/#sec-clear-kept-objects'
	},
	CloneArrayBuffer: {
		url: 'https://262.ecma-international.org/15.0/#sec-clonearraybuffer'
	},
	CodePointAt: {
		url: 'https://262.ecma-international.org/15.0/#sec-codepointat'
	},
	CodePointsToString: {
		url: 'https://262.ecma-international.org/15.0/#sec-codepointstostring'
	},
	CompareArrayElements: {
		url: 'https://262.ecma-international.org/15.0/#sec-comparearrayelements'
	},
	CompareTypedArrayElements: {
		url: 'https://262.ecma-international.org/15.0/#sec-comparetypedarrayelements'
	},
	CompletePropertyDescriptor: {
		url: 'https://262.ecma-international.org/15.0/#sec-completepropertydescriptor'
	},
	Completion: {
		url: 'https://262.ecma-international.org/15.0/#sec-completion-ao'
	},
	CompletionRecord: {
		url: 'https://262.ecma-international.org/15.0/#sec-completion-record-specification-type'
	},
	ComposeWriteEventBytes: {
		url: 'https://262.ecma-international.org/15.0/#sec-composewriteeventbytes'
	},
	Construct: {
		url: 'https://262.ecma-international.org/15.0/#sec-construct'
	},
	ContinueDynamicImport: {
		url: 'https://262.ecma-international.org/15.0/#sec-ContinueDynamicImport'
	},
	ContinueModuleLoading: {
		url: 'https://262.ecma-international.org/15.0/#sec-ContinueModuleLoading'
	},
	CopyDataBlockBytes: {
		url: 'https://262.ecma-international.org/15.0/#sec-copydatablockbytes'
	},
	CopyDataProperties: {
		url: 'https://262.ecma-international.org/15.0/#sec-copydataproperties'
	},
	CountLeftCapturingParensBefore: {
		url: 'https://262.ecma-international.org/15.0/#sec-countleftcapturingparensbefore'
	},
	CountLeftCapturingParensWithin: {
		url: 'https://262.ecma-international.org/15.0/#sec-countleftcapturingparenswithin'
	},
	CreateArrayFromList: {
		url: 'https://262.ecma-international.org/15.0/#sec-createarrayfromlist'
	},
	CreateArrayIterator: {
		url: 'https://262.ecma-international.org/15.0/#sec-createarrayiterator'
	},
	CreateAsyncFromSyncIterator: {
		url: 'https://262.ecma-international.org/15.0/#sec-createasyncfromsynciterator'
	},
	CreateAsyncIteratorFromClosure: {
		url: 'https://262.ecma-international.org/15.0/#sec-createasynciteratorfromclosure'
	},
	CreateBuiltinFunction: {
		url: 'https://262.ecma-international.org/15.0/#sec-createbuiltinfunction'
	},
	CreateByteDataBlock: {
		url: 'https://262.ecma-international.org/15.0/#sec-createbytedatablock'
	},
	CreateDataProperty: {
		url: 'https://262.ecma-international.org/15.0/#sec-createdataproperty'
	},
	CreateDataPropertyOrThrow: {
		url: 'https://262.ecma-international.org/15.0/#sec-createdatapropertyorthrow'
	},
	CreateDynamicFunction: {
		url: 'https://262.ecma-international.org/15.0/#sec-createdynamicfunction'
	},
	CreateForInIterator: {
		url: 'https://262.ecma-international.org/15.0/#sec-createforiniterator'
	},
	CreateHTML: {
		url: 'https://262.ecma-international.org/15.0/#sec-createhtml'
	},
	CreateIntrinsics: {
		url: 'https://262.ecma-international.org/15.0/#sec-createintrinsics'
	},
	CreateIteratorFromClosure: {
		url: 'https://262.ecma-international.org/15.0/#sec-createiteratorfromclosure'
	},
	CreateIterResultObject: {
		url: 'https://262.ecma-international.org/15.0/#sec-createiterresultobject'
	},
	CreateListFromArrayLike: {
		url: 'https://262.ecma-international.org/15.0/#sec-createlistfromarraylike'
	},
	CreateListIteratorRecord: {
		url: 'https://262.ecma-international.org/15.0/#sec-createlistiteratorRecord'
	},
	CreateMapIterator: {
		url: 'https://262.ecma-international.org/15.0/#sec-createmapiterator'
	},
	CreateMappedArgumentsObject: {
		url: 'https://262.ecma-international.org/15.0/#sec-createmappedargumentsobject'
	},
	CreateNonEnumerableDataPropertyOrThrow: {
		url: 'https://262.ecma-international.org/15.0/#sec-createnonenumerabledatapropertyorthrow'
	},
	CreatePerIterationEnvironment: {
		url: 'https://262.ecma-international.org/15.0/#sec-createperiterationenvironment'
	},
	CreateRealm: {
		url: 'https://262.ecma-international.org/15.0/#sec-createrealm'
	},
	CreateRegExpStringIterator: {
		url: 'https://262.ecma-international.org/15.0/#sec-createregexpstringiterator'
	},
	CreateResolvingFunctions: {
		url: 'https://262.ecma-international.org/15.0/#sec-createresolvingfunctions'
	},
	CreateSetIterator: {
		url: 'https://262.ecma-international.org/15.0/#sec-createsetiterator'
	},
	CreateSharedByteDataBlock: {
		url: 'https://262.ecma-international.org/15.0/#sec-createsharedbytedatablock'
	},
	CreateUnmappedArgumentsObject: {
		url: 'https://262.ecma-international.org/15.0/#sec-createunmappedargumentsobject'
	},
	DateFromTime: {
		url: 'https://262.ecma-international.org/15.0/#sec-datefromtime'
	},
	DateString: {
		url: 'https://262.ecma-international.org/15.0/#sec-datestring'
	},
	Day: {
		url: 'https://262.ecma-international.org/15.0/#sec-day'
	},
	DayFromYear: {
		url: 'https://262.ecma-international.org/15.0/#sec-dayfromyear'
	},
	DaysInYear: {
		url: 'https://262.ecma-international.org/15.0/#sec-daysinyear'
	},
	DayWithinYear: {
		url: 'https://262.ecma-international.org/15.0/#sec-daywithinyear'
	},
	Decode: {
		url: 'https://262.ecma-international.org/15.0/#sec-decode'
	},
	DefineField: {
		url: 'https://262.ecma-international.org/15.0/#sec-definefield'
	},
	DefineMethodProperty: {
		url: 'https://262.ecma-international.org/15.0/#sec-definemethodproperty'
	},
	DefinePropertyOrThrow: {
		url: 'https://262.ecma-international.org/15.0/#sec-definepropertyorthrow'
	},
	DeletePropertyOrThrow: {
		url: 'https://262.ecma-international.org/15.0/#sec-deletepropertyorthrow'
	},
	DetachArrayBuffer: {
		url: 'https://262.ecma-international.org/15.0/#sec-detacharraybuffer'
	},
	DoWait: {
		url: 'https://262.ecma-international.org/15.0/#sec-dowait'
	},
	EmptyMatcher: {
		url: 'https://262.ecma-international.org/15.0/#sec-emptymatcher'
	},
	Encode: {
		url: 'https://262.ecma-international.org/15.0/#sec-encode'
	},
	EnqueueAtomicsWaitAsyncTimeoutJob: {
		url: 'https://262.ecma-international.org/15.0/#sec-enqueueatomicswaitasynctimeoutjob'
	},
	EnqueueResolveInAgentJob: {
		url: 'https://262.ecma-international.org/15.0/#sec-enqueueresolveinagentjob'
	},
	EnterCriticalSection: {
		url: 'https://262.ecma-international.org/15.0/#sec-entercriticalsection'
	},
	EnumerableOwnProperties: {
		url: 'https://262.ecma-international.org/15.0/#sec-enumerableownproperties'
	},
	EnumerateObjectProperties: {
		url: 'https://262.ecma-international.org/15.0/#sec-enumerate-object-properties'
	},
	EscapeRegExpPattern: {
		url: 'https://262.ecma-international.org/15.0/#sec-escaperegexppattern'
	},
	EvalDeclarationInstantiation: {
		url: 'https://262.ecma-international.org/15.0/#sec-evaldeclarationinstantiation'
	},
	EvaluateCall: {
		url: 'https://262.ecma-international.org/15.0/#sec-evaluatecall'
	},
	EvaluateNew: {
		url: 'https://262.ecma-international.org/15.0/#sec-evaluatenew'
	},
	EvaluatePropertyAccessWithExpressionKey: {
		url: 'https://262.ecma-international.org/15.0/#sec-evaluate-property-access-with-expression-key'
	},
	EvaluatePropertyAccessWithIdentifierKey: {
		url: 'https://262.ecma-international.org/15.0/#sec-evaluate-property-access-with-identifier-key'
	},
	EvaluateStringOrNumericBinaryExpression: {
		url: 'https://262.ecma-international.org/15.0/#sec-evaluatestringornumericbinaryexpression'
	},
	EventSet: {
		url: 'https://262.ecma-international.org/15.0/#sec-event-set'
	},
	ExecuteAsyncModule: {
		url: 'https://262.ecma-international.org/15.0/#sec-execute-async-module'
	},
	'𝔽': {
		url: 'https://262.ecma-international.org/15.0/#𝔽'
	},
	FindViaPredicate: {
		url: 'https://262.ecma-international.org/15.0/#sec-findviapredicate'
	},
	FinishLoadingImportedModule: {
		url: 'https://262.ecma-international.org/15.0/#sec-FinishLoadingImportedModule'
	},
	FlattenIntoArray: {
		url: 'https://262.ecma-international.org/15.0/#sec-flattenintoarray'
	},
	floor: {
		url: 'https://262.ecma-international.org/15.0/#eqn-floor'
	},
	ForBodyEvaluation: {
		url: 'https://262.ecma-international.org/15.0/#sec-forbodyevaluation'
	},
	'ForIn/OfBodyEvaluation': {
		url: 'https://262.ecma-international.org/15.0/#sec-runtime-semantics-forin-div-ofbodyevaluation-lhs-stmt-iterator-lhskind-labelset'
	},
	'ForIn/OfHeadEvaluation': {
		url: 'https://262.ecma-international.org/15.0/#sec-runtime-semantics-forinofheadevaluation'
	},
	FromPropertyDescriptor: {
		url: 'https://262.ecma-international.org/15.0/#sec-frompropertydescriptor'
	},
	FulfillPromise: {
		url: 'https://262.ecma-international.org/15.0/#sec-fulfillpromise'
	},
	FunctionDeclarationInstantiation: {
		url: 'https://262.ecma-international.org/15.0/#sec-functiondeclarationinstantiation'
	},
	GatherAvailableAncestors: {
		url: 'https://262.ecma-international.org/15.0/#sec-gather-available-ancestors'
	},
	GeneratorResume: {
		url: 'https://262.ecma-international.org/15.0/#sec-generatorresume'
	},
	GeneratorResumeAbrupt: {
		url: 'https://262.ecma-international.org/15.0/#sec-generatorresumeabrupt'
	},
	GeneratorStart: {
		url: 'https://262.ecma-international.org/15.0/#sec-generatorstart'
	},
	GeneratorValidate: {
		url: 'https://262.ecma-international.org/15.0/#sec-generatorvalidate'
	},
	GeneratorYield: {
		url: 'https://262.ecma-international.org/15.0/#sec-generatoryield'
	},
	Get: {
		url: 'https://262.ecma-international.org/15.0/#sec-get-o-p'
	},
	GetActiveScriptOrModule: {
		url: 'https://262.ecma-international.org/15.0/#sec-getactivescriptormodule'
	},
	GetArrayBufferMaxByteLengthOption: {
		url: 'https://262.ecma-international.org/15.0/#sec-getarraybuffermaxbytelengthoption'
	},
	GetFunctionRealm: {
		url: 'https://262.ecma-international.org/15.0/#sec-getfunctionrealm'
	},
	GetGeneratorKind: {
		url: 'https://262.ecma-international.org/15.0/#sec-getgeneratorkind'
	},
	GetGlobalObject: {
		url: 'https://262.ecma-international.org/15.0/#sec-getglobalobject'
	},
	GetIdentifierReference: {
		url: 'https://262.ecma-international.org/15.0/#sec-getidentifierreference'
	},
	GetImportedModule: {
		url: 'https://262.ecma-international.org/15.0/#sec-GetImportedModule'
	},
	GetIterator: {
		url: 'https://262.ecma-international.org/15.0/#sec-getiterator'
	},
	GetIteratorFromMethod: {
		url: 'https://262.ecma-international.org/15.0/#sec-getiteratorfrommethod'
	},
	GetMatchIndexPair: {
		url: 'https://262.ecma-international.org/15.0/#sec-getmatchindexpair'
	},
	GetMatchString: {
		url: 'https://262.ecma-international.org/15.0/#sec-getmatchstring'
	},
	GetMethod: {
		url: 'https://262.ecma-international.org/15.0/#sec-getmethod'
	},
	GetModifySetValueInBuffer: {
		url: 'https://262.ecma-international.org/15.0/#sec-getmodifysetvalueinbuffer'
	},
	GetModuleNamespace: {
		url: 'https://262.ecma-international.org/15.0/#sec-getmodulenamespace'
	},
	GetNamedTimeZoneEpochNanoseconds: {
		url: 'https://262.ecma-international.org/15.0/#sec-getnamedtimezoneepochnanoseconds'
	},
	GetNamedTimeZoneOffsetNanoseconds: {
		url: 'https://262.ecma-international.org/15.0/#sec-getnamedtimezoneoffsetnanoseconds'
	},
	GetNewTarget: {
		url: 'https://262.ecma-international.org/15.0/#sec-getnewtarget'
	},
	GetOwnPropertyKeys: {
		url: 'https://262.ecma-international.org/15.0/#sec-getownpropertykeys'
	},
	GetPromiseResolve: {
		url: 'https://262.ecma-international.org/15.0/#sec-getpromiseresolve'
	},
	GetPrototypeFromConstructor: {
		url: 'https://262.ecma-international.org/15.0/#sec-getprototypefromconstructor'
	},
	GetRawBytesFromSharedBlock: {
		url: 'https://262.ecma-international.org/15.0/#sec-getrawbytesfromsharedblock'
	},
	GetStringIndex: {
		url: 'https://262.ecma-international.org/15.0/#sec-getstringindex'
	},
	GetSubstitution: {
		url: 'https://262.ecma-international.org/15.0/#sec-getsubstitution'
	},
	GetSuperConstructor: {
		url: 'https://262.ecma-international.org/15.0/#sec-getsuperconstructor'
	},
	GetTemplateObject: {
		url: 'https://262.ecma-international.org/15.0/#sec-gettemplateobject'
	},
	GetThisEnvironment: {
		url: 'https://262.ecma-international.org/15.0/#sec-getthisenvironment'
	},
	GetThisValue: {
		url: 'https://262.ecma-international.org/15.0/#sec-getthisvalue'
	},
	GetUTCEpochNanoseconds: {
		url: 'https://262.ecma-international.org/15.0/#sec-getutcepochnanoseconds'
	},
	GetV: {
		url: 'https://262.ecma-international.org/15.0/#sec-getv'
	},
	GetValue: {
		url: 'https://262.ecma-international.org/15.0/#sec-getvalue'
	},
	GetValueFromBuffer: {
		url: 'https://262.ecma-international.org/15.0/#sec-getvaluefrombuffer'
	},
	GetViewByteLength: {
		url: 'https://262.ecma-international.org/15.0/#sec-getviewbytelength'
	},
	GetViewValue: {
		url: 'https://262.ecma-international.org/15.0/#sec-getviewvalue'
	},
	GetWaiterList: {
		url: 'https://262.ecma-international.org/15.0/#sec-getwaiterlist'
	},
	GlobalDeclarationInstantiation: {
		url: 'https://262.ecma-international.org/15.0/#sec-globaldeclarationinstantiation'
	},
	GroupBy: {
		url: 'https://262.ecma-international.org/15.0/#sec-groupby'
	},
	GroupSpecifiersThatMatch: {
		url: 'https://262.ecma-international.org/15.0/#sec-groupspecifiersthatmatch'
	},
	'happens-before': {
		url: 'https://262.ecma-international.org/15.0/#sec-happens-before'
	},
	HasEitherUnicodeFlag: {
		url: 'https://262.ecma-international.org/15.0/#sec-runtime-semantics-haseitherunicodeflag-abstract-operation'
	},
	HasOwnProperty: {
		url: 'https://262.ecma-international.org/15.0/#sec-hasownproperty'
	},
	HasProperty: {
		url: 'https://262.ecma-international.org/15.0/#sec-hasproperty'
	},
	'host-synchronizes-with': {
		url: 'https://262.ecma-international.org/15.0/#sec-host-synchronizes-with'
	},
	HostEventSet: {
		url: 'https://262.ecma-international.org/15.0/#sec-hosteventset'
	},
	HourFromTime: {
		url: 'https://262.ecma-international.org/15.0/#sec-hourfromtime'
	},
	IfAbruptCloseIterator: {
		url: 'https://262.ecma-international.org/15.0/#sec-ifabruptcloseiterator'
	},
	IfAbruptRejectPromise: {
		url: 'https://262.ecma-international.org/15.0/#sec-ifabruptrejectpromise'
	},
	ImportedLocalNames: {
		url: 'https://262.ecma-international.org/15.0/#sec-importedlocalnames'
	},
	InitializeBoundName: {
		url: 'https://262.ecma-international.org/15.0/#sec-initializeboundname'
	},
	InitializeHostDefinedRealm: {
		url: 'https://262.ecma-international.org/15.0/#sec-initializehostdefinedrealm'
	},
	InitializeInstanceElements: {
		url: 'https://262.ecma-international.org/15.0/#sec-initializeinstanceelements'
	},
	InitializeReferencedBinding: {
		url: 'https://262.ecma-international.org/15.0/#sec-initializereferencedbinding'
	},
	InitializeTypedArrayFromArrayBuffer: {
		url: 'https://262.ecma-international.org/15.0/#sec-initializetypedarrayfromarraybuffer'
	},
	InitializeTypedArrayFromArrayLike: {
		url: 'https://262.ecma-international.org/15.0/#sec-initializetypedarrayfromarraylike'
	},
	InitializeTypedArrayFromList: {
		url: 'https://262.ecma-international.org/15.0/#sec-initializetypedarrayfromlist'
	},
	InitializeTypedArrayFromTypedArray: {
		url: 'https://262.ecma-international.org/15.0/#sec-initializetypedarrayfromtypedarray'
	},
	InLeapYear: {
		url: 'https://262.ecma-international.org/15.0/#sec-inleapyear'
	},
	InnerModuleEvaluation: {
		url: 'https://262.ecma-international.org/15.0/#sec-innermoduleevaluation'
	},
	InnerModuleLinking: {
		url: 'https://262.ecma-international.org/15.0/#sec-InnerModuleLinking'
	},
	InnerModuleLoading: {
		url: 'https://262.ecma-international.org/15.0/#sec-InnerModuleLoading'
	},
	InstallErrorCause: {
		url: 'https://262.ecma-international.org/15.0/#sec-installerrorcause'
	},
	InstanceofOperator: {
		url: 'https://262.ecma-international.org/15.0/#sec-instanceofoperator'
	},
	InternalizeJSONProperty: {
		url: 'https://262.ecma-international.org/15.0/#sec-internalizejsonproperty'
	},
	Invoke: {
		url: 'https://262.ecma-international.org/15.0/#sec-invoke'
	},
	IsAccessorDescriptor: {
		url: 'https://262.ecma-international.org/15.0/#sec-isaccessordescriptor'
	},
	IsAnonymousFunctionDefinition: {
		url: 'https://262.ecma-international.org/15.0/#sec-isanonymousfunctiondefinition'
	},
	IsArray: {
		url: 'https://262.ecma-international.org/15.0/#sec-isarray'
	},
	IsArrayBufferViewOutOfBounds: {
		url: 'https://262.ecma-international.org/15.0/#sec-isarraybufferviewoutofbounds'
	},
	IsBigIntElementType: {
		url: 'https://262.ecma-international.org/15.0/#sec-isbigintelementtype'
	},
	IsCallable: {
		url: 'https://262.ecma-international.org/15.0/#sec-iscallable'
	},
	IsCompatiblePropertyDescriptor: {
		url: 'https://262.ecma-international.org/15.0/#sec-iscompatiblepropertydescriptor'
	},
	IsConcatSpreadable: {
		url: 'https://262.ecma-international.org/15.0/#sec-isconcatspreadable'
	},
	IsConstructor: {
		url: 'https://262.ecma-international.org/15.0/#sec-isconstructor'
	},
	IsDataDescriptor: {
		url: 'https://262.ecma-international.org/15.0/#sec-isdatadescriptor'
	},
	IsDetachedBuffer: {
		url: 'https://262.ecma-international.org/15.0/#sec-isdetachedbuffer'
	},
	IsExtensible: {
		url: 'https://262.ecma-international.org/15.0/#sec-isextensible-o'
	},
	IsFixedLengthArrayBuffer: {
		url: 'https://262.ecma-international.org/15.0/#sec-isfixedlengtharraybuffer'
	},
	IsGenericDescriptor: {
		url: 'https://262.ecma-international.org/15.0/#sec-isgenericdescriptor'
	},
	IsInTailPosition: {
		url: 'https://262.ecma-international.org/15.0/#sec-isintailposition'
	},
	IsIntegralNumber: {
		url: 'https://262.ecma-international.org/15.0/#sec-isintegralnumber'
	},
	IsLabelledFunction: {
		url: 'https://262.ecma-international.org/15.0/#sec-islabelledfunction'
	},
	IsLessThan: {
		url: 'https://262.ecma-international.org/15.0/#sec-islessthan'
	},
	IsLooselyEqual: {
		url: 'https://262.ecma-international.org/15.0/#sec-islooselyequal'
	},
	IsNoTearConfiguration: {
		url: 'https://262.ecma-international.org/15.0/#sec-isnotearconfiguration'
	},
	IsPrivateReference: {
		url: 'https://262.ecma-international.org/15.0/#sec-isprivatereference'
	},
	IsPromise: {
		url: 'https://262.ecma-international.org/15.0/#sec-ispromise'
	},
	IsPropertyKey: {
		url: 'https://262.ecma-international.org/15.0/#sec-ispropertykey'
	},
	IsPropertyReference: {
		url: 'https://262.ecma-international.org/15.0/#sec-ispropertyreference'
	},
	IsRegExp: {
		url: 'https://262.ecma-international.org/15.0/#sec-isregexp'
	},
	IsSharedArrayBuffer: {
		url: 'https://262.ecma-international.org/15.0/#sec-issharedarraybuffer'
	},
	IsStrictlyEqual: {
		url: 'https://262.ecma-international.org/15.0/#sec-isstrictlyequal'
	},
	IsStringWellFormedUnicode: {
		url: 'https://262.ecma-international.org/15.0/#sec-isstringwellformedunicode'
	},
	IsSuperReference: {
		url: 'https://262.ecma-international.org/15.0/#sec-issuperreference'
	},
	IsTimeZoneOffsetString: {
		url: 'https://262.ecma-international.org/15.0/#sec-istimezoneoffsetstring'
	},
	IsTypedArrayOutOfBounds: {
		url: 'https://262.ecma-international.org/15.0/#sec-istypedarrayoutofbounds'
	},
	IsUnclampedIntegerElementType: {
		url: 'https://262.ecma-international.org/15.0/#sec-isunclampedintegerelementtype'
	},
	IsUnresolvableReference: {
		url: 'https://262.ecma-international.org/15.0/#sec-isunresolvablereference'
	},
	IsUnsignedElementType: {
		url: 'https://262.ecma-international.org/15.0/#sec-isunsignedelementtype'
	},
	IsValidIntegerIndex: {
		url: 'https://262.ecma-international.org/15.0/#sec-isvalidintegerindex'
	},
	IsValidRegularExpressionLiteral: {
		url: 'https://262.ecma-international.org/15.0/#sec-isvalidregularexpressionliteral'
	},
	IsViewOutOfBounds: {
		url: 'https://262.ecma-international.org/15.0/#sec-isviewoutofbounds'
	},
	IsWordChar: {
		url: 'https://262.ecma-international.org/15.0/#sec-runtime-semantics-iswordchar-abstract-operation'
	},
	IteratorClose: {
		url: 'https://262.ecma-international.org/15.0/#sec-iteratorclose'
	},
	IteratorComplete: {
		url: 'https://262.ecma-international.org/15.0/#sec-iteratorcomplete'
	},
	IteratorNext: {
		url: 'https://262.ecma-international.org/15.0/#sec-iteratornext'
	},
	IteratorStep: {
		url: 'https://262.ecma-international.org/15.0/#sec-iteratorstep'
	},
	IteratorStepValue: {
		url: 'https://262.ecma-international.org/15.0/#sec-iteratorstepvalue'
	},
	IteratorToList: {
		url: 'https://262.ecma-international.org/15.0/#sec-iteratortolist'
	},
	IteratorValue: {
		url: 'https://262.ecma-international.org/15.0/#sec-iteratorvalue'
	},
	KeyForSymbol: {
		url: 'https://262.ecma-international.org/15.0/#sec-keyforsymbol'
	},
	LeaveCriticalSection: {
		url: 'https://262.ecma-international.org/15.0/#sec-leavecriticalsection'
	},
	LengthOfArrayLike: {
		url: 'https://262.ecma-international.org/15.0/#sec-lengthofarraylike'
	},
	LocalTime: {
		url: 'https://262.ecma-international.org/15.0/#sec-localtime'
	},
	LoopContinues: {
		url: 'https://262.ecma-international.org/15.0/#sec-loopcontinues'
	},
	MakeArgGetter: {
		url: 'https://262.ecma-international.org/15.0/#sec-makearggetter'
	},
	MakeArgSetter: {
		url: 'https://262.ecma-international.org/15.0/#sec-makeargsetter'
	},
	MakeBasicObject: {
		url: 'https://262.ecma-international.org/15.0/#sec-makebasicobject'
	},
	MakeClassConstructor: {
		url: 'https://262.ecma-international.org/15.0/#sec-makeclassconstructor'
	},
	MakeConstructor: {
		url: 'https://262.ecma-international.org/15.0/#sec-makeconstructor'
	},
	MakeDataViewWithBufferWitnessRecord: {
		url: 'https://262.ecma-international.org/15.0/#sec-makedataviewwithbufferwitnessrecord'
	},
	MakeDate: {
		url: 'https://262.ecma-international.org/15.0/#sec-makedate'
	},
	MakeDay: {
		url: 'https://262.ecma-international.org/15.0/#sec-makeday'
	},
	MakeFullYear: {
		url: 'https://262.ecma-international.org/15.0/#sec-makefullyear'
	},
	MakeMatchIndicesIndexPairArray: {
		url: 'https://262.ecma-international.org/15.0/#sec-makematchindicesindexpairarray'
	},
	MakeMethod: {
		url: 'https://262.ecma-international.org/15.0/#sec-makemethod'
	},
	MakePrivateReference: {
		url: 'https://262.ecma-international.org/15.0/#sec-makeprivatereference'
	},
	MakeSuperPropertyReference: {
		url: 'https://262.ecma-international.org/15.0/#sec-makesuperpropertyreference'
	},
	MakeTime: {
		url: 'https://262.ecma-international.org/15.0/#sec-maketime'
	},
	MakeTypedArrayWithBufferWitnessRecord: {
		url: 'https://262.ecma-international.org/15.0/#sec-maketypedarraywithbufferwitnessrecord'
	},
	MatchSequence: {
		url: 'https://262.ecma-international.org/15.0/#sec-matchsequence'
	},
	MatchTwoAlternatives: {
		url: 'https://262.ecma-international.org/15.0/#sec-matchtwoalternatives'
	},
	max: {
		url: 'https://262.ecma-international.org/15.0/#eqn-max'
	},
	MaybeSimpleCaseFolding: {
		url: 'https://262.ecma-international.org/15.0/#sec-maybesimplecasefolding'
	},
	'memory-order': {
		url: 'https://262.ecma-international.org/15.0/#sec-memory-order'
	},
	min: {
		url: 'https://262.ecma-international.org/15.0/#eqn-min'
	},
	MinFromTime: {
		url: 'https://262.ecma-international.org/15.0/#sec-minfromtime'
	},
	ModuleNamespaceCreate: {
		url: 'https://262.ecma-international.org/15.0/#sec-modulenamespacecreate'
	},
	modulo: {
		url: 'https://262.ecma-international.org/15.0/#eqn-modulo'
	},
	MonthFromTime: {
		url: 'https://262.ecma-international.org/15.0/#sec-monthfromtime'
	},
	msFromTime: {
		url: 'https://262.ecma-international.org/15.0/#sec-msfromtime'
	},
	NewDeclarativeEnvironment: {
		url: 'https://262.ecma-international.org/15.0/#sec-newdeclarativeenvironment'
	},
	NewFunctionEnvironment: {
		url: 'https://262.ecma-international.org/15.0/#sec-newfunctionenvironment'
	},
	NewGlobalEnvironment: {
		url: 'https://262.ecma-international.org/15.0/#sec-newglobalenvironment'
	},
	NewModuleEnvironment: {
		url: 'https://262.ecma-international.org/15.0/#sec-newmoduleenvironment'
	},
	NewObjectEnvironment: {
		url: 'https://262.ecma-international.org/15.0/#sec-newobjectenvironment'
	},
	NewPrivateEnvironment: {
		url: 'https://262.ecma-international.org/15.0/#sec-newprivateenvironment'
	},
	NewPromiseCapability: {
		url: 'https://262.ecma-international.org/15.0/#sec-newpromisecapability'
	},
	NewPromiseReactionJob: {
		url: 'https://262.ecma-international.org/15.0/#sec-newpromisereactionjob'
	},
	NewPromiseResolveThenableJob: {
		url: 'https://262.ecma-international.org/15.0/#sec-newpromiseresolvethenablejob'
	},
	NormalCompletion: {
		url: 'https://262.ecma-international.org/15.0/#sec-normalcompletion'
	},
	NotifyWaiter: {
		url: 'https://262.ecma-international.org/15.0/#sec-notifywaiter'
	},
	'Number::add': {
		url: 'https://262.ecma-international.org/15.0/#sec-numeric-types-number-add'
	},
	'Number::bitwiseAND': {
		url: 'https://262.ecma-international.org/15.0/#sec-numeric-types-number-bitwiseAND'
	},
	'Number::bitwiseNOT': {
		url: 'https://262.ecma-international.org/15.0/#sec-numeric-types-number-bitwiseNOT'
	},
	'Number::bitwiseOR': {
		url: 'https://262.ecma-international.org/15.0/#sec-numeric-types-number-bitwiseOR'
	},
	'Number::bitwiseXOR': {
		url: 'https://262.ecma-international.org/15.0/#sec-numeric-types-number-bitwiseXOR'
	},
	'Number::divide': {
		url: 'https://262.ecma-international.org/15.0/#sec-numeric-types-number-divide'
	},
	'Number::equal': {
		url: 'https://262.ecma-international.org/15.0/#sec-numeric-types-number-equal'
	},
	'Number::exponentiate': {
		url: 'https://262.ecma-international.org/15.0/#sec-numeric-types-number-exponentiate'
	},
	'Number::leftShift': {
		url: 'https://262.ecma-international.org/15.0/#sec-numeric-types-number-leftShift'
	},
	'Number::lessThan': {
		url: 'https://262.ecma-international.org/15.0/#sec-numeric-types-number-lessThan'
	},
	'Number::multiply': {
		url: 'https://262.ecma-international.org/15.0/#sec-numeric-types-number-multiply'
	},
	'Number::remainder': {
		url: 'https://262.ecma-international.org/15.0/#sec-numeric-types-number-remainder'
	},
	'Number::sameValue': {
		url: 'https://262.ecma-international.org/15.0/#sec-numeric-types-number-sameValue'
	},
	'Number::sameValueZero': {
		url: 'https://262.ecma-international.org/15.0/#sec-numeric-types-number-sameValueZero'
	},
	'Number::signedRightShift': {
		url: 'https://262.ecma-international.org/15.0/#sec-numeric-types-number-signedRightShift'
	},
	'Number::subtract': {
		url: 'https://262.ecma-international.org/15.0/#sec-numeric-types-number-subtract'
	},
	'Number::toString': {
		url: 'https://262.ecma-international.org/15.0/#sec-numeric-types-number-tostring'
	},
	'Number::unaryMinus': {
		url: 'https://262.ecma-international.org/15.0/#sec-numeric-types-number-unaryMinus'
	},
	'Number::unsignedRightShift': {
		url: 'https://262.ecma-international.org/15.0/#sec-numeric-types-number-unsignedRightShift'
	},
	NumberBitwiseOp: {
		url: 'https://262.ecma-international.org/15.0/#sec-numberbitwiseop'
	},
	NumberToBigInt: {
		url: 'https://262.ecma-international.org/15.0/#sec-numbertobigint'
	},
	NumericToRawBytes: {
		url: 'https://262.ecma-international.org/15.0/#sec-numerictorawbytes'
	},
	ObjectDefineProperties: {
		url: 'https://262.ecma-international.org/15.0/#sec-objectdefineproperties'
	},
	OrdinaryCallBindThis: {
		url: 'https://262.ecma-international.org/15.0/#sec-ordinarycallbindthis'
	},
	OrdinaryCallEvaluateBody: {
		url: 'https://262.ecma-international.org/15.0/#sec-ordinarycallevaluatebody'
	},
	OrdinaryCreateFromConstructor: {
		url: 'https://262.ecma-international.org/15.0/#sec-ordinarycreatefromconstructor'
	},
	OrdinaryDefineOwnProperty: {
		url: 'https://262.ecma-international.org/15.0/#sec-ordinarydefineownproperty'
	},
	OrdinaryDelete: {
		url: 'https://262.ecma-international.org/15.0/#sec-ordinarydelete'
	},
	OrdinaryFunctionCreate: {
		url: 'https://262.ecma-international.org/15.0/#sec-ordinaryfunctioncreate'
	},
	OrdinaryGet: {
		url: 'https://262.ecma-international.org/15.0/#sec-ordinaryget'
	},
	OrdinaryGetOwnProperty: {
		url: 'https://262.ecma-international.org/15.0/#sec-ordinarygetownproperty'
	},
	OrdinaryGetPrototypeOf: {
		url: 'https://262.ecma-international.org/15.0/#sec-ordinarygetprototypeof'
	},
	OrdinaryHasInstance: {
		url: 'https://262.ecma-international.org/15.0/#sec-ordinaryhasinstance'
	},
	OrdinaryHasProperty: {
		url: 'https://262.ecma-international.org/15.0/#sec-ordinaryhasproperty'
	},
	OrdinaryIsExtensible: {
		url: 'https://262.ecma-international.org/15.0/#sec-ordinaryisextensible'
	},
	OrdinaryObjectCreate: {
		url: 'https://262.ecma-international.org/15.0/#sec-ordinaryobjectcreate'
	},
	OrdinaryOwnPropertyKeys: {
		url: 'https://262.ecma-international.org/15.0/#sec-ordinaryownpropertykeys'
	},
	OrdinaryPreventExtensions: {
		url: 'https://262.ecma-international.org/15.0/#sec-ordinarypreventextensions'
	},
	OrdinarySet: {
		url: 'https://262.ecma-international.org/15.0/#sec-ordinaryset'
	},
	OrdinarySetPrototypeOf: {
		url: 'https://262.ecma-international.org/15.0/#sec-ordinarysetprototypeof'
	},
	OrdinarySetWithOwnDescriptor: {
		url: 'https://262.ecma-international.org/15.0/#sec-ordinarysetwithowndescriptor'
	},
	OrdinaryToPrimitive: {
		url: 'https://262.ecma-international.org/15.0/#sec-ordinarytoprimitive'
	},
	ParseHexOctet: {
		url: 'https://262.ecma-international.org/15.0/#sec-parsehexoctet'
	},
	ParseModule: {
		url: 'https://262.ecma-international.org/15.0/#sec-parsemodule'
	},
	ParsePattern: {
		url: 'https://262.ecma-international.org/15.0/#sec-parsepattern'
	},
	ParseScript: {
		url: 'https://262.ecma-international.org/15.0/#sec-parse-script'
	},
	ParseText: {
		url: 'https://262.ecma-international.org/15.0/#sec-parsetext'
	},
	ParseTimeZoneOffsetString: {
		url: 'https://262.ecma-international.org/15.0/#sec-parsetimezoneoffsetstring'
	},
	PerformEval: {
		url: 'https://262.ecma-international.org/15.0/#sec-performeval'
	},
	PerformPromiseAll: {
		url: 'https://262.ecma-international.org/15.0/#sec-performpromiseall'
	},
	PerformPromiseAllSettled: {
		url: 'https://262.ecma-international.org/15.0/#sec-performpromiseallsettled'
	},
	PerformPromiseAny: {
		url: 'https://262.ecma-international.org/15.0/#sec-performpromiseany'
	},
	PerformPromiseRace: {
		url: 'https://262.ecma-international.org/15.0/#sec-performpromiserace'
	},
	PerformPromiseThen: {
		url: 'https://262.ecma-international.org/15.0/#sec-performpromisethen'
	},
	PrepareForOrdinaryCall: {
		url: 'https://262.ecma-international.org/15.0/#sec-prepareforordinarycall'
	},
	PrepareForTailCall: {
		url: 'https://262.ecma-international.org/15.0/#sec-preparefortailcall'
	},
	PrivateElementFind: {
		url: 'https://262.ecma-international.org/15.0/#sec-privateelementfind'
	},
	PrivateFieldAdd: {
		url: 'https://262.ecma-international.org/15.0/#sec-privatefieldadd'
	},
	PrivateGet: {
		url: 'https://262.ecma-international.org/15.0/#sec-privateget'
	},
	PrivateMethodOrAccessorAdd: {
		url: 'https://262.ecma-international.org/15.0/#sec-privatemethodoraccessoradd'
	},
	PrivateSet: {
		url: 'https://262.ecma-international.org/15.0/#sec-privateset'
	},
	PromiseResolve: {
		url: 'https://262.ecma-international.org/15.0/#sec-promise-resolve'
	},
	ProxyCreate: {
		url: 'https://262.ecma-international.org/15.0/#sec-proxycreate'
	},
	PutValue: {
		url: 'https://262.ecma-international.org/15.0/#sec-putvalue'
	},
	QuoteJSONString: {
		url: 'https://262.ecma-international.org/15.0/#sec-quotejsonstring'
	},
	ℝ: {
		url: 'https://262.ecma-international.org/15.0/#ℝ'
	},
	RawBytesToNumeric: {
		url: 'https://262.ecma-international.org/15.0/#sec-rawbytestonumeric'
	},
	'reads-bytes-from': {
		url: 'https://262.ecma-international.org/15.0/#sec-reads-bytes-from'
	},
	'reads-from': {
		url: 'https://262.ecma-international.org/15.0/#sec-reads-from'
	},
	RegExpAlloc: {
		url: 'https://262.ecma-international.org/15.0/#sec-regexpalloc'
	},
	RegExpBuiltinExec: {
		url: 'https://262.ecma-international.org/15.0/#sec-regexpbuiltinexec'
	},
	RegExpCreate: {
		url: 'https://262.ecma-international.org/15.0/#sec-regexpcreate'
	},
	RegExpExec: {
		url: 'https://262.ecma-international.org/15.0/#sec-regexpexec'
	},
	RegExpHasFlag: {
		url: 'https://262.ecma-international.org/15.0/#sec-regexphasflag'
	},
	RegExpInitialize: {
		url: 'https://262.ecma-international.org/15.0/#sec-regexpinitialize'
	},
	RejectPromise: {
		url: 'https://262.ecma-international.org/15.0/#sec-rejectpromise'
	},
	RemoveWaiter: {
		url: 'https://262.ecma-international.org/15.0/#sec-removewaiter'
	},
	RemoveWaiters: {
		url: 'https://262.ecma-international.org/15.0/#sec-removewaiters'
	},
	RepeatMatcher: {
		url: 'https://262.ecma-international.org/15.0/#sec-runtime-semantics-repeatmatcher-abstract-operation'
	},
	RequireInternalSlot: {
		url: 'https://262.ecma-international.org/15.0/#sec-requireinternalslot'
	},
	RequireObjectCoercible: {
		url: 'https://262.ecma-international.org/15.0/#sec-requireobjectcoercible'
	},
	ResolveBinding: {
		url: 'https://262.ecma-international.org/15.0/#sec-resolvebinding'
	},
	ResolvePrivateIdentifier: {
		url: 'https://262.ecma-international.org/15.0/#sec-resolve-private-identifier'
	},
	ResolveThisBinding: {
		url: 'https://262.ecma-international.org/15.0/#sec-resolvethisbinding'
	},
	ReturnIfAbrupt: {
		url: 'https://262.ecma-international.org/15.0/#sec-returnifabrupt'
	},
	RevalidateAtomicAccess: {
		url: 'https://262.ecma-international.org/15.0/#sec-revalidateatomicaccess'
	},
	RoundMVResult: {
		url: 'https://262.ecma-international.org/15.0/#sec-roundmvresult'
	},
	SameValue: {
		url: 'https://262.ecma-international.org/15.0/#sec-samevalue'
	},
	SameValueNonNumber: {
		url: 'https://262.ecma-international.org/15.0/#sec-samevaluenonnumber'
	},
	SameValueZero: {
		url: 'https://262.ecma-international.org/15.0/#sec-samevaluezero'
	},
	scf: {
		url: 'https://262.ecma-international.org/15.0/#eqn-scf'
	},
	ScriptEvaluation: {
		url: 'https://262.ecma-international.org/15.0/#sec-runtime-semantics-scriptevaluation'
	},
	SecFromTime: {
		url: 'https://262.ecma-international.org/15.0/#sec-secfromtime'
	},
	SerializeJSONArray: {
		url: 'https://262.ecma-international.org/15.0/#sec-serializejsonarray'
	},
	SerializeJSONObject: {
		url: 'https://262.ecma-international.org/15.0/#sec-serializejsonobject'
	},
	SerializeJSONProperty: {
		url: 'https://262.ecma-international.org/15.0/#sec-serializejsonproperty'
	},
	Set: {
		url: 'https://262.ecma-international.org/15.0/#sec-set-o-p-v-throw'
	},
	SetDefaultGlobalBindings: {
		url: 'https://262.ecma-international.org/15.0/#sec-setdefaultglobalbindings'
	},
	SetFunctionLength: {
		url: 'https://262.ecma-international.org/15.0/#sec-setfunctionlength'
	},
	SetFunctionName: {
		url: 'https://262.ecma-international.org/15.0/#sec-setfunctionname'
	},
	SetImmutablePrototype: {
		url: 'https://262.ecma-international.org/15.0/#sec-set-immutable-prototype'
	},
	SetIntegrityLevel: {
		url: 'https://262.ecma-international.org/15.0/#sec-setintegritylevel'
	},
	SetRealmGlobalObject: {
		url: 'https://262.ecma-international.org/15.0/#sec-setrealmglobalobject'
	},
	SetTypedArrayFromArrayLike: {
		url: 'https://262.ecma-international.org/15.0/#sec-settypedarrayfromarraylike'
	},
	SetTypedArrayFromTypedArray: {
		url: 'https://262.ecma-international.org/15.0/#sec-settypedarrayfromtypedarray'
	},
	SetValueInBuffer: {
		url: 'https://262.ecma-international.org/15.0/#sec-setvalueinbuffer'
	},
	SetViewValue: {
		url: 'https://262.ecma-international.org/15.0/#sec-setviewvalue'
	},
	SharedDataBlockEventSet: {
		url: 'https://262.ecma-international.org/15.0/#sec-sharedatablockeventset'
	},
	SortIndexedProperties: {
		url: 'https://262.ecma-international.org/15.0/#sec-sortindexedproperties'
	},
	SpeciesConstructor: {
		url: 'https://262.ecma-international.org/15.0/#sec-speciesconstructor'
	},
	StringCreate: {
		url: 'https://262.ecma-international.org/15.0/#sec-stringcreate'
	},
	StringGetOwnProperty: {
		url: 'https://262.ecma-international.org/15.0/#sec-stringgetownproperty'
	},
	StringIndexOf: {
		url: 'https://262.ecma-international.org/15.0/#sec-stringindexof'
	},
	StringPad: {
		url: 'https://262.ecma-international.org/15.0/#sec-stringpad'
	},
	StringPaddingBuiltinsImpl: {
		url: 'https://262.ecma-international.org/15.0/#sec-stringpaddingbuiltinsimpl'
	},
	StringToBigInt: {
		url: 'https://262.ecma-international.org/15.0/#sec-stringtobigint'
	},
	StringToCodePoints: {
		url: 'https://262.ecma-international.org/15.0/#sec-stringtocodepoints'
	},
	StringToNumber: {
		url: 'https://262.ecma-international.org/15.0/#sec-stringtonumber'
	},
	substring: {
		url: 'https://262.ecma-international.org/15.0/#substring'
	},
	SuspendThisAgent: {
		url: 'https://262.ecma-international.org/15.0/#sec-suspendthisagent'
	},
	SymbolDescriptiveString: {
		url: 'https://262.ecma-international.org/15.0/#sec-symboldescriptivestring'
	},
	'synchronizes-with': {
		url: 'https://262.ecma-international.org/15.0/#sec-synchronizes-with'
	},
	SystemTimeZoneIdentifier: {
		url: 'https://262.ecma-international.org/15.0/#sec-systemtimezoneidentifier'
	},
	TemplateString: {
		url: 'https://262.ecma-international.org/15.0/#sec-templatestring'
	},
	TestIntegrityLevel: {
		url: 'https://262.ecma-international.org/15.0/#sec-testintegritylevel'
	},
	ThisBigIntValue: {
		url: 'https://262.ecma-international.org/15.0/#sec-thisbigintvalue'
	},
	ThisBooleanValue: {
		url: 'https://262.ecma-international.org/15.0/#sec-thisbooleanvalue'
	},
	ThisNumberValue: {
		url: 'https://262.ecma-international.org/15.0/#sec-thisnumbervalue'
	},
	ThisStringValue: {
		url: 'https://262.ecma-international.org/15.0/#sec-thisstringvalue'
	},
	ThisSymbolValue: {
		url: 'https://262.ecma-international.org/15.0/#sec-thissymbolvalue'
	},
	ThrowCompletion: {
		url: 'https://262.ecma-international.org/15.0/#sec-throwcompletion'
	},
	TimeClip: {
		url: 'https://262.ecma-international.org/15.0/#sec-timeclip'
	},
	TimeFromYear: {
		url: 'https://262.ecma-international.org/15.0/#sec-timefromyear'
	},
	TimeString: {
		url: 'https://262.ecma-international.org/15.0/#sec-timestring'
	},
	TimeWithinDay: {
		url: 'https://262.ecma-international.org/15.0/#sec-timewithinday'
	},
	TimeZoneString: {
		url: 'https://262.ecma-international.org/15.0/#sec-timezoneestring'
	},
	ToBigInt: {
		url: 'https://262.ecma-international.org/15.0/#sec-tobigint'
	},
	ToBigInt64: {
		url: 'https://262.ecma-international.org/15.0/#sec-tobigint64'
	},
	ToBigUint64: {
		url: 'https://262.ecma-international.org/15.0/#sec-tobiguint64'
	},
	ToBoolean: {
		url: 'https://262.ecma-international.org/15.0/#sec-toboolean'
	},
	ToDateString: {
		url: 'https://262.ecma-international.org/15.0/#sec-todatestring'
	},
	ToIndex: {
		url: 'https://262.ecma-international.org/15.0/#sec-toindex'
	},
	ToInt16: {
		url: 'https://262.ecma-international.org/15.0/#sec-toint16'
	},
	ToInt32: {
		url: 'https://262.ecma-international.org/15.0/#sec-toint32'
	},
	ToInt8: {
		url: 'https://262.ecma-international.org/15.0/#sec-toint8'
	},
	ToIntegerOrInfinity: {
		url: 'https://262.ecma-international.org/15.0/#sec-tointegerorinfinity'
	},
	ToLength: {
		url: 'https://262.ecma-international.org/15.0/#sec-tolength'
	},
	ToNumber: {
		url: 'https://262.ecma-international.org/15.0/#sec-tonumber'
	},
	ToNumeric: {
		url: 'https://262.ecma-international.org/15.0/#sec-tonumeric'
	},
	ToObject: {
		url: 'https://262.ecma-international.org/15.0/#sec-toobject'
	},
	ToPrimitive: {
		url: 'https://262.ecma-international.org/15.0/#sec-toprimitive'
	},
	ToPropertyDescriptor: {
		url: 'https://262.ecma-international.org/15.0/#sec-topropertydescriptor'
	},
	ToPropertyKey: {
		url: 'https://262.ecma-international.org/15.0/#sec-topropertykey'
	},
	ToString: {
		url: 'https://262.ecma-international.org/15.0/#sec-tostring'
	},
	ToUint16: {
		url: 'https://262.ecma-international.org/15.0/#sec-touint16'
	},
	ToUint32: {
		url: 'https://262.ecma-international.org/15.0/#sec-touint32'
	},
	ToUint8: {
		url: 'https://262.ecma-international.org/15.0/#sec-touint8'
	},
	ToUint8Clamp: {
		url: 'https://262.ecma-international.org/15.0/#sec-touint8clamp'
	},
	ToZeroPaddedDecimalString: {
		url: 'https://262.ecma-international.org/15.0/#sec-tozeropaddeddecimalstring'
	},
	TriggerPromiseReactions: {
		url: 'https://262.ecma-international.org/15.0/#sec-triggerpromisereactions'
	},
	TrimString: {
		url: 'https://262.ecma-international.org/15.0/#sec-trimstring'
	},
	truncate: {
		url: 'https://262.ecma-international.org/15.0/#eqn-truncate'
	},
	Type: {
		url: 'https://262.ecma-international.org/15.0/#sec-ecmascript-data-types-and-values'
	},
	TypedArrayByteLength: {
		url: 'https://262.ecma-international.org/15.0/#sec-typedarraybytelength'
	},
	TypedArrayCreate: {
		url: 'https://262.ecma-international.org/15.0/#sec-typedarraycreate'
	},
	TypedArrayCreateFromConstructor: {
		url: 'https://262.ecma-international.org/15.0/#sec-typedarraycreatefromconstructor'
	},
	TypedArrayCreateSameType: {
		url: 'https://262.ecma-international.org/15.0/#sec-typedarray-create-same-type'
	},
	TypedArrayElementSize: {
		url: 'https://262.ecma-international.org/15.0/#sec-typedarrayelementsize'
	},
	TypedArrayElementType: {
		url: 'https://262.ecma-international.org/15.0/#sec-typedarrayelementtype'
	},
	TypedArrayGetElement: {
		url: 'https://262.ecma-international.org/15.0/#sec-typedarraygetelement'
	},
	TypedArrayLength: {
		url: 'https://262.ecma-international.org/15.0/#sec-typedarraylength'
	},
	TypedArraySetElement: {
		url: 'https://262.ecma-international.org/15.0/#sec-typedarraysetelement'
	},
	TypedArraySpeciesCreate: {
		url: 'https://262.ecma-international.org/15.0/#typedarray-species-create'
	},
	UnicodeEscape: {
		url: 'https://262.ecma-international.org/15.0/#sec-unicodeescape'
	},
	UnicodeMatchProperty: {
		url: 'https://262.ecma-international.org/15.0/#sec-runtime-semantics-unicodematchproperty-p'
	},
	UnicodeMatchPropertyValue: {
		url: 'https://262.ecma-international.org/15.0/#sec-runtime-semantics-unicodematchpropertyvalue-p-v'
	},
	UpdateEmpty: {
		url: 'https://262.ecma-international.org/15.0/#sec-updateempty'
	},
	UTC: {
		url: 'https://262.ecma-international.org/15.0/#sec-utc-t'
	},
	UTF16EncodeCodePoint: {
		url: 'https://262.ecma-international.org/15.0/#sec-utf16encodecodepoint'
	},
	UTF16SurrogatePairToCodePoint: {
		url: 'https://262.ecma-international.org/15.0/#sec-utf16decodesurrogatepair'
	},
	ValidateAndApplyPropertyDescriptor: {
		url: 'https://262.ecma-international.org/15.0/#sec-validateandapplypropertydescriptor'
	},
	ValidateAtomicAccess: {
		url: 'https://262.ecma-international.org/15.0/#sec-validateatomicaccess'
	},
	ValidateAtomicAccessOnIntegerTypedArray: {
		url: 'https://262.ecma-international.org/15.0/#sec-validateatomicaccessonintegertypedarray'
	},
	ValidateIntegerTypedArray: {
		url: 'https://262.ecma-international.org/15.0/#sec-validateintegertypedarray'
	},
	ValidateNonRevokedProxy: {
		url: 'https://262.ecma-international.org/15.0/#sec-validatenonrevokedproxy'
	},
	ValidateTypedArray: {
		url: 'https://262.ecma-international.org/15.0/#sec-validatetypedarray'
	},
	ValueOfReadEvent: {
		url: 'https://262.ecma-international.org/15.0/#sec-valueofreadevent'
	},
	WeakRefDeref: {
		url: 'https://262.ecma-international.org/15.0/#sec-weakrefderef'
	},
	WeekDay: {
		url: 'https://262.ecma-international.org/15.0/#sec-weekday'
	},
	WordCharacters: {
		url: 'https://262.ecma-international.org/15.0/#sec-wordcharacters'
	},
	YearFromTime: {
		url: 'https://262.ecma-international.org/15.0/#sec-yearfromtime'
	},
	Yield: {
		url: 'https://262.ecma-international.org/15.0/#sec-yield'
	},
	ℤ: {
		url: 'https://262.ecma-international.org/15.0/#ℤ'
	}
};
'use strict';

module.exports = {
	abs: {
		url: 'https://262.ecma-international.org/16.0/#eqn-abs'
	},
	AddEntriesFromIterable: {
		url: 'https://262.ecma-international.org/16.0/#sec-add-entries-from-iterable'
	},
	AddRestrictedFunctionProperties: {
		url: 'https://262.ecma-international.org/16.0/#sec-addrestrictedfunctionproperties'
	},
	AddToKeptObjects: {
		url: 'https://262.ecma-international.org/16.0/#sec-addtokeptobjects'
	},
	AddValueToKeyedGroup: {
		url: 'https://262.ecma-international.org/16.0/#sec-add-value-to-keyed-group'
	},
	AddWaiter: {
		url: 'https://262.ecma-international.org/16.0/#sec-addwaiter'
	},
	AdvanceStringIndex: {
		url: 'https://262.ecma-international.org/16.0/#sec-advancestringindex'
	},
	AgentCanSuspend: {
		url: 'https://262.ecma-international.org/16.0/#sec-agentcansuspend'
	},
	AgentSignifier: {
		url: 'https://262.ecma-international.org/16.0/#sec-agentsignifier'
	},
	AllCharacters: {
		url: 'https://262.ecma-international.org/16.0/#sec-allcharacters'
	},
	AllImportAttributesSupported: {
		url: 'https://262.ecma-international.org/16.0/#sec-AllImportAttributesSupported'
	},
	AllocateArrayBuffer: {
		url: 'https://262.ecma-international.org/16.0/#sec-allocatearraybuffer'
	},
	AllocateSharedArrayBuffer: {
		url: 'https://262.ecma-international.org/16.0/#sec-allocatesharedarraybuffer'
	},
	AllocateTypedArray: {
		url: 'https://262.ecma-international.org/16.0/#sec-allocatetypedarray'
	},
	AllocateTypedArrayBuffer: {
		url: 'https://262.ecma-international.org/16.0/#sec-allocatetypedarraybuffer'
	},
	ApplyStringOrNumericBinaryOperator: {
		url: 'https://262.ecma-international.org/16.0/#sec-applystringornumericbinaryoperator'
	},
	ArrayBufferByteLength: {
		url: 'https://262.ecma-international.org/16.0/#sec-arraybufferbytelength'
	},
	ArrayBufferCopyAndDetach: {
		url: 'https://262.ecma-international.org/16.0/#sec-arraybuffercopyanddetach'
	},
	ArrayCreate: {
		url: 'https://262.ecma-international.org/16.0/#sec-arraycreate'
	},
	ArraySetLength: {
		url: 'https://262.ecma-international.org/16.0/#sec-arraysetlength'
	},
	ArraySpeciesCreate: {
		url: 'https://262.ecma-international.org/16.0/#sec-arrayspeciescreate'
	},
	AsyncBlockStart: {
		url: 'https://262.ecma-international.org/16.0/#sec-asyncblockstart'
	},
	AsyncFromSyncIteratorContinuation: {
		url: 'https://262.ecma-international.org/16.0/#sec-asyncfromsynciteratorcontinuation'
	},
	AsyncFunctionStart: {
		url: 'https://262.ecma-international.org/16.0/#sec-async-functions-abstract-operations-async-function-start'
	},
	AsyncGeneratorAwaitReturn: {
		url: 'https://262.ecma-international.org/16.0/#sec-asyncgeneratorawaitreturn'
	},
	AsyncGeneratorCompleteStep: {
		url: 'https://262.ecma-international.org/16.0/#sec-asyncgeneratorcompletestep'
	},
	AsyncGeneratorDrainQueue: {
		url: 'https://262.ecma-international.org/16.0/#sec-asyncgeneratordrainqueue'
	},
	AsyncGeneratorEnqueue: {
		url: 'https://262.ecma-international.org/16.0/#sec-asyncgeneratorenqueue'
	},
	AsyncGeneratorResume: {
		url: 'https://262.ecma-international.org/16.0/#sec-asyncgeneratorresume'
	},
	AsyncGeneratorStart: {
		url: 'https://262.ecma-international.org/16.0/#sec-asyncgeneratorstart'
	},
	AsyncGeneratorUnwrapYieldResumption: {
		url: 'https://262.ecma-international.org/16.0/#sec-asyncgeneratorunwrapyieldresumption'
	},
	AsyncGeneratorValidate: {
		url: 'https://262.ecma-international.org/16.0/#sec-asyncgeneratorvalidate'
	},
	AsyncGeneratorYield: {
		url: 'https://262.ecma-international.org/16.0/#sec-asyncgeneratoryield'
	},
	AsyncIteratorClose: {
		url: 'https://262.ecma-international.org/16.0/#sec-asynciteratorclose'
	},
	AsyncModuleExecutionFulfilled: {
		url: 'https://262.ecma-international.org/16.0/#sec-async-module-execution-fulfilled'
	},
	AsyncModuleExecutionRejected: {
		url: 'https://262.ecma-international.org/16.0/#sec-async-module-execution-rejected'
	},
	AtomicCompareExchangeInSharedBlock: {
		url: 'https://262.ecma-international.org/16.0/#sec-atomiccompareexchangeinsharedblock'
	},
	AtomicReadModifyWrite: {
		url: 'https://262.ecma-international.org/16.0/#sec-atomicreadmodifywrite'
	},
	AvailableNamedTimeZoneIdentifiers: {
		url: 'https://262.ecma-international.org/16.0/#sec-availablenamedtimezoneidentifiers'
	},
	Await: {
		url: 'https://262.ecma-international.org/16.0/#await'
	},
	BackreferenceMatcher: {
		url: 'https://262.ecma-international.org/16.0/#sec-backreference-matcher'
	},
	'BigInt::add': {
		url: 'https://262.ecma-international.org/16.0/#sec-numeric-types-bigint-add'
	},
	'BigInt::bitwiseAND': {
		url: 'https://262.ecma-international.org/16.0/#sec-numeric-types-bigint-bitwiseAND'
	},
	'BigInt::bitwiseNOT': {
		url: 'https://262.ecma-international.org/16.0/#sec-numeric-types-bigint-bitwiseNOT'
	},
	'BigInt::bitwiseOR': {
		url: 'https://262.ecma-international.org/16.0/#sec-numeric-types-bigint-bitwiseOR'
	},
	'BigInt::bitwiseXOR': {
		url: 'https://262.ecma-international.org/16.0/#sec-numeric-types-bigint-bitwiseXOR'
	},
	'BigInt::divide': {
		url: 'https://262.ecma-international.org/16.0/#sec-numeric-types-bigint-divide'
	},
	'BigInt::equal': {
		url: 'https://262.ecma-international.org/16.0/#sec-numeric-types-bigint-equal'
	},
	'BigInt::exponentiate': {
		url: 'https://262.ecma-international.org/16.0/#sec-numeric-types-bigint-exponentiate'
	},
	'BigInt::leftShift': {
		url: 'https://262.ecma-international.org/16.0/#sec-numeric-types-bigint-leftShift'
	},
	'BigInt::lessThan': {
		url: 'https://262.ecma-international.org/16.0/#sec-numeric-types-bigint-lessThan'
	},
	'BigInt::multiply': {
		url: 'https://262.ecma-international.org/16.0/#sec-numeric-types-bigint-multiply'
	},
	'BigInt::remainder': {
		url: 'https://262.ecma-international.org/16.0/#sec-numeric-types-bigint-remainder'
	},
	'BigInt::signedRightShift': {
		url: 'https://262.ecma-international.org/16.0/#sec-numeric-types-bigint-signedRightShift'
	},
	'BigInt::subtract': {
		url: 'https://262.ecma-international.org/16.0/#sec-numeric-types-bigint-subtract'
	},
	'BigInt::toString': {
		url: 'https://262.ecma-international.org/16.0/#sec-numeric-types-bigint-tostring'
	},
	'BigInt::unaryMinus': {
		url: 'https://262.ecma-international.org/16.0/#sec-numeric-types-bigint-unaryMinus'
	},
	'BigInt::unsignedRightShift': {
		url: 'https://262.ecma-international.org/16.0/#sec-numeric-types-bigint-unsignedRightShift'
	},
	BigIntBitwiseOp: {
		url: 'https://262.ecma-international.org/16.0/#sec-bigintbitwiseop'
	},
	BinaryAnd: {
		url: 'https://262.ecma-international.org/16.0/#sec-binaryand'
	},
	BinaryOr: {
		url: 'https://262.ecma-international.org/16.0/#sec-binaryor'
	},
	BinaryXor: {
		url: 'https://262.ecma-international.org/16.0/#sec-binaryxor'
	},
	BindThisValue: {
		url: 'https://262.ecma-international.org/16.0/#sec-bindthisvalue'
	},
	BlockDeclarationInstantiation: {
		url: 'https://262.ecma-international.org/16.0/#sec-blockdeclarationinstantiation'
	},
	BoundFunctionCreate: {
		url: 'https://262.ecma-international.org/16.0/#sec-boundfunctioncreate'
	},
	BuiltinCallOrConstruct: {
		url: 'https://262.ecma-international.org/16.0/#sec-builtincallorconstruct'
	},
	ByteListBitwiseOp: {
		url: 'https://262.ecma-international.org/16.0/#sec-bytelistbitwiseop'
	},
	ByteListEqual: {
		url: 'https://262.ecma-international.org/16.0/#sec-bytelistequal'
	},
	Call: {
		url: 'https://262.ecma-international.org/16.0/#sec-call'
	},
	CanBeHeldWeakly: {
		url: 'https://262.ecma-international.org/16.0/#sec-canbeheldweakly'
	},
	CanDeclareGlobalFunction: {
		url: 'https://262.ecma-international.org/16.0/#sec-candeclareglobalfunction'
	},
	CanDeclareGlobalVar: {
		url: 'https://262.ecma-international.org/16.0/#sec-candeclareglobalvar'
	},
	Canonicalize: {
		url: 'https://262.ecma-international.org/16.0/#sec-runtime-semantics-canonicalize-ch'
	},
	CanonicalizeKeyedCollectionKey: {
		url: 'https://262.ecma-international.org/16.0/#sec-canonicalizekeyedcollectionkey'
	},
	CanonicalNumericIndexString: {
		url: 'https://262.ecma-international.org/16.0/#sec-canonicalnumericindexstring'
	},
	CaseClauseIsSelected: {
		url: 'https://262.ecma-international.org/16.0/#sec-runtime-semantics-caseclauseisselected'
	},
	CharacterComplement: {
		url: 'https://262.ecma-international.org/16.0/#sec-charactercomplement'
	},
	CharacterRange: {
		url: 'https://262.ecma-international.org/16.0/#sec-runtime-semantics-characterrange-abstract-operation'
	},
	CharacterRangeOrUnion: {
		url: 'https://262.ecma-international.org/16.0/#sec-runtime-semantics-characterrangeorunion-abstract-operation'
	},
	CharacterSetMatcher: {
		url: 'https://262.ecma-international.org/16.0/#sec-runtime-semantics-charactersetmatcher-abstract-operation'
	},
	clamp: {
		url: 'https://262.ecma-international.org/16.0/#clamping'
	},
	CleanupFinalizationRegistry: {
		url: 'https://262.ecma-international.org/16.0/#sec-cleanup-finalization-registry'
	},
	ClearKeptObjects: {
		url: 'https://262.ecma-international.org/16.0/#sec-clear-kept-objects'
	},
	CloneArrayBuffer: {
		url: 'https://262.ecma-international.org/16.0/#sec-clonearraybuffer'
	},
	CodePointAt: {
		url: 'https://262.ecma-international.org/16.0/#sec-codepointat'
	},
	CodePointsToString: {
		url: 'https://262.ecma-international.org/16.0/#sec-codepointstostring'
	},
	CompareArrayElements: {
		url: 'https://262.ecma-international.org/16.0/#sec-comparearrayelements'
	},
	CompareTypedArrayElements: {
		url: 'https://262.ecma-international.org/16.0/#sec-comparetypedarrayelements'
	},
	CompletePropertyDescriptor: {
		url: 'https://262.ecma-international.org/16.0/#sec-completepropertydescriptor'
	},
	Completion: {
		url: 'https://262.ecma-international.org/16.0/#sec-completion-ao'
	},
	CompletionRecord: {
		url: 'https://262.ecma-international.org/16.0/#sec-completion-record-specification-type'
	},
	ComposeWriteEventBytes: {
		url: 'https://262.ecma-international.org/16.0/#sec-composewriteeventbytes'
	},
	Construct: {
		url: 'https://262.ecma-international.org/16.0/#sec-construct'
	},
	ContinueDynamicImport: {
		url: 'https://262.ecma-international.org/16.0/#sec-ContinueDynamicImport'
	},
	ContinueModuleLoading: {
		url: 'https://262.ecma-international.org/16.0/#sec-ContinueModuleLoading'
	},
	CopyDataBlockBytes: {
		url: 'https://262.ecma-international.org/16.0/#sec-copydatablockbytes'
	},
	CopyDataProperties: {
		url: 'https://262.ecma-international.org/16.0/#sec-copydataproperties'
	},
	CountLeftCapturingParensBefore: {
		url: 'https://262.ecma-international.org/16.0/#sec-countleftcapturingparensbefore'
	},
	CountLeftCapturingParensWithin: {
		url: 'https://262.ecma-international.org/16.0/#sec-countleftcapturingparenswithin'
	},
	CreateArrayFromList: {
		url: 'https://262.ecma-international.org/16.0/#sec-createarrayfromlist'
	},
	CreateArrayIterator: {
		url: 'https://262.ecma-international.org/16.0/#sec-createarrayiterator'
	},
	CreateAsyncFromSyncIterator: {
		url: 'https://262.ecma-international.org/16.0/#sec-createasyncfromsynciterator'
	},
	CreateAsyncIteratorFromClosure: {
		url: 'https://262.ecma-international.org/16.0/#sec-createasynciteratorfromclosure'
	},
	CreateBuiltinFunction: {
		url: 'https://262.ecma-international.org/16.0/#sec-createbuiltinfunction'
	},
	CreateByteDataBlock: {
		url: 'https://262.ecma-international.org/16.0/#sec-createbytedatablock'
	},
	CreateDataProperty: {
		url: 'https://262.ecma-international.org/16.0/#sec-createdataproperty'
	},
	CreateDataPropertyOrThrow: {
		url: 'https://262.ecma-international.org/16.0/#sec-createdatapropertyorthrow'
	},
	CreateDefaultExportSyntheticModule: {
		url: 'https://262.ecma-international.org/16.0/#sec-create-default-export-synthetic-module'
	},
	CreateDynamicFunction: {
		url: 'https://262.ecma-international.org/16.0/#sec-createdynamicfunction'
	},
	CreateForInIterator: {
		url: 'https://262.ecma-international.org/16.0/#sec-createforiniterator'
	},
	CreateGlobalFunctionBinding: {
		url: 'https://262.ecma-international.org/16.0/#sec-createglobalfunctionbinding'
	},
	CreateGlobalVarBinding: {
		url: 'https://262.ecma-international.org/16.0/#sec-createglobalvarbinding'
	},
	CreateHTML: {
		url: 'https://262.ecma-international.org/16.0/#sec-createhtml'
	},
	CreateImportBinding: {
		url: 'https://262.ecma-international.org/16.0/#sec-createimportbinding'
	},
	CreateIntrinsics: {
		url: 'https://262.ecma-international.org/16.0/#sec-createintrinsics'
	},
	CreateIteratorFromClosure: {
		url: 'https://262.ecma-international.org/16.0/#sec-createiteratorfromclosure'
	},
	CreateIteratorResultObject: {
		url: 'https://262.ecma-international.org/16.0/#sec-createiterresultobject'
	},
	CreateListFromArrayLike: {
		url: 'https://262.ecma-international.org/16.0/#sec-createlistfromarraylike'
	},
	CreateListIteratorRecord: {
		url: 'https://262.ecma-international.org/16.0/#sec-createlistiteratorRecord'
	},
	CreateMapIterator: {
		url: 'https://262.ecma-international.org/16.0/#sec-createmapiterator'
	},
	CreateMappedArgumentsObject: {
		url: 'https://262.ecma-international.org/16.0/#sec-createmappedargumentsobject'
	},
	CreateNonEnumerableDataPropertyOrThrow: {
		url: 'https://262.ecma-international.org/16.0/#sec-createnonenumerabledatapropertyorthrow'
	},
	CreatePerIterationEnvironment: {
		url: 'https://262.ecma-international.org/16.0/#sec-createperiterationenvironment'
	},
	CreateRegExpStringIterator: {
		url: 'https://262.ecma-international.org/16.0/#sec-createregexpstringiterator'
	},
	CreateResolvingFunctions: {
		url: 'https://262.ecma-international.org/16.0/#sec-createresolvingfunctions'
	},
	CreateSetIterator: {
		url: 'https://262.ecma-international.org/16.0/#sec-createsetiterator'
	},
	CreateSharedByteDataBlock: {
		url: 'https://262.ecma-international.org/16.0/#sec-createsharedbytedatablock'
	},
	CreateUnmappedArgumentsObject: {
		url: 'https://262.ecma-international.org/16.0/#sec-createunmappedargumentsobject'
	},
	DateFromTime: {
		url: 'https://262.ecma-international.org/16.0/#sec-datefromtime'
	},
	DateString: {
		url: 'https://262.ecma-international.org/16.0/#sec-datestring'
	},
	Day: {
		url: 'https://262.ecma-international.org/16.0/#sec-day'
	},
	DayFromYear: {
		url: 'https://262.ecma-international.org/16.0/#sec-dayfromyear'
	},
	DaysInYear: {
		url: 'https://262.ecma-international.org/16.0/#sec-daysinyear'
	},
	DayWithinYear: {
		url: 'https://262.ecma-international.org/16.0/#sec-daywithinyear'
	},
	Decode: {
		url: 'https://262.ecma-international.org/16.0/#sec-decode'
	},
	DefineField: {
		url: 'https://262.ecma-international.org/16.0/#sec-definefield'
	},
	DefineMethodProperty: {
		url: 'https://262.ecma-international.org/16.0/#sec-definemethodproperty'
	},
	DefinePropertyOrThrow: {
		url: 'https://262.ecma-international.org/16.0/#sec-definepropertyorthrow'
	},
	DeletePropertyOrThrow: {
		url: 'https://262.ecma-international.org/16.0/#sec-deletepropertyorthrow'
	},
	DetachArrayBuffer: {
		url: 'https://262.ecma-international.org/16.0/#sec-detacharraybuffer'
	},
	DoWait: {
		url: 'https://262.ecma-international.org/16.0/#sec-dowait'
	},
	EmptyMatcher: {
		url: 'https://262.ecma-international.org/16.0/#sec-emptymatcher'
	},
	Encode: {
		url: 'https://262.ecma-international.org/16.0/#sec-encode'
	},
	EncodeForRegExpEscape: {
		url: 'https://262.ecma-international.org/16.0/#sec-encodeforregexpescape'
	},
	EnqueueAtomicsWaitAsyncTimeoutJob: {
		url: 'https://262.ecma-international.org/16.0/#sec-enqueueatomicswaitasynctimeoutjob'
	},
	EnqueueResolveInAgentJob: {
		url: 'https://262.ecma-international.org/16.0/#sec-enqueueresolveinagentjob'
	},
	EnterCriticalSection: {
		url: 'https://262.ecma-international.org/16.0/#sec-entercriticalsection'
	},
	EnumerableOwnProperties: {
		url: 'https://262.ecma-international.org/16.0/#sec-enumerableownproperties'
	},
	EnumerateObjectProperties: {
		url: 'https://262.ecma-international.org/16.0/#sec-enumerate-object-properties'
	},
	EscapeRegExpPattern: {
		url: 'https://262.ecma-international.org/16.0/#sec-escaperegexppattern'
	},
	EvalDeclarationInstantiation: {
		url: 'https://262.ecma-international.org/16.0/#sec-evaldeclarationinstantiation'
	},
	EvaluateCall: {
		url: 'https://262.ecma-international.org/16.0/#sec-evaluatecall'
	},
	EvaluateImportCall: {
		url: 'https://262.ecma-international.org/16.0/#sec-evaluate-import-call'
	},
	EvaluateNew: {
		url: 'https://262.ecma-international.org/16.0/#sec-evaluatenew'
	},
	EvaluatePropertyAccessWithExpressionKey: {
		url: 'https://262.ecma-international.org/16.0/#sec-evaluate-property-access-with-expression-key'
	},
	EvaluatePropertyAccessWithIdentifierKey: {
		url: 'https://262.ecma-international.org/16.0/#sec-evaluate-property-access-with-identifier-key'
	},
	EvaluateStringOrNumericBinaryExpression: {
		url: 'https://262.ecma-international.org/16.0/#sec-evaluatestringornumericbinaryexpression'
	},
	EventSet: {
		url: 'https://262.ecma-international.org/16.0/#sec-event-set'
	},
	ExecuteAsyncModule: {
		url: 'https://262.ecma-international.org/16.0/#sec-execute-async-module'
	},
	'𝔽': {
		url: 'https://262.ecma-international.org/16.0/#𝔽'
	},
	FindViaPredicate: {
		url: 'https://262.ecma-international.org/16.0/#sec-findviapredicate'
	},
	FinishLoadingImportedModule: {
		url: 'https://262.ecma-international.org/16.0/#sec-FinishLoadingImportedModule'
	},
	FlattenIntoArray: {
		url: 'https://262.ecma-international.org/16.0/#sec-flattenintoarray'
	},
	floor: {
		url: 'https://262.ecma-international.org/16.0/#eqn-floor'
	},
	ForBodyEvaluation: {
		url: 'https://262.ecma-international.org/16.0/#sec-forbodyevaluation'
	},
	'ForIn/OfBodyEvaluation': {
		url: 'https://262.ecma-international.org/16.0/#sec-runtime-semantics-forin-div-ofbodyevaluation-lhs-stmt-iterator-lhskind-labelset'
	},
	'ForIn/OfHeadEvaluation': {
		url: 'https://262.ecma-international.org/16.0/#sec-runtime-semantics-forinofheadevaluation'
	},
	FromPropertyDescriptor: {
		url: 'https://262.ecma-international.org/16.0/#sec-frompropertydescriptor'
	},
	FulfillPromise: {
		url: 'https://262.ecma-international.org/16.0/#sec-fulfillpromise'
	},
	FunctionDeclarationInstantiation: {
		url: 'https://262.ecma-international.org/16.0/#sec-functiondeclarationinstantiation'
	},
	GatherAvailableAncestors: {
		url: 'https://262.ecma-international.org/16.0/#sec-gather-available-ancestors'
	},
	GeneratorResume: {
		url: 'https://262.ecma-international.org/16.0/#sec-generatorresume'
	},
	GeneratorResumeAbrupt: {
		url: 'https://262.ecma-international.org/16.0/#sec-generatorresumeabrupt'
	},
	GeneratorStart: {
		url: 'https://262.ecma-international.org/16.0/#sec-generatorstart'
	},
	GeneratorValidate: {
		url: 'https://262.ecma-international.org/16.0/#sec-generatorvalidate'
	},
	GeneratorYield: {
		url: 'https://262.ecma-international.org/16.0/#sec-generatoryield'
	},
	Get: {
		url: 'https://262.ecma-international.org/16.0/#sec-get-o-p'
	},
	GetActiveScriptOrModule: {
		url: 'https://262.ecma-international.org/16.0/#sec-getactivescriptormodule'
	},
	GetArrayBufferMaxByteLengthOption: {
		url: 'https://262.ecma-international.org/16.0/#sec-getarraybuffermaxbytelengthoption'
	},
	GetFunctionRealm: {
		url: 'https://262.ecma-international.org/16.0/#sec-getfunctionrealm'
	},
	GetGeneratorKind: {
		url: 'https://262.ecma-international.org/16.0/#sec-getgeneratorkind'
	},
	GetGlobalObject: {
		url: 'https://262.ecma-international.org/16.0/#sec-getglobalobject'
	},
	GetIdentifierReference: {
		url: 'https://262.ecma-international.org/16.0/#sec-getidentifierreference'
	},
	GetImportedModule: {
		url: 'https://262.ecma-international.org/16.0/#sec-GetImportedModule'
	},
	GetIterator: {
		url: 'https://262.ecma-international.org/16.0/#sec-getiterator'
	},
	GetIteratorDirect: {
		url: 'https://262.ecma-international.org/16.0/#sec-getiteratordirect'
	},
	GetIteratorFlattenable: {
		url: 'https://262.ecma-international.org/16.0/#sec-getiteratorflattenable'
	},
	GetIteratorFromMethod: {
		url: 'https://262.ecma-international.org/16.0/#sec-getiteratorfrommethod'
	},
	GetMatchIndexPair: {
		url: 'https://262.ecma-international.org/16.0/#sec-getmatchindexpair'
	},
	GetMatchString: {
		url: 'https://262.ecma-international.org/16.0/#sec-getmatchstring'
	},
	GetMethod: {
		url: 'https://262.ecma-international.org/16.0/#sec-getmethod'
	},
	GetModifySetValueInBuffer: {
		url: 'https://262.ecma-international.org/16.0/#sec-getmodifysetvalueinbuffer'
	},
	GetModuleNamespace: {
		url: 'https://262.ecma-international.org/16.0/#sec-getmodulenamespace'
	},
	GetNamedTimeZoneEpochNanoseconds: {
		url: 'https://262.ecma-international.org/16.0/#sec-getnamedtimezoneepochnanoseconds'
	},
	GetNamedTimeZoneOffsetNanoseconds: {
		url: 'https://262.ecma-international.org/16.0/#sec-getnamedtimezoneoffsetnanoseconds'
	},
	GetNewTarget: {
		url: 'https://262.ecma-international.org/16.0/#sec-getnewtarget'
	},
	GetOwnPropertyKeys: {
		url: 'https://262.ecma-international.org/16.0/#sec-getownpropertykeys'
	},
	GetPromiseResolve: {
		url: 'https://262.ecma-international.org/16.0/#sec-getpromiseresolve'
	},
	GetPrototypeFromConstructor: {
		url: 'https://262.ecma-international.org/16.0/#sec-getprototypefromconstructor'
	},
	GetRawBytesFromSharedBlock: {
		url: 'https://262.ecma-international.org/16.0/#sec-getrawbytesfromsharedblock'
	},
	GetSetRecord: {
		url: 'https://262.ecma-international.org/16.0/#sec-getsetrecord'
	},
	GetStringIndex: {
		url: 'https://262.ecma-international.org/16.0/#sec-getstringindex'
	},
	GetSubstitution: {
		url: 'https://262.ecma-international.org/16.0/#sec-getsubstitution'
	},
	GetSuperBase: {
		url: 'https://262.ecma-international.org/16.0/#sec-getsuperbase'
	},
	GetSuperConstructor: {
		url: 'https://262.ecma-international.org/16.0/#sec-getsuperconstructor'
	},
	GetTemplateObject: {
		url: 'https://262.ecma-international.org/16.0/#sec-gettemplateobject'
	},
	GetThisEnvironment: {
		url: 'https://262.ecma-international.org/16.0/#sec-getthisenvironment'
	},
	GetThisValue: {
		url: 'https://262.ecma-international.org/16.0/#sec-getthisvalue'
	},
	GetUTCEpochNanoseconds: {
		url: 'https://262.ecma-international.org/16.0/#sec-getutcepochnanoseconds'
	},
	GetV: {
		url: 'https://262.ecma-international.org/16.0/#sec-getv'
	},
	GetValue: {
		url: 'https://262.ecma-international.org/16.0/#sec-getvalue'
	},
	GetValueFromBuffer: {
		url: 'https://262.ecma-international.org/16.0/#sec-getvaluefrombuffer'
	},
	GetViewByteLength: {
		url: 'https://262.ecma-international.org/16.0/#sec-getviewbytelength'
	},
	GetViewValue: {
		url: 'https://262.ecma-international.org/16.0/#sec-getviewvalue'
	},
	GetWaiterList: {
		url: 'https://262.ecma-international.org/16.0/#sec-getwaiterlist'
	},
	GlobalDeclarationInstantiation: {
		url: 'https://262.ecma-international.org/16.0/#sec-globaldeclarationinstantiation'
	},
	GroupBy: {
		url: 'https://262.ecma-international.org/16.0/#sec-groupby'
	},
	GroupSpecifiersThatMatch: {
		url: 'https://262.ecma-international.org/16.0/#sec-groupspecifiersthatmatch'
	},
	HasEitherUnicodeFlag: {
		url: 'https://262.ecma-international.org/16.0/#sec-runtime-semantics-haseitherunicodeflag-abstract-operation'
	},
	HasLexicalDeclaration: {
		url: 'https://262.ecma-international.org/16.0/#sec-haslexicaldeclaration'
	},
	HasOwnProperty: {
		url: 'https://262.ecma-international.org/16.0/#sec-hasownproperty'
	},
	HasProperty: {
		url: 'https://262.ecma-international.org/16.0/#sec-hasproperty'
	},
	HasRestrictedGlobalProperty: {
		url: 'https://262.ecma-international.org/16.0/#sec-hasrestrictedglobalproperty'
	},
	HostEventSet: {
		url: 'https://262.ecma-international.org/16.0/#sec-hosteventset'
	},
	HourFromTime: {
		url: 'https://262.ecma-international.org/16.0/#sec-hourfromtime'
	},
	IfAbruptCloseIterator: {
		url: 'https://262.ecma-international.org/16.0/#sec-ifabruptcloseiterator'
	},
	IfAbruptRejectPromise: {
		url: 'https://262.ecma-international.org/16.0/#sec-ifabruptrejectpromise'
	},
	ImportedLocalNames: {
		url: 'https://262.ecma-international.org/16.0/#sec-importedlocalnames'
	},
	IncrementModuleAsyncEvaluationCount: {
		url: 'https://262.ecma-international.org/16.0/#sec-IncrementModuleAsyncEvaluationCount'
	},
	InitializeBoundName: {
		url: 'https://262.ecma-international.org/16.0/#sec-initializeboundname'
	},
	InitializeHostDefinedRealm: {
		url: 'https://262.ecma-international.org/16.0/#sec-initializehostdefinedrealm'
	},
	InitializeInstanceElements: {
		url: 'https://262.ecma-international.org/16.0/#sec-initializeinstanceelements'
	},
	InitializeReferencedBinding: {
		url: 'https://262.ecma-international.org/16.0/#sec-initializereferencedbinding'
	},
	InitializeTypedArrayFromArrayBuffer: {
		url: 'https://262.ecma-international.org/16.0/#sec-initializetypedarrayfromarraybuffer'
	},
	InitializeTypedArrayFromArrayLike: {
		url: 'https://262.ecma-international.org/16.0/#sec-initializetypedarrayfromarraylike'
	},
	InitializeTypedArrayFromList: {
		url: 'https://262.ecma-international.org/16.0/#sec-initializetypedarrayfromlist'
	},
	InitializeTypedArrayFromTypedArray: {
		url: 'https://262.ecma-international.org/16.0/#sec-initializetypedarrayfromtypedarray'
	},
	InLeapYear: {
		url: 'https://262.ecma-international.org/16.0/#sec-inleapyear'
	},
	InnerModuleEvaluation: {
		url: 'https://262.ecma-international.org/16.0/#sec-innermoduleevaluation'
	},
	InnerModuleLinking: {
		url: 'https://262.ecma-international.org/16.0/#sec-InnerModuleLinking'
	},
	InnerModuleLoading: {
		url: 'https://262.ecma-international.org/16.0/#sec-InnerModuleLoading'
	},
	InstallErrorCause: {
		url: 'https://262.ecma-international.org/16.0/#sec-installerrorcause'
	},
	InstanceofOperator: {
		url: 'https://262.ecma-international.org/16.0/#sec-instanceofoperator'
	},
	InternalizeJSONProperty: {
		url: 'https://262.ecma-international.org/16.0/#sec-internalizejsonproperty'
	},
	Invoke: {
		url: 'https://262.ecma-international.org/16.0/#sec-invoke'
	},
	IsAccessorDescriptor: {
		url: 'https://262.ecma-international.org/16.0/#sec-isaccessordescriptor'
	},
	IsAnonymousFunctionDefinition: {
		url: 'https://262.ecma-international.org/16.0/#sec-isanonymousfunctiondefinition'
	},
	IsArray: {
		url: 'https://262.ecma-international.org/16.0/#sec-isarray'
	},
	IsArrayBufferViewOutOfBounds: {
		url: 'https://262.ecma-international.org/16.0/#sec-isarraybufferviewoutofbounds'
	},
	IsBigIntElementType: {
		url: 'https://262.ecma-international.org/16.0/#sec-isbigintelementtype'
	},
	IsCallable: {
		url: 'https://262.ecma-international.org/16.0/#sec-iscallable'
	},
	IsCompatiblePropertyDescriptor: {
		url: 'https://262.ecma-international.org/16.0/#sec-iscompatiblepropertydescriptor'
	},
	IsConcatSpreadable: {
		url: 'https://262.ecma-international.org/16.0/#sec-isconcatspreadable'
	},
	IsConstructor: {
		url: 'https://262.ecma-international.org/16.0/#sec-isconstructor'
	},
	IsDataDescriptor: {
		url: 'https://262.ecma-international.org/16.0/#sec-isdatadescriptor'
	},
	IsDetachedBuffer: {
		url: 'https://262.ecma-international.org/16.0/#sec-isdetachedbuffer'
	},
	IsExtensible: {
		url: 'https://262.ecma-international.org/16.0/#sec-isextensible-o'
	},
	IsFixedLengthArrayBuffer: {
		url: 'https://262.ecma-international.org/16.0/#sec-isfixedlengtharraybuffer'
	},
	IsGenericDescriptor: {
		url: 'https://262.ecma-international.org/16.0/#sec-isgenericdescriptor'
	},
	IsInTailPosition: {
		url: 'https://262.ecma-international.org/16.0/#sec-isintailposition'
	},
	IsLabelledFunction: {
		url: 'https://262.ecma-international.org/16.0/#sec-islabelledfunction'
	},
	IsLessThan: {
		url: 'https://262.ecma-international.org/16.0/#sec-islessthan'
	},
	IsLooselyEqual: {
		url: 'https://262.ecma-international.org/16.0/#sec-islooselyequal'
	},
	IsNoTearConfiguration: {
		url: 'https://262.ecma-international.org/16.0/#sec-isnotearconfiguration'
	},
	IsPrivateReference: {
		url: 'https://262.ecma-international.org/16.0/#sec-isprivatereference'
	},
	IsPromise: {
		url: 'https://262.ecma-international.org/16.0/#sec-ispromise'
	},
	IsPropertyReference: {
		url: 'https://262.ecma-international.org/16.0/#sec-ispropertyreference'
	},
	IsRegExp: {
		url: 'https://262.ecma-international.org/16.0/#sec-isregexp'
	},
	IsSharedArrayBuffer: {
		url: 'https://262.ecma-international.org/16.0/#sec-issharedarraybuffer'
	},
	IsStrict: {
		url: 'https://262.ecma-international.org/16.0/#sec-isstrict'
	},
	IsStrictlyEqual: {
		url: 'https://262.ecma-international.org/16.0/#sec-isstrictlyequal'
	},
	IsStringWellFormedUnicode: {
		url: 'https://262.ecma-international.org/16.0/#sec-isstringwellformedunicode'
	},
	IsSuperReference: {
		url: 'https://262.ecma-international.org/16.0/#sec-issuperreference'
	},
	IsTimeZoneOffsetString: {
		url: 'https://262.ecma-international.org/16.0/#sec-istimezoneoffsetstring'
	},
	IsTypedArrayFixedLength: {
		url: 'https://262.ecma-international.org/16.0/#sec-istypedarrayfixedlength'
	},
	IsTypedArrayOutOfBounds: {
		url: 'https://262.ecma-international.org/16.0/#sec-istypedarrayoutofbounds'
	},
	IsUnclampedIntegerElementType: {
		url: 'https://262.ecma-international.org/16.0/#sec-isunclampedintegerelementtype'
	},
	IsUnresolvableReference: {
		url: 'https://262.ecma-international.org/16.0/#sec-isunresolvablereference'
	},
	IsUnsignedElementType: {
		url: 'https://262.ecma-international.org/16.0/#sec-isunsignedelementtype'
	},
	IsValidIntegerIndex: {
		url: 'https://262.ecma-international.org/16.0/#sec-isvalidintegerindex'
	},
	IsValidRegularExpressionLiteral: {
		url: 'https://262.ecma-international.org/16.0/#sec-isvalidregularexpressionliteral'
	},
	IsViewOutOfBounds: {
		url: 'https://262.ecma-international.org/16.0/#sec-isviewoutofbounds'
	},
	IsWordChar: {
		url: 'https://262.ecma-international.org/16.0/#sec-runtime-semantics-iswordchar-abstract-operation'
	},
	IteratorClose: {
		url: 'https://262.ecma-international.org/16.0/#sec-iteratorclose'
	},
	IteratorComplete: {
		url: 'https://262.ecma-international.org/16.0/#sec-iteratorcomplete'
	},
	IteratorNext: {
		url: 'https://262.ecma-international.org/16.0/#sec-iteratornext'
	},
	IteratorStep: {
		url: 'https://262.ecma-international.org/16.0/#sec-iteratorstep'
	},
	IteratorStepValue: {
		url: 'https://262.ecma-international.org/16.0/#sec-iteratorstepvalue'
	},
	IteratorToList: {
		url: 'https://262.ecma-international.org/16.0/#sec-iteratortolist'
	},
	IteratorValue: {
		url: 'https://262.ecma-international.org/16.0/#sec-iteratorvalue'
	},
	KeyForSymbol: {
		url: 'https://262.ecma-international.org/16.0/#sec-keyforsymbol'
	},
	LeaveCriticalSection: {
		url: 'https://262.ecma-international.org/16.0/#sec-leavecriticalsection'
	},
	LengthOfArrayLike: {
		url: 'https://262.ecma-international.org/16.0/#sec-lengthofarraylike'
	},
	LocalTime: {
		url: 'https://262.ecma-international.org/16.0/#sec-localtime'
	},
	LoopContinues: {
		url: 'https://262.ecma-international.org/16.0/#sec-loopcontinues'
	},
	MakeArgGetter: {
		url: 'https://262.ecma-international.org/16.0/#sec-makearggetter'
	},
	MakeArgSetter: {
		url: 'https://262.ecma-international.org/16.0/#sec-makeargsetter'
	},
	MakeBasicObject: {
		url: 'https://262.ecma-international.org/16.0/#sec-makebasicobject'
	},
	MakeClassConstructor: {
		url: 'https://262.ecma-international.org/16.0/#sec-makeclassconstructor'
	},
	MakeConstructor: {
		url: 'https://262.ecma-international.org/16.0/#sec-makeconstructor'
	},
	MakeDataViewWithBufferWitnessRecord: {
		url: 'https://262.ecma-international.org/16.0/#sec-makedataviewwithbufferwitnessrecord'
	},
	MakeDate: {
		url: 'https://262.ecma-international.org/16.0/#sec-makedate'
	},
	MakeDay: {
		url: 'https://262.ecma-international.org/16.0/#sec-makeday'
	},
	MakeFullYear: {
		url: 'https://262.ecma-international.org/16.0/#sec-makefullyear'
	},
	MakeMatchIndicesIndexPairArray: {
		url: 'https://262.ecma-international.org/16.0/#sec-makematchindicesindexpairarray'
	},
	MakeMethod: {
		url: 'https://262.ecma-international.org/16.0/#sec-makemethod'
	},
	MakePrivateReference: {
		url: 'https://262.ecma-international.org/16.0/#sec-makeprivatereference'
	},
	MakeSuperPropertyReference: {
		url: 'https://262.ecma-international.org/16.0/#sec-makesuperpropertyreference'
	},
	MakeTime: {
		url: 'https://262.ecma-international.org/16.0/#sec-maketime'
	},
	MakeTypedArrayWithBufferWitnessRecord: {
		url: 'https://262.ecma-international.org/16.0/#sec-maketypedarraywithbufferwitnessrecord'
	},
	MatchSequence: {
		url: 'https://262.ecma-international.org/16.0/#sec-matchsequence'
	},
	MatchTwoAlternatives: {
		url: 'https://262.ecma-international.org/16.0/#sec-matchtwoalternatives'
	},
	max: {
		url: 'https://262.ecma-international.org/16.0/#eqn-max'
	},
	MaybeSimpleCaseFolding: {
		url: 'https://262.ecma-international.org/16.0/#sec-maybesimplecasefolding'
	},
	MightBothParticipate: {
		url: 'https://262.ecma-international.org/16.0/#sec-mightbothparticipate'
	},
	min: {
		url: 'https://262.ecma-international.org/16.0/#eqn-min'
	},
	MinFromTime: {
		url: 'https://262.ecma-international.org/16.0/#sec-minfromtime'
	},
	ModuleNamespaceCreate: {
		url: 'https://262.ecma-international.org/16.0/#sec-modulenamespacecreate'
	},
	ModuleRequestsEqual: {
		url: 'https://262.ecma-international.org/16.0/#sec-ModuleRequestsEqual'
	},
	modulo: {
		url: 'https://262.ecma-international.org/16.0/#eqn-modulo'
	},
	MonthFromTime: {
		url: 'https://262.ecma-international.org/16.0/#sec-monthfromtime'
	},
	msFromTime: {
		url: 'https://262.ecma-international.org/16.0/#sec-msfromtime'
	},
	NewDeclarativeEnvironment: {
		url: 'https://262.ecma-international.org/16.0/#sec-newdeclarativeenvironment'
	},
	NewFunctionEnvironment: {
		url: 'https://262.ecma-international.org/16.0/#sec-newfunctionenvironment'
	},
	NewGlobalEnvironment: {
		url: 'https://262.ecma-international.org/16.0/#sec-newglobalenvironment'
	},
	NewModuleEnvironment: {
		url: 'https://262.ecma-international.org/16.0/#sec-newmoduleenvironment'
	},
	NewObjectEnvironment: {
		url: 'https://262.ecma-international.org/16.0/#sec-newobjectenvironment'
	},
	NewPrivateEnvironment: {
		url: 'https://262.ecma-international.org/16.0/#sec-newprivateenvironment'
	},
	NewPromiseCapability: {
		url: 'https://262.ecma-international.org/16.0/#sec-newpromisecapability'
	},
	NewPromiseReactionJob: {
		url: 'https://262.ecma-international.org/16.0/#sec-newpromisereactionjob'
	},
	NewPromiseResolveThenableJob: {
		url: 'https://262.ecma-international.org/16.0/#sec-newpromiseresolvethenablejob'
	},
	NormalCompletion: {
		url: 'https://262.ecma-international.org/16.0/#sec-normalcompletion'
	},
	NotifyWaiter: {
		url: 'https://262.ecma-international.org/16.0/#sec-notifywaiter'
	},
	'Number::add': {
		url: 'https://262.ecma-international.org/16.0/#sec-numeric-types-number-add'
	},
	'Number::bitwiseAND': {
		url: 'https://262.ecma-international.org/16.0/#sec-numeric-types-number-bitwiseAND'
	},
	'Number::bitwiseNOT': {
		url: 'https://262.ecma-international.org/16.0/#sec-numeric-types-number-bitwiseNOT'
	},
	'Number::bitwiseOR': {
		url: 'https://262.ecma-international.org/16.0/#sec-numeric-types-number-bitwiseOR'
	},
	'Number::bitwiseXOR': {
		url: 'https://262.ecma-international.org/16.0/#sec-numeric-types-number-bitwiseXOR'
	},
	'Number::divide': {
		url: 'https://262.ecma-international.org/16.0/#sec-numeric-types-number-divide'
	},
	'Number::equal': {
		url: 'https://262.ecma-international.org/16.0/#sec-numeric-types-number-equal'
	},
	'Number::exponentiate': {
		url: 'https://262.ecma-international.org/16.0/#sec-numeric-types-number-exponentiate'
	},
	'Number::leftShift': {
		url: 'https://262.ecma-international.org/16.0/#sec-numeric-types-number-leftShift'
	},
	'Number::lessThan': {
		url: 'https://262.ecma-international.org/16.0/#sec-numeric-types-number-lessThan'
	},
	'Number::multiply': {
		url: 'https://262.ecma-international.org/16.0/#sec-numeric-types-number-multiply'
	},
	'Number::remainder': {
		url: 'https://262.ecma-international.org/16.0/#sec-numeric-types-number-remainder'
	},
	'Number::sameValue': {
		url: 'https://262.ecma-international.org/16.0/#sec-numeric-types-number-sameValue'
	},
	'Number::sameValueZero': {
		url: 'https://262.ecma-international.org/16.0/#sec-numeric-types-number-sameValueZero'
	},
	'Number::signedRightShift': {
		url: 'https://262.ecma-international.org/16.0/#sec-numeric-types-number-signedRightShift'
	},
	'Number::subtract': {
		url: 'https://262.ecma-international.org/16.0/#sec-numeric-types-number-subtract'
	},
	'Number::toString': {
		url: 'https://262.ecma-international.org/16.0/#sec-numeric-types-number-tostring'
	},
	'Number::unaryMinus': {
		url: 'https://262.ecma-international.org/16.0/#sec-numeric-types-number-unaryMinus'
	},
	'Number::unsignedRightShift': {
		url: 'https://262.ecma-international.org/16.0/#sec-numeric-types-number-unsignedRightShift'
	},
	NumberBitwiseOp: {
		url: 'https://262.ecma-international.org/16.0/#sec-numberbitwiseop'
	},
	NumberToBigInt: {
		url: 'https://262.ecma-international.org/16.0/#sec-numbertobigint'
	},
	NumericToRawBytes: {
		url: 'https://262.ecma-international.org/16.0/#sec-numerictorawbytes'
	},
	ObjectDefineProperties: {
		url: 'https://262.ecma-international.org/16.0/#sec-objectdefineproperties'
	},
	OrdinaryCallBindThis: {
		url: 'https://262.ecma-international.org/16.0/#sec-ordinarycallbindthis'
	},
	OrdinaryCallEvaluateBody: {
		url: 'https://262.ecma-international.org/16.0/#sec-ordinarycallevaluatebody'
	},
	OrdinaryCreateFromConstructor: {
		url: 'https://262.ecma-international.org/16.0/#sec-ordinarycreatefromconstructor'
	},
	OrdinaryDefineOwnProperty: {
		url: 'https://262.ecma-international.org/16.0/#sec-ordinarydefineownproperty'
	},
	OrdinaryDelete: {
		url: 'https://262.ecma-international.org/16.0/#sec-ordinarydelete'
	},
	OrdinaryFunctionCreate: {
		url: 'https://262.ecma-international.org/16.0/#sec-ordinaryfunctioncreate'
	},
	OrdinaryGet: {
		url: 'https://262.ecma-international.org/16.0/#sec-ordinaryget'
	},
	OrdinaryGetOwnProperty: {
		url: 'https://262.ecma-international.org/16.0/#sec-ordinarygetownproperty'
	},
	OrdinaryGetPrototypeOf: {
		url: 'https://262.ecma-international.org/16.0/#sec-ordinarygetprototypeof'
	},
	OrdinaryHasInstance: {
		url: 'https://262.ecma-international.org/16.0/#sec-ordinaryhasinstance'
	},
	OrdinaryHasProperty: {
		url: 'https://262.ecma-international.org/16.0/#sec-ordinaryhasproperty'
	},
	OrdinaryIsExtensible: {
		url: 'https://262.ecma-international.org/16.0/#sec-ordinaryisextensible'
	},
	OrdinaryObjectCreate: {
		url: 'https://262.ecma-international.org/16.0/#sec-ordinaryobjectcreate'
	},
	OrdinaryOwnPropertyKeys: {
		url: 'https://262.ecma-international.org/16.0/#sec-ordinaryownpropertykeys'
	},
	OrdinaryPreventExtensions: {
		url: 'https://262.ecma-international.org/16.0/#sec-ordinarypreventextensions'
	},
	OrdinarySet: {
		url: 'https://262.ecma-international.org/16.0/#sec-ordinaryset'
	},
	OrdinarySetPrototypeOf: {
		url: 'https://262.ecma-international.org/16.0/#sec-ordinarysetprototypeof'
	},
	OrdinarySetWithOwnDescriptor: {
		url: 'https://262.ecma-international.org/16.0/#sec-ordinarysetwithowndescriptor'
	},
	OrdinaryToPrimitive: {
		url: 'https://262.ecma-international.org/16.0/#sec-ordinarytoprimitive'
	},
	ParseHexOctet: {
		url: 'https://262.ecma-international.org/16.0/#sec-parsehexoctet'
	},
	ParseJSON: {
		url: 'https://262.ecma-international.org/16.0/#sec-ParseJSON'
	},
	ParseJSONModule: {
		url: 'https://262.ecma-international.org/16.0/#sec-parse-json-module'
	},
	ParseModule: {
		url: 'https://262.ecma-international.org/16.0/#sec-parsemodule'
	},
	ParsePattern: {
		url: 'https://262.ecma-international.org/16.0/#sec-parsepattern'
	},
	ParseScript: {
		url: 'https://262.ecma-international.org/16.0/#sec-parse-script'
	},
	ParseText: {
		url: 'https://262.ecma-international.org/16.0/#sec-parsetext'
	},
	ParseTimeZoneOffsetString: {
		url: 'https://262.ecma-international.org/16.0/#sec-parsetimezoneoffsetstring'
	},
	PerformEval: {
		url: 'https://262.ecma-international.org/16.0/#sec-performeval'
	},
	PerformPromiseAll: {
		url: 'https://262.ecma-international.org/16.0/#sec-performpromiseall'
	},
	PerformPromiseAllSettled: {
		url: 'https://262.ecma-international.org/16.0/#sec-performpromiseallsettled'
	},
	PerformPromiseAny: {
		url: 'https://262.ecma-international.org/16.0/#sec-performpromiseany'
	},
	PerformPromiseRace: {
		url: 'https://262.ecma-international.org/16.0/#sec-performpromiserace'
	},
	PerformPromiseThen: {
		url: 'https://262.ecma-international.org/16.0/#sec-performpromisethen'
	},
	PrepareForOrdinaryCall: {
		url: 'https://262.ecma-international.org/16.0/#sec-prepareforordinarycall'
	},
	PrepareForTailCall: {
		url: 'https://262.ecma-international.org/16.0/#sec-preparefortailcall'
	},
	PrivateElementFind: {
		url: 'https://262.ecma-international.org/16.0/#sec-privateelementfind'
	},
	PrivateFieldAdd: {
		url: 'https://262.ecma-international.org/16.0/#sec-privatefieldadd'
	},
	PrivateGet: {
		url: 'https://262.ecma-international.org/16.0/#sec-privateget'
	},
	PrivateMethodOrAccessorAdd: {
		url: 'https://262.ecma-international.org/16.0/#sec-privatemethodoraccessoradd'
	},
	PrivateSet: {
		url: 'https://262.ecma-international.org/16.0/#sec-privateset'
	},
	PromiseResolve: {
		url: 'https://262.ecma-international.org/16.0/#sec-promise-resolve'
	},
	ProxyCreate: {
		url: 'https://262.ecma-international.org/16.0/#sec-proxycreate'
	},
	PutValue: {
		url: 'https://262.ecma-international.org/16.0/#sec-putvalue'
	},
	QuoteJSONString: {
		url: 'https://262.ecma-international.org/16.0/#sec-quotejsonstring'
	},
	ℝ: {
		url: 'https://262.ecma-international.org/16.0/#ℝ'
	},
	RawBytesToNumeric: {
		url: 'https://262.ecma-international.org/16.0/#sec-rawbytestonumeric'
	},
	'reads-bytes-from': {
		url: 'https://262.ecma-international.org/16.0/#sec-reads-bytes-from'
	},
	RegExpAlloc: {
		url: 'https://262.ecma-international.org/16.0/#sec-regexpalloc'
	},
	RegExpBuiltinExec: {
		url: 'https://262.ecma-international.org/16.0/#sec-regexpbuiltinexec'
	},
	RegExpCreate: {
		url: 'https://262.ecma-international.org/16.0/#sec-regexpcreate'
	},
	RegExpExec: {
		url: 'https://262.ecma-international.org/16.0/#sec-regexpexec'
	},
	RegExpHasFlag: {
		url: 'https://262.ecma-international.org/16.0/#sec-regexphasflag'
	},
	RegExpInitialize: {
		url: 'https://262.ecma-international.org/16.0/#sec-regexpinitialize'
	},
	RejectPromise: {
		url: 'https://262.ecma-international.org/16.0/#sec-rejectpromise'
	},
	RemoveWaiter: {
		url: 'https://262.ecma-international.org/16.0/#sec-removewaiter'
	},
	RemoveWaiters: {
		url: 'https://262.ecma-international.org/16.0/#sec-removewaiters'
	},
	RepeatMatcher: {
		url: 'https://262.ecma-international.org/16.0/#sec-runtime-semantics-repeatmatcher-abstract-operation'
	},
	RequireInternalSlot: {
		url: 'https://262.ecma-international.org/16.0/#sec-requireinternalslot'
	},
	RequireObjectCoercible: {
		url: 'https://262.ecma-international.org/16.0/#sec-requireobjectcoercible'
	},
	ResolveBinding: {
		url: 'https://262.ecma-international.org/16.0/#sec-resolvebinding'
	},
	ResolvePrivateIdentifier: {
		url: 'https://262.ecma-international.org/16.0/#sec-resolve-private-identifier'
	},
	ResolveThisBinding: {
		url: 'https://262.ecma-international.org/16.0/#sec-resolvethisbinding'
	},
	ReturnCompletion: {
		url: 'https://262.ecma-international.org/16.0/#sec-returncompletion'
	},
	ReturnIfAbrupt: {
		url: 'https://262.ecma-international.org/16.0/#sec-returnifabrupt'
	},
	RevalidateAtomicAccess: {
		url: 'https://262.ecma-international.org/16.0/#sec-revalidateatomicaccess'
	},
	RoundMVResult: {
		url: 'https://262.ecma-international.org/16.0/#sec-roundmvresult'
	},
	SameType: {
		url: 'https://262.ecma-international.org/16.0/#sec-sametype'
	},
	SameValue: {
		url: 'https://262.ecma-international.org/16.0/#sec-samevalue'
	},
	SameValueNonNumber: {
		url: 'https://262.ecma-international.org/16.0/#sec-samevaluenonnumber'
	},
	SameValueZero: {
		url: 'https://262.ecma-international.org/16.0/#sec-samevaluezero'
	},
	scf: {
		url: 'https://262.ecma-international.org/16.0/#eqn-scf'
	},
	ScriptEvaluation: {
		url: 'https://262.ecma-international.org/16.0/#sec-runtime-semantics-scriptevaluation'
	},
	SecFromTime: {
		url: 'https://262.ecma-international.org/16.0/#sec-secfromtime'
	},
	SerializeJSONArray: {
		url: 'https://262.ecma-international.org/16.0/#sec-serializejsonarray'
	},
	SerializeJSONObject: {
		url: 'https://262.ecma-international.org/16.0/#sec-serializejsonobject'
	},
	SerializeJSONProperty: {
		url: 'https://262.ecma-international.org/16.0/#sec-serializejsonproperty'
	},
	Set: {
		url: 'https://262.ecma-international.org/16.0/#sec-set-o-p-v-throw'
	},
	SetDataHas: {
		url: 'https://262.ecma-international.org/16.0/#sec-setdatahas'
	},
	SetDataIndex: {
		url: 'https://262.ecma-international.org/16.0/#sec-setdataindex'
	},
	SetDataSize: {
		url: 'https://262.ecma-international.org/16.0/#sec-setdatasize'
	},
	SetDefaultGlobalBindings: {
		url: 'https://262.ecma-international.org/16.0/#sec-setdefaultglobalbindings'
	},
	SetFunctionLength: {
		url: 'https://262.ecma-international.org/16.0/#sec-setfunctionlength'
	},
	SetFunctionName: {
		url: 'https://262.ecma-international.org/16.0/#sec-setfunctionname'
	},
	SetImmutablePrototype: {
		url: 'https://262.ecma-international.org/16.0/#sec-set-immutable-prototype'
	},
	SetIntegrityLevel: {
		url: 'https://262.ecma-international.org/16.0/#sec-setintegritylevel'
	},
	SetSyntheticModuleExport: {
		url: 'https://262.ecma-international.org/16.0/#sec-setsyntheticmoduleexport'
	},
	SetterThatIgnoresPrototypeProperties: {
		url: 'https://262.ecma-international.org/16.0/#sec-SetterThatIgnoresPrototypeProperties'
	},
	SetTypedArrayFromArrayLike: {
		url: 'https://262.ecma-international.org/16.0/#sec-settypedarrayfromarraylike'
	},
	SetTypedArrayFromTypedArray: {
		url: 'https://262.ecma-international.org/16.0/#sec-settypedarrayfromtypedarray'
	},
	SetValueInBuffer: {
		url: 'https://262.ecma-international.org/16.0/#sec-setvalueinbuffer'
	},
	SetViewValue: {
		url: 'https://262.ecma-international.org/16.0/#sec-setviewvalue'
	},
	SharedDataBlockEventSet: {
		url: 'https://262.ecma-international.org/16.0/#sec-sharedatablockeventset'
	},
	SortIndexedProperties: {
		url: 'https://262.ecma-international.org/16.0/#sec-sortindexedproperties'
	},
	SpeciesConstructor: {
		url: 'https://262.ecma-international.org/16.0/#sec-speciesconstructor'
	},
	StringCreate: {
		url: 'https://262.ecma-international.org/16.0/#sec-stringcreate'
	},
	StringGetOwnProperty: {
		url: 'https://262.ecma-international.org/16.0/#sec-stringgetownproperty'
	},
	StringIndexOf: {
		url: 'https://262.ecma-international.org/16.0/#sec-stringindexof'
	},
	StringLastIndexOf: {
		url: 'https://262.ecma-international.org/16.0/#sec-stringlastindexof'
	},
	StringPad: {
		url: 'https://262.ecma-international.org/16.0/#sec-stringpad'
	},
	StringPaddingBuiltinsImpl: {
		url: 'https://262.ecma-international.org/16.0/#sec-stringpaddingbuiltinsimpl'
	},
	StringToBigInt: {
		url: 'https://262.ecma-international.org/16.0/#sec-stringtobigint'
	},
	StringToCodePoints: {
		url: 'https://262.ecma-international.org/16.0/#sec-stringtocodepoints'
	},
	StringToNumber: {
		url: 'https://262.ecma-international.org/16.0/#sec-stringtonumber'
	},
	substring: {
		url: 'https://262.ecma-international.org/16.0/#substring'
	},
	SuspendThisAgent: {
		url: 'https://262.ecma-international.org/16.0/#sec-suspendthisagent'
	},
	SymbolDescriptiveString: {
		url: 'https://262.ecma-international.org/16.0/#sec-symboldescriptivestring'
	},
	SystemTimeZoneIdentifier: {
		url: 'https://262.ecma-international.org/16.0/#sec-systemtimezoneidentifier'
	},
	TemplateString: {
		url: 'https://262.ecma-international.org/16.0/#sec-templatestring'
	},
	TestIntegrityLevel: {
		url: 'https://262.ecma-international.org/16.0/#sec-testintegritylevel'
	},
	ThisBigIntValue: {
		url: 'https://262.ecma-international.org/16.0/#sec-thisbigintvalue'
	},
	ThisBooleanValue: {
		url: 'https://262.ecma-international.org/16.0/#sec-thisbooleanvalue'
	},
	ThisNumberValue: {
		url: 'https://262.ecma-international.org/16.0/#sec-thisnumbervalue'
	},
	ThisStringValue: {
		url: 'https://262.ecma-international.org/16.0/#sec-thisstringvalue'
	},
	ThisSymbolValue: {
		url: 'https://262.ecma-international.org/16.0/#sec-thissymbolvalue'
	},
	ThrowCompletion: {
		url: 'https://262.ecma-international.org/16.0/#sec-throwcompletion'
	},
	TimeClip: {
		url: 'https://262.ecma-international.org/16.0/#sec-timeclip'
	},
	TimeFromYear: {
		url: 'https://262.ecma-international.org/16.0/#sec-timefromyear'
	},
	TimeString: {
		url: 'https://262.ecma-international.org/16.0/#sec-timestring'
	},
	TimeWithinDay: {
		url: 'https://262.ecma-international.org/16.0/#sec-timewithinday'
	},
	TimeZoneString: {
		url: 'https://262.ecma-international.org/16.0/#sec-timezoneestring'
	},
	ToBigInt: {
		url: 'https://262.ecma-international.org/16.0/#sec-tobigint'
	},
	ToBigInt64: {
		url: 'https://262.ecma-international.org/16.0/#sec-tobigint64'
	},
	ToBigUint64: {
		url: 'https://262.ecma-international.org/16.0/#sec-tobiguint64'
	},
	ToBoolean: {
		url: 'https://262.ecma-international.org/16.0/#sec-toboolean'
	},
	ToDateString: {
		url: 'https://262.ecma-international.org/16.0/#sec-todatestring'
	},
	ToIndex: {
		url: 'https://262.ecma-international.org/16.0/#sec-toindex'
	},
	ToInt16: {
		url: 'https://262.ecma-international.org/16.0/#sec-toint16'
	},
	ToInt32: {
		url: 'https://262.ecma-international.org/16.0/#sec-toint32'
	},
	ToInt8: {
		url: 'https://262.ecma-international.org/16.0/#sec-toint8'
	},
	ToIntegerOrInfinity: {
		url: 'https://262.ecma-international.org/16.0/#sec-tointegerorinfinity'
	},
	ToLength: {
		url: 'https://262.ecma-international.org/16.0/#sec-tolength'
	},
	ToNumber: {
		url: 'https://262.ecma-international.org/16.0/#sec-tonumber'
	},
	ToNumeric: {
		url: 'https://262.ecma-international.org/16.0/#sec-tonumeric'
	},
	ToObject: {
		url: 'https://262.ecma-international.org/16.0/#sec-toobject'
	},
	ToPrimitive: {
		url: 'https://262.ecma-international.org/16.0/#sec-toprimitive'
	},
	ToPropertyDescriptor: {
		url: 'https://262.ecma-international.org/16.0/#sec-topropertydescriptor'
	},
	ToPropertyKey: {
		url: 'https://262.ecma-international.org/16.0/#sec-topropertykey'
	},
	ToString: {
		url: 'https://262.ecma-international.org/16.0/#sec-tostring'
	},
	ToUint16: {
		url: 'https://262.ecma-international.org/16.0/#sec-touint16'
	},
	ToUint32: {
		url: 'https://262.ecma-international.org/16.0/#sec-touint32'
	},
	ToUint8: {
		url: 'https://262.ecma-international.org/16.0/#sec-touint8'
	},
	ToUint8Clamp: {
		url: 'https://262.ecma-international.org/16.0/#sec-touint8clamp'
	},
	ToZeroPaddedDecimalString: {
		url: 'https://262.ecma-international.org/16.0/#sec-tozeropaddeddecimalstring'
	},
	TriggerPromiseReactions: {
		url: 'https://262.ecma-international.org/16.0/#sec-triggerpromisereactions'
	},
	TrimString: {
		url: 'https://262.ecma-international.org/16.0/#sec-trimstring'
	},
	truncate: {
		url: 'https://262.ecma-international.org/16.0/#eqn-truncate'
	},
	TypedArrayByteLength: {
		url: 'https://262.ecma-international.org/16.0/#sec-typedarraybytelength'
	},
	TypedArrayCreate: {
		url: 'https://262.ecma-international.org/16.0/#sec-typedarraycreate'
	},
	TypedArrayCreateFromConstructor: {
		url: 'https://262.ecma-international.org/16.0/#sec-typedarraycreatefromconstructor'
	},
	TypedArrayCreateSameType: {
		url: 'https://262.ecma-international.org/16.0/#sec-typedarray-create-same-type'
	},
	TypedArrayElementSize: {
		url: 'https://262.ecma-international.org/16.0/#sec-typedarrayelementsize'
	},
	TypedArrayElementType: {
		url: 'https://262.ecma-international.org/16.0/#sec-typedarrayelementtype'
	},
	TypedArrayGetElement: {
		url: 'https://262.ecma-international.org/16.0/#sec-typedarraygetelement'
	},
	TypedArrayLength: {
		url: 'https://262.ecma-international.org/16.0/#sec-typedarraylength'
	},
	TypedArraySetElement: {
		url: 'https://262.ecma-international.org/16.0/#sec-typedarraysetelement'
	},
	TypedArraySpeciesCreate: {
		url: 'https://262.ecma-international.org/16.0/#typedarray-species-create'
	},
	UnicodeEscape: {
		url: 'https://262.ecma-international.org/16.0/#sec-unicodeescape'
	},
	UnicodeMatchProperty: {
		url: 'https://262.ecma-international.org/16.0/#sec-runtime-semantics-unicodematchproperty-p'
	},
	UnicodeMatchPropertyValue: {
		url: 'https://262.ecma-international.org/16.0/#sec-runtime-semantics-unicodematchpropertyvalue-p-v'
	},
	UpdateEmpty: {
		url: 'https://262.ecma-international.org/16.0/#sec-updateempty'
	},
	UpdateModifiers: {
		url: 'https://262.ecma-international.org/16.0/#sec-updatemodifiers'
	},
	UTC: {
		url: 'https://262.ecma-international.org/16.0/#sec-utc-t'
	},
	UTF16EncodeCodePoint: {
		url: 'https://262.ecma-international.org/16.0/#sec-utf16encodecodepoint'
	},
	UTF16SurrogatePairToCodePoint: {
		url: 'https://262.ecma-international.org/16.0/#sec-utf16decodesurrogatepair'
	},
	ValidateAndApplyPropertyDescriptor: {
		url: 'https://262.ecma-international.org/16.0/#sec-validateandapplypropertydescriptor'
	},
	ValidateAtomicAccess: {
		url: 'https://262.ecma-international.org/16.0/#sec-validateatomicaccess'
	},
	ValidateAtomicAccessOnIntegerTypedArray: {
		url: 'https://262.ecma-international.org/16.0/#sec-validateatomicaccessonintegertypedarray'
	},
	ValidateIntegerTypedArray: {
		url: 'https://262.ecma-international.org/16.0/#sec-validateintegertypedarray'
	},
	ValidateNonRevokedProxy: {
		url: 'https://262.ecma-international.org/16.0/#sec-validatenonrevokedproxy'
	},
	ValidateTypedArray: {
		url: 'https://262.ecma-international.org/16.0/#sec-validatetypedarray'
	},
	ValueOfReadEvent: {
		url: 'https://262.ecma-international.org/16.0/#sec-valueofreadevent'
	},
	WeakRefDeref: {
		url: 'https://262.ecma-international.org/16.0/#sec-weakrefderef'
	},
	WeekDay: {
		url: 'https://262.ecma-international.org/16.0/#sec-weekday'
	},
	WordCharacters: {
		url: 'https://262.ecma-international.org/16.0/#sec-wordcharacters'
	},
	YearFromTime: {
		url: 'https://262.ecma-international.org/16.0/#sec-yearfromtime'
	},
	Yield: {
		url: 'https://262.ecma-international.org/16.0/#sec-yield'
	},
	ℤ: {
		url: 'https://262.ecma-international.org/16.0/#ℤ'
	}
};
'use strict';

module.exports = {
	'Abstract Equality Comparison': 'https://262.ecma-international.org/5.1/#sec-11.9.3',
	'Abstract Relational Comparison': 'https://262.ecma-international.org/5.1/#sec-11.8.5',
	'Strict Equality Comparison': 'https://262.ecma-international.org/5.1/#sec-11.9.6',
	abs: 'http://262.ecma-international.org/5.1/#sec-5.2',
	Canonicalize: 'https://262.ecma-international.org/5.1/#sec-15.10.2.8',
	CheckObjectCoercible: 'https://262.ecma-international.org/5.1/#sec-9.10',
	DateFromTime: 'https://262.ecma-international.org/5.1/#sec-15.9.1.5',
	Day: 'https://262.ecma-international.org/5.1/#sec-15.9.1.2',
	DayFromYear: 'https://262.ecma-international.org/5.1/#sec-15.9.1.3',
	DaysInYear: 'https://262.ecma-international.org/5.1/#sec-15.9.1.3',
	DayWithinYear: 'https://262.ecma-international.org/5.1/#sec-15.9.1.4',
	floor: 'http://262.ecma-international.org/5.1/#sec-5.2',
	FromPropertyDescriptor: 'https://262.ecma-international.org/5.1/#sec-8.10.4',
	HourFromTime: 'https://262.ecma-international.org/5.1/#sec-15.9.1.10',
	InLeapYear: 'https://262.ecma-international.org/5.1/#sec-15.9.1.3',
	IsAccessorDescriptor: 'https://262.ecma-international.org/5.1/#sec-8.10.1',
	IsCallable: 'https://262.ecma-international.org/5.1/#sec-9.11',
	IsDataDescriptor: 'https://262.ecma-international.org/5.1/#sec-8.10.2',
	IsGenericDescriptor: 'https://262.ecma-international.org/5.1/#sec-8.10.3',
	IsPropertyDescriptor: 'https://262.ecma-international.org/5.1/#sec-8.10',
	MakeDate: 'https://262.ecma-international.org/5.1/#sec-15.9.1.13',
	MakeDay: 'https://262.ecma-international.org/5.1/#sec-15.9.1.12',
	MakeTime: 'https://262.ecma-international.org/5.1/#sec-15.9.1.11',
	MinFromTime: 'https://262.ecma-international.org/5.1/#sec-15.9.1.10',
	modulo: 'https://262.ecma-international.org/5.1/#sec-5.2',
	MonthFromTime: 'https://262.ecma-international.org/5.1/#sec-15.9.1.4',
	msFromTime: 'https://262.ecma-international.org/5.1/#sec-15.9.1.10',
	SameValue: 'https://262.ecma-international.org/5.1/#sec-9.12',
	SecFromTime: 'https://262.ecma-international.org/5.1/#sec-15.9.1.10',
	SplitMatch: 'https://262.ecma-international.org/5.1/#sec-15.5.4.14',
	TimeClip: 'https://262.ecma-international.org/5.1/#sec-15.9.1.14',
	TimeFromYear: 'https://262.ecma-international.org/5.1/#sec-15.9.1.3',
	TimeWithinDay: 'https://262.ecma-international.org/5.1/#sec-15.9.1.2',
	ToBoolean: 'https://262.ecma-international.org/5.1/#sec-9.2',
	ToInt32: 'https://262.ecma-international.org/5.1/#sec-9.5',
	ToInteger: 'https://262.ecma-international.org/5.1/#sec-9.4',
	ToNumber: 'https://262.ecma-international.org/5.1/#sec-9.3',
	ToObject: 'https://262.ecma-international.org/5.1/#sec-9.9',
	ToPrimitive: 'https://262.ecma-international.org/5.1/#sec-9.1',
	ToPropertyDescriptor: 'https://262.ecma-international.org/5.1/#sec-8.10.5',
	ToString: 'https://262.ecma-international.org/5.1/#sec-9.8',
	ToUint16: 'https://262.ecma-international.org/5.1/#sec-9.7',
	ToUint32: 'https://262.ecma-international.org/5.1/#sec-9.6',
	Type: 'https://262.ecma-international.org/5.1/#sec-8',
	WeekDay: 'https://262.ecma-international.org/5.1/#sec-15.9.1.6',
	YearFromTime: 'https://262.ecma-international.org/5.1/#sec-15.9.1.3'
};
'use strict';

var $defineProperty = require('../');

var test = require('tape');
var gOPD = require('gopd');

test('defineProperty: supported', { skip: !$defineProperty }, function (t) {
	t.plan(4);

	t.equal(typeof $defineProperty, 'function', 'defineProperty is supported');
	if ($defineProperty && gOPD) { // this `if` check is just to shut TS up
		/** @type {{ a: number, b?: number, c?: number }} */
		var o = { a: 1 };

		$defineProperty(o, 'b', { enumerable: true, value: 2 });
		t.deepEqual(
			gOPD(o, 'b'),
			{
				configurable: false,
				enumerable: true,
				value: 2,
				writable: false
			},
			'property descriptor is as expected'
		);

		$defineProperty(o, 'c', { enumerable: false, value: 3, writable: true });
		t.deepEqual(
			gOPD(o, 'c'),
			{
				configurable: false,
				enumerable: false,
				value: 3,
				writable: true
			},
			'property descriptor is as expected'
		);
	}

	t.equal($defineProperty, Object.defineProperty, 'defineProperty is Object.defineProperty');

	t.end();
});

test('defineProperty: not supported', { skip: !!$defineProperty }, function (t) {
	t.notOk($defineProperty, 'defineProperty is not supported');

	t.match(
		typeof $defineProperty,
		/^(?:undefined|boolean)$/,
		'`typeof defineProperty` is `undefined` or `boolean`'
	);

	t.end();
});
'use strict';

var test = require('tape');

var E = require('../');
var R = require('../range');
var Ref = require('../ref');
var S = require('../syntax');
var T = require('../type');

test('errors', function (t) {
	t.equal(E, Error);
	t.equal(R, RangeError);
	t.equal(Ref, ReferenceError);
	t.equal(S, SyntaxError);
	t.equal(T, TypeError);

	t.end();
});
'use strict';

var test = require('tape');

var $Object = require('../');
var isObject = require('../isObject');
var ToObject = require('../ToObject');
var RequireObjectCoercible = require('..//RequireObjectCoercible');

test('errors', function (t) {
	t.equal($Object, Object);
	// @ts-expect-error
	t['throws'](function () { ToObject(null); }, TypeError);
	// @ts-expect-error
	t['throws'](function () { ToObject(undefined); }, TypeError);
	// @ts-expect-error
	t['throws'](function () { RequireObjectCoercible(null); }, TypeError);
	// @ts-expect-error
	t['throws'](function () { RequireObjectCoercible(undefined); }, TypeError);

	t.deepEqual(RequireObjectCoercible(true), true);
	t.deepEqual(ToObject(true), Object(true));
	t.deepEqual(ToObject(42), Object(42));
	var f = function () {};
	t.equal(ToObject(f), f);

	t.equal(isObject(undefined), false);
	t.equal(isObject(null), false);
	t.equal(isObject({}), true);
	t.equal(isObject([]), true);
	t.equal(isObject(function () {}), true);

	var obj = {};
	t.equal(RequireObjectCoercible(obj), obj);
	t.equal(ToObject(obj), obj);

	t.end();
});
'use strict';

var test = require('tape');
var hasToStringTag = require('has-tostringtag/shams')();
var hasOwn = require('hasown');

var setToStringTag = require('../');

test('setToStringTag', function (t) {
	t.equal(typeof setToStringTag, 'function', 'is a function');

	/** @type {{ [Symbol.toStringTag]?: typeof sentinel }} */
	var obj = {};
	var sentinel = {};

	setToStringTag(obj, sentinel);

	t['throws'](
		// @ts-expect-error
		function () { setToStringTag(obj, sentinel, { force: 'yes' }); },
		TypeError,
		'throws if options is not an object'
	);

	t.test('has Symbol.toStringTag', { skip: !hasToStringTag }, function (st) {
		st.ok(hasOwn(obj, Symbol.toStringTag), 'has toStringTag property');

		st.equal(obj[Symbol.toStringTag], sentinel, 'toStringTag property is as expected');

		st.equal(String(obj), '[object Object]', 'toStringTag works');

		/** @type {{ [Symbol.toStringTag]?: string }} */
		var tagged = {};
		tagged[Symbol.toStringTag] = 'already tagged';
		st.equal(String(tagged), '[object already tagged]', 'toStringTag works');

		setToStringTag(tagged, 'new tag');
		st.equal(String(tagged), '[object already tagged]', 'toStringTag is unchanged');

		setToStringTag(tagged, 'new tag', { force: true });
		st.equal(String(tagged), '[object new tag]', 'toStringTag is changed with force: true');

		st.deepEqual(
			Object.getOwnPropertyDescriptor(tagged, Symbol.toStringTag),
			{
				configurable: true,
				enumerable: false,
				value: 'new tag',
				writable: false
			},
			'has expected property descriptor'
		);

		setToStringTag(tagged, 'new tag', { force: true, nonConfigurable: true });
		st.deepEqual(
			Object.getOwnPropertyDescriptor(tagged, Symbol.toStringTag),
			{
				configurable: false,
				enumerable: false,
				value: 'new tag',
				writable: false
			},
			'is nonconfigurable'
		);

		st.end();
	});

	t.test('does not have Symbol.toStringTag', { skip: hasToStringTag }, function (st) {
		var passed = true;
		for (var key in obj) { // eslint-disable-line no-restricted-syntax
			if (hasOwn(obj, key)) {
				st.fail('object has own key ' + key);
				passed = false;
			}
		}
		if (passed) {
			st.ok(true, 'object has no enumerable own keys');
		}

		st.end();
	});

	t.end();
});
'use strict';

/** @type {(value: unknown) => value is null | undefined | string | symbol | number | boolean | bigint} */
module.exports = function isPrimitive(value) {
	return value === null || (typeof value !== 'function' && typeof value !== 'object');
};
'use strict';

var test = require('tape');
var toPrimitive = require('../es2015');
var is = require('object-is');
var forEach = require('for-each');
var functionName = require('function.prototype.name');
var debug = require('object-inspect');
var v = require('es-value-fixtures');

/** @typedef {{ toString?: unknown, valueOf?: unknown, [Symbol.toPrimitive]?: unknown }} Coercible */

test('function properties', function (t) {
	t.equal(toPrimitive.length, 1, 'length is 1');
	t.equal(functionName(toPrimitive), 'ToPrimitive', 'name is ToPrimitive');

	t.end();
});

test('primitives', function (t) {
	forEach(v.primitives, function (i) {
		t.ok(is(toPrimitive(i), i), 'toPrimitive(' + debug(i) + ') returns the same value');
		t.ok(is(toPrimitive(i, String), i), 'toPrimitive(' + debug(i) + ', String) returns the same value');
		t.ok(is(toPrimitive(i, Number), i), 'toPrimitive(' + debug(i) + ', Number) returns the same value');
	});
	t.end();
});

test('Symbols', { skip: !v.hasSymbols }, function (t) {
	forEach(v.symbols, function (sym) {
		t.equal(toPrimitive(sym), sym, 'toPrimitive(' + debug(sym) + ') returns the same value');
		t.equal(toPrimitive(sym, String), sym, 'toPrimitive(' + debug(sym) + ', String) returns the same value');
		t.equal(toPrimitive(sym, Number), sym, 'toPrimitive(' + debug(sym) + ', Number) returns the same value');
	});

	var primitiveSym = Symbol('primitiveSym');
	var objectSym = Object(primitiveSym);
	t.equal(toPrimitive(objectSym), primitiveSym, 'toPrimitive(' + debug(objectSym) + ') returns ' + debug(primitiveSym));
	t.equal(toPrimitive(objectSym, String), primitiveSym, 'toPrimitive(' + debug(objectSym) + ', String) returns ' + debug(primitiveSym));
	t.equal(toPrimitive(objectSym, Number), primitiveSym, 'toPrimitive(' + debug(objectSym) + ', Number) returns ' + debug(primitiveSym));
	t.end();
});

test('Arrays', function (t) {
	var arrays = [[], ['a', 'b'], [1, 2]];
	forEach(arrays, function (arr) {
		t.equal(toPrimitive(arr), String(arr), 'toPrimitive(' + debug(arr) + ') returns the string version of the array');
		t.equal(toPrimitive(arr, String), String(arr), 'toPrimitive(' + debug(arr) + ') returns the string version of the array');
		t.equal(toPrimitive(arr, Number), String(arr), 'toPrimitive(' + debug(arr) + ') returns the string version of the array');
	});
	t.end();
});

test('Dates', function (t) {
	var dates = [new Date(), new Date(0), new Date(NaN)];
	forEach(dates, function (date) {
		t.equal(toPrimitive(date), String(date), 'toPrimitive(' + debug(date) + ') returns the string version of the date');
		t.equal(toPrimitive(date, String), String(date), 'toPrimitive(' + debug(date) + ') returns the string version of the date');
		t.ok(is(toPrimitive(date, Number), Number(date)), 'toPrimitive(' + debug(date) + ') returns the number version of the date');
	});
	t.end();
});

test('Objects', function (t) {
	t.equal(toPrimitive(v.coercibleObject), v.coercibleObject.valueOf(), 'coercibleObject with no hint coerces to valueOf');
	t.equal(toPrimitive(v.coercibleObject, Number), v.coercibleObject.valueOf(), 'coercibleObject with hint Number coerces to valueOf');
	t.equal(toPrimitive(v.coercibleObject, String), v.coercibleObject.toString(), 'coercibleObject with hint String coerces to non-stringified toString');

	t.equal(toPrimitive(v.coercibleFnObject), v.coercibleFnObject.toString(), 'coercibleFnObject coerces to non-stringified toString');
	t.equal(toPrimitive(v.coercibleFnObject, Number), v.coercibleFnObject.toString(), 'coercibleFnObject with hint Number coerces to non-stringified toString');
	t.equal(toPrimitive(v.coercibleFnObject, String), v.coercibleFnObject.toString(), 'coercibleFnObject with hint String coerces to non-stringified toString');

	t.equal(toPrimitive({}), '[object Object]', '{} with no hint coerces to Object#toString');
	t.equal(toPrimitive({}, Number), '[object Object]', '{} with hint Number coerces to Object#toString');
	t.equal(toPrimitive({}, String), '[object Object]', '{} with hint String coerces to Object#toString');

	t.equal(toPrimitive(v.toStringOnlyObject), v.toStringOnlyObject.toString(), 'toStringOnlyObject returns non-stringified toString');
	t.equal(toPrimitive(v.toStringOnlyObject, Number), v.toStringOnlyObject.toString(), 'toStringOnlyObject with hint Number returns non-stringified toString');
	t.equal(toPrimitive(v.toStringOnlyObject, String), v.toStringOnlyObject.toString(), 'toStringOnlyObject with hint String returns non-stringified toString');

	t.equal(toPrimitive(v.valueOfOnlyObject), v.valueOfOnlyObject.valueOf(), 'valueOfOnlyObject returns valueOf');
	t.equal(toPrimitive(v.valueOfOnlyObject, Number), v.valueOfOnlyObject.valueOf(), 'valueOfOnlyObject with hint Number returns valueOf');
	t.equal(toPrimitive(v.valueOfOnlyObject, String), v.valueOfOnlyObject.valueOf(), 'valueOfOnlyObject with hint String returns non-stringified valueOf');

	t.test('Symbol.toPrimitive', { skip: !v.hasSymbols || !Symbol.toPrimitive }, function (st) {
		/** @type {Coercible} */
		var overriddenObject = { toString: st.fail, valueOf: st.fail };
		overriddenObject[Symbol.toPrimitive] = /** @type {(hint: string) => unknown} */ function (hint) {
			return String(hint);
		};

		st.equal(toPrimitive(overriddenObject), 'default', 'object with Symbol.toPrimitive + no hint invokes that');
		st.equal(toPrimitive(overriddenObject, Number), 'number', 'object with Symbol.toPrimitive + hint Number invokes that');
		st.equal(toPrimitive(overriddenObject, String), 'string', 'object with Symbol.toPrimitive + hint String invokes that');

		/** @type {Coercible} */
		var nullToPrimitive = { toString: v.coercibleObject.toString, valueOf: v.coercibleObject.valueOf };
		nullToPrimitive[Symbol.toPrimitive] = null;
		st.equal(toPrimitive(nullToPrimitive), toPrimitive(v.coercibleObject), 'object with no hint + null Symbol.toPrimitive ignores it');
		st.equal(toPrimitive(nullToPrimitive, Number), toPrimitive(v.coercibleObject, Number), 'object with hint Number + null Symbol.toPrimitive ignores it');
		st.equal(toPrimitive(nullToPrimitive, String), toPrimitive(v.coercibleObject, String), 'object with hint String + null Symbol.toPrimitive ignores it');

		st.test('exceptions', function (sst) {
			/** @type {Coercible} */
			var nonFunctionToPrimitive = { toString: sst.fail, valueOf: sst.fail };
			nonFunctionToPrimitive[Symbol.toPrimitive] = {};
			sst['throws'](toPrimitive.bind(null, nonFunctionToPrimitive), TypeError, 'Symbol.toPrimitive returning a non-function throws');

			/** @type {Coercible} */
			var uncoercibleToPrimitive = { toString: sst.fail, valueOf: sst.fail };
			uncoercibleToPrimitive[Symbol.toPrimitive] = /** @type {(hint: string) => unknown} */ function (hint) {
				return { toString: function () { return hint; } };
			};
			sst['throws'](toPrimitive.bind(null, uncoercibleToPrimitive), TypeError, 'Symbol.toPrimitive returning an object throws');

			/** @type {Coercible} */
			var throwingToPrimitive = { toString: sst.fail, valueOf: sst.fail };
			throwingToPrimitive[Symbol.toPrimitive] = /** @type {(hint: string) => unknown} */ function (hint) {
				throw new RangeError(hint);
			};
			sst['throws'](toPrimitive.bind(null, throwingToPrimitive), RangeError, 'Symbol.toPrimitive throwing throws');

			sst.end();
		});

		st.end();
	});

	t.test('exceptions', function (st) {
		st['throws'](toPrimitive.bind(null, v.uncoercibleObject), TypeError, 'uncoercibleObject throws a TypeError');
		st['throws'](toPrimitive.bind(null, v.uncoercibleObject, Number), TypeError, 'uncoercibleObject with hint Number throws a TypeError');
		st['throws'](toPrimitive.bind(null, v.uncoercibleObject, String), TypeError, 'uncoercibleObject with hint String throws a TypeError');

		st['throws'](toPrimitive.bind(null, v.uncoercibleFnObject), TypeError, 'uncoercibleFnObject throws a TypeError');
		st['throws'](toPrimitive.bind(null, v.uncoercibleFnObject, Number), TypeError, 'uncoercibleFnObject with hint Number throws a TypeError');
		st['throws'](toPrimitive.bind(null, v.uncoercibleFnObject, String), TypeError, 'uncoercibleFnObject with hint String throws a TypeError');
		st.end();
	});
	t.end();
});
'use strict';

var test = require('tape');
var toPrimitive = require('../es5');
var is = require('object-is');
var forEach = require('for-each');
var functionName = require('function.prototype.name');
var debug = require('object-inspect');
var v = require('es-value-fixtures');

test('function properties', function (t) {
	t.equal(toPrimitive.length, 1, 'length is 1');
	t.equal(functionName(toPrimitive), 'ToPrimitive', 'name is ToPrimitive');

	t.end();
});

test('primitives', function (t) {
	forEach(v.primitives, function (i) {
		t.ok(is(toPrimitive(i), i), 'toPrimitive(' + debug(i) + ') returns the same value');
		t.ok(is(toPrimitive(i, String), i), 'toPrimitive(' + debug(i) + ', String) returns the same value');
		t.ok(is(toPrimitive(i, Number), i), 'toPrimitive(' + debug(i) + ', Number) returns the same value');
	});
	t.end();
});

test('Symbols', { skip: !v.hasSymbols }, function (t) {
	forEach(v.symbols, function (sym) {
		t.equal(toPrimitive(sym), sym, 'toPrimitive(' + debug(sym) + ') returns the same value');
		t.equal(toPrimitive(sym, String), sym, 'toPrimitive(' + debug(sym) + ', String) returns the same value');
		t.equal(toPrimitive(sym, Number), sym, 'toPrimitive(' + debug(sym) + ', Number) returns the same value');
	});

	var primitiveSym = Symbol('primitiveSym');
	var stringSym = Symbol.prototype.toString.call(primitiveSym);
	var objectSym = Object(primitiveSym);
	t.equal(toPrimitive(objectSym), primitiveSym, 'toPrimitive(' + debug(objectSym) + ') returns ' + debug(primitiveSym));

	// This is different from ES2015, as the ES5 algorithm doesn't account for the existence of Symbols:
	t.equal(toPrimitive(objectSym, String), stringSym, 'toPrimitive(' + debug(objectSym) + ', String) returns ' + debug(stringSym));
	t.equal(toPrimitive(objectSym, Number), primitiveSym, 'toPrimitive(' + debug(objectSym) + ', Number) returns ' + debug(primitiveSym));
	t.end();
});

test('Arrays', function (t) {
	var arrays = [[], ['a', 'b'], [1, 2]];
	forEach(arrays, function (arr) {
		t.ok(is(toPrimitive(arr), arr.toString()), 'toPrimitive(' + debug(arr) + ') returns toString of the array');
		t.equal(toPrimitive(arr, String), arr.toString(), 'toPrimitive(' + debug(arr) + ') returns toString of the array');
		t.ok(is(toPrimitive(arr, Number), arr.toString()), 'toPrimitive(' + debug(arr) + ') returns toString of the array');
	});
	t.end();
});

test('Dates', function (t) {
	var dates = [new Date(), new Date(0), new Date(NaN)];
	forEach(dates, function (date) {
		t.equal(toPrimitive(date), date.toString(), 'toPrimitive(' + debug(date) + ') returns toString of the date');
		t.equal(toPrimitive(date, String), date.toString(), 'toPrimitive(' + debug(date) + ') returns toString of the date');
		t.ok(is(toPrimitive(date, Number), date.valueOf()), 'toPrimitive(' + debug(date) + ') returns valueOf of the date');
	});
	t.end();
});

test('Objects', function (t) {
	t.equal(toPrimitive(v.coercibleObject), v.coercibleObject.valueOf(), 'coercibleObject with no hint coerces to valueOf');
	t.equal(toPrimitive(v.coercibleObject, String), v.coercibleObject.toString(), 'coercibleObject with hint String coerces to toString');
	t.equal(toPrimitive(v.coercibleObject, Number), v.coercibleObject.valueOf(), 'coercibleObject with hint Number coerces to valueOf');

	t.equal(toPrimitive(v.coercibleFnObject), v.coercibleFnObject.toString(), 'coercibleFnObject coerces to toString');
	t.equal(toPrimitive(v.coercibleFnObject, String), v.coercibleFnObject.toString(), 'coercibleFnObject with hint String coerces to toString');
	t.equal(toPrimitive(v.coercibleFnObject, Number), v.coercibleFnObject.toString(), 'coercibleFnObject with hint Number coerces to toString');

	t.ok(is(toPrimitive({}), '[object Object]'), '{} with no hint coerces to Object#toString');
	t.equal(toPrimitive({}, String), '[object Object]', '{} with hint String coerces to Object#toString');
	t.ok(is(toPrimitive({}, Number), '[object Object]'), '{} with hint Number coerces to Object#toString');

	t.equal(toPrimitive(v.toStringOnlyObject), v.toStringOnlyObject.toString(), 'toStringOnlyObject returns toString');
	t.equal(toPrimitive(v.toStringOnlyObject, String), v.toStringOnlyObject.toString(), 'toStringOnlyObject with hint String returns toString');
	t.equal(toPrimitive(v.toStringOnlyObject, Number), v.toStringOnlyObject.toString(), 'toStringOnlyObject with hint Number returns toString');

	t.equal(toPrimitive(v.valueOfOnlyObject), v.valueOfOnlyObject.valueOf(), 'valueOfOnlyObject returns valueOf');
	t.equal(toPrimitive(v.valueOfOnlyObject, String), v.valueOfOnlyObject.valueOf(), 'valueOfOnlyObject with hint String returns valueOf');
	t.equal(toPrimitive(v.valueOfOnlyObject, Number), v.valueOfOnlyObject.valueOf(), 'valueOfOnlyObject with hint Number returns valueOf');

	t.test('exceptions', function (st) {
		st['throws'](toPrimitive.bind(null, v.uncoercibleObject), TypeError, 'uncoercibleObject throws a TypeError');
		st['throws'](toPrimitive.bind(null, v.uncoercibleObject, String), TypeError, 'uncoercibleObject with hint String throws a TypeError');
		st['throws'](toPrimitive.bind(null, v.uncoercibleObject, Number), TypeError, 'uncoercibleObject with hint Number throws a TypeError');

		st['throws'](toPrimitive.bind(null, v.uncoercibleFnObject), TypeError, 'uncoercibleFnObject throws a TypeError');
		st['throws'](toPrimitive.bind(null, v.uncoercibleFnObject, String), TypeError, 'uncoercibleFnObject with hint String throws a TypeError');
		st['throws'](toPrimitive.bind(null, v.uncoercibleFnObject, Number), TypeError, 'uncoercibleFnObject with hint Number throws a TypeError');
		st.end();
	});

	t.end();
});
'use strict';

var test = require('tape');
var toPrimitive = require('../es6');
var is = require('object-is');
var forEach = require('for-each');
var functionName = require('function.prototype.name');
var debug = require('object-inspect');
var v = require('es-value-fixtures');

/** @typedef {{ toString?: unknown, valueOf?: unknown, [Symbol.toPrimitive]?: unknown }} Coercible */

test('function properties', function (t) {
	t.equal(toPrimitive.length, 1, 'length is 1');
	t.equal(functionName(toPrimitive), 'ToPrimitive', 'name is ToPrimitive');

	t.end();
});

test('primitives', function (t) {
	forEach(v.primitives, function (i) {
		t.ok(is(toPrimitive(i), i), 'toPrimitive(' + debug(i) + ') returns the same value');
		t.ok(is(toPrimitive(i, String), i), 'toPrimitive(' + debug(i) + ', String) returns the same value');
		t.ok(is(toPrimitive(i, Number), i), 'toPrimitive(' + debug(i) + ', Number) returns the same value');
	});
	t.end();
});

test('Symbols', { skip: !v.hasSymbols }, function (t) {
	forEach(v.symbols, function (sym) {
		t.equal(toPrimitive(sym), sym, 'toPrimitive(' + debug(sym) + ') returns the same value');
		t.equal(toPrimitive(sym, String), sym, 'toPrimitive(' + debug(sym) + ', String) returns the same value');
		t.equal(toPrimitive(sym, Number), sym, 'toPrimitive(' + debug(sym) + ', Number) returns the same value');
	});

	var primitiveSym = Symbol('primitiveSym');
	var objectSym = Object(primitiveSym);
	t.equal(toPrimitive(objectSym), primitiveSym, 'toPrimitive(' + debug(objectSym) + ') returns ' + debug(primitiveSym));
	t.equal(toPrimitive(objectSym, String), primitiveSym, 'toPrimitive(' + debug(objectSym) + ', String) returns ' + debug(primitiveSym));
	t.equal(toPrimitive(objectSym, Number), primitiveSym, 'toPrimitive(' + debug(objectSym) + ', Number) returns ' + debug(primitiveSym));
	t.end();
});

test('Arrays', function (t) {
	var arrays = [[], ['a', 'b'], [1, 2]];
	forEach(arrays, function (arr) {
		t.equal(toPrimitive(arr), String(arr), 'toPrimitive(' + debug(arr) + ') returns the string version of the array');
		t.equal(toPrimitive(arr, String), String(arr), 'toPrimitive(' + debug(arr) + ') returns the string version of the array');
		t.equal(toPrimitive(arr, Number), String(arr), 'toPrimitive(' + debug(arr) + ') returns the string version of the array');
	});
	t.end();
});

test('Dates', function (t) {
	var dates = [new Date(), new Date(0), new Date(NaN)];
	forEach(dates, function (date) {
		t.equal(toPrimitive(date), String(date), 'toPrimitive(' + debug(date) + ') returns the string version of the date');
		t.equal(toPrimitive(date, String), String(date), 'toPrimitive(' + debug(date) + ') returns the string version of the date');
		t.ok(is(toPrimitive(date, Number), Number(date)), 'toPrimitive(' + debug(date) + ') returns the number version of the date');
	});
	t.end();
});

test('Objects', function (t) {
	t.equal(toPrimitive(v.coercibleObject), v.coercibleObject.valueOf(), 'coercibleObject with no hint coerces to valueOf');
	t.equal(toPrimitive(v.coercibleObject, Number), v.coercibleObject.valueOf(), 'coercibleObject with hint Number coerces to valueOf');
	t.equal(toPrimitive(v.coercibleObject, String), v.coercibleObject.toString(), 'coercibleObject with hint String coerces to non-stringified toString');

	t.equal(toPrimitive(v.coercibleFnObject), v.coercibleFnObject.toString(), 'coercibleFnObject coerces to non-stringified toString');
	t.equal(toPrimitive(v.coercibleFnObject, Number), v.coercibleFnObject.toString(), 'coercibleFnObject with hint Number coerces to non-stringified toString');
	t.equal(toPrimitive(v.coercibleFnObject, String), v.coercibleFnObject.toString(), 'coercibleFnObject with hint String coerces to non-stringified toString');

	t.equal(toPrimitive({}), '[object Object]', '{} with no hint coerces to Object#toString');
	t.equal(toPrimitive({}, Number), '[object Object]', '{} with hint Number coerces to Object#toString');
	t.equal(toPrimitive({}, String), '[object Object]', '{} with hint String coerces to Object#toString');

	t.equal(toPrimitive(v.toStringOnlyObject), v.toStringOnlyObject.toString(), 'toStringOnlyObject returns non-stringified toString');
	t.equal(toPrimitive(v.toStringOnlyObject, Number), v.toStringOnlyObject.toString(), 'toStringOnlyObject with hint Number returns non-stringified toString');
	t.equal(toPrimitive(v.toStringOnlyObject, String), v.toStringOnlyObject.toString(), 'toStringOnlyObject with hint String returns non-stringified toString');

	t.equal(toPrimitive(v.valueOfOnlyObject), v.valueOfOnlyObject.valueOf(), 'valueOfOnlyObject returns valueOf');
	t.equal(toPrimitive(v.valueOfOnlyObject, Number), v.valueOfOnlyObject.valueOf(), 'valueOfOnlyObject with hint Number returns valueOf');
	t.equal(toPrimitive(v.valueOfOnlyObject, String), v.valueOfOnlyObject.valueOf(), 'valueOfOnlyObject with hint String returns non-stringified valueOf');

	t.test('Symbol.toPrimitive', { skip: !v.hasSymbols || !Symbol.toPrimitive }, function (st) {
		/** @type {Coercible} */
		var overriddenObject = { toString: st.fail, valueOf: st.fail };
		overriddenObject[Symbol.toPrimitive] = /** @type {(hint: string) => unknown} */ function (hint) {
			return String(hint);
		};

		st.equal(toPrimitive(overriddenObject), 'default', 'object with Symbol.toPrimitive + no hint invokes that');
		st.equal(toPrimitive(overriddenObject, Number), 'number', 'object with Symbol.toPrimitive + hint Number invokes that');
		st.equal(toPrimitive(overriddenObject, String), 'string', 'object with Symbol.toPrimitive + hint String invokes that');

		/** @type {Coercible} */
		var nullToPrimitive = { toString: v.coercibleObject.toString, valueOf: v.coercibleObject.valueOf };
		nullToPrimitive[Symbol.toPrimitive] = null;
		st.equal(toPrimitive(nullToPrimitive), toPrimitive(v.coercibleObject), 'object with no hint + null Symbol.toPrimitive ignores it');
		st.equal(toPrimitive(nullToPrimitive, Number), toPrimitive(v.coercibleObject, Number), 'object with hint Number + null Symbol.toPrimitive ignores it');
		st.equal(toPrimitive(nullToPrimitive, String), toPrimitive(v.coercibleObject, String), 'object with hint String + null Symbol.toPrimitive ignores it');

		st.test('exceptions', function (sst) {
			/** @type {Coercible} */
			var nonFunctionToPrimitive = { toString: sst.fail, valueOf: sst.fail };
			nonFunctionToPrimitive[Symbol.toPrimitive] = {};
			sst['throws'](toPrimitive.bind(null, nonFunctionToPrimitive), TypeError, 'Symbol.toPrimitive returning a non-function throws');

			/** @type {Coercible} */
			var uncoercibleToPrimitive = { toString: sst.fail, valueOf: sst.fail };
			uncoercibleToPrimitive[Symbol.toPrimitive] = /** @type {(hint: string) => unknown} */ function (hint) {
				return { toString: function () { return hint; } };
			};
			sst['throws'](toPrimitive.bind(null, uncoercibleToPrimitive), TypeError, 'Symbol.toPrimitive returning an object throws');

			/** @type {Coercible} */
			var throwingToPrimitive = { toString: sst.fail, valueOf: sst.fail };
			throwingToPrimitive[Symbol.toPrimitive] = /** @type {(hint: string) => unknown} */ function (hint) {
				throw new RangeError(hint);
			};
			sst['throws'](toPrimitive.bind(null, throwingToPrimitive), RangeError, 'Symbol.toPrimitive throwing throws');

			sst.end();
		});

		st.end();
	});

	t.test('exceptions', function (st) {
		st['throws'](toPrimitive.bind(null, v.uncoercibleObject), TypeError, 'uncoercibleObject throws a TypeError');
		st['throws'](toPrimitive.bind(null, v.uncoercibleObject, Number), TypeError, 'uncoercibleObject with hint Number throws a TypeError');
		st['throws'](toPrimitive.bind(null, v.uncoercibleObject, String), TypeError, 'uncoercibleObject with hint String throws a TypeError');

		st['throws'](toPrimitive.bind(null, v.uncoercibleFnObject), TypeError, 'uncoercibleFnObject throws a TypeError');
		st['throws'](toPrimitive.bind(null, v.uncoercibleFnObject, Number), TypeError, 'uncoercibleFnObject with hint Number throws a TypeError');
		st['throws'](toPrimitive.bind(null, v.uncoercibleFnObject, String), TypeError, 'uncoercibleFnObject with hint String throws a TypeError');
		st.end();
	});
	t.end();
});
'use strict';

var toPrimitive = require('../');
var ES5 = require('../es5');
var ES6 = require('../es6');
var ES2015 = require('../es2015');

var test = require('tape');

test('default export', function (t) {
	t.equal(toPrimitive, ES2015, 'default export is ES2015');
	t.equal(toPrimitive.ES5, ES5, 'ES5 property has ES5 method');
	t.equal(toPrimitive.ES6, ES6, 'ES6 property has ES6 method');
	t.equal(toPrimitive.ES2015, ES2015, 'ES2015 property has ES2015 method');
	t.end();
});

require('./es5');
require('./es6');
require('./es2015');
'use strict';

var test = require('tape');
var forEach = require('../');

test('forEach calls each iterator', function (t) {
    var count = 0;
    t.plan(4);

    forEach({ a: 1, b: 2 }, function (value, key) {
        if (count === 0) {
            t.equal(value, 1);
            t.equal(key, 'a');
        } else {
            t.equal(value, 2);
            t.equal(key, 'b');
        }
        count += 1;
    });
});

test('forEach calls iterator with correct this value', function (t) {
    var thisValue = {};

    t.plan(1);

    forEach([0], function () {
        t.equal(this, thisValue);
    }, thisValue);
});

test('second argument: iterator', function (t) {
    /** @type {unknown[]} */
    var arr = [];

    // @ts-expect-error
    t['throws'](function () { forEach(arr); }, TypeError, 'undefined is not a function');
    // @ts-expect-error
    t['throws'](function () { forEach(arr, null); }, TypeError, 'null is not a function');
    // @ts-expect-error
    t['throws'](function () { forEach(arr, ''); }, TypeError, 'string is not a function');
    // @ts-expect-error
    t['throws'](function () { forEach(arr, /a/); }, TypeError, 'regex is not a function');
    // @ts-expect-error
    t['throws'](function () { forEach(arr, true); }, TypeError, 'true is not a function');
    // @ts-expect-error
    t['throws'](function () { forEach(arr, false); }, TypeError, 'false is not a function');
    // @ts-expect-error
    t['throws'](function () { forEach(arr, NaN); }, TypeError, 'NaN is not a function');
    // @ts-expect-error
    t['throws'](function () { forEach(arr, 42); }, TypeError, '42 is not a function');

    t.doesNotThrow(function () { forEach(arr, function () {}); }, 'function is a function');
    // @ts-expect-error TODO fixme
    t.doesNotThrow(function () { forEach(arr, setTimeout); }, 'setTimeout is a function');

    /* eslint-env browser */
    if (typeof window !== 'undefined') {
        t.doesNotThrow(function () { forEach(arr, window.alert); }, 'alert is a function');
    }

    t.end();
});

test('array', function (t) {
    var arr = /** @type {const} */ ([1, 2, 3]);

    t.test('iterates over every item', function (st) {
        var index = 0;
        forEach(arr, function () { index += 1; });
        st.equal(index, arr.length, 'iterates ' + arr.length + ' times');
        st.end();
    });

    t.test('first iterator argument', function (st) {
        var index = 0;
        st.plan(arr.length);

        forEach(arr, function (item) {
            st.equal(arr[index], item, 'item ' + index + ' is passed as first argument');
            index += 1;
        });

        st.end();
    });

    t.test('second iterator argument', function (st) {
        var counter = 0;
        st.plan(arr.length);

        forEach(arr, function (_item, index) {
            st.equal(counter, index, 'index ' + index + ' is passed as second argument');
            counter += 1;
        });

        st.end();
    });

    t.test('third iterator argument', function (st) {
        st.plan(arr.length);

        forEach(arr, function (_item, _index, array) {
            st.deepEqual(arr, array, 'array is passed as third argument');
        });

        st.end();
    });

    t.test('context argument', function (st) {
        var context = {};

        forEach([], function () {
            st.equal(this, context, '"this" is the passed context');
        }, context);

        st.end();
    });

    t.end();
});

test('object', function (t) {
    var obj = {
        a: 1,
        b: 2,
        c: 3
    };
    var keys = /** @type {const} */ (['a', 'b', 'c']);

    /** @constructor */
    function F() {
        this.a = 1;
        this.b = 2;
    }
    F.prototype.c = 3;
    var fKeys = /** @type {const} */ (['a', 'b']);

    t.test('iterates over every object literal key', function (st) {
        var counter = 0;

        forEach(obj, function () { counter += 1; });

        st.equal(counter, keys.length, 'iterated ' + counter + ' times');

        st.end();
    });

    t.test('iterates only over own keys', function (st) {
        var counter = 0;

        forEach(new F(), function () { counter += 1; });

        st.equal(counter, fKeys.length, 'iterated ' + fKeys.length + ' times');

        st.end();
    });

    t.test('first iterator argument', function (st) {
        var index = 0;
        st.plan(keys.length);

        forEach(obj, function (item) {
            st.equal(obj[keys[index]], item, 'item at key ' + keys[index] + ' is passed as first argument');
            index += 1;
        });

        st.end();
    });

    t.test('second iterator argument', function (st) {
        var counter = 0;
        st.plan(keys.length);

        forEach(obj, function (_item, key) {
            st.equal(keys[counter], key, 'key ' + key + ' is passed as second argument');
            counter += 1;
        });

        st.end();
    });

    t.test('third iterator argument', function (st) {
        st.plan(keys.length);

        forEach(obj, function (_item, _key, object) {
            st.deepEqual(obj, object, 'object is passed as third argument');
        });

        st.end();
    });

    t.test('context argument', function (st) {
        var context = {};

        forEach({}, function () {
            st.equal(this, context, '"this" is the passed context');
        }, context);

        st.end();
    });

    t.end();
});

test('string', function (t) {
    var str = /** @type {const} */ ('str');

    t.test('second iterator argument', function (st) {
        var counter = 0;
        st.plan((str.length * 2) + 1);

        forEach(str, function (item, index) {
            st.equal(counter, index, 'index ' + index + ' is passed as second argument');
            st.equal(str.charAt(index), item);
            counter += 1;
        });

        st.equal(counter, str.length, 'iterates ' + str.length + ' times');

        st.end();
    });

    t.end();
});
// jscs:disable requireUseStrict

var test = require('tape');

var functionBind = require('../implementation');
var getCurrentContext = function () { return this; };

test('functionBind is a function', function (t) {
    t.equal(typeof functionBind, 'function');
    t.end();
});

test('non-functions', function (t) {
    var nonFunctions = [true, false, [], {}, 42, 'foo', NaN, /a/g];
    t.plan(nonFunctions.length);
    for (var i = 0; i < nonFunctions.length; ++i) {
        try { functionBind.call(nonFunctions[i]); } catch (ex) {
            t.ok(ex instanceof TypeError, 'throws when given ' + String(nonFunctions[i]));
        }
    }
    t.end();
});

test('without a context', function (t) {
    t.test('binds properly', function (st) {
        var args, context;
        var namespace = {
            func: functionBind.call(function () {
                args = Array.prototype.slice.call(arguments);
                context = this;
            })
        };
        namespace.func(1, 2, 3);
        st.deepEqual(args, [1, 2, 3]);
        st.equal(context, getCurrentContext.call());
        st.end();
    });

    t.test('binds properly, and still supplies bound arguments', function (st) {
        var args, context;
        var namespace = {
            func: functionBind.call(function () {
                args = Array.prototype.slice.call(arguments);
                context = this;
            }, undefined, 1, 2, 3)
        };
        namespace.func(4, 5, 6);
        st.deepEqual(args, [1, 2, 3, 4, 5, 6]);
        st.equal(context, getCurrentContext.call());
        st.end();
    });

    t.test('returns properly', function (st) {
        var args;
        var namespace = {
            func: functionBind.call(function () {
                args = Array.prototype.slice.call(arguments);
                return this;
            }, null)
        };
        var context = namespace.func(1, 2, 3);
        st.equal(context, getCurrentContext.call(), 'returned context is namespaced context');
        st.deepEqual(args, [1, 2, 3], 'passed arguments are correct');
        st.end();
    });

    t.test('returns properly with bound arguments', function (st) {
        var args;
        var namespace = {
            func: functionBind.call(function () {
                args = Array.prototype.slice.call(arguments);
                return this;
            }, null, 1, 2, 3)
        };
        var context = namespace.func(4, 5, 6);
        st.equal(context, getCurrentContext.call(), 'returned context is namespaced context');
        st.deepEqual(args, [1, 2, 3, 4, 5, 6], 'passed arguments are correct');
        st.end();
    });

    t.test('called as a constructor', function (st) {
        var thunkify = function (value) {
            return function () { return value; };
        };
        st.test('returns object value', function (sst) {
            var expectedReturnValue = [1, 2, 3];
            var Constructor = functionBind.call(thunkify(expectedReturnValue), null);
            var result = new Constructor();
            sst.equal(result, expectedReturnValue);
            sst.end();
        });

        st.test('does not return primitive value', function (sst) {
            var Constructor = functionBind.call(thunkify(42), null);
            var result = new Constructor();
            sst.notEqual(result, 42);
            sst.end();
        });

        st.test('object from bound constructor is instance of original and bound constructor', function (sst) {
            var A = function (x) {
                this.name = x || 'A';
            };
            var B = functionBind.call(A, null, 'B');

            var result = new B();
            sst.ok(result instanceof B, 'result is instance of bound constructor');
            sst.ok(result instanceof A, 'result is instance of original constructor');
            sst.end();
        });

        st.end();
    });

    t.end();
});

test('with a context', function (t) {
    t.test('with no bound arguments', function (st) {
        var args, context;
        var boundContext = {};
        var namespace = {
            func: functionBind.call(function () {
                args = Array.prototype.slice.call(arguments);
                context = this;
            }, boundContext)
        };
        namespace.func(1, 2, 3);
        st.equal(context, boundContext, 'binds a context properly');
        st.deepEqual(args, [1, 2, 3], 'supplies passed arguments');
        st.end();
    });

    t.test('with bound arguments', function (st) {
        var args, context;
        var boundContext = {};
        var namespace = {
            func: functionBind.call(function () {
                args = Array.prototype.slice.call(arguments);
                context = this;
            }, boundContext, 1, 2, 3)
        };
        namespace.func(4, 5, 6);
        st.equal(context, boundContext, 'binds a context properly');
        st.deepEqual(args, [1, 2, 3, 4, 5, 6], 'supplies bound and passed arguments');
        st.end();
    });

    t.test('returns properly', function (st) {
        var boundContext = {};
        var args;
        var namespace = {
            func: functionBind.call(function () {
                args = Array.prototype.slice.call(arguments);
                return this;
            }, boundContext)
        };
        var context = namespace.func(1, 2, 3);
        st.equal(context, boundContext, 'returned context is bound context');
        st.notEqual(context, getCurrentContext.call(), 'returned context is not lexical context');
        st.deepEqual(args, [1, 2, 3], 'passed arguments are correct');
        st.end();
    });

    t.test('returns properly with bound arguments', function (st) {
        var boundContext = {};
        var args;
        var namespace = {
            func: functionBind.call(function () {
                args = Array.prototype.slice.call(arguments);
                return this;
            }, boundContext, 1, 2, 3)
        };
        var context = namespace.func(4, 5, 6);
        st.equal(context, boundContext, 'returned context is bound context');
        st.notEqual(context, getCurrentContext.call(), 'returned context is not lexical context');
        st.deepEqual(args, [1, 2, 3, 4, 5, 6], 'passed arguments are correct');
        st.end();
    });

    t.test('passes the correct arguments when called as a constructor', function (st) {
        var expected = { name: 'Correct' };
        var namespace = {
            Func: functionBind.call(function (arg) {
                return arg;
            }, { name: 'Incorrect' })
        };
        var returned = new namespace.Func(expected);
        st.equal(returned, expected, 'returns the right arg when called as a constructor');
        st.end();
    });

    t.test('has the new instance\'s context when called as a constructor', function (st) {
        var actualContext;
        var expectedContext = { foo: 'bar' };
        var namespace = {
            Func: functionBind.call(function () {
                actualContext = this;
            }, expectedContext)
        };
        var result = new namespace.Func();
        st.equal(result instanceof namespace.Func, true);
        st.notEqual(actualContext, expectedContext);
        st.end();
    });

    t.end();
});

test('bound function length', function (t) {
    t.test('sets a correct length without thisArg', function (st) {
        var subject = functionBind.call(function (a, b, c) { return a + b + c; });
        st.equal(subject.length, 3);
        st.equal(subject(1, 2, 3), 6);
        st.end();
    });

    t.test('sets a correct length with thisArg', function (st) {
        var subject = functionBind.call(function (a, b, c) { return a + b + c; }, {});
        st.equal(subject.length, 3);
        st.equal(subject(1, 2, 3), 6);
        st.end();
    });

    t.test('sets a correct length without thisArg and first argument', function (st) {
        var subject = functionBind.call(function (a, b, c) { return a + b + c; }, undefined, 1);
        st.equal(subject.length, 2);
        st.equal(subject(2, 3), 6);
        st.end();
    });

    t.test('sets a correct length with thisArg and first argument', function (st) {
        var subject = functionBind.call(function (a, b, c) { return a + b + c; }, {}, 1);
        st.equal(subject.length, 2);
        st.equal(subject(2, 3), 6);
        st.end();
    });

    t.test('sets a correct length without thisArg and too many arguments', function (st) {
        var subject = functionBind.call(function (a, b, c) { return a + b + c; }, undefined, 1, 2, 3, 4);
        st.equal(subject.length, 0);
        st.equal(subject(), 6);
        st.end();
    });

    t.test('sets a correct length with thisArg and too many arguments', function (st) {
        var subject = functionBind.call(function (a, b, c) { return a + b + c; }, {}, 1, 2, 3, 4);
        st.equal(subject.length, 0);
        st.equal(subject(), 6);
        st.end();
    });
});
'use strict';

module.exports = require('functions-have-names')();

// TODO: semver-major, remove
'use strict';

var implementation = require('../implementation');
var callBind = require('call-bind');
var test = require('tape');
var hasStrictMode = require('has-strict-mode')();
var runTests = require('./tests');

test('as a function', function (t) {
	t.test('bad array/this value', { skip: !hasStrictMode }, function (st) {
		/* eslint no-useless-call: 0 */
		st['throws'](function () { implementation.call(undefined); }, TypeError, 'undefined is not an object');
		st['throws'](function () { implementation.call(null); }, TypeError, 'null is not an object');
		st.end();
	});

	runTests(callBind(implementation), t);

	t.end();
});
'use strict';

var getName = require('../');
var test = require('tape');
var runTests = require('./tests');

test('as a function', function (t) {
	t.test('non-functions', function (st) {
		st['throws'](function () { getName(); }, TypeError, 'undefined is not a function');
		st['throws'](function () { getName(null); }, TypeError, 'null is not a function');
		st['throws'](function () { getName(true); }, TypeError, 'true is not a function');
		st['throws'](function () { getName(false); }, TypeError, 'false is not a function');
		st['throws'](function () { getName('foo'); }, TypeError, '"foo" is not a function');
		st['throws'](function () { getName([]); }, TypeError, '[] is not a function');
		st['throws'](function () { getName({}); }, TypeError, '{} is not a function');
		st['throws'](function () { getName(/a/g); }, TypeError, '/a/g is not a function');
		st.end();
	});

	runTests(getName, t);

	t.end();
});
'use strict';

require('../auto');

var test = require('tape');
var supportsDescriptors = require('define-properties').supportsDescriptors;
var isEnumerable = Object.prototype.propertyIsEnumerable;

var runTests = require('./tests');

test('shimmed', function (t) {
	t.test('enumerability', { skip: !supportsDescriptors }, function (et) {
		et.equal(false, isEnumerable.call(Function.prototype, 'name'), 'Function#name is not enumerable');
		et.equal(false, isEnumerable.call(function foo() {}, 'name'), 'a function’s name is not enumerable');
		et.end();
	});

	runTests(function (fn) { return fn.name; }, t);

	t.end();
});
'use strict';

var functionsHaveNames = require('functions-have-names')();
var arrows = require('make-arrow-function').list();
var generators = require('make-generator-function')();
var asyncs = require('make-async-function').list();
var IsCallable = require('is-callable');
var forEach = require('for-each');

var foo = Object(function foo() {});
var anon = Object(function () {});
var evalled = Object(Function()); // eslint-disable-line no-new-func

module.exports = function (getName, t) {
	t.test('functions', function (st) {
		if (functionsHaveNames) {
			st.equal(getName(foo), foo.name, 'foo has name "foo"');
			st.equal(getName(anon), anon.name, 'anonymous function has name of empty string');
			st.equal(getName(evalled), evalled.name, 'eval-d function has name "anonymous" (or empty string)');
		}
		st.equal(getName(foo), 'foo', 'foo has name "foo"');
		st.equal(getName(anon), '', 'anonymous function has name of empty string');
		var evalledName = getName(evalled);
		st.equal(evalledName === 'anonymous' || evalledName === '', true, 'eval-d function has name "anonymous" (or empty string');
		st.end();
	});

	t.test('arrow functions', { skip: arrows.length === 0 }, function (st) {
		st.equal(true, functionsHaveNames, 'functions have names in any env with arrow functions');
		forEach(arrows, function (arrowFn) {
			st.equal(getName(arrowFn), arrowFn.name, 'arrow function name matches for ' + arrowFn);
		});
		st.end();
	});

	t.test('generators', { skip: generators.length === 0 }, function (st) {
		st.equal(true, functionsHaveNames, 'functions have names in any env with generator functions');
		forEach(generators, function (genFn) {
			st.equal(getName(genFn), genFn.name, 'generator function name matches for ' + genFn);
		});
		st.end();
	});

	t.test('asyncs', { skip: asyncs.length === 0 }, function (st) {
		st.equal(true, functionsHaveNames, 'functions have names in any env with async functions');
		forEach(asyncs, function (asyncFn) {
			st.equal(getName(asyncFn), asyncFn.name, 'async function name matches for ' + asyncFn);
		});
		st.end();
	});

	t.test('Function.prototype.name', function (st) {
		st.equal(getName(function before() {}), 'before', 'function prior to accessing Function.prototype has the right name');
		var protoName = getName(Function.prototype);
		// on <= node v2.5, this is "Empty"; on Opera 12.1, "Function.prototype" - otherwise, the empty string
		st.equal(protoName === '' || protoName === 'Empty' || protoName === 'Function.prototype', true, 'Function.prototype has the right name');
		st.equal(getName(function after() {}), 'after', 'function after accessing Function.prototype has the right name');

		st.end();
	});

	t.test('DOM', function (st) {
		/* eslint-env browser */

		st.test('document.all', { skip: typeof document !== 'object' }, function (s2t) {
			s2t['throws'](
				function () { getName(document.all); },
				TypeError,
				'a document.all has no name'
			);

			s2t.end();
		});

		forEach([
			'HTMLElement',
			'HTMLAnchorElement'
		], function (name) {
			var constructor = global[name];

			st.test(name, { skip: !constructor }, function (s2t) {
				s2t.match(typeof constructor, /^(?:function|object)$/, name + ' is a function or an object');

				if (IsCallable(constructor)) {
					try {
						s2t.equal(getName(constructor), name, name + ' has the right name');
					} catch (e) {
						s2t.fail(e);
					}
				} else {
					s2t['throws'](
						function () { getName(constructor); },
						TypeError,
						name + ' is not callable'
					);
				}

				s2t.end();
			});
		});

		st.end();
	});
};
'use strict';

var test = require('tape');
var runTests = require('./tests');

test('with uglify', function (t) {
	/* eslint global-require: 0 */
	require('uglify-register/api').register({
		exclude: [/\/node_modules\//, /\/test\//],
		uglify: { mangle: true }
	});

	var getName = require('../');
	runTests(getName, t);

	t.end();
});
'use strict';

var test = require('tape');

var hasNames = require('../');

test('named functions', function (t) {
	function f() {} // eslint-disable-line func-style
	var g = function h() {};

	t.equal(typeof hasNames, 'function', 'is a function');
	t.equal(hasNames(), f.name === 'f' && g.name === 'h', 'functions have names or not as expected');

	t.end();
});

var oDP = Object.defineProperty;
if (oDP) {
	try {
		oDP({}, 'a', { value: 1 });
	} catch (e) {
		oDP = null;
	}
}

test('functionsHaveConfigurableNames', function (t) {
	t.equal(typeof hasNames.functionsHaveConfigurableNames, 'function', 'is a function');

	if (hasNames()) {
		var fn = function f() {};
		if (oDP) {
			try {
				oDP(fn, 'name', { configurable: true, value: 'foo' });
			} catch (e) {}
			if (fn.name === 'f') {
				t.equal(hasNames.functionsHaveConfigurableNames(), false, 'function names are not configurable');
			} else if (fn.name === 'foo') {
				t.equal(hasNames.functionsHaveConfigurableNames(), true, 'function names are not configurable');
			} else {
				t.fail('functions have names, but something surprising has happened. Please report this!');
			}
		} else {
			t.equal(hasNames.functionsHaveConfigurableNames(), false, 'function names are not configurable');
		}
	} else {
		t.equal(hasNames.functionsHaveConfigurableNames(), false, 'functions do not have names');
	}

	t.end();
});

test('boundFunctionsHaveNames', function (t) {
	t.equal(typeof hasNames.boundFunctionsHaveNames, 'function', 'is a function');

	var fn = function f() {};
	if (typeof fn.bind !== 'function') {
		t.equal(hasNames.boundFunctionsHaveNames(), false, 'bound functions do not have names, because .bind does not exist');
	} else if (hasNames()) {
		t.equal(hasNames.boundFunctionsHaveNames(), fn.bind().name !== '', 'bound functions have names');
	} else {
		t.equal(hasNames.boundFunctionsHaveNames(), false, 'bound functions do not have names, because none do');
	}

	t.end();
});
'use strict';

var GetIntrinsic = require('../');

var test = require('tape');
var forEach = require('for-each');
var debug = require('object-inspect');
var generatorFns = require('make-generator-function')();
var asyncFns = require('make-async-function').list();
var asyncGenFns = require('make-async-generator-function')();
var mockProperty = require('mock-property');

var callBound = require('call-bound');
var v = require('es-value-fixtures');
var $gOPD = require('gopd');
var DefinePropertyOrThrow = require('es-abstract/2023/DefinePropertyOrThrow');

var $isProto = callBound('%Object.prototype.isPrototypeOf%');

test('export', function (t) {
	t.equal(typeof GetIntrinsic, 'function', 'it is a function');
	t.equal(GetIntrinsic.length, 2, 'function has length of 2');

	t.end();
});

test('throws', function (t) {
	t['throws'](
		function () { GetIntrinsic('not an intrinsic'); },
		SyntaxError,
		'nonexistent intrinsic throws a syntax error'
	);

	t['throws'](
		function () { GetIntrinsic(''); },
		TypeError,
		'empty string intrinsic throws a type error'
	);

	t['throws'](
		function () { GetIntrinsic('.'); },
		SyntaxError,
		'"just a dot" intrinsic throws a syntax error'
	);

	t['throws'](
		function () { GetIntrinsic('%String'); },
		SyntaxError,
		'Leading % without trailing % throws a syntax error'
	);

	t['throws'](
		function () { GetIntrinsic('String%'); },
		SyntaxError,
		'Trailing % without leading % throws a syntax error'
	);

	t['throws'](
		function () { GetIntrinsic("String['prototype]"); },
		SyntaxError,
		'Dynamic property access is disallowed for intrinsics (unterminated string)'
	);

	t['throws'](
		function () { GetIntrinsic('%Proxy.prototype.undefined%'); },
		TypeError,
		"Throws when middle part doesn't exist (%Proxy.prototype.undefined%)"
	);

	t['throws'](
		function () { GetIntrinsic('%Array.prototype%garbage%'); },
		SyntaxError,
		'Throws with extra percent signs'
	);

	t['throws'](
		function () { GetIntrinsic('%Array.prototype%push%'); },
		SyntaxError,
		'Throws with extra percent signs, even on an existing intrinsic'
	);

	forEach(v.nonStrings, function (nonString) {
		t['throws'](
			function () { GetIntrinsic(nonString); },
			TypeError,
			debug(nonString) + ' is not a String'
		);
	});

	forEach(v.nonBooleans, function (nonBoolean) {
		t['throws'](
			function () { GetIntrinsic('%', nonBoolean); },
			TypeError,
			debug(nonBoolean) + ' is not a Boolean'
		);
	});

	forEach([
		'toString',
		'propertyIsEnumerable',
		'hasOwnProperty'
	], function (objectProtoMember) {
		t['throws'](
			function () { GetIntrinsic(objectProtoMember); },
			SyntaxError,
			debug(objectProtoMember) + ' is not an intrinsic'
		);
	});

	t.end();
});

test('base intrinsics', function (t) {
	t.equal(GetIntrinsic('%Object%'), Object, '%Object% yields Object');
	t.equal(GetIntrinsic('Object'), Object, 'Object yields Object');
	t.equal(GetIntrinsic('%Array%'), Array, '%Array% yields Array');
	t.equal(GetIntrinsic('Array'), Array, 'Array yields Array');

	t.end();
});

test('dotted paths', function (t) {
	t.equal(GetIntrinsic('%Object.prototype.toString%'), Object.prototype.toString, '%Object.prototype.toString% yields Object.prototype.toString');
	t.equal(GetIntrinsic('Object.prototype.toString'), Object.prototype.toString, 'Object.prototype.toString yields Object.prototype.toString');
	t.equal(GetIntrinsic('%Array.prototype.push%'), Array.prototype.push, '%Array.prototype.push% yields Array.prototype.push');
	t.equal(GetIntrinsic('Array.prototype.push'), Array.prototype.push, 'Array.prototype.push yields Array.prototype.push');

	test('underscore paths are aliases for dotted paths', { skip: !Object.isFrozen || Object.isFrozen(Object.prototype) }, function (st) {
		var original = GetIntrinsic('%ObjProto_toString%');

		forEach([
			'%Object.prototype.toString%',
			'Object.prototype.toString',
			'%ObjectPrototype.toString%',
			'ObjectPrototype.toString',
			'%ObjProto_toString%',
			'ObjProto_toString'
		], function (name) {
			DefinePropertyOrThrow(Object.prototype, 'toString', {
				'[[Value]]': function toString() {
					return original.apply(this, arguments);
				}
			});
			st.equal(GetIntrinsic(name), original, name + ' yields original Object.prototype.toString');
		});

		DefinePropertyOrThrow(Object.prototype, 'toString', { '[[Value]]': original });
		st.end();
	});

	test('dotted paths cache', { skip: !Object.isFrozen || Object.isFrozen(Object.prototype) }, function (st) {
		var original = GetIntrinsic('%Object.prototype.propertyIsEnumerable%');

		forEach([
			'%Object.prototype.propertyIsEnumerable%',
			'Object.prototype.propertyIsEnumerable',
			'%ObjectPrototype.propertyIsEnumerable%',
			'ObjectPrototype.propertyIsEnumerable'
		], function (name) {
			var restore = mockProperty(Object.prototype, 'propertyIsEnumerable', {
				value: function propertyIsEnumerable() {
					return original.apply(this, arguments);
				}
			});
			st.equal(GetIntrinsic(name), original, name + ' yields cached Object.prototype.propertyIsEnumerable');

			restore();
		});

		st.end();
	});

	test('dotted path reports correct error', function (st) {
		st['throws'](function () {
			GetIntrinsic('%NonExistentIntrinsic.prototype.property%');
		}, /%NonExistentIntrinsic%/, 'The base intrinsic of %NonExistentIntrinsic.prototype.property% is %NonExistentIntrinsic%');

		st['throws'](function () {
			GetIntrinsic('%NonExistentIntrinsicPrototype.property%');
		}, /%NonExistentIntrinsicPrototype%/, 'The base intrinsic of %NonExistentIntrinsicPrototype.property% is %NonExistentIntrinsicPrototype%');

		st.end();
	});

	t.end();
});

test('accessors', { skip: !$gOPD || typeof Map !== 'function' }, function (t) {
	var actual = $gOPD(Map.prototype, 'size');
	t.ok(actual, 'Map.prototype.size has a descriptor');
	t.equal(typeof actual.get, 'function', 'Map.prototype.size has a getter function');
	t.equal(GetIntrinsic('%Map.prototype.size%'), actual.get, '%Map.prototype.size% yields the getter for it');
	t.equal(GetIntrinsic('Map.prototype.size'), actual.get, 'Map.prototype.size yields the getter for it');

	t.end();
});

test('generator functions', { skip: !generatorFns.length }, function (t) {
	var $GeneratorFunction = GetIntrinsic('%GeneratorFunction%');
	var $GeneratorFunctionPrototype = GetIntrinsic('%Generator%');
	var $GeneratorPrototype = GetIntrinsic('%GeneratorPrototype%');

	forEach(generatorFns, function (genFn) {
		var fnName = genFn.name;
		fnName = fnName ? "'" + fnName + "'" : 'genFn';

		t.ok(genFn instanceof $GeneratorFunction, fnName + ' instanceof %GeneratorFunction%');
		t.ok($isProto($GeneratorFunctionPrototype, genFn), '%Generator% is prototype of ' + fnName);
		t.ok($isProto($GeneratorPrototype, genFn.prototype), '%GeneratorPrototype% is prototype of ' + fnName + '.prototype');
	});

	t.end();
});

test('async functions', { skip: !asyncFns.length }, function (t) {
	var $AsyncFunction = GetIntrinsic('%AsyncFunction%');
	var $AsyncFunctionPrototype = GetIntrinsic('%AsyncFunctionPrototype%');

	forEach(asyncFns, function (asyncFn) {
		var fnName = asyncFn.name;
		fnName = fnName ? "'" + fnName + "'" : 'asyncFn';

		t.ok(asyncFn instanceof $AsyncFunction, fnName + ' instanceof %AsyncFunction%');
		t.ok($isProto($AsyncFunctionPrototype, asyncFn), '%AsyncFunctionPrototype% is prototype of ' + fnName);
	});

	t.end();
});

test('async generator functions', { skip: asyncGenFns.length === 0 }, function (t) {
	var $AsyncGeneratorFunction = GetIntrinsic('%AsyncGeneratorFunction%');
	var $AsyncGeneratorFunctionPrototype = GetIntrinsic('%AsyncGenerator%');
	var $AsyncGeneratorPrototype = GetIntrinsic('%AsyncGeneratorPrototype%');

	forEach(asyncGenFns, function (asyncGenFn) {
		var fnName = asyncGenFn.name;
		fnName = fnName ? "'" + fnName + "'" : 'asyncGenFn';

		t.ok(asyncGenFn instanceof $AsyncGeneratorFunction, fnName + ' instanceof %AsyncGeneratorFunction%');
		t.ok($isProto($AsyncGeneratorFunctionPrototype, asyncGenFn), '%AsyncGenerator% is prototype of ' + fnName);
		t.ok($isProto($AsyncGeneratorPrototype, asyncGenFn.prototype), '%AsyncGeneratorPrototype% is prototype of ' + fnName + '.prototype');
	});

	t.end();
});

test('%ThrowTypeError%', function (t) {
	var $ThrowTypeError = GetIntrinsic('%ThrowTypeError%');

	t.equal(typeof $ThrowTypeError, 'function', 'is a function');
	t['throws'](
		$ThrowTypeError,
		TypeError,
		'%ThrowTypeError% throws a TypeError'
	);

	t.end();
});

test('allowMissing', { skip: asyncGenFns.length > 0 }, function (t) {
	t['throws'](
		function () { GetIntrinsic('%AsyncGeneratorPrototype%'); },
		TypeError,
		'throws when missing'
	);

	t.equal(
		GetIntrinsic('%AsyncGeneratorPrototype%', true),
		undefined,
		'does not throw when allowMissing'
	);

	t.end();
});
'use strict';

var test = require('tape');

var getProto = require('../');

test('getProto', function (t) {
	t.equal(typeof getProto, 'function', 'is a function');

	t.test('can get', { skip: !getProto }, function (st) {
		if (getProto) { // TS doesn't understand tape's skip
			var proto = { b: 2 };
			st.equal(getProto(proto), Object.prototype, 'proto: returns the [[Prototype]]');

			st.test('nullish value', function (s2t) {
			// @ts-expect-error
				s2t['throws'](function () { return getProto(undefined); }, TypeError, 'undefined is not an object');
				// @ts-expect-error
				s2t['throws'](function () { return getProto(null); }, TypeError, 'null is not an object');
				s2t.end();
			});

			// @ts-expect-error
			st['throws'](function () { getProto(true); }, 'throws for true');
			// @ts-expect-error
			st['throws'](function () { getProto(false); }, 'throws for false');
			// @ts-expect-error
			st['throws'](function () { getProto(42); }, 'throws for 42');
			// @ts-expect-error
			st['throws'](function () { getProto(NaN); }, 'throws for NaN');
			// @ts-expect-error
			st['throws'](function () { getProto(0); }, 'throws for +0');
			// @ts-expect-error
			st['throws'](function () { getProto(-0); }, 'throws for -0');
			// @ts-expect-error
			st['throws'](function () { getProto(Infinity); }, 'throws for ∞');
			// @ts-expect-error
			st['throws'](function () { getProto(-Infinity); }, 'throws for -∞');
			// @ts-expect-error
			st['throws'](function () { getProto(''); }, 'throws for empty string');
			// @ts-expect-error
			st['throws'](function () { getProto('foo'); }, 'throws for non-empty string');
			st.equal(getProto(/a/g), RegExp.prototype);
			st.equal(getProto(new Date()), Date.prototype);
			st.equal(getProto(function () {}), Function.prototype);
			st.equal(getProto([]), Array.prototype);
			st.equal(getProto({}), Object.prototype);

			var nullObject = { __proto__: null };
			if ('toString' in nullObject) {
				st.comment('no null objects in this engine');
				st.equal(getProto(nullObject), Object.prototype, '"null" object has Object.prototype as [[Prototype]]');
			} else {
				st.equal(getProto(nullObject), null, 'null object has null [[Prototype]]');
			}
		}

		st.end();
	});

	t.test('can not get', { skip: !!getProto }, function (st) {
		st.equal(getProto, null);

		st.end();
	});

	t.end();
});
'use strict';

var test = require('tape');
var debug = require('object-inspect');
var forEach = require('for-each');
var hasOwn = require('hasown');
var v = require('es-value-fixtures');

var getSymbolDescription = require('../');
var getInferredName = require('../getInferredName');

test('getSymbolDescription', function (t) {
	t.test('no symbols', { skip: v.hasSymbols }, function (st) {
		st['throws'](
			// @ts-expect-error
			getSymbolDescription,
			SyntaxError,
			'requires Symbol support'
		);

		st.end();
	});

	forEach([].concat(
		// @ts-expect-error TS sucks with concat
		v.nonSymbolPrimitives,
		v.objects
	), function (nonSymbol) {
		t['throws'](
			function () { getSymbolDescription(nonSymbol); },
			v.hasSymbols ? TypeError : SyntaxError,
			debug(nonSymbol) + ' is not a Symbol'
		);
	});

	t.test('with symbols', { skip: !v.hasSymbols }, function (st) {
		forEach(
			// eslint-disable-next-line no-extra-parens
			/** @type {[symbol, undefined | string][]} */ ([
				[Symbol(), undefined],
				[Symbol(undefined), undefined],
				// @ts-expect-error
				[Symbol(null), 'null'],
				[Symbol.iterator, 'Symbol.iterator'],
				[Symbol('foo'), 'foo']
			]),
			function (pair) {
				var sym = pair[0];
				var desc = pair[1];
				st.equal(getSymbolDescription(sym), desc, debug(sym) + ' description is ' + debug(desc));
			}
		);

		st.test('only possible when inference or native `Symbol.prototype.description` is supported', {
			skip: !getInferredName && !hasOwn(Symbol.prototype, 'description')
		}, function (s2t) {
			s2t.equal(getSymbolDescription(Symbol('')), '', 'Symbol("") description is ""');

			s2t.end();
		});

		st.test('only possible when global symbols are supported', {
			skip: !hasOwn(Symbol, 'for') || !hasOwn(Symbol, 'keyFor')
		}, function (s2t) {
			// eslint-disable-next-line no-restricted-properties
			s2t.equal(getSymbolDescription(Symbol['for']('')), '', 'Symbol.for("") description is ""');
			s2t.end();
		});

		st.end();
	});

	t.end();
});
'use strict';

var implementation = require('../implementation');
var test = require('tape');
var runTests = require('./tests');

test('implementation', function (t) {
	runTests(implementation, t);

	t.end();
});
'use strict';

var systemGlobal = require('../');
var test = require('tape');
var runTests = require('./tests');

test('as a function', function (t) {
	runTests(systemGlobal(), t);

	t.end();
});
'use strict';

var test = require('tape');
var defineProperties = require('define-properties');
var isEnumerable = Object.prototype.propertyIsEnumerable;

var missing = {};
var theGlobal = typeof globalThis === 'object' ? globalThis : missing;

var runTests = require('./tests');

test('native', { todo: theGlobal === missing }, function (t) {
	if (theGlobal !== missing) {
		t.equal(typeof theGlobal, 'object', 'globalThis is an object');
		t.equal('globalThis' in theGlobal, true, 'globalThis is in globalThis');

		t.test('enumerability', { skip: !defineProperties.supportsDescriptors }, function (et) {
			et.equal(false, isEnumerable.call(theGlobal, 'globalThis'), 'globalThis is not enumerable');
			et.end();
		});

		runTests(theGlobal, t);
	}

	t.end();
});
'use strict';

require('../auto');

var test = require('tape');
var defineProperties = require('define-properties');
var isEnumerable = Object.prototype.propertyIsEnumerable;

var runTests = require('./tests');

test('shimmed', function (t) {
	t.equal(typeof globalThis, 'object', 'globalThis is an object');
	t.equal('globalThis' in globalThis, true, 'globalThis is in globalThis');

	t.test('enumerability', { skip: !defineProperties.supportsDescriptors }, function (et) {
		et.equal(false, isEnumerable.call(globalThis, 'globalThis'), 'globalThis.globalThis is not enumerable');
		et.end();
	});

	t.test('writability', { skip: !defineProperties.supportsDescriptors }, function (wt) {
		var desc = Object.getOwnPropertyDescriptor(globalThis, 'globalThis');
		wt.equal(desc.writable, true, 'globalThis.globalThis is writable');
		wt.end();
	});

	runTests(globalThis.globalThis, t);

	t.end();
});
/* jscs:disable requireUseStrict */
/* eslint strict: 0, max-statements: 0 */

module.exports = function (theGlobal, t) {
	t.equal(typeof theGlobal, 'object', 'is an object');

	t.test('built-in globals', function (st) {
		st.equal(theGlobal.Math, Math, 'Math is on the global');
		st.equal(theGlobal.JSON, JSON, 'JSON is on the global');
		st.equal(theGlobal.String, String, 'String is on the global');
		st.equal(theGlobal.Array, Array, 'Array is on the global');
		st.equal(theGlobal.Number, Number, 'Number is on the global');
		st.equal(theGlobal.Boolean, Boolean, 'Boolean is on the global');
		st.equal(theGlobal.Object, Object, 'Object is on the global');
		st.equal(theGlobal.Function, Function, 'Function is on the global');
		st.equal(theGlobal.Date, Date, 'Date is on the global');
		st.equal(theGlobal.RegExp, RegExp, 'RegExp is on the global');

		if (typeof Symbol === 'undefined') {
			st.comment('# SKIP Symbol is not supported');
		} else {
			st.equal(theGlobal.Symbol, Symbol, 'Symbol is on the global');
		}
		st.end();
	});

	t.test('custom property', function (st) {
		var key = 'random_custom_key_' + new Date().getTime();
		var semaphore = {};
		/* eslint no-eval: 1 */
		eval(key + ' = semaphore;');
		st.equal(theGlobal[key], semaphore, 'global variable ends up on the global object');
		delete theGlobal[key]; // eslint-disable-line no-param-reassign
		st.end();
	});
};
'use strict';

var test = require('tape');
var gOPD = require('../');

test('gOPD', function (t) {
	t.test('supported', { skip: !gOPD }, function (st) {
		st.equal(typeof gOPD, 'function', 'is a function');

		var obj = { x: 1 };
		st.ok('x' in obj, 'property exists');

		// @ts-expect-error TS can't figure out narrowing from `skip`
		var desc = gOPD(obj, 'x');
		st.deepEqual(
			desc,
			{
				configurable: true,
				enumerable: true,
				value: 1,
				writable: true
			},
			'descriptor is as expected'
		);

		st.end();
	});

	t.test('not supported', { skip: !!gOPD }, function (st) {
		st.notOk(gOPD, 'is falsy');

		st.end();
	});

	t.end();
});
'use strict';

var test = require('tape');
var hasBigInts = require('..');

test('interface', function (t) {
	t.equal(typeof hasBigInts, 'function', 'is a function');
	t.equal(typeof hasBigInts(), 'boolean', 'returns a boolean');
	t.end();
});

test('BigInts are supported', { skip: !hasBigInts() }, function (t) {
	t.equal(typeof BigInt, 'function', 'global BigInt is a function');
	if (typeof BigInt !== 'function') {
		return;
	}

	t.equal(BigInt(42), BigInt(42), '42n === 42n');
	t['throws'](
		function () { BigInt(NaN); },
		RangeError,
		'NaN is not an integer; BigInt(NaN) throws'
	);

	t['throws'](
		function () { BigInt(Infinity); },
		RangeError,
		'Infinity is not an integer; BigInt(Infinity) throws'
	);

	t['throws'](
		function () { BigInt(1.1); },
		RangeError,
		'1.1 is not an integer; BigInt(1.1) throws'
	);

	t.end();
});

test('BigInts are not supported', { skip: hasBigInts() }, function (t) {
	t.equal(typeof BigInt, 'undefined', 'global BigInt is undefined');

	t.end();
});
'use strict';

var test = require('tape');

var hasPropertyDescriptors = require('../');

var sentinel = {};

test('hasPropertyDescriptors', function (t) {
	t.equal(typeof hasPropertyDescriptors, 'function', 'is a function');
	t.equal(typeof hasPropertyDescriptors.hasArrayLengthDefineBug, 'function', '`hasArrayLengthDefineBug` property is a function');

	var yes = hasPropertyDescriptors();
	t.test('property descriptors', { skip: !yes }, function (st) {
		var o = { a: sentinel };

		st.deepEqual(
			Object.getOwnPropertyDescriptor(o, 'a'),
			{
				configurable: true,
				enumerable: true,
				value: sentinel,
				writable: true
			},
			'has expected property descriptor'
		);

		Object.defineProperty(o, 'a', { enumerable: false, writable: false });

		st.deepEqual(
			Object.getOwnPropertyDescriptor(o, 'a'),
			{
				configurable: true,
				enumerable: false,
				value: sentinel,
				writable: false
			},
			'has expected property descriptor after [[Define]]'
		);

		st.end();
	});

	var arrayBug = hasPropertyDescriptors.hasArrayLengthDefineBug();
	t.test('defining array lengths', { skip: !yes || arrayBug }, function (st) {
		var arr = [1, , 3]; // eslint-disable-line no-sparse-arrays
		st.equal(arr.length, 3, 'array starts with length 3');

		Object.defineProperty(arr, 'length', { value: 5 });

		st.equal(arr.length, 5, 'array ends with length 5');

		st.end();
	});

	t.end();
});
'use strict';

var test = require('tape');
var gPO = require('reflect.getprototypeof/polyfill')();
var gOPD = require('gopd');

var hasProto = require('../');
var hasProtoAccessor = require('../accessor');

var getter = require('dunder-proto/get');

test('hasProtoAccessor', function (t) {
	var result = hasProtoAccessor();
	t.equal(typeof result, 'boolean', 'returns a boolean (' + result + ')');

	var obj = { __proto__: null };
	if (result) {
		t.notOk('toString' in obj, 'null object lacks toString');
		t.equal(gPO(obj), null);
		if (gOPD && getter) {
			t.equal(getter(obj), null);
		}
	} else if (hasProto()) {
		t.notOk('toString' in obj, 'null object lacks toString');
		if (gOPD && getter) {
			t.equal(getter(obj), null);
		}
	} else {
		t.ok('toString' in obj, 'without proto, null object has toString');
		t.equal(gPO(obj), Object.prototype);
	}

	t.end();
});
'use strict';

var test = require('tape');
var gPO = require('reflect.getprototypeof/polyfill')();
var gOPD = require('gopd');

var hasProto = require('../');

var getter = require('dunder-proto/get');

test('hasProto', function (t) {
	var result = hasProto();
	t.equal(typeof result, 'boolean', 'returns a boolean (' + result + ')');

	var obj = { __proto__: null };
	if (result) {
		t.notOk('toString' in obj, 'null object lacks toString');
		if (gOPD && getter) {
			t.equal(getter(obj), null);
		}
	} else {
		t.ok('toString' in obj, 'without proto, null object has toString');
		t.equal(gPO(obj), Object.prototype);
	}

	t.end();
});

'use strict';

var test = require('tape');
var gPO = require('reflect.getprototypeof/polyfill')();
var gOPD = require('gopd');

var hasProto = require('../');
var hasProtoMutator = require('../mutator');

var getter = require('dunder-proto/get');

test('hasProtoMutator', function (t) {
	var result = hasProtoMutator();
	t.equal(typeof result, 'boolean', 'returns a boolean (' + result + ')');

	var obj = { __proto__: null };
	if (result) {
		t.notOk('toString' in obj, 'null object lacks toString');
		t.equal(gPO(obj), null);
		if (gOPD && getter) {
			t.equal(getter(obj), null);
		}
	} else if (hasProto()) {
		t.notOk('toString' in obj, 'null object lacks toString');
		if (gOPD && getter) {
			t.equal(getter(obj), null);
		}
	} else {
		t.ok('toString' in obj, 'without proto, null object has toString');
		t.equal(gPO(obj), Object.prototype);
	}

	t.end();
});
'use strict';

var test = require('tape');
var hasSymbols = require('../');
var runSymbolTests = require('./tests');

test('interface', function (t) {
	t.equal(typeof hasSymbols, 'function', 'is a function');
	t.equal(typeof hasSymbols(), 'boolean', 'returns a boolean');
	t.end();
});

test('Symbols are supported', { skip: !hasSymbols() }, function (t) {
	runSymbolTests(t);
	t.end();
});

test('Symbols are not supported', { skip: hasSymbols() }, function (t) {
	t.equal(typeof Symbol, 'undefined', 'global Symbol is undefined');
	t.equal(typeof Object.getOwnPropertySymbols, 'undefined', 'Object.getOwnPropertySymbols does not exist');
	t.end();
});
'use strict';

/** @type {(t: import('tape').Test) => false | void} */
// eslint-disable-next-line consistent-return
module.exports = function runSymbolTests(t) {
	t.equal(typeof Symbol, 'function', 'global Symbol is a function');

	if (typeof Symbol !== 'function') { return false; }

	t.notEqual(Symbol(), Symbol(), 'two symbols are not equal');

	/*
	t.equal(
		Symbol.prototype.toString.call(Symbol('foo')),
		Symbol.prototype.toString.call(Symbol('foo')),
		'two symbols with the same description stringify the same'
	);
	*/

	/*
	var foo = Symbol('foo');

	t.notEqual(
		String(foo),
		String(Symbol('bar')),
		'two symbols with different descriptions do not stringify the same'
	);
	*/

	t.equal(typeof Symbol.prototype.toString, 'function', 'Symbol#toString is a function');
	// t.equal(String(foo), Symbol.prototype.toString.call(foo), 'Symbol#toString equals String of the same symbol');

	t.equal(typeof Object.getOwnPropertySymbols, 'function', 'Object.getOwnPropertySymbols is a function');

	/** @type {{ [k in symbol]?: unknown }} */
	var obj = {};
	var sym = Symbol('test');
	var symObj = Object(sym);
	t.notEqual(typeof sym, 'string', 'Symbol is not a string');
	t.equal(Object.prototype.toString.call(sym), '[object Symbol]', 'symbol primitive Object#toStrings properly');
	t.equal(Object.prototype.toString.call(symObj), '[object Symbol]', 'symbol primitive Object#toStrings properly');

	var symVal = 42;
	obj[sym] = symVal;
	// eslint-disable-next-line no-restricted-syntax, no-unused-vars
	for (var _ in obj) { t.fail('symbol property key was found in for..in of object'); }

	t.deepEqual(Object.keys(obj), [], 'no enumerable own keys on symbol-valued object');
	t.deepEqual(Object.getOwnPropertyNames(obj), [], 'no own names on symbol-valued object');
	t.deepEqual(Object.getOwnPropertySymbols(obj), [sym], 'one own symbol on symbol-valued object');
	t.equal(Object.prototype.propertyIsEnumerable.call(obj, sym), true, 'symbol is enumerable');
	t.deepEqual(Object.getOwnPropertyDescriptor(obj, sym), {
		configurable: true,
		enumerable: true,
		value: 42,
		writable: true
	}, 'property descriptor is correct');
};
'use strict';

var test = require('tape');
var hasSymbolToStringTag = require('../');
var runSymbolTests = require('./tests');

test('interface', function (t) {
	t.equal(typeof hasSymbolToStringTag, 'function', 'is a function');
	t.equal(typeof hasSymbolToStringTag(), 'boolean', 'returns a boolean');
	t.end();
});

test('Symbol.toStringTag exists', { skip: !hasSymbolToStringTag() }, function (t) {
	runSymbolTests(t);
	t.end();
});

test('Symbol.toStringTag does not exist', { skip: hasSymbolToStringTag() }, function (t) {
	t.equal(typeof Symbol === 'undefined' ? 'undefined' : typeof Symbol.toStringTag, 'undefined', 'global Symbol.toStringTag is undefined');
	t.end();
});
'use strict';

// eslint-disable-next-line consistent-return
module.exports = /** @type {(t: import('tape').Test) => void | false} */ function runSymbolTests(t) {
	t.equal(typeof Symbol, 'function', 'global Symbol is a function');
	t.ok(Symbol.toStringTag, 'Symbol.toStringTag exists');

	if (typeof Symbol !== 'function' || !Symbol.toStringTag) { return false; }

	/** @type {{ [Symbol.toStringTag]?: 'test'}} */
	var obj = {};
	obj[Symbol.toStringTag] = 'test';

	t.equal(Object.prototype.toString.call(obj), '[object test]');
};
'use strict';

var test = require('tape');
var inspect = require('object-inspect');
var forEach = require('for-each');

var SLOT = require('../');

test('assert', function (t) {
	forEach([null, undefined, true, false, 'foo', '', 42, 0], function (primitive) {
		t['throws'](
			// @ts-expect-error
			function () { SLOT.assert(primitive, ''); },
			TypeError,
			inspect(primitive) + ' is not an Object'
		);
	});

	forEach([null, undefined, true, false, 42, 0, {}, [], function () {}, /a/g], function (nonString) {
		t['throws'](
			// @ts-expect-error
			function () { SLOT.assert({}, nonString); },
			TypeError,
			inspect(nonString) + ' is not a String'
		);
	});

	t['throws'](
		function () { SLOT.assert({}, '[[whatever]]'); },
		TypeError,
		'nonexistent slot throws'
	);

	var o = {};
	SLOT.set(o, 'x');
	t.doesNotThrow(function () { SLOT.assert(o, 'x'); }, 'existent slot noops');
	t['throws'](function () { SLOT.assert(o, 'y'); }, 'thing with a slot throws on a nonexistent slot');

	t.end();
});

test('has', function (t) {
	forEach([null, undefined, true, false, 'foo', '', 42, 0], function (primitive) {
		t['throws'](
			// @ts-expect-error
			function () { SLOT.has(primitive, ''); },
			TypeError,
			inspect(primitive) + ' is not an Object'
		);
	});

	forEach([null, undefined, true, false, 42, 0, {}, [], function () {}, /a/g], function (nonString) {
		t['throws'](
			// @ts-expect-error
			function () { SLOT.has({}, nonString); },
			TypeError,
			inspect(nonString) + ' is not a String'
		);
	});

	var o = {};

	t.equal(SLOT.has(o, '[[nonexistent]]'), false, 'nonexistent slot yields false');

	SLOT.set(o, 'foo');
	t.equal(SLOT.has(o, 'foo'), true, 'existent slot yields true');

	t.end();
});

test('get', function (t) {
	forEach([null, undefined, true, false, 'foo', '', 42, 0], function (primitive) {
		t['throws'](
			// @ts-expect-error
			function () { SLOT.get(primitive, ''); },
			TypeError,
			inspect(primitive) + ' is not an Object'
		);
	});

	forEach([null, undefined, true, false, 42, 0, {}, [], function () {}, /a/g], function (nonString) {
		t['throws'](
			// @ts-expect-error
			function () { SLOT.get({}, nonString); },
			TypeError,
			inspect(nonString) + ' is not a String'
		);
	});

	var o = {};
	t.equal(SLOT.get(o, 'nonexistent'), undefined, 'nonexistent slot is undefined');

	var v = {};
	SLOT.set(o, 'f', v);
	t.equal(SLOT.get(o, 'f'), v, '"get" retrieves value set by "set"');

	t.end();
});

test('set', function (t) {
	forEach([null, undefined, true, false, 'foo', '', 42, 0], function (primitive) {
		t['throws'](
			// @ts-expect-error
			function () { SLOT.set(primitive, ''); },
			TypeError,
			inspect(primitive) + ' is not an Object'
		);
	});

	forEach([null, undefined, true, false, 42, 0, {}, [], function () {}, /a/g], function (nonString) {
		t['throws'](
			// @ts-expect-error
			function () { SLOT.set({}, nonString); },
			TypeError,
			inspect(nonString) + ' is not a String'
		);
	});

	var o = function () {};
	t.equal(SLOT.get(o, 'f'), undefined, 'slot not set');

	SLOT.set(o, 'f', 42);
	t.equal(SLOT.get(o, 'f'), 42, 'slot was set');

	SLOT.set(o, 'f', Infinity);
	t.equal(SLOT.get(o, 'f'), Infinity, 'slot was set again');

	t.end();
});
'use strict';

var test = require('tape');
var inspect = require('object-inspect');
var forEach = require('for-each');
var v = require('es-value-fixtures');
var availableTypedArrays = require('available-typed-arrays')();

var isArrayBuffer = require('..');

test('isArrayBuffer', function (t) {
	t.equal(typeof isArrayBuffer, 'function', 'is a function');

	/** @type {unknown[]} */
	var nonABs = [].concat(
		// @ts-expect-error TS sucks with [].concat
		v.primitives,
		v.objects,
		typeof SharedArrayBuffer === 'function' ? new SharedArrayBuffer(0) : []
	);
	forEach(nonABs, function (nonAB) {
		t.equal(isArrayBuffer(nonAB), false, inspect(nonAB) + ' is not an ArrayBuffer');
	});

	t.test('actual ArrayBuffer instances', { skip: typeof ArrayBuffer === 'undefined' }, function (st) {
		var ab = new ArrayBuffer();
		st.equal(isArrayBuffer(ab), true, inspect(ab) + ' is an ArrayBuffer');

		var ab42 = new ArrayBuffer(42);
		st.equal(isArrayBuffer(ab42), true, inspect(ab42) + ' is an ArrayBuffer');

		var dv = new DataView(ab42);
		st.equal(isArrayBuffer(dv), false, inspect(dv) + ' is not an ArrayBuffer');

		st.end();
	});

	t.test('Typed Arrays', { skip: availableTypedArrays.length === 0 }, function (st) {
		forEach(availableTypedArrays, function (TypedArray) {
			var ta = new global[TypedArray](0);
			st.equal(isArrayBuffer(ta.buffer), true, inspect(ta.buffer) + ', the TA\'s buffer, is an ArrayBuffer');
			st.equal(isArrayBuffer(ta), false, inspect(ta) + ' is not an ArrayBuffer');
		});

		st.end();
	});

	t.end();
});
'use strict';

/* globals window */

var test = require('tape');
var isAsyncFunction = require('../index');
var generatorFuncs = require('make-generator-function')();
var asyncFuncs = require('make-async-function').list();
var hasToStringTag = require('has-tostringtag/shams')();

var forEach = require('for-each');

test('returns false for non-functions', function (t) {
	var nonFuncs = [
		true,
		false,
		null,
		undefined,
		{},
		[],
		/a/g,
		'string',
		42,
		new Date()
	];
	t.plan(nonFuncs.length);
	forEach(nonFuncs, function (nonFunc) {
		t.notOk(isAsyncFunction(nonFunc), nonFunc + ' is not a function');
	});
	t.end();
});

test('returns false for non-async functions', function (t) {
	var func = function () {};
	t.notOk(isAsyncFunction(func), 'anonymous function is not an async function');

	var namedFunc = function foo() {};
	t.notOk(isAsyncFunction(namedFunc), 'named function is not an async function');

	if (typeof window === 'undefined') {
		t.skip('window.alert is not an async function');
	} else {
		t.notOk(isAsyncFunction(window.alert), 'window.alert is not an async function');
	}
	t.end();
});

var fakeToString = function () { return 'async function () { return "TOTALLY REAL I SWEAR!"; }'; };

test('returns false for non-async function with faked toString', function (t) {
	var func = function () {};
	func.toString = fakeToString;

	t.notEqual(String(func), Function.prototype.toString.apply(func), 'faked toString is not real toString');
	t.notOk(isAsyncFunction(func), 'anonymous function with faked toString is not an async function');
	t.end();
});

test('returns false for generator functions', function (t) {
	if (generatorFuncs.length > 0) {
		forEach(generatorFuncs, function (generatorFunc) {
			t.notOk(isAsyncFunction(generatorFunc), generatorFunc + ' is not async function');
		});
	} else {
		t.skip('generator function is not async function - this environment does not support ES6 generator functions. Please use an engine that supports them.');
	}
	t.end();
});

test('returns false for non-async function with faked @@toStringTag', { skip: !hasToStringTag || asyncFuncs.length === 0 }, function (t) {
	var asyncFunc = asyncFuncs[0];
	/** @type {{ toString(): unknown; valueOf(): unknown; [Symbol.toStringTag]?: unknown }} */
	var fakeAsyncFunction = {
		toString: function () { return String(asyncFunc); },
		valueOf: function () { return asyncFunc; }
	};
	fakeAsyncFunction[Symbol.toStringTag] = 'AsyncFunction';
	t.notOk(isAsyncFunction(fakeAsyncFunction), 'fake AsyncFunction with @@toStringTag "AsyncFunction" is not an async function');
	t.end();
});

test('returns true for async functions', function (t) {
	if (asyncFuncs.length > 0) {
		forEach(asyncFuncs, function (asyncFunc) {
			t.ok(isAsyncFunction(asyncFunc), asyncFunc + ' is async function');
		});
	} else {
		t.skip('async function is async function - this environment does not support ES2018 async functions. Please use an engine that supports them.');
	}
	t.end();
});
'use strict';

// @ts-expect-error
require('uglify-register/api').register({
	exclude: [/\/node_modules\//, /\/test\//],
	uglify: { mangle: true }
});

require('./');
'use strict';

var test = require('tape');
var inspect = require('object-inspect');
var hasBigInts = require('has-bigints')();
var hasToStringTag = require('has-tostringtag/shams')();
var forEach = require('for-each');
var v = require('es-value-fixtures');

var isBigInt = require('../');

test('non-BigInt values', function (t) {
	/** @type {(typeof v.primitives[number] | object)[]} */
	var nonBigInts = v.nonBigInts.concat(
		Object(true),
		Object(false),
		// @ts-expect-error TS sucks with concat
		{},
		[],
		/a/g,
		new Date(),
		function () {},
		NaN,
		v.symbols
	);
	t.plan(nonBigInts.length);
	forEach(nonBigInts, function (nonBigInt) {
		t.equal(false, isBigInt(nonBigInt), inspect(nonBigInt) + ' is not a BigInt');
	});
	t.end();
});

test('faked BigInt values', function (t) {
	t.test('real BigInt valueOf', { skip: !hasBigInts }, function (st) {
		var fakeBigInt = { valueOf: function () { return BigInt(42); } };
		st.equal(false, isBigInt(fakeBigInt), 'object with valueOf returning a BigInt is not a BigInt');
		st.end();
	});

	t.test('faked @@toStringTag', { skip: !hasBigInts || !hasToStringTag }, function (st) {
		/** @type {{ valueOf(): unknown; [Symbol.toStringTag]?: unknown }} */
		var fakeBigInt = { valueOf: function () { return BigInt(42); } };
		fakeBigInt[Symbol.toStringTag] = 'BigInt';
		st.equal(false, isBigInt(fakeBigInt), 'object with fake BigInt @@toStringTag and valueOf returning a BigInt is not a BigInt');

		/** @type {{ valueOf(): unknown; [Symbol.toStringTag]?: unknown }} */
		var notSoFakeBigInt = { valueOf: function () { return 42; } };
		notSoFakeBigInt[Symbol.toStringTag] = 'BigInt';
		st.equal(false, isBigInt(notSoFakeBigInt), 'object with fake BigInt @@toStringTag and valueOf not returning a BigInt is not a BigInt');
		st.end();
	});

	var fakeBigIntString = { toString: function () { return '42n'; } };
	t.equal(false, isBigInt(fakeBigIntString), 'object with toString returning 42n is not a BigInt');

	t.end();
});

test('BigInt support', { skip: !hasBigInts }, function (t) {
	forEach(v.bigints.concat(Object(BigInt(42))), function (bigInt) {
		t.equal(true, isBigInt(bigInt), inspect(bigInt) + ' is a BigInt');
	});

	t.end();
});
'use strict';

var test = require('tape');
var hasToStringTag = require('has-tostringtag/shams')();
var inspect = require('object-inspect');

var isBoolean = require('../');

test('not Booleans', function (t) {
	t.test('primitives', function (st) {
		// @ts-expect-error
		st.notOk(isBoolean(), 'undefined is not Boolean');
		st.notOk(isBoolean(null), 'null is not Boolean');
		st.notOk(isBoolean(0), '0 is not Boolean');
		st.notOk(isBoolean(NaN), 'NaN is not Boolean');
		st.notOk(isBoolean(Infinity), 'Infinity is not Boolean');
		st.notOk(isBoolean('foo'), 'string is not Boolean');
		st.end();
	});

	t.test('objects', function (st) {
		st.notOk(isBoolean(Object(42)), 'number object is not Boolean');
		st.notOk(isBoolean([]), 'array is not Boolean');
		st.notOk(isBoolean({}), 'object is not Boolean');
		st.notOk(isBoolean(function () {}), 'function is not Boolean');
		st.notOk(isBoolean(/a/g), 'regex literal is not Boolean');
		st.notOk(isBoolean(new RegExp('a', 'g')), 'regex object is not Boolean');
		st.notOk(isBoolean(new Date()), 'new Date() is not Boolean');
		st.end();
	});

	t.end();
});

test('@@toStringTag', { skip: !hasToStringTag }, function (t) {
	/** @type {{ toString(): unknown; valueOf(): unknown; [Symbol.toStringTag]?: string; }} */
	var fakeBoolean = {
		toString: function () { return 'true'; },
		valueOf: function () { return true; }
	};
	fakeBoolean[Symbol.toStringTag] = 'Boolean';
	t.notOk(isBoolean(fakeBoolean), 'fake Boolean with @@toStringTag "Boolean" is not Boolean');
	t.end();
});

test('Booleans', function (t) {
	t.ok(isBoolean(true), 'true is Boolean');
	t.ok(isBoolean(false), 'false is Boolean');
	t.ok(isBoolean(Object(true)), 'Object(true) is Boolean');
	t.ok(isBoolean(Object(false)), 'Object(false) is Boolean');
	t.end();
});

test('Proxy', { skip: typeof Proxy !== 'function' || !hasToStringTag }, function (t) {
	/** @type {Record<PropertyKey, unknown>} */
	var target = {};
	target[Symbol.toStringTag] = 'Boolean';
	var fake = new Proxy(target, { has: function () { return false; } });

	t.equal(
		isBoolean(target),
		false,
		inspect(target) + ' is not a Boolean'
	);

	t.equal(
		isBoolean(fake),
		false,
		inspect(fake) + ' is not a Boolean'
	);

	t.end();
});
'use strict';

/* eslint no-magic-numbers: 1 */

var test = require('tape');
var isCallable = require('../');
var hasToStringTag = require('has-tostringtag/shams')();
var v = require('es-value-fixtures');
var forEach = require('for-each');
var inspect = require('object-inspect');
var typedArrayNames = require('available-typed-arrays')();
var generators = require('make-generator-function')();
var arrows = require('make-arrow-function').list();
var asyncs = require('make-async-function').list();
var weirdlyCommentedArrowFn;
try {
	/* eslint-disable no-new-func */
	weirdlyCommentedArrowFn = Function('return cl/*/**/=>/**/ass - 1;')();
	/* eslint-enable no-new-func */
} catch (e) { /**/ }

var isIE68 = !(0 in [undefined]);
var isFirefox = typeof window !== 'undefined' && ('netscape' in window) && (/ rv:/).test(navigator.userAgent);
var fnToStringCoerces;
try {
	Function.prototype.toString.call(v.uncoercibleFnObject);
	fnToStringCoerces = true;
} catch (e) {
	fnToStringCoerces = false;
}

var noop = function () {};
var classFake = function classFake() { }; // eslint-disable-line func-name-matching
var returnClass = function () { return ' class '; };
var return3 = function () { return 3; };
/* for coverage */
noop();
classFake();
returnClass();
return3();
/* end for coverage */

var proxy;
if (typeof Proxy === 'function') {
	try {
		proxy = new Proxy(function () {}, {});
		// for coverage
		proxy();
		String(proxy);
	} catch (_) {
		// Older engines throw a `TypeError` when `Function.prototype.toString` is called on a Proxy object.
		proxy = null;
	}
}

var invokeFunction = function invokeFunctionString(str) {
	var result;
	try {
		/* eslint-disable no-new-func */
		var fn = Function(str);
		/* eslint-enable no-new-func */
		result = fn();
	} catch (e) {}
	return result;
};

var classConstructor = invokeFunction('"use strict"; return class Foo {}');
var hasDetectableClasses = classConstructor && Function.prototype.toString.call(classConstructor) === 'class Foo {}';

var commentedClass = invokeFunction('"use strict"; return class/*kkk*/\n//blah\n Bar\n//blah\n {}');
var commentedClassOneLine = invokeFunction('"use strict"; return class/**/A{}');
var classAnonymous = invokeFunction('"use strict"; return class{}');
var classAnonymousCommentedOneLine = invokeFunction('"use strict"; return class/*/*/{}');

test('not callables', function (t) {
	t.notOk(isCallable(), 'implicit undefined is not callable');

	forEach(v.nonFunctions.concat([
		Object(42),
		Object('foo'),
		NaN,
		[],
		/a/g,
		new RegExp('a', 'g'),
		new Date()
	]), function (nonFunction) {
		if (fnToStringCoerces && nonFunction === v.coercibleFnObject) {
			t.comment('FF 3.6 has a Function toString that coerces its receiver, so this test is skipped');
			return;
		}
		if (nonFunction != null) { // eslint-disable-line eqeqeq
			if (isFirefox) {
			// Firefox 3 throws some kind of *object* here instead of a proper error
				t['throws'](
					function () { Function.prototype.toString.call(nonFunction); },
					inspect(nonFunction) + ' can not be used with Function toString'
				);
			} else {
				t['throws'](
					function () { Function.prototype.toString.call(nonFunction); },
					TypeError,
					inspect(nonFunction) + ' can not be used with Function toString'
				);
			}
		}
		t.equal(isCallable(nonFunction), false, inspect(nonFunction) + ' is not callable');
	});

	t.test('non-function with function in its [[Prototype]] chain', function (st) {
		var Foo = function Bar() {};
		Foo.prototype = noop;
		st.equal(isCallable(Foo), true, 'sanity check: Foo is callable');
		st.equal(isCallable(new Foo()), false, 'instance of Foo is not callable');
		st.end();
	});

	t.end();
});

test('@@toStringTag', { skip: !hasToStringTag }, function (t) {
	var fakeFunction = {
		toString: function () { return String(return3); },
		valueOf: return3
	};
	fakeFunction[Symbol.toStringTag] = 'Function';
	t.equal(String(fakeFunction), String(return3));
	t.equal(Number(fakeFunction), return3());
	t.notOk(isCallable(fakeFunction), 'fake Function with @@toStringTag "Function" is not callable');
	t.end();
});

test('Functions', function (t) {
	t.ok(isCallable(noop), 'function is callable');
	t.ok(isCallable(classFake), 'function with name containing "class" is callable');
	t.ok(isCallable(returnClass), 'function with string " class " is callable');
	t.ok(isCallable(isCallable), 'isCallable is callable');
	t.end();
});

test('Typed Arrays', { skip: typedArrayNames.length === 0 }, function (st) {
	forEach(typedArrayNames, function (typedArray) {
		st.ok(isCallable(global[typedArray]), typedArray + ' is callable');
	});
	st.end();
});

test('Generators', { skip: generators.length === 0 }, function (t) {
	forEach(generators, function (genFn) {
		t.ok(isCallable(genFn), 'generator function ' + genFn + ' is callable');
	});
	t.end();
});

test('Arrow functions', { skip: arrows.length === 0 }, function (t) {
	forEach(arrows, function (arrowFn) {
		t.ok(isCallable(arrowFn), 'arrow function ' + arrowFn + ' is callable');
	});
	t.ok(isCallable(weirdlyCommentedArrowFn), 'weirdly commented arrow functions are callable');
	t.end();
});

test('"Class" constructors', {
	skip: !classConstructor || !commentedClass || !commentedClassOneLine || !classAnonymous, todo: !hasDetectableClasses
}, function (t) {
	if (!hasDetectableClasses) {
		t.comment('WARNING: This engine does not support detectable classes');
	}
	t.notOk(isCallable(classConstructor), 'class constructors are not callable');
	t.notOk(isCallable(commentedClass), 'class constructors with comments in the signature are not callable');
	t.notOk(isCallable(commentedClassOneLine), 'one-line class constructors with comments in the signature are not callable');
	t.notOk(isCallable(classAnonymous), 'anonymous class constructors are not callable');
	t.notOk(isCallable(classAnonymousCommentedOneLine), 'anonymous one-line class constructors with comments in the signature are not callable');
	t.end();
});

test('`async function`s', { skip: asyncs.length === 0 }, function (t) {
	forEach(asyncs, function (asyncFn) {
		t.ok(isCallable(asyncFn), '`async function` ' + asyncFn + ' is callable');
	});
	t.end();
});

test('proxies of functions', { skip: !proxy }, function (t) {
	t.equal(isCallable(proxy), true, 'proxies of functions are callable');
	t.end();
});

test('throwing functions', function (t) {
	t.plan(1);

	var thrower = function (a) { return a.b; };
	t.ok(isCallable(thrower), 'a function that throws is callable');
});

test('DOM', function (t) {
	/* eslint-env browser */

	t.test('document.all', { skip: typeof document !== 'object' }, function (st) {
		st.notOk(isCallable(document), 'document is not callable');

		var all = document.all;
		var isFF3 = !isIE68 && Object.prototype.toString(all) === Object.prototype.toString.call(document.all); // this test is true in IE 6-8 also
		var expected = false;
		if (!isFF3) {
			try {
				expected = document.all('') == null; // eslint-disable-line eqeqeq
			} catch (e) { /**/ }
		}
		st.equal(isCallable(document.all), expected, 'document.all is ' + (isFF3 ? 'not ' : '') + 'callable');

		st.end();
	});

	forEach([
		'HTMLElement',
		'HTMLAnchorElement'
	], function (name) {
		var constructor = global[name];

		t.test(name, { skip: !constructor }, function (st) {
			st.match(typeof constructor, /^(?:function|object)$/, name + ' is a function or object');

			var callable = isCallable(constructor);
			st.equal(typeof callable, 'boolean');

			if (callable) {
				st.doesNotThrow(
					function () { Function.prototype.toString.call(constructor); },
					'anything this library claims is callable should be accepted by Function toString'
				);
			} else {
				st['throws'](
					function () { Function.prototype.toString.call(constructor); },
					TypeError,
					'anything this library claims is not callable should not be accepted by Function toString'
				);
			}

			st.end();
		});
	});

	t.end();
});
'use strict';

var test = require('tape');
var isDataView = require('../');

var hasToStringTag = require('has-tostringtag/shams')();
var generators = require('make-generator-function')();
var arrowFns = require('make-arrow-function').list();
var forEach = require('for-each');
var v = require('es-value-fixtures');
var inspect = require('object-inspect');
var availableTypedArrays = require('available-typed-arrays')();

test('not DataViews', function (t) {
	forEach([].concat(
		// @ts-expect-error TS sucks at [].concat
		v.primitives,
		v.objects,
		function () {},
		generators,
		arrowFns,
		[]
	), /** @type {(nonDV: unknown) => void} */ function (nonDV) {
		t.equal(
			isDataView(nonDV),
			false,
			inspect(nonDV) + ' is not a DataView'
		);
	});

	forEach(availableTypedArrays, function (typedArray) {
		var TA = global[typedArray];
		var ta = new TA(8);
		t.equal(isDataView(ta), false, inspect(ta) + ' is not a DataView');
	});

	t.end();
});

test('@@toStringTag', { skip: !hasToStringTag }, function (t) {
	forEach(availableTypedArrays, function (typedArray) {
		// @ts-expect-error
		var fakeTypedArray = [];
		// @ts-expect-error
		fakeTypedArray[Symbol.toStringTag] = typedArray;
		// @ts-expect-error
		t.notOk(isDataView(fakeTypedArray), 'faked ' + typedArray + ' is not typed array');
	});

	t.end();
});

test('Data Views', { skip: typeof DataView !== 'function' }, function (t) {
	var ab = new ArrayBuffer(1);
	var dv = new DataView(ab);

	t.equal(isDataView(dv), true, inspect(dv) + ' is a DataView');

	t.end();
});
'use strict';

var test = require('tape');
var isDate = require('../');
var hasToStringTag = require('has-tostringtag/shams')();

test('not Dates', function (t) {
	// @ts-expect-error
	t.notOk(isDate(), 'undefined is not Date');
	t.notOk(isDate(null), 'null is not Date');
	t.notOk(isDate(false), 'false is not Date');
	t.notOk(isDate(true), 'true is not Date');
	t.notOk(isDate(42), 'number is not Date');
	t.notOk(isDate('foo'), 'string is not Date');
	t.notOk(isDate([]), 'array is not Date');
	t.notOk(isDate({}), 'object is not Date');
	t.notOk(isDate(function () {}), 'function is not Date');
	t.notOk(isDate(/a/g), 'regex literal is not Date');
	t.notOk(isDate(new RegExp('a', 'g')), 'regex object is not Date');
	t.end();
});

test('@@toStringTag', { skip: !hasToStringTag }, function (t) {
	var realDate = new Date();
	/** @type {{ toString(): unknown; valueOf(): unknown; [Symbol.toStringTag]?: string; }} */
	var fakeDate = {
		toString: function () { return String(realDate); },
		valueOf: function () { return realDate.getTime(); }
	};
	fakeDate[Symbol.toStringTag] = 'Date';
	t.notOk(isDate(fakeDate), 'fake Date with @@toStringTag "Date" is not Date');
	t.end();
});

test('Dates', function (t) {
	t.ok(isDate(new Date()), 'new Date() is Date');
	t.end();
});
'use strict';

var test = require('tape');
var inspect = require('object-inspect');
var forEach = require('for-each');

var isFinalizationRegistry = require('..');

test('isFinalizationRegistry', function (t) {
	t.equal(typeof isFinalizationRegistry, 'function', 'is a function');

	var nonFinalizationRegistries = [undefined, null, true, false, 42, 0, Infinity, NaN, /a/g, function () {}, {}, []];
	forEach(nonFinalizationRegistries, function (nonFinalizationRegistry) {
		t.equal(isFinalizationRegistry(nonFinalizationRegistry), false, inspect(nonFinalizationRegistry) + ' is not a FinalizationRegistry');
	});

	t.test('actual FinalizationRegistry instances', { skip: typeof FinalizationRegistry === 'undefined' }, function (st) {
		var registry = new FinalizationRegistry(function () {});

		st.equal(isFinalizationRegistry(registry), true, inspect(registry) + ' is a FinalizationRegistry');

		st.end();
	});

	t.end();
});
'use strict';

// @ts-ignore
require('core-js');

require('./');
'use strict';

/* globals window */

var test = require('tape');

var generatorFuncs = require('make-generator-function')();
var hasToStringTag = require('has-tostringtag/shams')();
var forEach = require('for-each');

var isGeneratorFunction = require('../index');

test('returns false for non-functions', function (t) {
	var nonFuncs = [
		true,
		false,
		null,
		undefined,
		{},
		[],
		/a/g,
		'string',
		42,
		new Date()
	];
	t.plan(nonFuncs.length);
	forEach(nonFuncs, function (nonFunc) {
		t.notOk(isGeneratorFunction(nonFunc), nonFunc + ' is not a function');
	});
	t.end();
});

test('returns false for non-generator functions', function (t) {
	var func = function () {};
	t.notOk(isGeneratorFunction(func), 'anonymous function is not an generator function');

	var namedFunc = function foo() {};
	t.notOk(isGeneratorFunction(namedFunc), 'named function is not an generator function');

	if (typeof window === 'undefined') {
		t.skip('window.alert is not an generator function');
	} else {
		t.notOk(isGeneratorFunction(window.alert), 'window.alert is not an generator function');
	}
	t.end();
});

var fakeToString = function () { return 'function* () { return "TOTALLY REAL I SWEAR!"; }'; };

test('returns false for non-generator function with faked toString', function (t) {
	var func = function () {};
	func.toString = fakeToString;

	t.notEqual(String(func), Function.prototype.toString.apply(func), 'faked toString is not real toString');
	t.notOk(isGeneratorFunction(func), 'anonymous function with faked toString is not a generator function');
	t.end();
});

test('returns false for non-generator function with faked @@toStringTag', { skip: !hasToStringTag || generatorFuncs.length === 0 }, function (t) {
	var generatorFunc = generatorFuncs[0];
	/** @type {{ toString(): unknown; valueOf(): unknown; [Symbol.toStringTag]?: unknown; }} */
	var fakeGenFunction = {
		toString: function () { return String(generatorFunc); },
		valueOf: function () { return generatorFunc; }
	};
	fakeGenFunction[Symbol.toStringTag] = 'GeneratorFunction';
	t.notOk(isGeneratorFunction(fakeGenFunction), 'fake GeneratorFunction with @@toStringTag "GeneratorFunction" is not a generator function');
	t.end();
});

test('returns true for generator functions', function (t) {
	if (generatorFuncs.length > 0) {
		forEach(generatorFuncs, function (generatorFunc) {
			t.ok(isGeneratorFunction(generatorFunc), generatorFunc + ' is generator function');
		});
	} else {
		t.skip('generator function is generator function - this environment does not support ES6 generator functions. Please run `node --harmony`, or use a supporting browser.');
	}
	t.end();
});
'use strict';

// @ts-ignore
require('uglify-register/api').register({
	exclude: [/\/node_modules\//, /\/test\//],
	uglify: { mangle: true }
});

require('./');
'use strict';

var test = require('tape');
var debug = require('object-inspect');
var forEach = require('for-each');

var isMap = require('..');

test('non-collections', function (t) {
	forEach([
		null,
		undefined,
		true,
		false,
		42,
		0,
		-0,
		NaN,
		Infinity,
		'',
		'foo',
		/a/g,
		[],
		{},
		function () {}
	], function (nonCollection) {
		t.equal(isMap(nonCollection), false, debug(nonCollection) + ' is not a Map');
	});

	t.end();
});

test('Maps', { skip: typeof Map !== 'function' }, function (t) {
	var m = new Map();
	t.equal(isMap(m), true, debug(m) + ' is a Map');

	t.end();
});

test('Sets', { skip: typeof Set !== 'function' }, function (t) {
	var s = new Set();
	t.equal(isMap(s), false, debug(s) + ' is not a Map');

	t.end();
});

test('WeakMaps', { skip: typeof WeakMap !== 'function' }, function (t) {
	var wm = new WeakMap();
	t.equal(isMap(wm), false, debug(wm) + ' is not a Map');

	t.end();
});

test('WeakSets', { skip: typeof WeakSet !== 'function' }, function (t) {
	var ws = new WeakSet();
	t.equal(isMap(ws), false, debug(ws) + ' is not a Map');

	t.end();
});
'use strict';

var test = require('tape');
var isNegativeZero = require('../');

test('not negative zero', function (t) {
	// @ts-expect-error
	t.notOk(isNegativeZero(), 'undefined is not negative zero');
	t.notOk(isNegativeZero(null), 'null is not negative zero');
	t.notOk(isNegativeZero(false), 'false is not negative zero');
	t.notOk(isNegativeZero(true), 'true is not negative zero');
	t.notOk(isNegativeZero(0), 'positive zero is not negative zero');
	t.notOk(isNegativeZero(Infinity), 'Infinity is not negative zero');
	t.notOk(isNegativeZero(-Infinity), '-Infinity is not negative zero');
	t.notOk(isNegativeZero(NaN), 'NaN is not negative zero');
	t.notOk(isNegativeZero('foo'), 'string is not negative zero');
	t.notOk(isNegativeZero([]), 'array is not negative zero');
	t.notOk(isNegativeZero({}), 'object is not negative zero');
	t.notOk(isNegativeZero(function () {}), 'function is not negative zero');
	t.notOk(isNegativeZero(-1), '-1 is not negative zero');

	t.end();
});

test('negative zero', function (t) {
	t.ok(isNegativeZero(-0), 'negative zero is negative zero');
	t.end();
});

'use strict';

var test = require('tape');
var isNumber = require('../');
var hasToStringTag = require('has-tostringtag/shams')();

test('not Numbers', function (t) {
	// @ts-expect-error
	t.notOk(isNumber(), 'undefined is not Number');
	t.notOk(isNumber(null), 'null is not Number');
	t.notOk(isNumber(false), 'false is not Number');
	t.notOk(isNumber(true), 'true is not Number');
	t.notOk(isNumber('foo'), 'string is not Number');
	t.notOk(isNumber([]), 'array is not Number');
	t.notOk(isNumber({}), 'object is not Number');
	t.notOk(isNumber(function () {}), 'function is not Number');
	t.notOk(isNumber(/a/g), 'regex literal is not Number');
	t.notOk(isNumber(new RegExp('a', 'g')), 'regex object is not Number');
	t.notOk(isNumber(new Date()), 'new Date() is not Number');
	t.end();
});

test('@@toStringTag', { skip: !hasToStringTag }, function (t) {
	/** @type {{ toString(): string; valueOf(): number; [Symbol.toStringTag]?: string; }} */
	var fakeNumber = {
		toString: function () { return '7'; },
		valueOf: function () { return 42; }
	};
	fakeNumber[Symbol.toStringTag] = 'Number';
	t.notOk(isNumber(fakeNumber), 'fake Number with @@toStringTag "Number" is not Number');
	t.end();
});

test('Numbers', function (t) {
	t.ok(isNumber(42), 'number is Number');
	t.ok(isNumber(Object(42)), 'number object is Number');
	t.ok(isNumber(NaN), 'NaN is Number');
	t.ok(isNumber(Infinity), 'Infinity is Number');
	t.end();
});
'use strict';

var hasToStringTag = require('has-tostringtag/shams')();
var forEach = require('for-each');
var test = require('tape');
var isRegex = require('..');

test('not regexes', function (t) {
	// @ts-expect-error
	t.notOk(isRegex(), 'undefined is not regex');
	t.notOk(isRegex(null), 'null is not regex');
	t.notOk(isRegex(false), 'false is not regex');
	t.notOk(isRegex(true), 'true is not regex');
	t.notOk(isRegex(42), 'number is not regex');
	t.notOk(isRegex('foo'), 'string is not regex');
	t.notOk(isRegex([]), 'array is not regex');
	t.notOk(isRegex({}), 'object is not regex');
	t.notOk(isRegex(function () {}), 'function is not regex');
	t.end();
});

test('@@toStringTag', { skip: !hasToStringTag }, function (t) {
	var regex = /a/g;
	/** @type {{ toString(): string, valueOf(): RegExp, [Symbol.toStringTag]?: string}} */
	var fakeRegex = {
		toString: function () { return String(regex); },
		valueOf: function () { return regex; }
	};
	fakeRegex[Symbol.toStringTag] = 'RegExp';
	t.notOk(isRegex(fakeRegex), 'fake RegExp with @@toStringTag "RegExp" is not regex');
	t.end();
});

test('regexes', function (t) {
	t.ok(isRegex(/a/g), 'regex literal is regex');
	t.ok(isRegex(new RegExp('a', 'g')), 'regex object is regex');
	t.end();
});

test('does not mutate regexes', function (t) {
	t.test('lastIndex is a marker object', function (st) {
		var regex = /a/;
		var marker = {};
		// @ts-expect-error
		regex.lastIndex = marker;
		st.equal(regex.lastIndex, marker, 'lastIndex is the marker object');
		st.ok(isRegex(regex), 'is regex');
		st.equal(regex.lastIndex, marker, 'lastIndex is the marker object after isRegex');
		st.end();
	});

	t.test('lastIndex is nonzero', function (st) {
		var regex = /a/;
		regex.lastIndex = 3;
		st.equal(regex.lastIndex, 3, 'lastIndex is 3');
		st.ok(isRegex(regex), 'is regex');
		st.equal(regex.lastIndex, 3, 'lastIndex is 3 after isRegex');
		st.end();
	});

	t.end();
});

test('does not perform operations observable to Proxies', { skip: typeof Proxy !== 'function' }, function (t) {
	/** @constructor */
	function Handler() {
		/** @type (keyof Reflect)[]} */
		this.trapCalls = [];
	}

	// eslint-disable-next-line no-extra-parens
	forEach(/** @const @type {(keyof Reflect)[]} */ ([
		'defineProperty',
		'deleteProperty',
		'get',
		'getOwnPropertyDescriptor',
		'getPrototypeOf',
		'has',
		'isExtensible',
		'ownKeys',
		'preventExtensions',
		'set',
		'setPrototypeOf'
	]), function (trapName) {
		Handler.prototype[trapName] = function () {
			this.trapCalls.push(trapName);
			// @ts-expect-error TODO: not sure why this is erroring
			return Reflect[trapName].apply(Reflect, arguments);
		};
	});

	t.test('proxy of object', function (st) {
		var handler = new Handler();
		// @ts-expect-error Proxy handlers can be any object
		var proxy = new Proxy({ lastIndex: 0 }, handler);

		st.equal(isRegex(proxy), false, 'proxy of plain object is not regex');
		st.deepEqual(
			handler.trapCalls,
			handler.trapCalls.length > 0 ? ['getOwnPropertyDescriptor'] : [],
			'no unexpected proxy traps were triggered'
		);
		st.end();
	});

	t.test('proxy of RegExp instance', function (st) {
		var handler = new Handler();
		// @ts-expect-error Proxy handlers can be any object
		var proxy = new Proxy(/a/, handler);

		st.equal(isRegex(proxy), false, 'proxy of RegExp instance is not regex');
		st.deepEqual(
			handler.trapCalls,
			handler.trapCalls.length > 0 ? ['getOwnPropertyDescriptor'] : [],
			'no unexpected proxy traps were triggered'
		);
		st.end();
	});

	t.end();
});
'use strict';

var test = require('tape');
var debug = require('object-inspect');
var forEach = require('for-each');

var isSet = require('..');

test('non-collections', function (t) {
	forEach([
		null,
		undefined,
		true,
		false,
		42,
		0,
		-0,
		NaN,
		Infinity,
		'',
		'foo',
		/a/g,
		[],
		{},
		function () {}
	], function (nonCollection) {
		t.equal(isSet(nonCollection), false, debug(nonCollection) + ' is not a Set');
	});

	t.end();
});

test('Maps', { skip: typeof Map !== 'function' }, function (t) {
	var m = new Map();
	t.equal(isSet(m), false, debug(m) + ' is not a Set');

	t.end();
});

test('Sets', { skip: typeof Set !== 'function' }, function (t) {
	var s = new Set();
	t.equal(isSet(s), true, debug(s) + ' is a Set');

	t.end();
});

test('WeakMaps', { skip: typeof WeakMap !== 'function' }, function (t) {
	var wm = new WeakMap();
	t.equal(isSet(wm), false, debug(wm) + ' is not a Set');

	t.end();
});

test('WeakSets', { skip: typeof WeakSet !== 'function' }, function (t) {
	var ws = new WeakSet();
	t.equal(isSet(ws), false, debug(ws) + ' is not a Set');

	t.end();
});
'use strict';

var test = require('tape');
var inspect = require('object-inspect');
var forEach = require('for-each');
var v = require('es-value-fixtures');
var availableTypedArrays = require('available-typed-arrays')();

var isSharedArrayBuffer = require('..');

test('isSharedArrayBuffer', function (t) {
	t.equal(typeof isSharedArrayBuffer, 'function', 'is a function');

	// @ts-expect-error TS sucks with concat
	var nonSABs = [].concat(v.primitives, v.objects);
	forEach(nonSABs, function (nonSAB) {
		t.equal(isSharedArrayBuffer(nonSAB), false, inspect(nonSAB) + ' is not a SharedArrayBuffer');
	});

	t.test('actual SharedArrayBuffer instances', { skip: typeof SharedArrayBuffer === 'undefined' }, function (st) {
		var sab = new SharedArrayBuffer(0);

		st.equal(isSharedArrayBuffer(sab), true, inspect(sab) + ' is a SharedArrayBuffer');

		st.end();
	});

	t.test('Typed Arrays', { skip: availableTypedArrays.length === 0 }, function (st) {
		forEach(availableTypedArrays, function (TypedArray) {
			var ta = new global[TypedArray](0);
			st.equal(isSharedArrayBuffer(ta.buffer), false, inspect(ta.buffer) + ', the TA\'s buffer, is not a SharedArrayBuffer');
			st.equal(isSharedArrayBuffer(ta), false, inspect(ta) + ' is not a SharedArrayBuffer');
		});

		st.end();
	});

	t.end();
});
'use strict';

var test = require('tape');
var isString = require('../');
var hasToStringTag = require('has-tostringtag/shams')();

test('not Strings', function (t) {
	// @ts-expect-error
	t.notOk(isString(), 'undefined is not String');
	t.notOk(isString(null), 'null is not String');
	t.notOk(isString(false), 'false is not String');
	t.notOk(isString(true), 'true is not String');
	t.notOk(isString([]), 'array is not String');
	t.notOk(isString({}), 'object is not String');
	t.notOk(isString(function () {}), 'function is not String');
	t.notOk(isString(/a/g), 'regex literal is not String');
	t.notOk(isString(new RegExp('a', 'g')), 'regex object is not String');
	t.notOk(isString(new Date()), 'new Date() is not String');
	t.notOk(isString(42), 'number is not String');
	t.notOk(isString(Object(42)), 'number object is not String');
	t.notOk(isString(NaN), 'NaN is not String');
	t.notOk(isString(Infinity), 'Infinity is not String');
	t.end();
});

test('@@toStringTag', { skip: !hasToStringTag }, function (t) {
	/** @type {{ toString(): unknown; valueOf(): unknown; [Symbol.toStringTag]?: string; }} */
	var fakeString = {
		toString: function () { return '7'; },
		valueOf: function () { return '42'; }
	};
	fakeString[Symbol.toStringTag] = 'String';
	t.notOk(isString(fakeString), 'fake String with @@toStringTag "String" is not String');
	t.end();
});

test('Strings', function (t) {
	t.ok(isString('foo'), 'string primitive is String');
	t.ok(isString(Object('foo')), 'string object is String');
	t.end();
});
'use strict';

var test = require('tape');
var forEach = require('for-each');
var v = require('es-value-fixtures');

var isSymbol = require('../index');

var hasSymbols = require('has-symbols')();
var hasToStringTag = require('has-tostringtag/shams')();
var inspect = require('object-inspect');

test('non-symbol values', function (t) {
	var nonSymbols = v.nonSymbolPrimitives.concat(
		Object(true),
		Object(false),
		// @ts-expect-error TS sucks with concat
		{},
		[],
		/a/g,
		new Date(),
		function () {},
		NaN
	);
	t.plan(nonSymbols.length);
	forEach(nonSymbols, function (nonSymbol) {
		t.equal(isSymbol(nonSymbol), false, inspect(nonSymbol) + ' is not a symbol');
	});
	t.end();
});

test('faked symbol values', function (t) {
	t.test('real symbol valueOf', { skip: !hasSymbols }, function (st) {
		var fakeSymbol = { valueOf: function () { return Symbol('foo'); } };
		st.equal(isSymbol(fakeSymbol), false, 'object with valueOf returning a symbol is not a symbol');
		st.end();
	});

	t.test('faked @@toStringTag', { skip: !hasToStringTag }, function (st) {
		/** @type {{ valueOf(): unknown; [Symbol.toStringTag]?: unknown }} */
		var fakeSymbol = { valueOf: function () { return Symbol('foo'); } };
		fakeSymbol[Symbol.toStringTag] = 'Symbol';
		st.equal(isSymbol(fakeSymbol), false, 'object with fake Symbol @@toStringTag and valueOf returning a symbol is not a symbol');

		/** @type {{ valueOf(): unknown; [Symbol.toStringTag]?: unknown }} */
		var notSoFakeSymbol = { valueOf: function () { return 42; } };
		notSoFakeSymbol[Symbol.toStringTag] = 'Symbol';
		st.equal(isSymbol(notSoFakeSymbol), false, 'object with fake Symbol @@toStringTag and valueOf not returning a symbol is not a symbol');
		st.end();
	});

	var fakeSymbolString = { toString: function () { return 'Symbol(foo)'; } };
	t.equal(isSymbol(fakeSymbolString), false, 'object with toString returning Symbol(foo) is not a symbol');

	t.end();
});

test('Symbol support', { skip: !hasSymbols }, function (t) {
	t.test('well-known Symbols', function (st) {
		/** @type {(name: string) => name is Exclude<keyof SymbolConstructor, 'for' | 'keyFor'>} */
		var isWellKnown = function filterer(name) {
			return name !== 'for' && name !== 'keyFor' && !(name in filterer);
		};
		var wellKnownSymbols = Object.getOwnPropertyNames(Symbol).filter(isWellKnown);
		wellKnownSymbols.forEach(function (name) {
			// eslint-disable-next-line no-extra-parens
			var sym = Symbol[/** @type {keyof SymbolConstructor} */ (name)];
			st.equal(isSymbol(sym), true, inspect(sym) + ' is a symbol');
		});
		st.end();
	});

	t.test('user-created symbols', function (st) {
		var symbols = v.symbols.concat(
			Symbol(),
			Symbol('foo'),
			Symbol['for']('foo'),
			Object(Symbol('object'))
		);
		symbols.forEach(function (sym) {
			st.equal(isSymbol(sym), true, inspect(sym) + ' is a symbol');
		});
		st.end();
	});

	t.end();
});

'use strict';

var test = require('tape');
var isTypedArray = require('../');
var isCallable = require('is-callable');
var hasToStringTag = require('has-tostringtag/shams')();
var generators = require('make-generator-function')();
var arrowFn = require('make-arrow-function')();
var forEach = require('for-each');
var inspect = require('object-inspect');

var typedArrayNames = [
	'Int8Array',
	'Uint8Array',
	'Uint8ClampedArray',
	'Int16Array',
	'Uint16Array',
	'Int32Array',
	'Uint32Array',
	'Float32Array',
	'Float64Array',
	'BigInt64Array',
	'BigUint64Array'
];

test('not arrays', function (t) {
	t.test('non-number/string primitives', function (st) {
		// @ts-expect-error Expected 1 arguments, but got 0.ts(2554)
		st.notOk(isTypedArray(), 'undefined is not typed array');
		st.notOk(isTypedArray(null), 'null is not typed array');
		st.notOk(isTypedArray(false), 'false is not typed array');
		st.notOk(isTypedArray(true), 'true is not typed array');
		st.end();
	});

	t.notOk(isTypedArray({}), 'object is not typed array');
	t.notOk(isTypedArray(/a/g), 'regex literal is not typed array');
	t.notOk(isTypedArray(new RegExp('a', 'g')), 'regex object is not typed array');
	t.notOk(isTypedArray(new Date()), 'new Date() is not typed array');

	t.test('numbers', function (st) {
		st.notOk(isTypedArray(42), 'number is not typed array');
		st.notOk(isTypedArray(Object(42)), 'number object is not typed array');
		st.notOk(isTypedArray(NaN), 'NaN is not typed array');
		st.notOk(isTypedArray(Infinity), 'Infinity is not typed array');
		st.end();
	});

	t.test('strings', function (st) {
		st.notOk(isTypedArray('foo'), 'string primitive is not typed array');
		st.notOk(isTypedArray(Object('foo')), 'string object is not typed array');
		st.end();
	});

	t.end();
});

test('Functions', function (t) {
	t.notOk(isTypedArray(function () {}), 'function is not typed array');
	t.end();
});

test('Generators', { skip: generators.length === 0 }, function (t) {
	forEach(generators, function (genFn) {
		t.notOk(isTypedArray(genFn), 'generator function ' + inspect(genFn) + ' is not typed array');
	});
	t.end();
});

test('Arrow functions', { skip: !arrowFn }, function (t) {
	t.notOk(isTypedArray(arrowFn), 'arrow function is not typed array');
	t.end();
});

test('@@toStringTag', { skip: !hasToStringTag }, function (t) {
	forEach(typedArrayNames, function (typedArray) {
		// @ts-expect-error
		if (typeof global[typedArray] === 'function') {
			// @ts-expect-error
			var fakeTypedArray = [];
			// @ts-expect-error
			fakeTypedArray[Symbol.toStringTag] = typedArray;
			// @ts-expect-error
			t.notOk(isTypedArray(fakeTypedArray), 'faked ' + typedArray + ' is not typed array');
		} else {
			t.comment('# SKIP ' + typedArray + ' is not supported');
		}
	});
	t.end();
});

test('non-Typed Arrays', function (t) {
	t.notOk(isTypedArray([]), '[] is not typed array');
	t.end();
});

/** @typedef {Int8ArrayConstructor | Uint8ArrayConstructor | Uint8ClampedArrayConstructor | Int16ArrayConstructor | Uint16ArrayConstructor | Int32ArrayConstructor | Uint32ArrayConstructor | Float32ArrayConstructor | Float64ArrayConstructor | BigInt64ArrayConstructor | BigUint64ArrayConstructor} TypedArrayConstructor */

test('Typed Arrays', function (t) {
	forEach(typedArrayNames, function (typedArray) {
		// @ts-expect-error
		/** @type {TypedArrayConstructor} */ var TypedArray = global[typedArray];
		if (isCallable(TypedArray)) {
			var arr = new TypedArray(10);
			t.ok(isTypedArray(arr), 'new ' + typedArray + '(10) is typed array');
		} else {
			t.comment('# SKIP ' + typedArray + ' is not supported');
		}
	});
	t.end();
});
'use strict';

var test = require('tape');
var debug = require('object-inspect');
var forEach = require('for-each');

var isWeakMap = require('..');

test('non-collections', function (t) {
	forEach([
		null,
		undefined,
		true,
		false,
		42,
		0,
		-0,
		NaN,
		Infinity,
		'',
		'foo',
		/a/g,
		[],
		{},
		function () {}
	], function (nonCollection) {
		t.equal(isWeakMap(nonCollection), false, debug(nonCollection) + ' is not a WeakMap');
	});

	t.end();
});

test('Maps', { skip: typeof Map !== 'function' }, function (t) {
	var m = new Map();
	t.equal(isWeakMap(m), false, debug(m) + ' is not a WeakMap');

	t.end();
});

test('Sets', { skip: typeof Set !== 'function' }, function (t) {
	var s = new Set();
	t.equal(isWeakMap(s), false, debug(s) + ' is not a WeakMap');

	t.end();
});

test('WeakMaps', { skip: typeof WeakMap !== 'function' }, function (t) {
	var wm = new WeakMap();
	t.equal(isWeakMap(wm), true, debug(wm) + ' is a WeakMap');

	t.end();
});

test('WeakSets', { skip: typeof WeakSet !== 'function' }, function (t) {
	var ws = new WeakSet();
	t.equal(isWeakMap(ws), false, debug(ws) + ' is not a WeakMap');

	t.end();
});
'use strict';

var test = require('tape');
var inspect = require('object-inspect');
var forEach = require('for-each');

var isWeakRef = require('..');

test('isWeakRef', function (t) {
	t.equal(typeof isWeakRef, 'function', 'is a function');

	var nonWeakRefs = [undefined, null, true, false, 42, 0, Infinity, NaN, /a/g, function () {}, {}, []];
	forEach(nonWeakRefs, function (nonWeakRef) {
		t.equal(isWeakRef(nonWeakRef), false, inspect(nonWeakRef) + ' is not a WeakRef');
	});

	t.test('actual WeakRefs', { skip: typeof WeakRef === 'undefined' }, function (st) {
		var ref = new WeakRef({});

		st.equal(isWeakRef(ref), true, inspect(ref) + ' is a WeakRef');

		st.end();
	});

	t.end();
});
'use strict';

var test = require('tape');
var debug = require('object-inspect');
var forEach = require('for-each');

var isWeakSet = require('..');

test('non-collections', function (t) {
	forEach([
		null,
		undefined,
		true,
		false,
		42,
		0,
		-0,
		NaN,
		Infinity,
		'',
		'foo',
		/a/g,
		[],
		{},
		function () {}
	], function (nonCollection) {
		t.equal(isWeakSet(nonCollection), false, debug(nonCollection) + ' is not a WeakSet');
	});

	t.end();
});

test('Maps', { skip: typeof Map !== 'function' }, function (t) {
	var m = new Map();
	t.equal(isWeakSet(m), false, debug(m) + ' is not a WeakSet');

	t.end();
});

test('Sets', { skip: typeof Set !== 'function' }, function (t) {
	var s = new Set();
	t.equal(isWeakSet(s), false, debug(s) + ' is not a WeakSet');

	t.end();
});

test('WeakMaps', { skip: typeof WeakMap !== 'function' }, function (t) {
	var wm = new WeakMap();
	t.equal(isWeakSet(wm), false, debug(wm) + ' is not a WeakSet');

	t.end();
});

test('WeakSets', { skip: typeof WeakSet !== 'function' }, function (t) {
	var ws = new WeakSet();
	t.equal(isWeakSet(ws), true, debug(ws) + ' is a WeakSet');

	t.end();
});
'use strict';

/** @type {import('./maxArrayLength')} */
module.exports = 4294967295; // Math.pow(2, 32) - 1;
'use strict';

/** @type {import('./maxSafeInteger')} */
// eslint-disable-next-line no-extra-parens
module.exports = /** @type {import('./maxSafeInteger')} */ (Number.MAX_SAFE_INTEGER) || 9007199254740991; // Math.pow(2, 53) - 1;
'use strict';

/** @type {import('./maxValue')}  */
// eslint-disable-next-line no-extra-parens
module.exports = /** @type {import('./maxValue')}  */ (Number.MAX_VALUE) || 1.7976931348623157e+308;
'use strict';

var test = require('tape');
var v = require('es-value-fixtures');
var forEach = require('for-each');
var inspect = require('object-inspect');

var abs = require('../abs');
var floor = require('../floor');
var isFinite = require('../isFinite');
var isInteger = require('../isInteger');
var isNaN = require('../isNaN');
var isNegativeZero = require('../isNegativeZero');
var max = require('../max');
var min = require('../min');
var mod = require('../mod');
var pow = require('../pow');
var round = require('../round');
var sign = require('../sign');

var maxArrayLength = require('../constants/maxArrayLength');
var maxSafeInteger = require('../constants/maxSafeInteger');
var maxValue = require('../constants/maxValue');

test('abs', function (t) {
	t.equal(abs(-1), 1, 'abs(-1) === 1');
	t.equal(abs(+1), 1, 'abs(+1) === 1');
	t.equal(abs(+0), +0, 'abs(+0) === +0');
	t.equal(abs(-0), +0, 'abs(-0) === +0');

	t.end();
});

test('floor', function (t) {
	t.equal(floor(-1.1), -2, 'floor(-1.1) === -2');
	t.equal(floor(+1.1), 1, 'floor(+1.1) === 1');
	t.equal(floor(+0), +0, 'floor(+0) === +0');
	t.equal(floor(-0), -0, 'floor(-0) === -0');
	t.equal(floor(-Infinity), -Infinity, 'floor(-Infinity) === -Infinity');
	t.equal(floor(Number(Infinity)), Number(Infinity), 'floor(+Infinity) === +Infinity');
	t.equal(floor(NaN), NaN, 'floor(NaN) === NaN');
	t.equal(floor(0), +0, 'floor(0) === +0');
	t.equal(floor(-0), -0, 'floor(-0) === -0');
	t.equal(floor(1), 1, 'floor(1) === 1');
	t.equal(floor(-1), -1, 'floor(-1) === -1');
	t.equal(floor(1.1), 1, 'floor(1.1) === 1');
	t.equal(floor(-1.1), -2, 'floor(-1.1) === -2');
	t.equal(floor(maxValue), maxValue, 'floor(maxValue) === maxValue');
	t.equal(floor(maxSafeInteger), maxSafeInteger, 'floor(maxSafeInteger) === maxSafeInteger');

	t.end();
});

test('isFinite', function (t) {
	t.equal(isFinite(0), true, 'isFinite(+0) === true');
	t.equal(isFinite(-0), true, 'isFinite(-0) === true');
	t.equal(isFinite(1), true, 'isFinite(1) === true');
	t.equal(isFinite(Infinity), false, 'isFinite(Infinity) === false');
	t.equal(isFinite(-Infinity), false, 'isFinite(-Infinity) === false');
	t.equal(isFinite(NaN), false, 'isFinite(NaN) === false');

	forEach(v.nonNumbers, function (nonNumber) {
		t.equal(isFinite(nonNumber), false, 'isFinite(' + inspect(nonNumber) + ') === false');
	});

	t.end();
});

test('isInteger', function (t) {
	forEach([].concat(
		// @ts-expect-error TS sucks with concat
		v.nonNumbers,
		v.nonIntegerNumbers
	), function (nonInteger) {
		t.equal(isInteger(nonInteger), false, 'isInteger(' + inspect(nonInteger) + ') === false');
	});

	t.end();
});

test('isNaN', function (t) {
	forEach([].concat(
		// @ts-expect-error TS sucks with concat
		v.nonNumbers,
		v.infinities,
		v.zeroes,
		v.integerNumbers
	), function (nonNaN) {
		t.equal(isNaN(nonNaN), false, 'isNaN(' + inspect(nonNaN) + ') === false');
	});

	t.equal(isNaN(NaN), true, 'isNaN(NaN) === true');

	t.end();
});

test('isNegativeZero', function (t) {
	t.equal(isNegativeZero(-0), true, 'isNegativeZero(-0) === true');
	t.equal(isNegativeZero(+0), false, 'isNegativeZero(+0) === false');
	t.equal(isNegativeZero(1), false, 'isNegativeZero(1) === false');
	t.equal(isNegativeZero(-1), false, 'isNegativeZero(-1) === false');
	t.equal(isNegativeZero(NaN), false, 'isNegativeZero(NaN) === false');
	t.equal(isNegativeZero(Infinity), false, 'isNegativeZero(Infinity) === false');
	t.equal(isNegativeZero(-Infinity), false, 'isNegativeZero(-Infinity) === false');

	forEach(v.nonNumbers, function (nonNumber) {
		t.equal(isNegativeZero(nonNumber), false, 'isNegativeZero(' + inspect(nonNumber) + ') === false');
	});

	t.end();
});

test('max', function (t) {
	t.equal(max(1, 2), 2, 'max(1, 2) === 2');
	t.equal(max(1, 2, 3), 3, 'max(1, 2, 3) === 3');
	t.equal(max(1, 2, 3, 4), 4, 'max(1, 2, 3, 4) === 4');
	t.equal(max(1, 2, 3, 4, 5), 5, 'max(1, 2, 3, 4, 5) === 5');
	t.equal(max(1, 2, 3, 4, 5, 6), 6, 'max(1, 2, 3, 4, 5, 6) === 6');
	t.equal(max(1, 2, 3, 4, 5, 6, 7), 7, 'max(1, 2, 3, 4, 5, 6, 7) === 7');

	t.end();
});

test('min', function (t) {
	t.equal(min(1, 2), 1, 'min(1, 2) === 1');
	t.equal(min(1, 2, 3), 1, 'min(1, 2, 3) === 1');
	t.equal(min(1, 2, 3, 4), 1, 'min(1, 2, 3, 4) === 1');
	t.equal(min(1, 2, 3, 4, 5), 1, 'min(1, 2, 3, 4, 5) === 1');
	t.equal(min(1, 2, 3, 4, 5, 6), 1, 'min(1, 2, 3, 4, 5, 6) === 1');

	t.end();
});

test('mod', function (t) {
	t.equal(mod(1, 2), 1, 'mod(1, 2) === 1');
	t.equal(mod(2, 2), 0, 'mod(2, 2) === 0');
	t.equal(mod(3, 2), 1, 'mod(3, 2) === 1');
	t.equal(mod(4, 2), 0, 'mod(4, 2) === 0');
	t.equal(mod(5, 2), 1, 'mod(5, 2) === 1');
	t.equal(mod(6, 2), 0, 'mod(6, 2) === 0');
	t.equal(mod(7, 2), 1, 'mod(7, 2) === 1');
	t.equal(mod(8, 2), 0, 'mod(8, 2) === 0');
	t.equal(mod(9, 2), 1, 'mod(9, 2) === 1');
	t.equal(mod(10, 2), 0, 'mod(10, 2) === 0');
	t.equal(mod(11, 2), 1, 'mod(11, 2) === 1');

	t.end();
});

test('pow', function (t) {
	t.equal(pow(2, 2), 4, 'pow(2, 2) === 4');
	t.equal(pow(2, 3), 8, 'pow(2, 3) === 8');
	t.equal(pow(2, 4), 16, 'pow(2, 4) === 16');
	t.equal(pow(2, 5), 32, 'pow(2, 5) === 32');
	t.equal(pow(2, 6), 64, 'pow(2, 6) === 64');
	t.equal(pow(2, 7), 128, 'pow(2, 7) === 128');
	t.equal(pow(2, 8), 256, 'pow(2, 8) === 256');
	t.equal(pow(2, 9), 512, 'pow(2, 9) === 512');
	t.equal(pow(2, 10), 1024, 'pow(2, 10) === 1024');

	t.end();
});

test('round', function (t) {
	t.equal(round(1.1), 1, 'round(1.1) === 1');
	t.equal(round(1.5), 2, 'round(1.5) === 2');
	t.equal(round(1.9), 2, 'round(1.9) === 2');

	t.end();
});

test('sign', function (t) {
	t.equal(sign(-1), -1, 'sign(-1) === -1');
	t.equal(sign(+1), +1, 'sign(+1) === +1');
	t.equal(sign(+0), +0, 'sign(+0) === +0');
	t.equal(sign(-0), -0, 'sign(-0) === -0');
	t.equal(sign(NaN), NaN, 'sign(NaN) === NaN');
	t.equal(sign(Infinity), +1, 'sign(Infinity) === +1');
	t.equal(sign(-Infinity), -1, 'sign(-Infinity) === -1');
	t.equal(sign(maxValue), +1, 'sign(maxValue) === +1');
	t.equal(sign(maxSafeInteger), +1, 'sign(maxSafeInteger) === +1');

	t.end();
});

test('constants', function (t) {
	t.equal(typeof maxArrayLength, 'number', 'typeof maxArrayLength === "number"');
	t.equal(typeof maxSafeInteger, 'number', 'typeof maxSafeInteger === "number"');
	t.equal(typeof maxValue, 'number', 'typeof maxValue === "number"');

	t.end();
});
(function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c="function"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error("Cannot find module '"+i+"'");throw a.code="MODULE_NOT_FOUND",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u="function"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()({1:[function(require,module,exports){
'use strict';

var keys = require('object-keys').shim();
delete keys.shim;

var assign = require('./');

module.exports = assign.shim();

delete assign.shim;

},{"./":3,"object-keys":39}],2:[function(require,module,exports){
'use strict';

// modified from https://github.com/es-shims/es6-shim
var objectKeys = require('object-keys');
var hasSymbols = require('has-symbols/shams')();
var callBound = require('call-bound');
var $Object = require('es-object-atoms');
var $push = callBound('Array.prototype.push');
var $propIsEnumerable = callBound('Object.prototype.propertyIsEnumerable');
var originalGetSymbols = hasSymbols ? $Object.getOwnPropertySymbols : null;

// eslint-disable-next-line no-unused-vars
module.exports = function assign(target, source1) {
	if (target == null) { throw new TypeError('target must be an object'); }
	var to = $Object(target); // step 1
	if (arguments.length === 1) {
		return to; // step 2
	}
	for (var s = 1; s < arguments.length; ++s) {
		var from = $Object(arguments[s]); // step 3.a.i

		// step 3.a.ii:
		var keys = objectKeys(from);
		var getSymbols = hasSymbols && ($Object.getOwnPropertySymbols || originalGetSymbols);
		if (getSymbols) {
			var syms = getSymbols(from);
			for (var j = 0; j < syms.length; ++j) {
				var key = syms[j];
				if ($propIsEnumerable(from, key)) {
					$push(keys, key);
				}
			}
		}

		// step 3.a.iii:
		for (var i = 0; i < keys.length; ++i) {
			var nextKey = keys[i];
			if ($propIsEnumerable(from, nextKey)) { // step 3.a.iii.2
				var propValue = from[nextKey]; // step 3.a.iii.2.a
				to[nextKey] = propValue; // step 3.a.iii.2.b
			}
		}
	}

	return to; // step 4
};

},{"call-bound":11,"es-object-atoms":23,"has-symbols/shams":31,"object-keys":39}],3:[function(require,module,exports){
'use strict';

var defineProperties = require('define-properties');
var callBind = require('call-bind');

var implementation = require('./implementation');
var getPolyfill = require('./polyfill');
var shim = require('./shim');

var polyfill = callBind.apply(getPolyfill());
// eslint-disable-next-line no-unused-vars
var bound = function assign(target, source1) {
	return polyfill(Object, arguments);
};

defineProperties(bound, {
	getPolyfill: getPolyfill,
	implementation: implementation,
	shim: shim
});

module.exports = bound;

},{"./implementation":2,"./polyfill":42,"./shim":43,"call-bind":10,"define-properties":13}],4:[function(require,module,exports){
'use strict';

var bind = require('function-bind');

var $apply = require('./functionApply');
var $call = require('./functionCall');
var $reflectApply = require('./reflectApply');

/** @type {import('./actualApply')} */
module.exports = $reflectApply || bind.call($call, $apply);

},{"./functionApply":6,"./functionCall":7,"./reflectApply":9,"function-bind":25}],5:[function(require,module,exports){
'use strict';

var bind = require('function-bind');
var $apply = require('./functionApply');
var actualApply = require('./actualApply');

/** @type {import('./applyBind')} */
module.exports = function applyBind() {
	return actualApply(bind, $apply, arguments);
};

},{"./actualApply":4,"./functionApply":6,"function-bind":25}],6:[function(require,module,exports){
'use strict';

/** @type {import('./functionApply')} */
module.exports = Function.prototype.apply;

},{}],7:[function(require,module,exports){
'use strict';

/** @type {import('./functionCall')} */
module.exports = Function.prototype.call;

},{}],8:[function(require,module,exports){
'use strict';

var bind = require('function-bind');
var $TypeError = require('es-errors/type');

var $call = require('./functionCall');
var $actualApply = require('./actualApply');

/** @type {import('.')} */
module.exports = function callBindBasic(args) {
	if (args.length < 1 || typeof args[0] !== 'function') {
		throw new $TypeError('a function is required');
	}
	return $actualApply(bind, $call, args);
};

},{"./actualApply":4,"./functionCall":7,"es-errors/type":21,"function-bind":25}],9:[function(require,module,exports){
'use strict';

/** @type {import('./reflectApply')} */
module.exports = typeof Reflect !== 'undefined' && Reflect && Reflect.apply;

},{}],10:[function(require,module,exports){
'use strict';

var setFunctionLength = require('set-function-length');

var $defineProperty = require('es-define-property');

var callBindBasic = require('call-bind-apply-helpers');
var applyBind = require('call-bind-apply-helpers/applyBind');

module.exports = function callBind(originalFunction) {
	var func = callBindBasic(arguments);
	var adjustedLength = originalFunction.length - (arguments.length - 1);
	return setFunctionLength(
		func,
		1 + (adjustedLength > 0 ? adjustedLength : 0),
		true
	);
};

if ($defineProperty) {
	$defineProperty(module.exports, 'apply', { value: applyBind });
} else {
	module.exports.apply = applyBind;
}

},{"call-bind-apply-helpers":8,"call-bind-apply-helpers/applyBind":5,"es-define-property":15,"set-function-length":41}],11:[function(require,module,exports){
'use strict';

var GetIntrinsic = require('get-intrinsic');

var callBindBasic = require('call-bind-apply-helpers');

/** @type {(thisArg: string, searchString: string, position?: number) => number} */
var $indexOf = callBindBasic([GetIntrinsic('%String.prototype.indexOf%')]);

/** @type {import('.')} */
module.exports = function callBoundIntrinsic(name, allowMissing) {
	// eslint-disable-next-line no-extra-parens
	var intrinsic = /** @type {Parameters<typeof callBindBasic>[0][0]} */ (GetIntrinsic(name, !!allowMissing));
	if (typeof intrinsic === 'function' && $indexOf(name, '.prototype.') > -1) {
		return callBindBasic([intrinsic]);
	}
	return intrinsic;
};

},{"call-bind-apply-helpers":8,"get-intrinsic":26}],12:[function(require,module,exports){
'use strict';

var $defineProperty = require('es-define-property');

var $SyntaxError = require('es-errors/syntax');
var $TypeError = require('es-errors/type');

var gopd = require('gopd');

/** @type {import('.')} */
module.exports = function defineDataProperty(
	obj,
	property,
	value
) {
	if (!obj || (typeof obj !== 'object' && typeof obj !== 'function')) {
		throw new $TypeError('`obj` must be an object or a function`');
	}
	if (typeof property !== 'string' && typeof property !== 'symbol') {
		throw new $TypeError('`property` must be a string or a symbol`');
	}
	if (arguments.length > 3 && typeof arguments[3] !== 'boolean' && arguments[3] !== null) {
		throw new $TypeError('`nonEnumerable`, if provided, must be a boolean or null');
	}
	if (arguments.length > 4 && typeof arguments[4] !== 'boolean' && arguments[4] !== null) {
		throw new $TypeError('`nonWritable`, if provided, must be a boolean or null');
	}
	if (arguments.length > 5 && typeof arguments[5] !== 'boolean' && arguments[5] !== null) {
		throw new $TypeError('`nonConfigurable`, if provided, must be a boolean or null');
	}
	if (arguments.length > 6 && typeof arguments[6] !== 'boolean') {
		throw new $TypeError('`loose`, if provided, must be a boolean');
	}

	var nonEnumerable = arguments.length > 3 ? arguments[3] : null;
	var nonWritable = arguments.length > 4 ? arguments[4] : null;
	var nonConfigurable = arguments.length > 5 ? arguments[5] : null;
	var loose = arguments.length > 6 ? arguments[6] : false;

	/* @type {false | TypedPropertyDescriptor<unknown>} */
	var desc = !!gopd && gopd(obj, property);

	if ($defineProperty) {
		$defineProperty(obj, property, {
			configurable: nonConfigurable === null && desc ? desc.configurable : !nonConfigurable,
			enumerable: nonEnumerable === null && desc ? desc.enumerable : !nonEnumerable,
			value: value,
			writable: nonWritable === null && desc ? desc.writable : !nonWritable
		});
	} else if (loose || (!nonEnumerable && !nonWritable && !nonConfigurable)) {
		// must fall back to [[Set]], and was not explicitly asked to make non-enumerable, non-writable, or non-configurable
		obj[property] = value; // eslint-disable-line no-param-reassign
	} else {
		throw new $SyntaxError('This environment does not support defining a property as non-configurable, non-writable, or non-enumerable.');
	}
};

},{"es-define-property":15,"es-errors/syntax":20,"es-errors/type":21,"gopd":28}],13:[function(require,module,exports){
'use strict';

var keys = require('object-keys');
var hasSymbols = typeof Symbol === 'function' && typeof Symbol('foo') === 'symbol';

var toStr = Object.prototype.toString;
var concat = Array.prototype.concat;
var defineDataProperty = require('define-data-property');

var isFunction = function (fn) {
	return typeof fn === 'function' && toStr.call(fn) === '[object Function]';
};

var supportsDescriptors = require('has-property-descriptors')();

var defineProperty = function (object, name, value, predicate) {
	if (name in object) {
		if (predicate === true) {
			if (object[name] === value) {
				return;
			}
		} else if (!isFunction(predicate) || !predicate()) {
			return;
		}
	}

	if (supportsDescriptors) {
		defineDataProperty(object, name, value, true);
	} else {
		defineDataProperty(object, name, value);
	}
};

var defineProperties = function (object, map) {
	var predicates = arguments.length > 2 ? arguments[2] : {};
	var props = keys(map);
	if (hasSymbols) {
		props = concat.call(props, Object.getOwnPropertySymbols(map));
	}
	for (var i = 0; i < props.length; i += 1) {
		defineProperty(object, props[i], map[props[i]], predicates[props[i]]);
	}
};

defineProperties.supportsDescriptors = !!supportsDescriptors;

module.exports = defineProperties;

},{"define-data-property":12,"has-property-descriptors":29,"object-keys":39}],14:[function(require,module,exports){
'use strict';

var callBind = require('call-bind-apply-helpers');
var gOPD = require('gopd');

var hasProtoAccessor;
try {
	// eslint-disable-next-line no-extra-parens, no-proto
	hasProtoAccessor = /** @type {{ __proto__?: typeof Array.prototype }} */ ([]).__proto__ === Array.prototype;
} catch (e) {
	if (!e || typeof e !== 'object' || !('code' in e) || e.code !== 'ERR_PROTO_ACCESS') {
		throw e;
	}
}

// eslint-disable-next-line no-extra-parens
var desc = !!hasProtoAccessor && gOPD && gOPD(Object.prototype, /** @type {keyof typeof Object.prototype} */ ('__proto__'));

var $Object = Object;
var $getPrototypeOf = $Object.getPrototypeOf;

/** @type {import('./get')} */
module.exports = desc && typeof desc.get === 'function'
	? callBind([desc.get])
	: typeof $getPrototypeOf === 'function'
		? /** @type {import('./get')} */ function getDunder(value) {
			// eslint-disable-next-line eqeqeq
			return $getPrototypeOf(value == null ? value : $Object(value));
		}
		: false;

},{"call-bind-apply-helpers":8,"gopd":28}],15:[function(require,module,exports){
'use strict';

/** @type {import('.')} */
var $defineProperty = Object.defineProperty || false;
if ($defineProperty) {
	try {
		$defineProperty({}, 'a', { value: 1 });
	} catch (e) {
		// IE 8 has a broken defineProperty
		$defineProperty = false;
	}
}

module.exports = $defineProperty;

},{}],16:[function(require,module,exports){
'use strict';

/** @type {import('./eval')} */
module.exports = EvalError;

},{}],17:[function(require,module,exports){
'use strict';

/** @type {import('.')} */
module.exports = Error;

},{}],18:[function(require,module,exports){
'use strict';

/** @type {import('./range')} */
module.exports = RangeError;

},{}],19:[function(require,module,exports){
'use strict';

/** @type {import('./ref')} */
module.exports = ReferenceError;

},{}],20:[function(require,module,exports){
'use strict';

/** @type {import('./syntax')} */
module.exports = SyntaxError;

},{}],21:[function(require,module,exports){
'use strict';

/** @type {import('./type')} */
module.exports = TypeError;

},{}],22:[function(require,module,exports){
'use strict';

/** @type {import('./uri')} */
module.exports = URIError;

},{}],23:[function(require,module,exports){
'use strict';

/** @type {import('.')} */
module.exports = Object;

},{}],24:[function(require,module,exports){
'use strict';

/* eslint no-invalid-this: 1 */

var ERROR_MESSAGE = 'Function.prototype.bind called on incompatible ';
var toStr = Object.prototype.toString;
var max = Math.max;
var funcType = '[object Function]';

var concatty = function concatty(a, b) {
    var arr = [];

    for (var i = 0; i < a.length; i += 1) {
        arr[i] = a[i];
    }
    for (var j = 0; j < b.length; j += 1) {
        arr[j + a.length] = b[j];
    }

    return arr;
};

var slicy = function slicy(arrLike, offset) {
    var arr = [];
    for (var i = offset || 0, j = 0; i < arrLike.length; i += 1, j += 1) {
        arr[j] = arrLike[i];
    }
    return arr;
};

var joiny = function (arr, joiner) {
    var str = '';
    for (var i = 0; i < arr.length; i += 1) {
        str += arr[i];
        if (i + 1 < arr.length) {
            str += joiner;
        }
    }
    return str;
};

module.exports = function bind(that) {
    var target = this;
    if (typeof target !== 'function' || toStr.apply(target) !== funcType) {
        throw new TypeError(ERROR_MESSAGE + target);
    }
    var args = slicy(arguments, 1);

    var bound;
    var binder = function () {
        if (this instanceof bound) {
            var result = target.apply(
                this,
                concatty(args, arguments)
            );
            if (Object(result) === result) {
                return result;
            }
            return this;
        }
        return target.apply(
            that,
            concatty(args, arguments)
        );

    };

    var boundLength = max(0, target.length - args.length);
    var boundArgs = [];
    for (var i = 0; i < boundLength; i++) {
        boundArgs[i] = '$' + i;
    }

    bound = Function('binder', 'return function (' + joiny(boundArgs, ',') + '){ return binder.apply(this,arguments); }')(binder);

    if (target.prototype) {
        var Empty = function Empty() {};
        Empty.prototype = target.prototype;
        bound.prototype = new Empty();
        Empty.prototype = null;
    }

    return bound;
};

},{}],25:[function(require,module,exports){
'use strict';

var implementation = require('./implementation');

module.exports = Function.prototype.bind || implementation;

},{"./implementation":24}],26:[function(require,module,exports){
'use strict';

var undefined;

var $Object = require('es-object-atoms');

var $Error = require('es-errors');
var $EvalError = require('es-errors/eval');
var $RangeError = require('es-errors/range');
var $ReferenceError = require('es-errors/ref');
var $SyntaxError = require('es-errors/syntax');
var $TypeError = require('es-errors/type');
var $URIError = require('es-errors/uri');

var abs = require('math-intrinsics/abs');
var floor = require('math-intrinsics/floor');
var max = require('math-intrinsics/max');
var min = require('math-intrinsics/min');
var pow = require('math-intrinsics/pow');

var $Function = Function;

// eslint-disable-next-line consistent-return
var getEvalledConstructor = function (expressionSyntax) {
	try {
		return $Function('"use strict"; return (' + expressionSyntax + ').constructor;')();
	} catch (e) {}
};

var $gOPD = require('gopd');
var $defineProperty = require('es-define-property');

var throwTypeError = function () {
	throw new $TypeError();
};
var ThrowTypeError = $gOPD
	? (function () {
		try {
			// eslint-disable-next-line no-unused-expressions, no-caller, no-restricted-properties
			arguments.callee; // IE 8 does not throw here
			return throwTypeError;
		} catch (calleeThrows) {
			try {
				// IE 8 throws on Object.getOwnPropertyDescriptor(arguments, '')
				return $gOPD(arguments, 'callee').get;
			} catch (gOPDthrows) {
				return throwTypeError;
			}
		}
	}())
	: throwTypeError;

var hasSymbols = require('has-symbols')();
var getDunderProto = require('dunder-proto/get');

var getProto = (typeof Reflect === 'function' && Reflect.getPrototypeOf)
	|| $Object.getPrototypeOf
	|| getDunderProto;

var $apply = require('call-bind-apply-helpers/functionApply');
var $call = require('call-bind-apply-helpers/functionCall');

var needsEval = {};

var TypedArray = typeof Uint8Array === 'undefined' || !getProto ? undefined : getProto(Uint8Array);

var INTRINSICS = {
	__proto__: null,
	'%AggregateError%': typeof AggregateError === 'undefined' ? undefined : AggregateError,
	'%Array%': Array,
	'%ArrayBuffer%': typeof ArrayBuffer === 'undefined' ? undefined : ArrayBuffer,
	'%ArrayIteratorPrototype%': hasSymbols && getProto ? getProto([][Symbol.iterator]()) : undefined,
	'%AsyncFromSyncIteratorPrototype%': undefined,
	'%AsyncFunction%': needsEval,
	'%AsyncGenerator%': needsEval,
	'%AsyncGeneratorFunction%': needsEval,
	'%AsyncIteratorPrototype%': needsEval,
	'%Atomics%': typeof Atomics === 'undefined' ? undefined : Atomics,
	'%BigInt%': typeof BigInt === 'undefined' ? undefined : BigInt,
	'%BigInt64Array%': typeof BigInt64Array === 'undefined' ? undefined : BigInt64Array,
	'%BigUint64Array%': typeof BigUint64Array === 'undefined' ? undefined : BigUint64Array,
	'%Boolean%': Boolean,
	'%DataView%': typeof DataView === 'undefined' ? undefined : DataView,
	'%Date%': Date,
	'%decodeURI%': decodeURI,
	'%decodeURIComponent%': decodeURIComponent,
	'%encodeURI%': encodeURI,
	'%encodeURIComponent%': encodeURIComponent,
	'%Error%': $Error,
	'%eval%': eval, // eslint-disable-line no-eval
	'%EvalError%': $EvalError,
	'%Float32Array%': typeof Float32Array === 'undefined' ? undefined : Float32Array,
	'%Float64Array%': typeof Float64Array === 'undefined' ? undefined : Float64Array,
	'%FinalizationRegistry%': typeof FinalizationRegistry === 'undefined' ? undefined : FinalizationRegistry,
	'%Function%': $Function,
	'%GeneratorFunction%': needsEval,
	'%Int8Array%': typeof Int8Array === 'undefined' ? undefined : Int8Array,
	'%Int16Array%': typeof Int16Array === 'undefined' ? undefined : Int16Array,
	'%Int32Array%': typeof Int32Array === 'undefined' ? undefined : Int32Array,
	'%isFinite%': isFinite,
	'%isNaN%': isNaN,
	'%IteratorPrototype%': hasSymbols && getProto ? getProto(getProto([][Symbol.iterator]())) : undefined,
	'%JSON%': typeof JSON === 'object' ? JSON : undefined,
	'%Map%': typeof Map === 'undefined' ? undefined : Map,
	'%MapIteratorPrototype%': typeof Map === 'undefined' || !hasSymbols || !getProto ? undefined : getProto(new Map()[Symbol.iterator]()),
	'%Math%': Math,
	'%Number%': Number,
	'%Object%': $Object,
	'%Object.getOwnPropertyDescriptor%': $gOPD,
	'%parseFloat%': parseFloat,
	'%parseInt%': parseInt,
	'%Promise%': typeof Promise === 'undefined' ? undefined : Promise,
	'%Proxy%': typeof Proxy === 'undefined' ? undefined : Proxy,
	'%RangeError%': $RangeError,
	'%ReferenceError%': $ReferenceError,
	'%Reflect%': typeof Reflect === 'undefined' ? undefined : Reflect,
	'%RegExp%': RegExp,
	'%Set%': typeof Set === 'undefined' ? undefined : Set,
	'%SetIteratorPrototype%': typeof Set === 'undefined' || !hasSymbols || !getProto ? undefined : getProto(new Set()[Symbol.iterator]()),
	'%SharedArrayBuffer%': typeof SharedArrayBuffer === 'undefined' ? undefined : SharedArrayBuffer,
	'%String%': String,
	'%StringIteratorPrototype%': hasSymbols && getProto ? getProto(''[Symbol.iterator]()) : undefined,
	'%Symbol%': hasSymbols ? Symbol : undefined,
	'%SyntaxError%': $SyntaxError,
	'%ThrowTypeError%': ThrowTypeError,
	'%TypedArray%': TypedArray,
	'%TypeError%': $TypeError,
	'%Uint8Array%': typeof Uint8Array === 'undefined' ? undefined : Uint8Array,
	'%Uint8ClampedArray%': typeof Uint8ClampedArray === 'undefined' ? undefined : Uint8ClampedArray,
	'%Uint16Array%': typeof Uint16Array === 'undefined' ? undefined : Uint16Array,
	'%Uint32Array%': typeof Uint32Array === 'undefined' ? undefined : Uint32Array,
	'%URIError%': $URIError,
	'%WeakMap%': typeof WeakMap === 'undefined' ? undefined : WeakMap,
	'%WeakRef%': typeof WeakRef === 'undefined' ? undefined : WeakRef,
	'%WeakSet%': typeof WeakSet === 'undefined' ? undefined : WeakSet,

	'%Function.prototype.call%': $call,
	'%Function.prototype.apply%': $apply,
	'%Object.defineProperty%': $defineProperty,
	'%Math.abs%': abs,
	'%Math.floor%': floor,
	'%Math.max%': max,
	'%Math.min%': min,
	'%Math.pow%': pow
};

if (getProto) {
	try {
		null.error; // eslint-disable-line no-unused-expressions
	} catch (e) {
		// https://github.com/tc39/proposal-shadowrealm/pull/384#issuecomment-1364264229
		var errorProto = getProto(getProto(e));
		INTRINSICS['%Error.prototype%'] = errorProto;
	}
}

var doEval = function doEval(name) {
	var value;
	if (name === '%AsyncFunction%') {
		value = getEvalledConstructor('async function () {}');
	} else if (name === '%GeneratorFunction%') {
		value = getEvalledConstructor('function* () {}');
	} else if (name === '%AsyncGeneratorFunction%') {
		value = getEvalledConstructor('async function* () {}');
	} else if (name === '%AsyncGenerator%') {
		var fn = doEval('%AsyncGeneratorFunction%');
		if (fn) {
			value = fn.prototype;
		}
	} else if (name === '%AsyncIteratorPrototype%') {
		var gen = doEval('%AsyncGenerator%');
		if (gen && getProto) {
			value = getProto(gen.prototype);
		}
	}

	INTRINSICS[name] = value;

	return value;
};

var LEGACY_ALIASES = {
	__proto__: null,
	'%ArrayBufferPrototype%': ['ArrayBuffer', 'prototype'],
	'%ArrayPrototype%': ['Array', 'prototype'],
	'%ArrayProto_entries%': ['Array', 'prototype', 'entries'],
	'%ArrayProto_forEach%': ['Array', 'prototype', 'forEach'],
	'%ArrayProto_keys%': ['Array', 'prototype', 'keys'],
	'%ArrayProto_values%': ['Array', 'prototype', 'values'],
	'%AsyncFunctionPrototype%': ['AsyncFunction', 'prototype'],
	'%AsyncGenerator%': ['AsyncGeneratorFunction', 'prototype'],
	'%AsyncGeneratorPrototype%': ['AsyncGeneratorFunction', 'prototype', 'prototype'],
	'%BooleanPrototype%': ['Boolean', 'prototype'],
	'%DataViewPrototype%': ['DataView', 'prototype'],
	'%DatePrototype%': ['Date', 'prototype'],
	'%ErrorPrototype%': ['Error', 'prototype'],
	'%EvalErrorPrototype%': ['EvalError', 'prototype'],
	'%Float32ArrayPrototype%': ['Float32Array', 'prototype'],
	'%Float64ArrayPrototype%': ['Float64Array', 'prototype'],
	'%FunctionPrototype%': ['Function', 'prototype'],
	'%Generator%': ['GeneratorFunction', 'prototype'],
	'%GeneratorPrototype%': ['GeneratorFunction', 'prototype', 'prototype'],
	'%Int8ArrayPrototype%': ['Int8Array', 'prototype'],
	'%Int16ArrayPrototype%': ['Int16Array', 'prototype'],
	'%Int32ArrayPrototype%': ['Int32Array', 'prototype'],
	'%JSONParse%': ['JSON', 'parse'],
	'%JSONStringify%': ['JSON', 'stringify'],
	'%MapPrototype%': ['Map', 'prototype'],
	'%NumberPrototype%': ['Number', 'prototype'],
	'%ObjectPrototype%': ['Object', 'prototype'],
	'%ObjProto_toString%': ['Object', 'prototype', 'toString'],
	'%ObjProto_valueOf%': ['Object', 'prototype', 'valueOf'],
	'%PromisePrototype%': ['Promise', 'prototype'],
	'%PromiseProto_then%': ['Promise', 'prototype', 'then'],
	'%Promise_all%': ['Promise', 'all'],
	'%Promise_reject%': ['Promise', 'reject'],
	'%Promise_resolve%': ['Promise', 'resolve'],
	'%RangeErrorPrototype%': ['RangeError', 'prototype'],
	'%ReferenceErrorPrototype%': ['ReferenceError', 'prototype'],
	'%RegExpPrototype%': ['RegExp', 'prototype'],
	'%SetPrototype%': ['Set', 'prototype'],
	'%SharedArrayBufferPrototype%': ['SharedArrayBuffer', 'prototype'],
	'%StringPrototype%': ['String', 'prototype'],
	'%SymbolPrototype%': ['Symbol', 'prototype'],
	'%SyntaxErrorPrototype%': ['SyntaxError', 'prototype'],
	'%TypedArrayPrototype%': ['TypedArray', 'prototype'],
	'%TypeErrorPrototype%': ['TypeError', 'prototype'],
	'%Uint8ArrayPrototype%': ['Uint8Array', 'prototype'],
	'%Uint8ClampedArrayPrototype%': ['Uint8ClampedArray', 'prototype'],
	'%Uint16ArrayPrototype%': ['Uint16Array', 'prototype'],
	'%Uint32ArrayPrototype%': ['Uint32Array', 'prototype'],
	'%URIErrorPrototype%': ['URIError', 'prototype'],
	'%WeakMapPrototype%': ['WeakMap', 'prototype'],
	'%WeakSetPrototype%': ['WeakSet', 'prototype']
};

var bind = require('function-bind');
var hasOwn = require('hasown');
var $concat = bind.call($call, Array.prototype.concat);
var $spliceApply = bind.call($apply, Array.prototype.splice);
var $replace = bind.call($call, String.prototype.replace);
var $strSlice = bind.call($call, String.prototype.slice);
var $exec = bind.call($call, RegExp.prototype.exec);

/* adapted from https://github.com/lodash/lodash/blob/4.17.15/dist/lodash.js#L6735-L6744 */
var rePropName = /[^%.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|%$))/g;
var reEscapeChar = /\\(\\)?/g; /** Used to match backslashes in property paths. */
var stringToPath = function stringToPath(string) {
	var first = $strSlice(string, 0, 1);
	var last = $strSlice(string, -1);
	if (first === '%' && last !== '%') {
		throw new $SyntaxError('invalid intrinsic syntax, expected closing `%`');
	} else if (last === '%' && first !== '%') {
		throw new $SyntaxError('invalid intrinsic syntax, expected opening `%`');
	}
	var result = [];
	$replace(string, rePropName, function (match, number, quote, subString) {
		result[result.length] = quote ? $replace(subString, reEscapeChar, '$1') : number || match;
	});
	return result;
};
/* end adaptation */

var getBaseIntrinsic = function getBaseIntrinsic(name, allowMissing) {
	var intrinsicName = name;
	var alias;
	if (hasOwn(LEGACY_ALIASES, intrinsicName)) {
		alias = LEGACY_ALIASES[intrinsicName];
		intrinsicName = '%' + alias[0] + '%';
	}

	if (hasOwn(INTRINSICS, intrinsicName)) {
		var value = INTRINSICS[intrinsicName];
		if (value === needsEval) {
			value = doEval(intrinsicName);
		}
		if (typeof value === 'undefined' && !allowMissing) {
			throw new $TypeError('intrinsic ' + name + ' exists, but is not available. Please file an issue!');
		}

		return {
			alias: alias,
			name: intrinsicName,
			value: value
		};
	}

	throw new $SyntaxError('intrinsic ' + name + ' does not exist!');
};

module.exports = function GetIntrinsic(name, allowMissing) {
	if (typeof name !== 'string' || name.length === 0) {
		throw new $TypeError('intrinsic name must be a non-empty string');
	}
	if (arguments.length > 1 && typeof allowMissing !== 'boolean') {
		throw new $TypeError('"allowMissing" argument must be a boolean');
	}

	if ($exec(/^%?[^%]*%?$/, name) === null) {
		throw new $SyntaxError('`%` may not be present anywhere but at the beginning and end of the intrinsic name');
	}
	var parts = stringToPath(name);
	var intrinsicBaseName = parts.length > 0 ? parts[0] : '';

	var intrinsic = getBaseIntrinsic('%' + intrinsicBaseName + '%', allowMissing);
	var intrinsicRealName = intrinsic.name;
	var value = intrinsic.value;
	var skipFurtherCaching = false;

	var alias = intrinsic.alias;
	if (alias) {
		intrinsicBaseName = alias[0];
		$spliceApply(parts, $concat([0, 1], alias));
	}

	for (var i = 1, isOwn = true; i < parts.length; i += 1) {
		var part = parts[i];
		var first = $strSlice(part, 0, 1);
		var last = $strSlice(part, -1);
		if (
			(
				(first === '"' || first === "'" || first === '`')
				|| (last === '"' || last === "'" || last === '`')
			)
			&& first !== last
		) {
			throw new $SyntaxError('property names with quotes must have matching quotes');
		}
		if (part === 'constructor' || !isOwn) {
			skipFurtherCaching = true;
		}

		intrinsicBaseName += '.' + part;
		intrinsicRealName = '%' + intrinsicBaseName + '%';

		if (hasOwn(INTRINSICS, intrinsicRealName)) {
			value = INTRINSICS[intrinsicRealName];
		} else if (value != null) {
			if (!(part in value)) {
				if (!allowMissing) {
					throw new $TypeError('base intrinsic for ' + name + ' exists, but the property is not available.');
				}
				return void undefined;
			}
			if ($gOPD && (i + 1) >= parts.length) {
				var desc = $gOPD(value, part);
				isOwn = !!desc;

				// By convention, when a data property is converted to an accessor
				// property to emulate a data property that does not suffer from
				// the override mistake, that accessor's getter is marked with
				// an `originalValue` property. Here, when we detect this, we
				// uphold the illusion by pretending to see that original data
				// property, i.e., returning the value rather than the getter
				// itself.
				if (isOwn && 'get' in desc && !('originalValue' in desc.get)) {
					value = desc.get;
				} else {
					value = value[part];
				}
			} else {
				isOwn = hasOwn(value, part);
				value = value[part];
			}

			if (isOwn && !skipFurtherCaching) {
				INTRINSICS[intrinsicRealName] = value;
			}
		}
	}
	return value;
};

},{"call-bind-apply-helpers/functionApply":6,"call-bind-apply-helpers/functionCall":7,"dunder-proto/get":14,"es-define-property":15,"es-errors":17,"es-errors/eval":16,"es-errors/range":18,"es-errors/ref":19,"es-errors/syntax":20,"es-errors/type":21,"es-errors/uri":22,"es-object-atoms":23,"function-bind":25,"gopd":28,"has-symbols":30,"hasown":32,"math-intrinsics/abs":33,"math-intrinsics/floor":34,"math-intrinsics/max":35,"math-intrinsics/min":36,"math-intrinsics/pow":37}],27:[function(require,module,exports){
'use strict';

/** @type {import('./gOPD')} */
module.exports = Object.getOwnPropertyDescriptor;

},{}],28:[function(require,module,exports){
'use strict';

/** @type {import('.')} */
var $gOPD = require('./gOPD');

if ($gOPD) {
	try {
		$gOPD([], 'length');
	} catch (e) {
		// IE 8 has a broken gOPD
		$gOPD = null;
	}
}

module.exports = $gOPD;

},{"./gOPD":27}],29:[function(require,module,exports){
'use strict';

var $defineProperty = require('es-define-property');

var hasPropertyDescriptors = function hasPropertyDescriptors() {
	return !!$defineProperty;
};

hasPropertyDescriptors.hasArrayLengthDefineBug = function hasArrayLengthDefineBug() {
	// node v0.6 has a bug where array lengths can be Set but not Defined
	if (!$defineProperty) {
		return null;
	}
	try {
		return $defineProperty([], 'length', { value: 1 }).length !== 1;
	} catch (e) {
		// In Firefox 4-22, defining length on an array throws an exception.
		return true;
	}
};

module.exports = hasPropertyDescriptors;

},{"es-define-property":15}],30:[function(require,module,exports){
'use strict';

var origSymbol = typeof Symbol !== 'undefined' && Symbol;
var hasSymbolSham = require('./shams');

/** @type {import('.')} */
module.exports = function hasNativeSymbols() {
	if (typeof origSymbol !== 'function') { return false; }
	if (typeof Symbol !== 'function') { return false; }
	if (typeof origSymbol('foo') !== 'symbol') { return false; }
	if (typeof Symbol('bar') !== 'symbol') { return false; }

	return hasSymbolSham();
};

},{"./shams":31}],31:[function(require,module,exports){
'use strict';

/** @type {import('./shams')} */
/* eslint complexity: [2, 18], max-statements: [2, 33] */
module.exports = function hasSymbols() {
	if (typeof Symbol !== 'function' || typeof Object.getOwnPropertySymbols !== 'function') { return false; }
	if (typeof Symbol.iterator === 'symbol') { return true; }

	/** @type {{ [k in symbol]?: unknown }} */
	var obj = {};
	var sym = Symbol('test');
	var symObj = Object(sym);
	if (typeof sym === 'string') { return false; }

	if (Object.prototype.toString.call(sym) !== '[object Symbol]') { return false; }
	if (Object.prototype.toString.call(symObj) !== '[object Symbol]') { return false; }

	// temp disabled per https://github.com/ljharb/object.assign/issues/17
	// if (sym instanceof Symbol) { return false; }
	// temp disabled per https://github.com/WebReflection/get-own-property-symbols/issues/4
	// if (!(symObj instanceof Symbol)) { return false; }

	// if (typeof Symbol.prototype.toString !== 'function') { return false; }
	// if (String(sym) !== Symbol.prototype.toString.call(sym)) { return false; }

	var symVal = 42;
	obj[sym] = symVal;
	for (var _ in obj) { return false; } // eslint-disable-line no-restricted-syntax, no-unreachable-loop
	if (typeof Object.keys === 'function' && Object.keys(obj).length !== 0) { return false; }

	if (typeof Object.getOwnPropertyNames === 'function' && Object.getOwnPropertyNames(obj).length !== 0) { return false; }

	var syms = Object.getOwnPropertySymbols(obj);
	if (syms.length !== 1 || syms[0] !== sym) { return false; }

	if (!Object.prototype.propertyIsEnumerable.call(obj, sym)) { return false; }

	if (typeof Object.getOwnPropertyDescriptor === 'function') {
		// eslint-disable-next-line no-extra-parens
		var descriptor = /** @type {PropertyDescriptor} */ (Object.getOwnPropertyDescriptor(obj, sym));
		if (descriptor.value !== symVal || descriptor.enumerable !== true) { return false; }
	}

	return true;
};

},{}],32:[function(require,module,exports){
'use strict';

var call = Function.prototype.call;
var $hasOwn = Object.prototype.hasOwnProperty;
var bind = require('function-bind');

/** @type {import('.')} */
module.exports = bind.call(call, $hasOwn);

},{"function-bind":25}],33:[function(require,module,exports){
'use strict';

/** @type {import('./abs')} */
module.exports = Math.abs;

},{}],34:[function(require,module,exports){
'use strict';

/** @type {import('./abs')} */
module.exports = Math.floor;

},{}],35:[function(require,module,exports){
'use strict';

/** @type {import('./max')} */
module.exports = Math.max;

},{}],36:[function(require,module,exports){
'use strict';

/** @type {import('./min')} */
module.exports = Math.min;

},{}],37:[function(require,module,exports){
'use strict';

/** @type {import('./pow')} */
module.exports = Math.pow;

},{}],38:[function(require,module,exports){
'use strict';

var keysShim;
if (!Object.keys) {
	// modified from https://github.com/es-shims/es5-shim
	var has = Object.prototype.hasOwnProperty;
	var toStr = Object.prototype.toString;
	var isArgs = require('./isArguments'); // eslint-disable-line global-require
	var isEnumerable = Object.prototype.propertyIsEnumerable;
	var hasDontEnumBug = !isEnumerable.call({ toString: null }, 'toString');
	var hasProtoEnumBug = isEnumerable.call(function () {}, 'prototype');
	var dontEnums = [
		'toString',
		'toLocaleString',
		'valueOf',
		'hasOwnProperty',
		'isPrototypeOf',
		'propertyIsEnumerable',
		'constructor'
	];
	var equalsConstructorPrototype = function (o) {
		var ctor = o.constructor;
		return ctor && ctor.prototype === o;
	};
	var excludedKeys = {
		$applicationCache: true,
		$console: true,
		$external: true,
		$frame: true,
		$frameElement: true,
		$frames: true,
		$innerHeight: true,
		$innerWidth: true,
		$onmozfullscreenchange: true,
		$onmozfullscreenerror: true,
		$outerHeight: true,
		$outerWidth: true,
		$pageXOffset: true,
		$pageYOffset: true,
		$parent: true,
		$scrollLeft: true,
		$scrollTop: true,
		$scrollX: true,
		$scrollY: true,
		$self: true,
		$webkitIndexedDB: true,
		$webkitStorageInfo: true,
		$window: true
	};
	var hasAutomationEqualityBug = (function () {
		/* global window */
		if (typeof window === 'undefined') { return false; }
		for (var k in window) {
			try {
				if (!excludedKeys['$' + k] && has.call(window, k) && window[k] !== null && typeof window[k] === 'object') {
					try {
						equalsConstructorPrototype(window[k]);
					} catch (e) {
						return true;
					}
				}
			} catch (e) {
				return true;
			}
		}
		return false;
	}());
	var equalsConstructorPrototypeIfNotBuggy = function (o) {
		/* global window */
		if (typeof window === 'undefined' || !hasAutomationEqualityBug) {
			return equalsConstructorPrototype(o);
		}
		try {
			return equalsConstructorPrototype(o);
		} catch (e) {
			return false;
		}
	};

	keysShim = function keys(object) {
		var isObject = object !== null && typeof object === 'object';
		var isFunction = toStr.call(object) === '[object Function]';
		var isArguments = isArgs(object);
		var isString = isObject && toStr.call(object) === '[object String]';
		var theKeys = [];

		if (!isObject && !isFunction && !isArguments) {
			throw new TypeError('Object.keys called on a non-object');
		}

		var skipProto = hasProtoEnumBug && isFunction;
		if (isString && object.length > 0 && !has.call(object, 0)) {
			for (var i = 0; i < object.length; ++i) {
				theKeys.push(String(i));
			}
		}

		if (isArguments && object.length > 0) {
			for (var j = 0; j < object.length; ++j) {
				theKeys.push(String(j));
			}
		} else {
			for (var name in object) {
				if (!(skipProto && name === 'prototype') && has.call(object, name)) {
					theKeys.push(String(name));
				}
			}
		}

		if (hasDontEnumBug) {
			var skipConstructor = equalsConstructorPrototypeIfNotBuggy(object);

			for (var k = 0; k < dontEnums.length; ++k) {
				if (!(skipConstructor && dontEnums[k] === 'constructor') && has.call(object, dontEnums[k])) {
					theKeys.push(dontEnums[k]);
				}
			}
		}
		return theKeys;
	};
}
module.exports = keysShim;

},{"./isArguments":40}],39:[function(require,module,exports){
'use strict';

var slice = Array.prototype.slice;
var isArgs = require('./isArguments');

var origKeys = Object.keys;
var keysShim = origKeys ? function keys(o) { return origKeys(o); } : require('./implementation');

var originalKeys = Object.keys;

keysShim.shim = function shimObjectKeys() {
	if (Object.keys) {
		var keysWorksWithArguments = (function () {
			// Safari 5.0 bug
			var args = Object.keys(arguments);
			return args && args.length === arguments.length;
		}(1, 2));
		if (!keysWorksWithArguments) {
			Object.keys = function keys(object) { // eslint-disable-line func-name-matching
				if (isArgs(object)) {
					return originalKeys(slice.call(object));
				}
				return originalKeys(object);
			};
		}
	} else {
		Object.keys = keysShim;
	}
	return Object.keys || keysShim;
};

module.exports = keysShim;

},{"./implementation":38,"./isArguments":40}],40:[function(require,module,exports){
'use strict';

var toStr = Object.prototype.toString;

module.exports = function isArguments(value) {
	var str = toStr.call(value);
	var isArgs = str === '[object Arguments]';
	if (!isArgs) {
		isArgs = str !== '[object Array]' &&
			value !== null &&
			typeof value === 'object' &&
			typeof value.length === 'number' &&
			value.length >= 0 &&
			toStr.call(value.callee) === '[object Function]';
	}
	return isArgs;
};

},{}],41:[function(require,module,exports){
'use strict';

var GetIntrinsic = require('get-intrinsic');
var define = require('define-data-property');
var hasDescriptors = require('has-property-descriptors')();
var gOPD = require('gopd');

var $TypeError = require('es-errors/type');
var $floor = GetIntrinsic('%Math.floor%');

/** @type {import('.')} */
module.exports = function setFunctionLength(fn, length) {
	if (typeof fn !== 'function') {
		throw new $TypeError('`fn` is not a function');
	}
	if (typeof length !== 'number' || length < 0 || length > 0xFFFFFFFF || $floor(length) !== length) {
		throw new $TypeError('`length` must be a positive 32-bit integer');
	}

	var loose = arguments.length > 2 && !!arguments[2];

	var functionLengthIsConfigurable = true;
	var functionLengthIsWritable = true;
	if ('length' in fn && gOPD) {
		var desc = gOPD(fn, 'length');
		if (desc && !desc.configurable) {
			functionLengthIsConfigurable = false;
		}
		if (desc && !desc.writable) {
			functionLengthIsWritable = false;
		}
	}

	if (functionLengthIsConfigurable || functionLengthIsWritable || !loose) {
		if (hasDescriptors) {
			define(/** @type {Parameters<define>[0]} */ (fn), 'length', length, true, true);
		} else {
			define(/** @type {Parameters<define>[0]} */ (fn), 'length', length);
		}
	}
	return fn;
};

},{"define-data-property":12,"es-errors/type":21,"get-intrinsic":26,"gopd":28,"has-property-descriptors":29}],42:[function(require,module,exports){
'use strict';

var implementation = require('./implementation');

var lacksProperEnumerationOrder = function () {
	if (!Object.assign) {
		return false;
	}
	/*
	 * v8, specifically in node 4.x, has a bug with incorrect property enumeration order
	 * note: this does not detect the bug unless there's 20 characters
	 */
	var str = 'abcdefghijklmnopqrst';
	var letters = str.split('');
	var map = {};
	for (var i = 0; i < letters.length; ++i) {
		map[letters[i]] = letters[i];
	}
	var obj = Object.assign({}, map);
	var actual = '';
	for (var k in obj) {
		actual += k;
	}
	return str !== actual;
};

var assignHasPendingExceptions = function () {
	if (!Object.assign || !Object.preventExtensions) {
		return false;
	}
	/*
	 * Firefox 37 still has "pending exception" logic in its Object.assign implementation,
	 * which is 72% slower than our shim, and Firefox 40's native implementation.
	 */
	var thrower = Object.preventExtensions({ 1: 2 });
	try {
		Object.assign(thrower, 'xy');
	} catch (e) {
		return thrower[1] === 'y';
	}
	return false;
};

module.exports = function getPolyfill() {
	if (!Object.assign) {
		return implementation;
	}
	if (lacksProperEnumerationOrder()) {
		return implementation;
	}
	if (assignHasPendingExceptions()) {
		return implementation;
	}
	return Object.assign;
};

},{"./implementation":2}],43:[function(require,module,exports){
'use strict';

var define = require('define-properties');
var getPolyfill = require('./polyfill');

module.exports = function shimAssign() {
	var polyfill = getPolyfill();
	define(
		Object,
		{ assign: polyfill },
		{ assign: function () { return Object.assign !== polyfill; } }
	);
	return polyfill;
};

},{"./polyfill":42,"define-properties":13}]},{},[1]);
'use strict';

var implementation = require('../implementation');
var callBind = require('call-bind');
var test = require('tape');
var hasStrictMode = require('has-strict-mode')();
var runTests = require('./tests');

test('as a function', function (t) {
	t.test('bad first arg/receiver', { skip: !hasStrictMode }, function (st) {
		st['throws'](function () { implementation(undefined); }, TypeError, 'undefined is not an object');
		st['throws'](function () { implementation(null); }, TypeError, 'null is not an object');
		st.end();
	});

	runTests(callBind(implementation, Object), t);

	t.end();
});
'use strict';

var assign = require('../');
var test = require('tape');
var runTests = require('./tests');

test('as a function', function (t) {
	t.test('bad array/this value', function (st) {
		st['throws'](function () { assign(undefined); }, TypeError, 'undefined is not an object');
		st['throws'](function () { assign(null); }, TypeError, 'null is not an object');
		st.end();
	});

	runTests(assign, t);

	t.end();
});
'use strict';

var test = require('tape');
var defineProperties = require('define-properties');
var isEnumerable = Object.prototype.propertyIsEnumerable;
var functionsHaveNames = require('functions-have-names')();

var runTests = require('./tests');

test('native', function (t) {
	t.equal(Object.assign.length, 2, 'Object.assign has a length of 2');
	t.test('Function name', { skip: !functionsHaveNames }, function (st) {
		st.equal(Object.assign.name, 'assign', 'Object.assign has name "assign"');
		st.end();
	});

	t.test('enumerability', { skip: !defineProperties.supportsDescriptors }, function (et) {
		et.equal(false, isEnumerable.call(Object, 'assign'), 'Object.assign is not enumerable');
		et.end();
	});

	var supportsStrictMode = (function () { return typeof this === 'undefined'; }());

	t.test('bad object value', { skip: !supportsStrictMode }, function (st) {
		st['throws'](function () { return Object.assign(undefined); }, TypeError, 'undefined is not an object');
		st['throws'](function () { return Object.assign(null); }, TypeError, 'null is not an object');
		st.end();
	});

	// v8 in node 0.8 and 0.10 have non-enumerable string properties
	var stringCharsAreEnumerable = isEnumerable.call('xy', 0);
	t.test('when Object.assign is present and has pending exceptions', { skip: !stringCharsAreEnumerable || !Object.preventExtensions }, function (st) {
		/*
		 * Firefox 37 still has "pending exception" logic in its Object.assign implementation,
		 * which is 72% slower than our shim, and Firefox 40's native implementation.
		 */
		var thrower = Object.preventExtensions({ 1: '2' });
		var error;
		try { Object.assign(thrower, 'xy'); } catch (e) { error = e; }
		st.equal(error instanceof TypeError, true, 'error is TypeError');
		st.equal(thrower[1], '2', 'thrower[1] === "2"');

		st.end();
	});

	runTests(Object.assign, t);

	t.end();
});
'use strict';

/* globals lockdown */

// requiring ses exposes "lockdown" on the global
require('ses');

// lockdown freezes the primordials
lockdown({ errorTaming: 'unsafe' });

// initialize the module
require('./');
'use strict';

var assign = require('../');
assign.shim();

var test = require('tape');
var defineProperties = require('define-properties');
var isEnumerable = Object.prototype.propertyIsEnumerable;
var functionsHaveNames = require('functions-have-names')();

var runTests = require('./tests');

test('shimmed', function (t) {
	t.equal(Object.assign.length, 2, 'Object.assign has a length of 2');
	t.test('Function name', { skip: !functionsHaveNames }, function (st) {
		st.equal(Object.assign.name, 'assign', 'Object.assign has name "assign"');
		st.end();
	});

	t.test('enumerability', { skip: !defineProperties.supportsDescriptors }, function (et) {
		et.equal(false, isEnumerable.call(Object, 'assign'), 'Object.assign is not enumerable');
		et.end();
	});

	var supportsStrictMode = (function () { return typeof this === 'undefined'; }());

	t.test('bad object value', { skip: !supportsStrictMode }, function (st) {
		st['throws'](function () { return Object.assign(undefined); }, TypeError, 'undefined is not an object');
		st['throws'](function () { return Object.assign(null); }, TypeError, 'null is not an object');
		st.end();
	});

	// v8 in node 0.8 and 0.10 have non-enumerable string properties
	var stringCharsAreEnumerable = isEnumerable.call('xy', 0);
	t.test('when Object.assign is present and has pending exceptions', { skip: !stringCharsAreEnumerable || !Object.preventExtensions }, function (st) {
		/*
		 * Firefox 37 still has "pending exception" logic in its Object.assign implementation,
		 * which is 72% slower than our shim, and Firefox 40's native implementation.
		 */
		var thrower = Object.preventExtensions({ 1: '2' });
		var error;
		try { Object.assign(thrower, 'xy'); } catch (e) { error = e; }
		st.equal(error instanceof TypeError, true, 'error is TypeError');
		st.equal(thrower[1], '2', 'thrower[1] === "2"');

		st.end();
	});

	runTests(Object.assign, t);

	t.end();
});
'use strict';

var hasSymbols = require('has-symbols/shams')();
var forEach = require('for-each');
var hasOwn = require('hasown');
var mockProperty = require('mock-property');

module.exports = function (assign, t) {
	t.test('error cases', function (st) {
		st['throws'](function () { assign(null); }, TypeError, 'target must be an object');
		st['throws'](function () { assign(undefined); }, TypeError, 'target must be an object');
		st['throws'](function () { assign(null, {}); }, TypeError, 'target must be an object');
		st['throws'](function () { assign(undefined, {}); }, TypeError, 'target must be an object');
		st.end();
	});

	t.test('non-object target, no sources', function (st) {
		var bool = assign(true);
		st.equal(typeof bool, 'object', 'bool is object');
		st.equal(Boolean.prototype.valueOf.call(bool), true, 'bool coerces to `true`');

		var number = assign(1);
		st.equal(typeof number, 'object', 'number is object');
		st.equal(Number.prototype.valueOf.call(number), 1, 'number coerces to `1`');

		var string = assign('1');
		st.equal(typeof string, 'object', 'number is object');
		st.equal(String.prototype.valueOf.call(string), '1', 'number coerces to `"1"`');

		st.end();
	});

	t.test('non-object target, with sources', function (st) {
		var signal = {};

		st.test('boolean', function (st2) {
			var bool = assign(true, { a: signal });
			st2.equal(typeof bool, 'object', 'bool is object');
			st2.equal(Boolean.prototype.valueOf.call(bool), true, 'bool coerces to `true`');
			st2.equal(bool.a, signal, 'source properties copied');
			st2.end();
		});

		st.test('number', function (st2) {
			var number = assign(1, { a: signal });
			st2.equal(typeof number, 'object', 'number is object');
			st2.equal(Number.prototype.valueOf.call(number), 1, 'number coerces to `1`');
			st2.equal(number.a, signal, 'source properties copied');
			st2.end();
		});

		st.test('string', function (st2) {
			var string = assign('1', { a: signal });
			st2.equal(typeof string, 'object', 'number is object');
			st2.equal(String.prototype.valueOf.call(string), '1', 'number coerces to `"1"`');
			st2.equal(string.a, signal, 'source properties copied');
			st2.end();
		});

		st.end();
	});

	t.test('non-object sources', function (st) {
		st.deepEqual(assign({ a: 1 }, null, { b: 2 }), { a: 1, b: 2 }, 'ignores null source');
		st.deepEqual(assign({ a: 1 }, { b: 2 }, undefined), { a: 1, b: 2 }, 'ignores undefined source');
		st.end();
	});

	t.test('returns the modified target object', function (st) {
		var target = {};
		var returned = assign(target, { a: 1 });
		st.equal(returned, target, 'returned object is the same reference as the target object');
		st.end();
	});

	t.test('has the right length', function (st) {
		st.equal(assign.length, 2, 'length is 2 => 2 required arguments');
		st.end();
	});

	t.test('merge two objects', function (st) {
		var target = { a: 1 };
		var returned = assign(target, { b: 2 });
		st.deepEqual(returned, { a: 1, b: 2 }, 'returned object has properties from both');
		st.end();
	});

	t.test('works with functions', function (st) {
		var target = function () {};
		target.a = 1;
		var returned = assign(target, { b: 2 });
		st.equal(target, returned, 'returned object is target');
		st.equal(returned.a, 1);
		st.equal(returned.b, 2);
		st.end();
	});

	t.test('works with primitives', function (st) {
		var target = 2;
		var source = { b: 42 };
		var returned = assign(target, source);
		st.equal(Object.prototype.toString.call(returned), '[object Number]', 'returned is object form of number primitive');
		st.equal(Number(returned), target, 'returned and target have same valueOf');
		st.equal(returned.b, source.b);
		st.end();
	});

	/* globals window */
	t.test('works with window.location', { skip: typeof window === 'undefined' }, function (st) {
		var target = {};
		assign(target, window.location);
		for (var prop in window.location) {
			if (hasOwn(window.location, prop)) {
				st.deepEqual(target[prop], window.location[prop], prop + ' is copied');
			}
		}
		st.end();
	});

	t.test('merge N objects', function (st) {
		var target = { a: 1 };
		var source1 = { b: 2 };
		var source2 = { c: 3 };
		var returned = assign(target, source1, source2);
		st.deepEqual(returned, { a: 1, b: 2, c: 3 }, 'returned object has properties from all sources');
		st.end();
	});

	t.test('only iterates over own keys', function (st) {
		var Foo = function () {};
		Foo.prototype.bar = true;
		var foo = new Foo();
		foo.baz = true;
		var target = { a: 1 };
		var returned = assign(target, foo);
		st.equal(returned, target, 'returned object is the same reference as the target object');
		st.deepEqual(target, { a: 1, baz: true }, 'returned object has only own properties from both');
		st.end();
	});

	t.test('includes enumerable symbols, after keys', { skip: !hasSymbols }, function (st) {
		var visited = [];
		var obj = {};
		Object.defineProperty(obj, 'a', { enumerable: true, get: function () { visited.push('a'); return 42; } });
		var symbol = Symbol('enumerable');
		Object.defineProperty(obj, symbol, {
			enumerable: true,
			get: function () { visited.push(symbol); return Infinity; }
		});
		var nonEnumSymbol = Symbol('non-enumerable');
		Object.defineProperty(obj, nonEnumSymbol, {
			enumerable: false,
			get: function () { visited.push(nonEnumSymbol); return -Infinity; }
		});
		var target = assign({}, obj);
		st.deepEqual(visited, ['a', symbol], 'key is visited first, then symbol');
		st.equal(target.a, 42, 'target.a is 42');
		st.equal(target[symbol], Infinity, 'target[symbol] is Infinity');
		st.notEqual(target[nonEnumSymbol], -Infinity, 'target[nonEnumSymbol] is not -Infinity');
		st.end();
	});

	t.test('does not fail when symbols are not present', { skip: !Object.isFrozen || Object.isFrozen(Object) }, function (st) {
		st.teardown(mockProperty(Object, 'getOwnPropertySymbols', { 'delete': true }));

		var visited = [];
		var obj = {};
		Object.defineProperty(obj, 'a', { enumerable: true, get: function () { visited.push('a'); return 42; } });
		var keys = ['a'];
		if (hasSymbols) {
			var symbol = Symbol('sym');
			Object.defineProperty(obj, symbol, {
				enumerable: true,
				get: function () { visited.push(symbol); return Infinity; }
			});
			keys.push(symbol);
		}
		var target = assign({}, obj);
		st.deepEqual(visited, keys, 'assign visits expected keys');
		st.equal(target.a, 42, 'target.a is 42');

		if (hasSymbols) {
			st.equal(target[symbol], Infinity);
		}
		st.end();
	});

	t.test('preserves correct property enumeration order', function (st) {
		var str = 'abcdefghijklmnopqrst';
		var letters = {};
		forEach(str.split(''), function (letter) {
			letters[letter] = letter;
		});

		var n = 5;
		st.comment('run the next test ' + n + ' times');
		var object = assign({}, letters);
		var actual = '';
		for (var k in object) {
			actual += k;
		}
		for (var i = 0; i < n; ++i) {
			st.equal(actual, str, 'property enumeration order should be followed');
		}
		st.end();
	});

	t.test('checks enumerability and existence, in case of modification during [[Get]]', { skip: !Object.defineProperty }, function (st) {
		var targetBvalue = {};
		var targetCvalue = {};
		var target = { b: targetBvalue, c: targetCvalue };
		var source = {};
		Object.defineProperty(source, 'a', {
			enumerable: true,
			get: function () {
				delete this.b;
				Object.defineProperty(this, 'c', { enumerable: false });
				return 'a';
			}
		});
		var sourceBvalue = {};
		var sourceCvalue = {};
		source.b = sourceBvalue;
		source.c = sourceCvalue;
		var result = assign(target, source);
		st.equal(result, target, 'sanity check: result is === target');
		st.equal(result.b, targetBvalue, 'target key not overwritten by deleted source key');
		st.equal(result.c, targetCvalue, 'target key not overwritten by non-enumerable source key');

		st.end();
	});
};
'use strict';

var inspect = require('../');
var Buffer = require('safer-buffer').Buffer;

var holes = ['a', 'b'];
holes[4] = 'e';
holes[6] = 'g';

var obj = {
    a: 1,
    b: [3, 4, undefined, null],
    c: undefined,
    d: null,
    e: {
        regex: /^x/i,
        buf: Buffer.from('abc'),
        holes: holes
    },
    now: new Date()
};
obj.self = obj;
console.log(inspect(obj));
'use strict';

var inspect = require('../');
var obj = { a: 1, b: [3, 4] };
obj.c = obj;
console.log(inspect(obj));
'use strict';

var inspect = require('../');
var obj = [1, 2, function f(n) { return n + 5; }, 4];
console.log(inspect(obj));
'use strict';

/* eslint-env browser */
var inspect = require('../');

var d = document.createElement('div');
d.setAttribute('id', 'beep');
d.innerHTML = '<b>wooo</b><i>iiiii</i>';

console.log(inspect([d, { a: 3, b: 4, c: [5, 6, [7, [8, [9]]]] }]));
'use strict';

var inspect = require('../');
var test = require('tape');
var hasToStringTag = require('has-tostringtag/shams')();

test('bigint', { skip: typeof BigInt === 'undefined' }, function (t) {
    t.test('primitives', function (st) {
        st.plan(3);

        st.equal(inspect(BigInt(-256)), '-256n');
        st.equal(inspect(BigInt(0)), '0n');
        st.equal(inspect(BigInt(256)), '256n');
    });

    t.test('objects', function (st) {
        st.plan(3);

        st.equal(inspect(Object(BigInt(-256))), 'Object(-256n)');
        st.equal(inspect(Object(BigInt(0))), 'Object(0n)');
        st.equal(inspect(Object(BigInt(256))), 'Object(256n)');
    });

    t.test('syntactic primitives', function (st) {
        st.plan(3);

        /* eslint-disable no-new-func */
        st.equal(inspect(Function('return -256n')()), '-256n');
        st.equal(inspect(Function('return 0n')()), '0n');
        st.equal(inspect(Function('return 256n')()), '256n');
    });

    t.test('toStringTag', { skip: !hasToStringTag }, function (st) {
        st.plan(1);

        var faker = {};
        faker[Symbol.toStringTag] = 'BigInt';
        st.equal(
            inspect(faker),
            '{ [Symbol(Symbol.toStringTag)]: \'BigInt\' }',
            'object lying about being a BigInt inspects as an object'
        );
    });

    t.test('numericSeparator', function (st) {
        st.equal(inspect(BigInt(0), { numericSeparator: false }), '0n', '0n, numericSeparator false');
        st.equal(inspect(BigInt(0), { numericSeparator: true }), '0n', '0n, numericSeparator true');

        st.equal(inspect(BigInt(1234), { numericSeparator: false }), '1234n', '1234n, numericSeparator false');
        st.equal(inspect(BigInt(1234), { numericSeparator: true }), '1_234n', '1234n, numericSeparator true');
        st.equal(inspect(BigInt(-1234), { numericSeparator: false }), '-1234n', '1234n, numericSeparator false');
        st.equal(inspect(BigInt(-1234), { numericSeparator: true }), '-1_234n', '1234n, numericSeparator true');

        st.end();
    });

    t.end();
});
var inspect = require('../');
var test = require('tape');

test('circular', function (t) {
    t.plan(2);
    var obj = { a: 1, b: [3, 4] };
    obj.c = obj;
    t.equal(inspect(obj), '{ a: 1, b: [ 3, 4 ], c: [Circular] }');

    var double = {};
    double.a = [double];
    double.b = {};
    double.b.inner = double.b;
    double.b.obj = double;
    t.equal(inspect(double), '{ a: [ [Circular] ], b: { inner: [Circular], obj: [Circular] } }');
});
var inspect = require('../');
var test = require('tape');

test('deep', function (t) {
    t.plan(4);
    var obj = [[[[[[500]]]]]];
    t.equal(inspect(obj), '[ [ [ [ [ [Array] ] ] ] ] ]');
    t.equal(inspect(obj, { depth: 4 }), '[ [ [ [ [Array] ] ] ] ]');
    t.equal(inspect(obj, { depth: 2 }), '[ [ [Array] ] ]');

    t.equal(inspect([[[{ a: 1 }]]], { depth: 3 }), '[ [ [ [Object] ] ] ]');
});
var inspect = require('../');
var test = require('tape');

test('element', function (t) {
    t.plan(3);
    var elem = {
        nodeName: 'div',
        attributes: [{ name: 'class', value: 'row' }],
        getAttribute: function (key) { return key; },
        childNodes: []
    };
    var obj = [1, elem, 3];
    t.deepEqual(inspect(obj), '[ 1, <div class="row"></div>, 3 ]');
    t.deepEqual(inspect(obj, { quoteStyle: 'single' }), "[ 1, <div class='row'></div>, 3 ]");
    t.deepEqual(inspect(obj, { quoteStyle: 'double' }), '[ 1, <div class="row"></div>, 3 ]');
});

test('element no attr', function (t) {
    t.plan(1);
    var elem = {
        nodeName: 'div',
        getAttribute: function (key) { return key; },
        childNodes: []
    };
    var obj = [1, elem, 3];
    t.deepEqual(inspect(obj), '[ 1, <div></div>, 3 ]');
});

test('element with contents', function (t) {
    t.plan(1);
    var elem = {
        nodeName: 'div',
        getAttribute: function (key) { return key; },
        childNodes: [{ nodeName: 'b' }]
    };
    var obj = [1, elem, 3];
    t.deepEqual(inspect(obj), '[ 1, <div>...</div>, 3 ]');
});

test('element instance', function (t) {
    t.plan(1);
    var h = global.HTMLElement;
    global.HTMLElement = function (name, attr) {
        this.nodeName = name;
        this.attributes = attr;
    };
    global.HTMLElement.prototype.getAttribute = function () {};

    var elem = new global.HTMLElement('div', []);
    var obj = [1, elem, 3];
    t.deepEqual(inspect(obj), '[ 1, <div></div>, 3 ]');
    global.HTMLElement = h;
});
var test = require('tape');
var ErrorWithCause = require('error-cause/Error');

var inspect = require('../');

test('type error', function (t) {
    t.plan(1);
    var aerr = new TypeError();
    aerr.foo = 555;
    aerr.bar = [1, 2, 3];

    var berr = new TypeError('tuv');
    berr.baz = 555;

    var cerr = new SyntaxError();
    cerr.message = 'whoa';
    cerr['a-b'] = 5;

    var withCause = new ErrorWithCause('foo', { cause: 'bar' });
    var withCausePlus = new ErrorWithCause('foo', { cause: 'bar' });
    withCausePlus.foo = 'bar';
    var withUndefinedCause = new ErrorWithCause('foo', { cause: undefined });
    var withEnumerableCause = new Error('foo');
    withEnumerableCause.cause = 'bar';

    var obj = [
        new TypeError(),
        new TypeError('xxx'),
        aerr,
        berr,
        cerr,
        withCause,
        withCausePlus,
        withUndefinedCause,
        withEnumerableCause
    ];
    t.equal(inspect(obj), '[ ' + [
        '[TypeError]',
        '[TypeError: xxx]',
        '{ [TypeError] foo: 555, bar: [ 1, 2, 3 ] }',
        '{ [TypeError: tuv] baz: 555 }',
        '{ [SyntaxError: whoa] message: \'whoa\', \'a-b\': 5 }',
        'cause' in Error.prototype ? '[Error: foo]' : '{ [Error: foo] [cause]: \'bar\' }',
        '{ [Error: foo] ' + ('cause' in Error.prototype ? '' : '[cause]: \'bar\', ') + 'foo: \'bar\' }',
        'cause' in Error.prototype ? '[Error: foo]' : '{ [Error: foo] [cause]: undefined }',
        '{ [Error: foo] cause: \'bar\' }'
    ].join(', ') + ' ]');
});
'use strict';

var inspect = require('../');
var test = require('tape');
var hasToStringTag = require('has-tostringtag/shams')();
var forEach = require('for-each');

test('fakes', { skip: !hasToStringTag }, function (t) {
    forEach([
        'Array',
        'Boolean',
        'Date',
        'Error',
        'Number',
        'RegExp',
        'String'
    ], function (expected) {
        var faker = {};
        faker[Symbol.toStringTag] = expected;

        t.equal(
            inspect(faker),
            '{ [Symbol(Symbol.toStringTag)]: \'' + expected + '\' }',
            'faker masquerading as ' + expected + ' is not shown as one'
        );
    });

    t.end();
});
var inspect = require('../');
var test = require('tape');
var arrow = require('make-arrow-function')();
var functionsHaveConfigurableNames = require('functions-have-names').functionsHaveConfigurableNames();

test('function', function (t) {
    t.plan(1);
    var obj = [1, 2, function f(n) { return n; }, 4];
    t.equal(inspect(obj), '[ 1, 2, [Function: f], 4 ]');
});

test('function name', function (t) {
    t.plan(1);
    var f = (function () {
        return function () {};
    }());
    f.toString = function toStr() { return 'function xxx () {}'; };
    var obj = [1, 2, f, 4];
    t.equal(inspect(obj), '[ 1, 2, [Function (anonymous)] { toString: [Function: toStr] }, 4 ]');
});

test('anon function', function (t) {
    var f = (function () {
        return function () {};
    }());
    var obj = [1, 2, f, 4];
    t.equal(inspect(obj), '[ 1, 2, [Function (anonymous)], 4 ]');

    t.end();
});

test('arrow function', { skip: !arrow }, function (t) {
    t.equal(inspect(arrow), '[Function (anonymous)]');

    t.end();
});

test('truly nameless function', { skip: !arrow || !functionsHaveConfigurableNames }, function (t) {
    function f() {}
    Object.defineProperty(f, 'name', { value: false });
    t.equal(f.name, false);
    t.equal(
        inspect(f),
        '[Function: f]',
        'named function with falsy `.name` does not hide its original name'
    );

    function g() {}
    Object.defineProperty(g, 'name', { value: true });
    t.equal(g.name, true);
    t.equal(
        inspect(g),
        '[Function: true]',
        'named function with truthy `.name` hides its original name'
    );

    var anon = function () {}; // eslint-disable-line func-style
    Object.defineProperty(anon, 'name', { value: null });
    t.equal(anon.name, null);
    t.equal(
        inspect(anon),
        '[Function (anonymous)]',
        'anon function with falsy `.name` does not hide its anonymity'
    );

    var anon2 = function () {}; // eslint-disable-line func-style
    Object.defineProperty(anon2, 'name', { value: 1 });
    t.equal(anon2.name, 1);
    t.equal(
        inspect(anon2),
        '[Function: 1]',
        'anon function with truthy `.name` hides its anonymity'
    );

    t.end();
});
'use strict';

var inspect = require('../');

var test = require('tape');
var globalThis = require('globalthis')();

test('global object', function (t) {
    /* eslint-env browser */
    var expected = typeof window === 'undefined' ? 'globalThis' : 'Window';
    t.equal(
        inspect([globalThis]),
        '[ { [object ' + expected + '] } ]'
    );

    t.end();
});
'use strict';

var inspect = require('../');
var test = require('tape');
var mockProperty = require('mock-property');

test('when Object#hasOwnProperty is deleted', function (t) {
    t.plan(1);
    var arr = [1, , 3]; // eslint-disable-line no-sparse-arrays

    t.teardown(mockProperty(Array.prototype, 1, { value: 2 })); // this is needed to account for "in" vs "hasOwnProperty"
    t.teardown(mockProperty(Object.prototype, 'hasOwnProperty', { 'delete': true }));

    t.equal(inspect(arr), '[ 1, , 3 ]');
});
var test = require('tape');
var inspect = require('../');

var xs = ['a', 'b'];
xs[5] = 'f';
xs[7] = 'j';
xs[8] = 'k';

test('holes', function (t) {
    t.plan(1);
    t.equal(
        inspect(xs),
        "[ 'a', 'b', , , , 'f', , 'j', 'k' ]"
    );
});
var test = require('tape');
var forEach = require('for-each');

var inspect = require('../');

test('bad indent options', function (t) {
    forEach([
        undefined,
        true,
        false,
        -1,
        1.2,
        Infinity,
        -Infinity,
        NaN
    ], function (indent) {
        t['throws'](
            function () { inspect('', { indent: indent }); },
            TypeError,
            inspect(indent) + ' is invalid'
        );
    });

    t.end();
});

test('simple object with indent', function (t) {
    t.plan(2);

    var obj = { a: 1, b: 2 };

    var expectedSpaces = [
        '{',
        '  a: 1,',
        '  b: 2',
        '}'
    ].join('\n');
    var expectedTabs = [
        '{',
        '	a: 1,',
        '	b: 2',
        '}'
    ].join('\n');

    t.equal(inspect(obj, { indent: 2 }), expectedSpaces, 'two');
    t.equal(inspect(obj, { indent: '\t' }), expectedTabs, 'tabs');
});

test('two deep object with indent', function (t) {
    t.plan(2);

    var obj = { a: 1, b: { c: 3, d: 4 } };

    var expectedSpaces = [
        '{',
        '  a: 1,',
        '  b: {',
        '    c: 3,',
        '    d: 4',
        '  }',
        '}'
    ].join('\n');
    var expectedTabs = [
        '{',
        '	a: 1,',
        '	b: {',
        '		c: 3,',
        '		d: 4',
        '	}',
        '}'
    ].join('\n');

    t.equal(inspect(obj, { indent: 2 }), expectedSpaces, 'two');
    t.equal(inspect(obj, { indent: '\t' }), expectedTabs, 'tabs');
});

test('simple array with all single line elements', function (t) {
    t.plan(2);

    var obj = [1, 2, 3, 'asdf\nsdf'];

    var expected = '[ 1, 2, 3, \'asdf\\nsdf\' ]';

    t.equal(inspect(obj, { indent: 2 }), expected, 'two');
    t.equal(inspect(obj, { indent: '\t' }), expected, 'tabs');
});

test('array with complex elements', function (t) {
    t.plan(2);

    var obj = [1, { a: 1, b: { c: 1 } }, 'asdf\nsdf'];

    var expectedSpaces = [
        '[',
        '  1,',
        '  {',
        '    a: 1,',
        '    b: {',
        '      c: 1',
        '    }',
        '  },',
        '  \'asdf\\nsdf\'',
        ']'
    ].join('\n');
    var expectedTabs = [
        '[',
        '	1,',
        '	{',
        '		a: 1,',
        '		b: {',
        '			c: 1',
        '		}',
        '	},',
        '	\'asdf\\nsdf\'',
        ']'
    ].join('\n');

    t.equal(inspect(obj, { indent: 2 }), expectedSpaces, 'two');
    t.equal(inspect(obj, { indent: '\t' }), expectedTabs, 'tabs');
});

test('values', function (t) {
    t.plan(2);
    var obj = [{}, [], { 'a-b': 5 }];

    var expectedSpaces = [
        '[',
        '  {},',
        '  [],',
        '  {',
        '    \'a-b\': 5',
        '  }',
        ']'
    ].join('\n');
    var expectedTabs = [
        '[',
        '	{},',
        '	[],',
        '	{',
        '		\'a-b\': 5',
        '	}',
        ']'
    ].join('\n');

    t.equal(inspect(obj, { indent: 2 }), expectedSpaces, 'two');
    t.equal(inspect(obj, { indent: '\t' }), expectedTabs, 'tabs');
});

test('Map', { skip: typeof Map !== 'function' }, function (t) {
    var map = new Map();
    map.set({ a: 1 }, ['b']);
    map.set(3, NaN);

    var expectedStringSpaces = [
        'Map (2) {',
        '  { a: 1 } => [ \'b\' ],',
        '  3 => NaN',
        '}'
    ].join('\n');
    var expectedStringTabs = [
        'Map (2) {',
        '	{ a: 1 } => [ \'b\' ],',
        '	3 => NaN',
        '}'
    ].join('\n');
    var expectedStringTabsDoubleQuotes = [
        'Map (2) {',
        '	{ a: 1 } => [ "b" ],',
        '	3 => NaN',
        '}'
    ].join('\n');

    t.equal(
        inspect(map, { indent: 2 }),
        expectedStringSpaces,
        'Map keys are not indented (two)'
    );
    t.equal(
        inspect(map, { indent: '\t' }),
        expectedStringTabs,
        'Map keys are not indented (tabs)'
    );
    t.equal(
        inspect(map, { indent: '\t', quoteStyle: 'double' }),
        expectedStringTabsDoubleQuotes,
        'Map keys are not indented (tabs + double quotes)'
    );

    t.equal(inspect(new Map(), { indent: 2 }), 'Map (0) {}', 'empty Map should show as empty (two)');
    t.equal(inspect(new Map(), { indent: '\t' }), 'Map (0) {}', 'empty Map should show as empty (tabs)');

    var nestedMap = new Map();
    nestedMap.set(nestedMap, map);
    var expectedNestedSpaces = [
        'Map (1) {',
        '  [Circular] => Map (2) {',
        '    { a: 1 } => [ \'b\' ],',
        '    3 => NaN',
        '  }',
        '}'
    ].join('\n');
    var expectedNestedTabs = [
        'Map (1) {',
        '	[Circular] => Map (2) {',
        '		{ a: 1 } => [ \'b\' ],',
        '		3 => NaN',
        '	}',
        '}'
    ].join('\n');
    t.equal(inspect(nestedMap, { indent: 2 }), expectedNestedSpaces, 'Map containing a Map should work (two)');
    t.equal(inspect(nestedMap, { indent: '\t' }), expectedNestedTabs, 'Map containing a Map should work (tabs)');

    t.end();
});

test('Set', { skip: typeof Set !== 'function' }, function (t) {
    var set = new Set();
    set.add({ a: 1 });
    set.add(['b']);
    var expectedStringSpaces = [
        'Set (2) {',
        '  {',
        '    a: 1',
        '  },',
        '  [ \'b\' ]',
        '}'
    ].join('\n');
    var expectedStringTabs = [
        'Set (2) {',
        '	{',
        '		a: 1',
        '	},',
        '	[ \'b\' ]',
        '}'
    ].join('\n');
    t.equal(inspect(set, { indent: 2 }), expectedStringSpaces, 'new Set([{ a: 1 }, ["b"]]) should show size and contents (two)');
    t.equal(inspect(set, { indent: '\t' }), expectedStringTabs, 'new Set([{ a: 1 }, ["b"]]) should show size and contents (tabs)');

    t.equal(inspect(new Set(), { indent: 2 }), 'Set (0) {}', 'empty Set should show as empty (two)');
    t.equal(inspect(new Set(), { indent: '\t' }), 'Set (0) {}', 'empty Set should show as empty (tabs)');

    var nestedSet = new Set();
    nestedSet.add(set);
    nestedSet.add(nestedSet);
    var expectedNestedSpaces = [
        'Set (2) {',
        '  Set (2) {',
        '    {',
        '      a: 1',
        '    },',
        '    [ \'b\' ]',
        '  },',
        '  [Circular]',
        '}'
    ].join('\n');
    var expectedNestedTabs = [
        'Set (2) {',
        '	Set (2) {',
        '		{',
        '			a: 1',
        '		},',
        '		[ \'b\' ]',
        '	},',
        '	[Circular]',
        '}'
    ].join('\n');
    t.equal(inspect(nestedSet, { indent: 2 }), expectedNestedSpaces, 'Set containing a Set should work (two)');
    t.equal(inspect(nestedSet, { indent: '\t' }), expectedNestedTabs, 'Set containing a Set should work (tabs)');

    t.end();
});
var test = require('tape');
var hasSymbols = require('has-symbols/shams')();
var utilInspect = require('../util.inspect');
var repeat = require('string.prototype.repeat');

var inspect = require('..');

test('inspect', function (t) {
    t.plan(5);

    var obj = [{ inspect: function xyzInspect() { return '!XYZ¡'; } }, []];
    var stringResult = '[ !XYZ¡, [] ]';
    var falseResult = '[ { inspect: [Function: xyzInspect] }, [] ]';

    t.equal(inspect(obj), stringResult);
    t.equal(inspect(obj, { customInspect: true }), stringResult);
    t.equal(inspect(obj, { customInspect: 'symbol' }), falseResult);
    t.equal(inspect(obj, { customInspect: false }), falseResult);
    t['throws'](
        function () { inspect(obj, { customInspect: 'not a boolean or "symbol"' }); },
        TypeError,
        '`customInspect` must be a boolean or the string "symbol"'
    );
});

test('inspect custom symbol', { skip: !hasSymbols || !utilInspect || !utilInspect.custom }, function (t) {
    t.plan(4);

    var obj = { inspect: function stringInspect() { return 'string'; } };
    obj[utilInspect.custom] = function custom() { return 'symbol'; };

    var symbolResult = '[ symbol, [] ]';
    var stringResult = '[ string, [] ]';
    var falseResult = '[ { inspect: [Function: stringInspect]' + (utilInspect.custom ? ', [' + inspect(utilInspect.custom) + ']: [Function: custom]' : '') + ' }, [] ]';

    var symbolStringFallback = utilInspect.custom ? symbolResult : stringResult;
    var symbolFalseFallback = utilInspect.custom ? symbolResult : falseResult;

    t.equal(inspect([obj, []]), symbolStringFallback);
    t.equal(inspect([obj, []], { customInspect: true }), symbolStringFallback);
    t.equal(inspect([obj, []], { customInspect: 'symbol' }), symbolFalseFallback);
    t.equal(inspect([obj, []], { customInspect: false }), falseResult);
});

test('symbols', { skip: !hasSymbols }, function (t) {
    t.plan(2);

    var obj = { a: 1 };
    obj[Symbol('test')] = 2;
    obj[Symbol.iterator] = 3;
    Object.defineProperty(obj, Symbol('non-enum'), {
        enumerable: false,
        value: 4
    });

    if (typeof Symbol.iterator === 'symbol') {
        t.equal(inspect(obj), '{ a: 1, [Symbol(test)]: 2, [Symbol(Symbol.iterator)]: 3 }', 'object with symbols');
        t.equal(inspect([obj, []]), '[ { a: 1, [Symbol(test)]: 2, [Symbol(Symbol.iterator)]: 3 }, [] ]', 'object with symbols in array');
    } else {
        // symbol sham key ordering is unreliable
        t.match(
            inspect(obj),
            /^(?:{ a: 1, \[Symbol\(test\)\]: 2, \[Symbol\(Symbol.iterator\)\]: 3 }|{ a: 1, \[Symbol\(Symbol.iterator\)\]: 3, \[Symbol\(test\)\]: 2 })$/,
            'object with symbols (nondeterministic symbol sham key ordering)'
        );
        t.match(
            inspect([obj, []]),
            /^\[ (?:{ a: 1, \[Symbol\(test\)\]: 2, \[Symbol\(Symbol.iterator\)\]: 3 }|{ a: 1, \[Symbol\(Symbol.iterator\)\]: 3, \[Symbol\(test\)\]: 2 }), \[\] \]$/,
            'object with symbols in array (nondeterministic symbol sham key ordering)'
        );
    }
});

test('maxStringLength', function (t) {
    t['throws'](
        function () { inspect('', { maxStringLength: -1 }); },
        TypeError,
        'maxStringLength must be >= 0, or Infinity, not negative'
    );

    var str = repeat('a', 1e8);

    t.equal(
        inspect([str], { maxStringLength: 10 }),
        '[ \'aaaaaaaaaa\'... 99999990 more characters ]',
        'maxStringLength option limits output'
    );

    t.equal(
        inspect(['f'], { maxStringLength: null }),
        '[ \'\'... 1 more character ]',
        'maxStringLength option accepts `null`'
    );

    t.equal(
        inspect([str], { maxStringLength: Infinity }),
        '[ \'' + str + '\' ]',
        'maxStringLength option accepts ∞'
    );

    t.end();
});

test('inspect options', { skip: !utilInspect.custom }, function (t) {
    var obj = {};
    obj[utilInspect.custom] = function () {
        return JSON.stringify(arguments);
    };
    t.equal(
        inspect(obj),
        utilInspect(obj, { depth: 5 }),
        'custom symbols will use node\'s inspect'
    );
    t.equal(
        inspect(obj, { depth: 2 }),
        utilInspect(obj, { depth: 2 }),
        'a reduced depth will be passed to node\'s inspect'
    );
    t.equal(
        inspect({ d1: obj }, { depth: 3 }),
        '{ d1: ' + utilInspect(obj, { depth: 2 }) + ' }',
        'deep objects will receive a reduced depth'
    );
    t.equal(
        inspect({ d1: obj }, { depth: 1 }),
        '{ d1: [Object] }',
        'unlike nodejs inspect, customInspect will not be used once the depth is exceeded.'
    );
    t.end();
});

test('inspect URL', { skip: typeof URL === 'undefined' }, function (t) {
    t.match(
        inspect(new URL('https://nodejs.org')),
        /nodejs\.org/, // Different environments stringify it differently
        'url can be inspected'
    );
    t.end();
});
var test = require('tape');
var inspect = require('../');

var obj = { x: 'a\r\nb', y: '\x05! \x1f \x12' };

test('interpolate low bytes', function (t) {
    t.plan(1);
    t.equal(
        inspect(obj),
        "{ x: 'a\\r\\nb', y: '\\x05! \\x1F \\x12' }"
    );
});
var test = require('tape');
var v = require('es-value-fixtures');
var forEach = require('for-each');

var inspect = require('../');

test('negative zero', function (t) {
    t.equal(inspect(0), '0', 'inspect(0) === "0"');
    t.equal(inspect(Object(0)), 'Object(0)', 'inspect(Object(0)) === "Object(0)"');

    t.equal(inspect(-0), '-0', 'inspect(-0) === "-0"');
    t.equal(inspect(Object(-0)), 'Object(-0)', 'inspect(Object(-0)) === "Object(-0)"');

    t.end();
});

test('numericSeparator', function (t) {
    forEach(v.nonBooleans, function (nonBoolean) {
        t['throws'](
            function () { inspect(true, { numericSeparator: nonBoolean }); },
            TypeError,
            inspect(nonBoolean) + ' is not a boolean'
        );
    });

    t.test('3 digit numbers', function (st) {
        var failed = false;
        for (var i = -999; i < 1000; i += 1) {
            var actual = inspect(i);
            var actualSepNo = inspect(i, { numericSeparator: false });
            var actualSepYes = inspect(i, { numericSeparator: true });
            var expected = String(i);
            if (actual !== expected || actualSepNo !== expected || actualSepYes !== expected) {
                failed = true;
                t.equal(actual, expected);
                t.equal(actualSepNo, expected);
                t.equal(actualSepYes, expected);
            }
        }

        st.notOk(failed, 'all 3 digit numbers passed');

        st.end();
    });

    t.equal(inspect(1e3), '1000', '1000');
    t.equal(inspect(1e3, { numericSeparator: false }), '1000', '1000, numericSeparator false');
    t.equal(inspect(1e3, { numericSeparator: true }), '1_000', '1000, numericSeparator true');
    t.equal(inspect(-1e3), '-1000', '-1000');
    t.equal(inspect(-1e3, { numericSeparator: false }), '-1000', '-1000, numericSeparator false');
    t.equal(inspect(-1e3, { numericSeparator: true }), '-1_000', '-1000, numericSeparator true');

    t.equal(inspect(1234.5678, { numericSeparator: true }), '1_234.567_8', 'fractional numbers get separators');
    t.equal(inspect(1234.56789, { numericSeparator: true }), '1_234.567_89', 'fractional numbers get separators');
    t.equal(inspect(1234.567891, { numericSeparator: true }), '1_234.567_891', 'fractional numbers get separators');

    t.end();
});
'use strict';

var inspect = require('../');
var test = require('tape');

test('quoteStyle option', function (t) {
    t['throws'](function () { inspect(null, { quoteStyle: false }); }, 'false is not a valid value');
    t['throws'](function () { inspect(null, { quoteStyle: true }); }, 'true is not a valid value');
    t['throws'](function () { inspect(null, { quoteStyle: '' }); }, '"" is not a valid value');
    t['throws'](function () { inspect(null, { quoteStyle: {} }); }, '{} is not a valid value');
    t['throws'](function () { inspect(null, { quoteStyle: [] }); }, '[] is not a valid value');
    t['throws'](function () { inspect(null, { quoteStyle: 42 }); }, '42 is not a valid value');
    t['throws'](function () { inspect(null, { quoteStyle: NaN }); }, 'NaN is not a valid value');
    t['throws'](function () { inspect(null, { quoteStyle: function () {} }); }, 'a function is not a valid value');

    t.equal(inspect('"', { quoteStyle: 'single' }), '\'"\'', 'double quote, quoteStyle: "single"');
    t.equal(inspect('"', { quoteStyle: 'double' }), '"\\""', 'double quote, quoteStyle: "double"');

    t.equal(inspect('\'', { quoteStyle: 'single' }), '\'\\\'\'', 'single quote, quoteStyle: "single"');
    t.equal(inspect('\'', { quoteStyle: 'double' }), '"\'"', 'single quote, quoteStyle: "double"');

    t.equal(inspect('`', { quoteStyle: 'single' }), '\'`\'', 'backtick, quoteStyle: "single"');
    t.equal(inspect('`', { quoteStyle: 'double' }), '"`"', 'backtick, quoteStyle: "double"');

    t.end();
});
'use strict';

var test = require('tape');
var hasToStringTag = require('has-tostringtag/shams')();

var inspect = require('../');

test('Symbol.toStringTag', { skip: !hasToStringTag }, function (t) {
    t.plan(4);

    var obj = { a: 1 };
    t.equal(inspect(obj), '{ a: 1 }', 'object, no Symbol.toStringTag');

    obj[Symbol.toStringTag] = 'foo';
    t.equal(inspect(obj), '{ a: 1, [Symbol(Symbol.toStringTag)]: \'foo\' }', 'object with Symbol.toStringTag');

    t.test('null objects', { skip: 'toString' in { __proto__: null } }, function (st) {
        st.plan(2);

        var dict = { __proto__: null, a: 1 };
        st.equal(inspect(dict), '[Object: null prototype] { a: 1 }', 'null object with Symbol.toStringTag');

        dict[Symbol.toStringTag] = 'Dict';
        st.equal(inspect(dict), '[Dict: null prototype] { a: 1, [Symbol(Symbol.toStringTag)]: \'Dict\' }', 'null object with Symbol.toStringTag');
    });

    t.test('instances', function (st) {
        st.plan(4);

        function C() {
            this.a = 1;
        }
        st.equal(Object.prototype.toString.call(new C()), '[object Object]', 'instance, no toStringTag, Object.prototype.toString');
        st.equal(inspect(new C()), 'C { a: 1 }', 'instance, no toStringTag');

        C.prototype[Symbol.toStringTag] = 'Class!';
        st.equal(Object.prototype.toString.call(new C()), '[object Class!]', 'instance, with toStringTag, Object.prototype.toString');
        st.equal(inspect(new C()), 'C [Class!] { a: 1 }', 'instance, with toStringTag');
    });
});
var test = require('tape');
var inspect = require('../');

var obj = { a: 1, b: [3, 4, undefined, null], c: undefined, d: null };

test('undef and null', function (t) {
    t.plan(1);
    t.equal(
        inspect(obj),
        '{ a: 1, b: [ 3, 4, undefined, null ], c: undefined, d: null }'
    );
});
'use strict';

var inspect = require('../');
var test = require('tape');
var mockProperty = require('mock-property');
var hasSymbols = require('has-symbols/shams')();
var hasToStringTag = require('has-tostringtag/shams')();
var forEach = require('for-each');
var semver = require('semver');

test('values', function (t) {
    t.plan(1);
    var obj = [{}, [], { 'a-b': 5 }];
    t.equal(inspect(obj), '[ {}, [], { \'a-b\': 5 } ]');
});

test('arrays with properties', function (t) {
    t.plan(1);
    var arr = [3];
    arr.foo = 'bar';
    var obj = [1, 2, arr];
    obj.baz = 'quux';
    obj.index = -1;
    t.equal(inspect(obj), '[ 1, 2, [ 3, foo: \'bar\' ], baz: \'quux\', index: -1 ]');
});

test('has', function (t) {
    t.plan(1);
    t.teardown(mockProperty(Object.prototype, 'hasOwnProperty', { 'delete': true }));

    t.equal(inspect({ a: 1, b: 2 }), '{ a: 1, b: 2 }');
});

test('indexOf seen', function (t) {
    t.plan(1);
    var xs = [1, 2, 3, {}];
    xs.push(xs);

    var seen = [];
    seen.indexOf = undefined;

    t.equal(
        inspect(xs, {}, 0, seen),
        '[ 1, 2, 3, {}, [Circular] ]'
    );
});

test('seen seen', function (t) {
    t.plan(1);
    var xs = [1, 2, 3];

    var seen = [xs];
    seen.indexOf = undefined;

    t.equal(
        inspect(xs, {}, 0, seen),
        '[Circular]'
    );
});

test('seen seen seen', function (t) {
    t.plan(1);
    var xs = [1, 2, 3];

    var seen = [5, xs];
    seen.indexOf = undefined;

    t.equal(
        inspect(xs, {}, 0, seen),
        '[Circular]'
    );
});

test('symbols', { skip: !hasSymbols }, function (t) {
    var sym = Symbol('foo');
    t.equal(inspect(sym), 'Symbol(foo)', 'Symbol("foo") should be "Symbol(foo)"');
    if (typeof sym === 'symbol') {
        // Symbol shams are incapable of differentiating boxed from unboxed symbols
        t.equal(inspect(Object(sym)), 'Object(Symbol(foo))', 'Object(Symbol("foo")) should be "Object(Symbol(foo))"');
    }

    t.test('toStringTag', { skip: !hasToStringTag }, function (st) {
        st.plan(1);

        var faker = {};
        faker[Symbol.toStringTag] = 'Symbol';
        st.equal(
            inspect(faker),
            '{ [Symbol(Symbol.toStringTag)]: \'Symbol\' }',
            'object lying about being a Symbol inspects as an object'
        );
    });

    t.end();
});

test('Map', { skip: typeof Map !== 'function' }, function (t) {
    var map = new Map();
    map.set({ a: 1 }, ['b']);
    map.set(3, NaN);
    var expectedString = 'Map (2) {' + inspect({ a: 1 }) + ' => ' + inspect(['b']) + ', 3 => NaN}';
    t.equal(inspect(map), expectedString, 'new Map([[{ a: 1 }, ["b"]], [3, NaN]]) should show size and contents');
    t.equal(inspect(new Map()), 'Map (0) {}', 'empty Map should show as empty');

    var nestedMap = new Map();
    nestedMap.set(nestedMap, map);
    t.equal(inspect(nestedMap), 'Map (1) {[Circular] => ' + expectedString + '}', 'Map containing a Map should work');

    t.end();
});

test('WeakMap', { skip: typeof WeakMap !== 'function' }, function (t) {
    var map = new WeakMap();
    map.set({ a: 1 }, ['b']);
    var expectedString = 'WeakMap { ? }';
    t.equal(inspect(map), expectedString, 'new WeakMap([[{ a: 1 }, ["b"]]]) should not show size or contents');
    t.equal(inspect(new WeakMap()), 'WeakMap { ? }', 'empty WeakMap should not show as empty');

    t.end();
});

test('Set', { skip: typeof Set !== 'function' }, function (t) {
    var set = new Set();
    set.add({ a: 1 });
    set.add(['b']);
    var expectedString = 'Set (2) {' + inspect({ a: 1 }) + ', ' + inspect(['b']) + '}';
    t.equal(inspect(set), expectedString, 'new Set([{ a: 1 }, ["b"]]) should show size and contents');
    t.equal(inspect(new Set()), 'Set (0) {}', 'empty Set should show as empty');

    var nestedSet = new Set();
    nestedSet.add(set);
    nestedSet.add(nestedSet);
    t.equal(inspect(nestedSet), 'Set (2) {' + expectedString + ', [Circular]}', 'Set containing a Set should work');

    t.end();
});

test('WeakSet', { skip: typeof WeakSet !== 'function' }, function (t) {
    var map = new WeakSet();
    map.add({ a: 1 });
    var expectedString = 'WeakSet { ? }';
    t.equal(inspect(map), expectedString, 'new WeakSet([{ a: 1 }]) should not show size or contents');
    t.equal(inspect(new WeakSet()), 'WeakSet { ? }', 'empty WeakSet should not show as empty');

    t.end();
});

test('WeakRef', { skip: typeof WeakRef !== 'function' }, function (t) {
    var ref = new WeakRef({ a: 1 });
    var expectedString = 'WeakRef { ? }';
    t.equal(inspect(ref), expectedString, 'new WeakRef({ a: 1 }) should not show contents');

    t.end();
});

test('FinalizationRegistry', { skip: typeof FinalizationRegistry !== 'function' }, function (t) {
    var registry = new FinalizationRegistry(function () {});
    var expectedString = 'FinalizationRegistry [FinalizationRegistry] {}';
    t.equal(inspect(registry), expectedString, 'new FinalizationRegistry(function () {}) should work normallys');

    t.end();
});

test('Strings', function (t) {
    var str = 'abc';

    t.equal(inspect(str), "'" + str + "'", 'primitive string shows as such');
    t.equal(inspect(str, { quoteStyle: 'single' }), "'" + str + "'", 'primitive string shows as such, single quoted');
    t.equal(inspect(str, { quoteStyle: 'double' }), '"' + str + '"', 'primitive string shows as such, double quoted');
    t.equal(inspect(Object(str)), 'Object(' + inspect(str) + ')', 'String object shows as such');
    t.equal(inspect(Object(str), { quoteStyle: 'single' }), 'Object(' + inspect(str, { quoteStyle: 'single' }) + ')', 'String object shows as such, single quoted');
    t.equal(inspect(Object(str), { quoteStyle: 'double' }), 'Object(' + inspect(str, { quoteStyle: 'double' }) + ')', 'String object shows as such, double quoted');

    t.end();
});

test('Numbers', function (t) {
    var num = 42;

    t.equal(inspect(num), String(num), 'primitive number shows as such');
    t.equal(inspect(Object(num)), 'Object(' + inspect(num) + ')', 'Number object shows as such');

    t.end();
});

test('Booleans', function (t) {
    t.equal(inspect(true), String(true), 'primitive true shows as such');
    t.equal(inspect(Object(true)), 'Object(' + inspect(true) + ')', 'Boolean object true shows as such');

    t.equal(inspect(false), String(false), 'primitive false shows as such');
    t.equal(inspect(Object(false)), 'Object(' + inspect(false) + ')', 'Boolean false object shows as such');

    t.end();
});

test('Date', function (t) {
    var now = new Date();
    t.equal(inspect(now), String(now), 'Date shows properly');
    t.equal(inspect(new Date(NaN)), 'Invalid Date', 'Invalid Date shows properly');

    t.end();
});

test('RegExps', function (t) {
    t.equal(inspect(/a/g), '/a/g', 'regex shows properly');
    t.equal(inspect(new RegExp('abc', 'i')), '/abc/i', 'new RegExp shows properly');

    var match = 'abc abc'.match(/[ab]+/);
    delete match.groups; // for node < 10
    t.equal(inspect(match), '[ \'ab\', index: 0, input: \'abc abc\' ]', 'RegExp match object shows properly');

    t.end();
});

test('Proxies', { skip: typeof Proxy !== 'function' || !hasToStringTag }, function (t) {
    var target = { proxy: true };
    var fake = new Proxy(target, { has: function () { return false; } });

    // needed to work around a weird difference in node v6.0 - v6.4 where non-present properties are not logged
    var isNode60 = semver.satisfies(process.version, '6.0 - 6.4');

    forEach([
        'Boolean',
        'Number',
        'String',
        'Symbol',
        'Date'
    ], function (tag) {
        target[Symbol.toStringTag] = tag;

        t.equal(
            inspect(fake),
            '{ ' + (isNode60 ? '' : 'proxy: true, ') + '[Symbol(Symbol.toStringTag)]: \'' + tag + '\' }',
            'Proxy for + ' + tag + ' shows as the target, which has no slots'
        );
    });

    t.end();
});

test('fakers', { skip: !hasToStringTag }, function (t) {
    var target = { proxy: false };

    forEach([
        'Boolean',
        'Number',
        'String',
        'Symbol',
        'Date'
    ], function (tag) {
        target[Symbol.toStringTag] = tag;

        t.equal(
            inspect(target),
            '{ proxy: false, [Symbol(Symbol.toStringTag)]: \'' + tag + '\' }',
            'Object pretending to be ' + tag + ' does not trick us'
        );
    });

    t.end();
});
'use strict';

require('./isArguments');

require('./shim');
'use strict';

var test = require('tape');
var hasSymbols = require('has-symbols/shams')();
var hasPropertyDescriptors = require('has-property-descriptors')();

var ownKeys = require('../');

/** @type {(a: PropertyKey, b: PropertyKey) => number} */
function comparator(a, b) {
	if (typeof a === 'string' && typeof b === 'string') {
		return a.localeCompare(b);
	}
	if (typeof a === 'number' && typeof b === 'number') {
		return a - b;
	}
	return typeof a === 'symbol' ? 1 : -1;
}

test('ownKeys', function (t) {
	t.equal(typeof ownKeys, 'function', 'is a function');
	t.equal(
		ownKeys.length,
		1,
		'has a length of 1'
	);

	t.test('basics', function (st) {
		var obj = { a: 1, b: 2 };
		if (hasPropertyDescriptors) {
			Object.defineProperty(obj, 'c', {
				configurable: true,
				enumerable: false,
				writable: true,
				value: 3
			});
		}

		st.deepEqual(
			ownKeys(obj).sort(comparator),
			(hasPropertyDescriptors ? ['a', 'b', 'c'] : ['a', 'b']).sort(comparator),
			'includes non-enumerable properties'
		);

		st.end();
	});

	t.test('symbols', { skip: !hasSymbols }, function (st) {
		/** @type {Record<PropertyKey, unknown>} */
		var obj = { a: 1 };
		var sym = Symbol('b');
		obj[sym] = 2;

		var nonEnumSym = Symbol('c');
		Object.defineProperty(obj, nonEnumSym, {
			configurable: true,
			enumerable: false,
			writable: true,
			value: 3
		});

		st.deepEqual(
			ownKeys(obj).sort(comparator),
			['a', sym, nonEnumSym].sort(comparator),
			'works with symbols, both enum and non-enum'
		);

		st.end();
	});

	t.end();
});
'use strict';

var test = require('tape');

var names = require('../');

test('typed array names', function (t) {
	for (var i = 0; i < names.length; i++) {
		var name = names[i];

		t.equal(typeof name, 'string', 'is string');
		t.equal(names.indexOf(name), i, 'is unique (from start)');
		t.equal(names.lastIndexOf(name), i, 'is unique (from end)');

		t.match(typeof global[name], /^(?:function|undefined)$/, 'is a global function, or `undefined`');
	}

	t.end();
});
'use strict';

var getPrototypeOf = require('../implementation');
var test = require('tape');
var runTests = require('./tests');

test('as a function', function (t) {
	runTests(getPrototypeOf, t);

	t.end();
});
'use strict';

var getPrototypeOf = require('../');
var test = require('tape');
var runTests = require('./tests');

test('as a function', function (t) {
	runTests(getPrototypeOf, t);

	t.end();
});
'use strict';

require('../auto');

var test = require('tape');
var defineProperties = require('define-properties');

var isEnumerable = Object.prototype.propertyIsEnumerable;
var functionsHaveNames = require('functions-have-names')();

var runTests = require('./tests');

test('shimmed', function (t) {
	t.equal(Reflect.getPrototypeOf.length, 1, 'Reflect.getPrototypeOf has length of 1');
	t.test('Function name', { skip: !functionsHaveNames }, function (st) {
		st.equal(Reflect.getPrototypeOf.name, 'getPrototypeOf', 'Reflect.getPrototypeOf has name "getPrototypeOf"');
		st.end();
	});

	t.test('enumerability', { skip: !defineProperties.supportsDescriptors }, function (et) {
		et.equal(false, isEnumerable.call(Reflect, 'getPrototypeOf'), 'Reflect.getPrototypeOf is not enumerable');
		et.end();
	});

	runTests(Reflect.getPrototypeOf, t);

	t.end();
});
'use strict';

module.exports = function (getPrototypeOf, t) {
	t.test('nullish value', function (st) {
		st['throws'](function () { return getPrototypeOf(undefined); }, TypeError, 'undefined is not an object');
		st['throws'](function () { return getPrototypeOf(null); }, TypeError, 'null is not an object');
		st.end();
	});

	t['throws'](function () { getPrototypeOf(true); }, 'throws for true');
	t['throws'](function () { getPrototypeOf(false); }, 'throws for false');
	t['throws'](function () { getPrototypeOf(42); }, 'throws for 42');
	t['throws'](function () { getPrototypeOf(NaN); }, 'throws for NaN');
	t['throws'](function () { getPrototypeOf(0); }, 'throws for +0');
	t['throws'](function () { getPrototypeOf(-0); }, 'throws for -0');
	t['throws'](function () { getPrototypeOf(Infinity); }, 'throws for ∞');
	t['throws'](function () { getPrototypeOf(-Infinity); }, 'throws for -∞');
	t['throws'](function () { getPrototypeOf(''); }, 'throws for empty string');
	t['throws'](function () { getPrototypeOf('foo'); }, 'throws for non-empty string');
	t.equal(getPrototypeOf(/a/g), RegExp.prototype);
	t.equal(getPrototypeOf(new Date()), Date.prototype);
	t.equal(getPrototypeOf(function () {}), Function.prototype);
	t.equal(getPrototypeOf([]), Array.prototype);
	t.equal(getPrototypeOf({}), Object.prototype);

	var obj = { __proto__: null };
	if ('toString' in obj) {
		t.comment('no null objects in this engine');
		t.equal(getPrototypeOf(obj), Object.prototype, '"null" object has Object.prototype as [[Prototype]]');
	} else {
		t.equal(getPrototypeOf(obj), null, 'null object has null [[Prototype]]');
	}
};
'use strict';

var NumberToString = require('es-abstract/2024/Number/toString');
var StringIndexOf = require('es-abstract/2024/StringIndexOf');
var StringPad = require('es-abstract/2024/StringPad');
// var StringToCodePoints = require('es-abstract/2024/StringToCodePoints');
var UnicodeEscape = require('es-abstract/2024/UnicodeEscape');
var UTF16EncodeCodePoint = require('es-abstract/2024/UTF16EncodeCodePoint');

var isLeadingSurrogate = require('es-abstract/helpers/isLeadingSurrogate');
var isTrailingSurrogate = require('es-abstract/helpers/isTrailingSurrogate');

var $TypeError = require('es-errors/type');

var isCodePoint = require('es-abstract/helpers/isCodePoint');
var forEach = require('for-each');
var regexTester = require('safe-regex-test');

var isWhiteSpace = regexTester(/^\s$/);
var isLineTerminator = regexTester(/^[\n\r\u2028\u2029]$/);

// var punctuators = "(){}[]|,.?*+-^$=<>/#&!%:;@~'`\"\\"; // step 1
var syntaxCharacter = '^$\\.*+?()[]{}|';

var otherPunctuators = ",-=<>#&!%:;@~'`\""; // step 3
// var toEscape = StringToCodePoints(otherPunctuators); // step 4

var table64 = {
	'\u0009': 't',
	'\u000a': 'n',
	'\u000b': 'v',
	'\u000c': 'f',
	'\u000d': 'r',
	__proto__: null
};

module.exports = function EncodeForRegExpEscape(c) {
	if (!isCodePoint(c)) {
		throw new $TypeError('Assertion failed: `c` must be a valid Unicode code point');
	}

	var encoded = UTF16EncodeCodePoint(c);

	if (StringIndexOf(syntaxCharacter, encoded, 0) > -1 || encoded === '\u002F') { // step 1
		return '\\' + encoded; // step 1.a
	} else if (encoded in table64) { // step 2
		return '\\' + table64[encoded]; // step 2.a
	}

	if (
		StringIndexOf(otherPunctuators, encoded, 0) > -1
		|| isWhiteSpace(encoded)
		|| isLineTerminator(encoded)
		|| isLeadingSurrogate(c)
		|| isTrailingSurrogate(c)
	) { // step 5
		if (c < 0xFF) { // step 5.a
			var hex = NumberToString(c, 16); // step 5.a.i
			return '\\x' + StringPad(hex, 2, '0', 'START'); // step 5.a.ii
		}

		var escaped = ''; // step 5.b

		var codeUnits = encoded; // step 5.c

		forEach(codeUnits, function (cu) { // step 5.d
			escaped += UnicodeEscape(cu); // step 5.d.i
		});

		return escaped; // step 5.e
	}

	return encoded; // step 6
};
'use strict';

var escapeShim = require('../');
var test = require('tape');

var runTests = require('./tests');

test('as a function', function (t) {
	runTests(escapeShim, t);

	t.end();
});
'use strict';

require('es5-shim');
require('es6-shim');
require('../auto');

var test = require('tape');
var defineProperties = require('define-properties');
var isEnumerable = Object.prototype.propertyIsEnumerable;
var functionsHaveNames = function f() {}.name === 'f';

var runTests = require('./tests');

test('shimmed', function (t) {
	t.equal(RegExp.escape.length, 1, 'RegExp.escape has a length of 1');
	t.test('Function name', { skip: !functionsHaveNames }, function (st) {
		st.equal(RegExp.escape.name, 'escape', 'RegExp.escape has name "escape"');
		st.end();
	});

	t.test('enumerability', { skip: !defineProperties.supportsDescriptors }, function (et) {
		et.equal(false, isEnumerable.call(RegExp, 'escape'), 'RegExp.escape is not enumerable');
		et.end();
	});

	runTests(RegExp.escape, t);

	t.end();
});
'use strict';

var forEach = require('for-each');
var inspect = require('object-inspect');

module.exports = function (escape, t) {
	t.test('strings', function (st) {
		var strings = [
			'The Quick Brown Fox',
			'hello there',
			'',
			'hi. how are you? 💩',
			'^$\\.*+?()[]{}|',
			'\uD834\uDF06.',
			'123 Fake St.'
		];

		forEach(strings, function (str) {
			var regex = new RegExp('^' + escape(str) + '$');
			st.match(str, regex, inspect(str) + ' escapes to ' + inspect(regex) + ', which matches itself');

			var nonStr = { toString: function () { return str; } };
			st['throws'](
				function () { escape(nonStr); },
				TypeError,
				'does not coerce to string'
			);
		});

		st.end();
	});

	t.test('test262: test/built-ins/RegExp/escape/escaped-control-characters', function (st) {
		var controlCharacters = '\t\n\v\f\r';
		var expectedEscapedCharacters = '\\t\\n\\v\\f\\r';

		st.equal(escape(controlCharacters), expectedEscapedCharacters, 'Control characters are correctly escaped');

		st.end();
	});

	t.test('test262: test/built-ins/RegExp/escape/escaped-lineterminator', function (st) {
		st.equal(escape('\u2028'), '\\u2028', 'line terminator \\u2028 is escaped correctly to \\\\u2028');
		st.equal(escape('\u2029'), '\\u2029', 'line terminator \\u2029 is escaped correctly to \\\\u2029');

		st.equal(escape('\u2028\u2029'), '\\u2028\\u2029', 'line terminators are escaped correctly');
		st.equal(escape('\u2028a\u2029a'), '\\u2028a\\u2029a', 'mixed line terminators are escaped correctly');

		st.end();
	});

	t.test('test/built-ins/RegExp/escape/escaped-otherpunctuators', function (st) {
		var otherPunctuators = ",-=<>#&!%:;@~'`\"";

		forEach(otherPunctuators, function (c) {
			var expected = '\\x' + c.codePointAt(0).toString(16);
			st.equal(escape(c), expected, c + ' is escaped correctly');
		});

		var otherPunctuatorsExpected = '\\x2c\\x2d\\x3d\\x3c\\x3e\\x23\\x26\\x21\\x25\\x3a\\x3b\\x40\\x7e\\x27\\x60\\x22';

		st.equal(
			escape(otherPunctuators),
			otherPunctuatorsExpected,
			'all other punctuators are escaped correctly'
		);

		st.end();
	});

	t.test('test262: test/built-ins/RegExp/escape/escaped-solidus-character-mixed', function (st) {
		st.equal(escape('.a/b'), '\\.a\\/b', 'mixed string with solidus character is escaped correctly');
		st.equal(escape('/./'), '\\/\\.\\/', 'solidus character is escaped correctly - regexp similar');
		st.equal(escape('./a\\/*b+c?d^e$f|g{2}h[i]j\\k'), '\\.\\/a\\\\\\/\\*b\\+c\\?d\\^e\\$f\\|g\\{2\\}h\\[i\\]j\\\\k', 'complex string with multiple special characters is escaped correctly');

		st.end();
	});

	t.test('test262: test/built-ins/RegExp/escape/escaped-solidus-character-simple', function (st) {
		st.equal(escape('/'), '\\/', 'solidus character is escaped correctly');
		st.equal(escape('//'), '\\/\\/', 'solidus character is escaped correctly - multiple occurrences 1');
		st.equal(escape('///'), '\\/\\/\\/', 'solidus character is escaped correctly - multiple occurrences 2');
		st.equal(escape('////'), '\\/\\/\\/\\/', 'solidus character is escaped correctly - multiple occurrences 3');

		st.end();
	});

	t.test('test262: test/built-ins/RegExp/escape/escaped-syntax-characters-simple', function (st) {
		st.equal(escape('.'), '\\.', 'dot character is escaped correctly');
		st.equal(escape('*'), '\\*', 'asterisk character is escaped correctly');
		st.equal(escape('+'), '\\+', 'plus character is escaped correctly');
		st.equal(escape('?'), '\\?', 'question mark character is escaped correctly');
		st.equal(escape('^'), '\\^', 'caret character is escaped correctly');
		st.equal(escape('$'), '\\$', 'dollar character is escaped correctly');
		st.equal(escape('|'), '\\|', 'pipe character is escaped correctly');
		st.equal(escape('('), '\\(', 'open parenthesis character is escaped correctly');
		st.equal(escape(')'), '\\)', 'close parenthesis character is escaped correctly');
		st.equal(escape('['), '\\[', 'open bracket character is escaped correctly');
		st.equal(escape(']'), '\\]', 'close bracket character is escaped correctly');
		st.equal(escape('{'), '\\{', 'open brace character is escaped correctly');
		st.equal(escape('}'), '\\}', 'close brace character is escaped correctly');
		st.equal(escape('\\'), '\\\\', 'backslash character is escaped correctly');

		st.end();
	});

	t.test('test262: test/built-ins/RegExp/escape/escaped-utf16encodecodepoint', function (st) {
		var codePoints = String.fromCharCode(0x100, 0x200, 0x300);

		st.equal(escape(codePoints), codePoints, 'characters are correctly not escaped');

		st.equal(escape('你好'), '你好', 'Chinese characters are correctly not escaped');
		st.equal(escape('こんにちは'), 'こんにちは', 'Japanese characters are correctly not escaped');
		st.equal(escape('안녕하세요'), '안녕하세요', 'Korean characters are correctly not escaped');
		st.equal(escape('Привет'), 'Привет', 'Cyrillic characters are correctly not escaped');
		st.equal(escape('مرحبا'), 'مرحبا', 'Arabic characters are correctly not escaped');
		st.equal(escape('हेलो'), 'हेलो', 'Devanagari characters are correctly not escaped');
		st.equal(escape('Γειά σου'), 'Γειά\\x20σου', 'Greek characters are correctly not escaped');
		st.equal(escape('שלום'), 'שלום', 'Hebrew characters are correctly not escaped');
		st.equal(escape('สวัสดี'), 'สวัสดี', 'Thai characters are correctly not escaped');
		st.equal(escape('नमस्ते'), 'नमस्ते', 'Hindi characters are correctly not escaped');
		st.equal(escape('ሰላም'), 'ሰላም', 'Amharic characters are correctly not escaped');
		st.equal(escape('हैलो'), 'हैलो', 'Hindi characters with diacritics are correctly not escaped');
		st.equal(escape('안녕!'), '안녕\\x21', 'Korean character with special character is correctly escaped');
		st.equal(escape('.hello\uD7FFworld'), '\\.hello\uD7FFworld', 'Mixed ASCII and Unicode characters are correctly escaped');

		st.end();
	});

	t.test('test262: test/built-ins/RegExp/escape/escaped-whitespace', function (st) {
		var WhiteSpace = '\uFEFF\u0020\u00A0\u202F\u0009\u000B\u000C';

		st.equal(escape('\uFEFF'), '\\ufeff', 'whitespace \\uFEFF is escaped correctly to \\uFEFF');
		st.equal(escape('\u0020'), '\\x20', 'whitespace \\u0020 is escaped correctly to \\x20');
		st.equal(escape('\u00A0'), '\\xa0', 'whitespace \\u00A0 is escaped correctly to \\xA0');
		st.equal(escape('\u202F'), '\\u202f', 'whitespace \\u202F is escaped correctly to \\u202F');
		st.equal(escape('\u0009'), '\\t', 'whitespace \\u0009 is escaped correctly to \\t');
		st.equal(escape('\u000B'), '\\v', 'whitespace \\u000B is escaped correctly to \\v');
		st.equal(escape('\u000C'), '\\f', 'whitespace \\u000C is escaped correctly to \\f');

		st.equal(escape(WhiteSpace), '\\ufeff\\x20\\xa0\\u202f\\t\\v\\f', 'whitespaces are escaped correctly');

		st.end();
	});

	t.test('test262: test/built-ins/RegExp/escape/initial-char-escape', function (st) {
		// Escaping initial digits
		st.equal(escape('1111'), '\\x31111', 'Initial decimal digit 1 is escaped');
		st.equal(escape('2222'), '\\x32222', 'Initial decimal digit 2 is escaped');
		st.equal(escape('3333'), '\\x33333', 'Initial decimal digit 3 is escaped');
		st.equal(escape('4444'), '\\x34444', 'Initial decimal digit 4 is escaped');
		st.equal(escape('5555'), '\\x35555', 'Initial decimal digit 5 is escaped');
		st.equal(escape('6666'), '\\x36666', 'Initial decimal digit 6 is escaped');
		st.equal(escape('7777'), '\\x37777', 'Initial decimal digit 7 is escaped');
		st.equal(escape('8888'), '\\x38888', 'Initial decimal digit 8 is escaped');
		st.equal(escape('9999'), '\\x39999', 'Initial decimal digit 9 is escaped');
		st.equal(escape('0000'), '\\x30000', 'Initial decimal digit 0 is escaped');

		// Escaping initial ASCII letters
		st.equal(escape('aaa'), '\\x61aa', 'Initial ASCII letter a is escaped');
		st.equal(escape('bbb'), '\\x62bb', 'Initial ASCII letter b is escaped');
		st.equal(escape('ccc'), '\\x63cc', 'Initial ASCII letter c is escaped');
		st.equal(escape('ddd'), '\\x64dd', 'Initial ASCII letter d is escaped');
		st.equal(escape('eee'), '\\x65ee', 'Initial ASCII letter e is escaped');
		st.equal(escape('fff'), '\\x66ff', 'Initial ASCII letter f is escaped');
		st.equal(escape('ggg'), '\\x67gg', 'Initial ASCII letter g is escaped');
		st.equal(escape('hhh'), '\\x68hh', 'Initial ASCII letter h is escaped');
		st.equal(escape('iii'), '\\x69ii', 'Initial ASCII letter i is escaped');
		st.equal(escape('jjj'), '\\x6ajj', 'Initial ASCII letter j is escaped');
		st.equal(escape('kkk'), '\\x6bkk', 'Initial ASCII letter k is escaped');
		st.equal(escape('lll'), '\\x6cll', 'Initial ASCII letter l is escaped');
		st.equal(escape('mmm'), '\\x6dmm', 'Initial ASCII letter m is escaped');
		st.equal(escape('nnn'), '\\x6enn', 'Initial ASCII letter n is escaped');
		st.equal(escape('ooo'), '\\x6foo', 'Initial ASCII letter o is escaped');
		st.equal(escape('ppp'), '\\x70pp', 'Initial ASCII letter p is escaped');
		st.equal(escape('qqq'), '\\x71qq', 'Initial ASCII letter q is escaped');
		st.equal(escape('rrr'), '\\x72rr', 'Initial ASCII letter r is escaped');
		st.equal(escape('sss'), '\\x73ss', 'Initial ASCII letter s is escaped');
		st.equal(escape('ttt'), '\\x74tt', 'Initial ASCII letter t is escaped');
		st.equal(escape('uuu'), '\\x75uu', 'Initial ASCII letter u is escaped');
		st.equal(escape('vvv'), '\\x76vv', 'Initial ASCII letter v is escaped');
		st.equal(escape('www'), '\\x77ww', 'Initial ASCII letter w is escaped');
		st.equal(escape('xxx'), '\\x78xx', 'Initial ASCII letter x is escaped');
		st.equal(escape('yyy'), '\\x79yy', 'Initial ASCII letter y is escaped');
		st.equal(escape('zzz'), '\\x7azz', 'Initial ASCII letter z is escaped');
		st.equal(escape('AAA'), '\\x41AA', 'Initial ASCII letter A is escaped');
		st.equal(escape('BBB'), '\\x42BB', 'Initial ASCII letter B is escaped');
		st.equal(escape('CCC'), '\\x43CC', 'Initial ASCII letter C is escaped');
		st.equal(escape('DDD'), '\\x44DD', 'Initial ASCII letter D is escaped');
		st.equal(escape('EEE'), '\\x45EE', 'Initial ASCII letter E is escaped');
		st.equal(escape('FFF'), '\\x46FF', 'Initial ASCII letter F is escaped');
		st.equal(escape('GGG'), '\\x47GG', 'Initial ASCII letter G is escaped');
		st.equal(escape('HHH'), '\\x48HH', 'Initial ASCII letter H is escaped');
		st.equal(escape('III'), '\\x49II', 'Initial ASCII letter I is escaped');
		st.equal(escape('JJJ'), '\\x4aJJ', 'Initial ASCII letter J is escaped');
		st.equal(escape('KKK'), '\\x4bKK', 'Initial ASCII letter K is escaped');
		st.equal(escape('LLL'), '\\x4cLL', 'Initial ASCII letter L is escaped');
		st.equal(escape('MMM'), '\\x4dMM', 'Initial ASCII letter M is escaped');
		st.equal(escape('NNN'), '\\x4eNN', 'Initial ASCII letter N is escaped');
		st.equal(escape('OOO'), '\\x4fOO', 'Initial ASCII letter O is escaped');
		st.equal(escape('PPP'), '\\x50PP', 'Initial ASCII letter P is escaped');
		st.equal(escape('QQQ'), '\\x51QQ', 'Initial ASCII letter Q is escaped');
		st.equal(escape('RRR'), '\\x52RR', 'Initial ASCII letter R is escaped');
		st.equal(escape('SSS'), '\\x53SS', 'Initial ASCII letter S is escaped');
		st.equal(escape('TTT'), '\\x54TT', 'Initial ASCII letter T is escaped');
		st.equal(escape('UUU'), '\\x55UU', 'Initial ASCII letter U is escaped');
		st.equal(escape('VVV'), '\\x56VV', 'Initial ASCII letter V is escaped');
		st.equal(escape('WWW'), '\\x57WW', 'Initial ASCII letter W is escaped');
		st.equal(escape('XXX'), '\\x58XX', 'Initial ASCII letter X is escaped');
		st.equal(escape('YYY'), '\\x59YY', 'Initial ASCII letter Y is escaped');
		st.equal(escape('ZZZ'), '\\x5aZZ', 'Initial ASCII letter Z is escaped');

		// Mixed case with special characters
		st.equal(escape('1+1'), '\\x31\\+1', 'Initial decimal digit 1 with special character is escaped');
		st.equal(escape('2+2'), '\\x32\\+2', 'Initial decimal digit 2 with special character is escaped');
		st.equal(escape('3+3'), '\\x33\\+3', 'Initial decimal digit 3 with special character is escaped');
		st.equal(escape('4+4'), '\\x34\\+4', 'Initial decimal digit 4 with special character is escaped');
		st.equal(escape('5+5'), '\\x35\\+5', 'Initial decimal digit 5 with special character is escaped');
		st.equal(escape('6+6'), '\\x36\\+6', 'Initial decimal digit 6 with special character is escaped');
		st.equal(escape('7+7'), '\\x37\\+7', 'Initial decimal digit 7 with special character is escaped');
		st.equal(escape('8+8'), '\\x38\\+8', 'Initial decimal digit 8 with special character is escaped');
		st.equal(escape('9+9'), '\\x39\\+9', 'Initial decimal digit 9 with special character is escaped');
		st.equal(escape('0+0'), '\\x30\\+0', 'Initial decimal digit 0 with special character is escaped');

		st.equal(escape('a*a'), '\\x61\\*a', 'Initial ASCII letter a with special character is escaped');
		st.equal(escape('b*b'), '\\x62\\*b', 'Initial ASCII letter b with special character is escaped');
		st.equal(escape('c*c'), '\\x63\\*c', 'Initial ASCII letter c with special character is escaped');
		st.equal(escape('d*d'), '\\x64\\*d', 'Initial ASCII letter d with special character is escaped');
		st.equal(escape('e*e'), '\\x65\\*e', 'Initial ASCII letter e with special character is escaped');
		st.equal(escape('f*f'), '\\x66\\*f', 'Initial ASCII letter f with special character is escaped');
		st.equal(escape('g*g'), '\\x67\\*g', 'Initial ASCII letter g with special character is escaped');
		st.equal(escape('h*h'), '\\x68\\*h', 'Initial ASCII letter h with special character is escaped');
		st.equal(escape('i*i'), '\\x69\\*i', 'Initial ASCII letter i with special character is escaped');
		st.equal(escape('j*j'), '\\x6a\\*j', 'Initial ASCII letter j with special character is escaped');
		st.equal(escape('k*k'), '\\x6b\\*k', 'Initial ASCII letter k with special character is escaped');
		st.equal(escape('l*l'), '\\x6c\\*l', 'Initial ASCII letter l with special character is escaped');
		st.equal(escape('m*m'), '\\x6d\\*m', 'Initial ASCII letter m with special character is escaped');
		st.equal(escape('n*n'), '\\x6e\\*n', 'Initial ASCII letter n with special character is escaped');
		st.equal(escape('o*o'), '\\x6f\\*o', 'Initial ASCII letter o with special character is escaped');
		st.equal(escape('p*p'), '\\x70\\*p', 'Initial ASCII letter p with special character is escaped');
		st.equal(escape('q*q'), '\\x71\\*q', 'Initial ASCII letter q with special character is escaped');
		st.equal(escape('r*r'), '\\x72\\*r', 'Initial ASCII letter r with special character is escaped');
		st.equal(escape('s*s'), '\\x73\\*s', 'Initial ASCII letter s with special character is escaped');
		st.equal(escape('t*t'), '\\x74\\*t', 'Initial ASCII letter t with special character is escaped');
		st.equal(escape('u*u'), '\\x75\\*u', 'Initial ASCII letter u with special character is escaped');
		st.equal(escape('v*v'), '\\x76\\*v', 'Initial ASCII letter v with special character is escaped');
		st.equal(escape('w*w'), '\\x77\\*w', 'Initial ASCII letter w with special character is escaped');
		st.equal(escape('x*x'), '\\x78\\*x', 'Initial ASCII letter x with special character is escaped');
		st.equal(escape('y*y'), '\\x79\\*y', 'Initial ASCII letter y with special character is escaped');
		st.equal(escape('z*z'), '\\x7a\\*z', 'Initial ASCII letter z with special character is escaped');
		st.equal(escape('A*A'), '\\x41\\*A', 'Initial ASCII letter A with special character is escaped');
		st.equal(escape('B*B'), '\\x42\\*B', 'Initial ASCII letter B with special character is escaped');
		st.equal(escape('C*C'), '\\x43\\*C', 'Initial ASCII letter C with special character is escaped');
		st.equal(escape('D*D'), '\\x44\\*D', 'Initial ASCII letter D with special character is escaped');
		st.equal(escape('E*E'), '\\x45\\*E', 'Initial ASCII letter E with special character is escaped');
		st.equal(escape('F*F'), '\\x46\\*F', 'Initial ASCII letter F with special character is escaped');
		st.equal(escape('G*G'), '\\x47\\*G', 'Initial ASCII letter G with special character is escaped');
		st.equal(escape('H*H'), '\\x48\\*H', 'Initial ASCII letter H with special character is escaped');
		st.equal(escape('I*I'), '\\x49\\*I', 'Initial ASCII letter I with special character is escaped');
		st.equal(escape('J*J'), '\\x4a\\*J', 'Initial ASCII letter J with special character is escaped');
		st.equal(escape('K*K'), '\\x4b\\*K', 'Initial ASCII letter K with special character is escaped');
		st.equal(escape('L*L'), '\\x4c\\*L', 'Initial ASCII letter L with special character is escaped');
		st.equal(escape('M*M'), '\\x4d\\*M', 'Initial ASCII letter M with special character is escaped');
		st.equal(escape('N*N'), '\\x4e\\*N', 'Initial ASCII letter N with special character is escaped');
		st.equal(escape('O*O'), '\\x4f\\*O', 'Initial ASCII letter O with special character is escaped');
		st.equal(escape('P*P'), '\\x50\\*P', 'Initial ASCII letter P with special character is escaped');
		st.equal(escape('Q*Q'), '\\x51\\*Q', 'Initial ASCII letter Q with special character is escaped');
		st.equal(escape('R*R'), '\\x52\\*R', 'Initial ASCII letter R with special character is escaped');
		st.equal(escape('S*S'), '\\x53\\*S', 'Initial ASCII letter S with special character is escaped');
		st.equal(escape('T*T'), '\\x54\\*T', 'Initial ASCII letter T with special character is escaped');
		st.equal(escape('U*U'), '\\x55\\*U', 'Initial ASCII letter U with special character is escaped');
		st.equal(escape('V*V'), '\\x56\\*V', 'Initial ASCII letter V with special character is escaped');
		st.equal(escape('W*W'), '\\x57\\*W', 'Initial ASCII letter W with special character is escaped');
		st.equal(escape('X*X'), '\\x58\\*X', 'Initial ASCII letter X with special character is escaped');
		st.equal(escape('Y*Y'), '\\x59\\*Y', 'Initial ASCII letter Y with special character is escaped');
		st.equal(escape('Z*Z'), '\\x5a\\*Z', 'Initial ASCII letter Z with special character is escaped');

		st.end();
	});

	t.test('test262: test/built-ins/RegExp/escape/not-escaped-underscore', function (st) {
		st.equal(escape('_'), '_', 'Single underscore character is not escaped');
		st.equal(escape('__'), '__', 'Thunderscore character is not escaped');
		st.equal(escape('hello_world'), '\\x68ello_world', 'String starting with ASCII letter and containing underscore is not escaped');
		st.equal(escape('1_hello_world'), '\\x31_hello_world', 'String starting with digit and containing underscore is correctly escaped');
		st.equal(escape('a_b_c'), '\\x61_b_c', 'String starting with ASCII letter and containing multiple underscores is correctly escaped');
		st.equal(escape('3_b_4'), '\\x33_b_4', 'String starting with digit and containing multiple underscores is correctly escaped');
		st.equal(escape('_hello'), '_hello', 'String starting with underscore and containing other characters is not escaped');
		st.equal(escape('_1hello'), '_1hello', 'String starting with underscore and digit is not escaped');
		st.equal(escape('_a_1_2'), '_a_1_2', 'String starting with underscore and mixed characters is not escaped');

		st.end();
	});

	t.test('test262: test/built-ins/RegExp/escape/escaped-surrogates', function (st) {

		// Specific surrogate points
		st.equal(escape('\uD800'), '\\ud800', 'High surrogate \\uD800 is correctly escaped');
		st.equal(escape('\uDBFF'), '\\udbff', 'High surrogate \\uDBFF is correctly escaped');
		st.equal(escape('\uDC00'), '\\udc00', 'Low surrogate \\uDC00 is correctly escaped');
		st.equal(escape('\uDFFF'), '\\udfff', 'Low surrogate \\uDFFF is correctly escaped');

		// Leading Surrogates
		var highSurrogatesGroup1 = '\uD800\uD801\uD802\uD803\uD804\uD805\uD806\uD807\uD808\uD809\uD80A\uD80B\uD80C\uD80D\uD80E\uD80F';
		var highSurrogatesGroup2 = '\uD810\uD811\uD812\uD813\uD814\uD815\uD816\uD817\uD818\uD819\uD81A\uD81B\uD81C\uD81D\uD81E\uD81F';
		var highSurrogatesGroup3 = '\uD820\uD821\uD822\uD823\uD824\uD825\uD826\uD827\uD828\uD829\uD82A\uD82B\uD82C\uD82D\uD82E\uD82F';
		var highSurrogatesGroup4 = '\uD830\uD831\uD832\uD833\uD834\uD835\uD836\uD837\uD838\uD839\uD83A\uD83B\uD83C\uD83D\uD83E\uD83F';
		var highSurrogatesGroup5 = '\uD840\uD841\uD842\uD843\uD844\uD845\uD846\uD847\uD848\uD849\uD84A\uD84B\uD84C\uD84D\uD84E\uD84F';
		var highSurrogatesGroup6 = '\uD850\uD851\uD852\uD853\uD854\uD855\uD856\uD857\uD858\uD859\uD85A\uD85B\uD85C\uD85D\uD85E\uD85F';
		var highSurrogatesGroup7 = '\uD860\uD861\uD862\uD863\uD864\uD865\uD866\uD867\uD868\uD869\uD86A\uD86B\uD86C\uD86D\uD86E\uD86F';
		var highSurrogatesGroup8 = '\uD870\uD871\uD872\uD873\uD874\uD875\uD876\uD877\uD878\uD879\uD87A\uD87B\uD87C\uD87D\uD87E\uD87F';
		var highSurrogatesGroup9 = '\uD880\uD881\uD882\uD883\uD884\uD885\uD886\uD887\uD888\uD889\uD88A\uD88B\uD88C\uD88D\uD88E\uD88F';
		var highSurrogatesGroup10 = '\uD890\uD891\uD892\uD893\uD894\uD895\uD896\uD897\uD898\uD899\uD89A\uD89B\uD89C\uD89D\uD89E\uD89F';
		var highSurrogatesGroup11 = '\uD8A0\uD8A1\uD8A2\uD8A3\uD8A4\uD8A5\uD8A6\uD8A7\uD8A8\uD8A9\uD8AA\uD8AB\uD8AC\uD8AD\uD8AE\uD8AF';
		var highSurrogatesGroup12 = '\uD8B0\uD8B1\uD8B2\uD8B3\uD8B4\uD8B5\uD8B6\uD8B7\uD8B8\uD8B9\uD8BA\uD8BB\uD8BC\uD8BD\uD8BE\uD8BF';
		var highSurrogatesGroup13 = '\uD8C0\uD8C1\uD8C2\uD8C3\uD8C4\uD8C5\uD8C6\uD8C7\uD8C8\uD8C9\uD8CA\uD8CB\uD8CC\uD8CD\uD8CE\uD8CF';
		var highSurrogatesGroup14 = '\uD8D0\uD8D1\uD8D2\uD8D3\uD8D4\uD8D5\uD8D6\uD8D7\uD8D8\uD8D9\uD8DA\uD8DB\uD8DC\uD8DD\uD8DE\uD8DF';
		var highSurrogatesGroup15 = '\uD8E0\uD8E1\uD8E2\uD8E3\uD8E4\uD8E5\uD8E6\uD8E7\uD8E8\uD8E9\uD8EA\uD8EB\uD8EC\uD8ED\uD8EE\uD8EF';
		var highSurrogatesGroup16 = '\uD8F0\uD8F1\uD8F2\uD8F3\uD8F4\uD8F5\uD8F6\uD8F7\uD8F8\uD8F9\uD8FA\uD8FB\uD8FC\uD8FD\uD8FE\uD8FF';

		st.equal(escape(highSurrogatesGroup1), '\\ud800\\ud801\\ud802\\ud803\\ud804\\ud805\\ud806\\ud807\\ud808\\ud809\\ud80a\\ud80b\\ud80c\\ud80d\\ud80e\\ud80f', 'High surrogates group 1 are correctly escaped');
		st.equal(escape(highSurrogatesGroup2), '\\ud810\\ud811\\ud812\\ud813\\ud814\\ud815\\ud816\\ud817\\ud818\\ud819\\ud81a\\ud81b\\ud81c\\ud81d\\ud81e\\ud81f', 'High surrogates group 2 are correctly escaped');
		st.equal(escape(highSurrogatesGroup3), '\\ud820\\ud821\\ud822\\ud823\\ud824\\ud825\\ud826\\ud827\\ud828\\ud829\\ud82a\\ud82b\\ud82c\\ud82d\\ud82e\\ud82f', 'High surrogates group 3 are correctly escaped');
		st.equal(escape(highSurrogatesGroup4), '\\ud830\\ud831\\ud832\\ud833\\ud834\\ud835\\ud836\\ud837\\ud838\\ud839\\ud83a\\ud83b\\ud83c\\ud83d\\ud83e\\ud83f', 'High surrogates group 4 are correctly escaped');
		st.equal(escape(highSurrogatesGroup5), '\\ud840\\ud841\\ud842\\ud843\\ud844\\ud845\\ud846\\ud847\\ud848\\ud849\\ud84a\\ud84b\\ud84c\\ud84d\\ud84e\\ud84f', 'High surrogates group 5 are correctly escaped');
		st.equal(escape(highSurrogatesGroup6), '\\ud850\\ud851\\ud852\\ud853\\ud854\\ud855\\ud856\\ud857\\ud858\\ud859\\ud85a\\ud85b\\ud85c\\ud85d\\ud85e\\ud85f', 'High surrogates group 6 are correctly escaped');
		st.equal(escape(highSurrogatesGroup7), '\\ud860\\ud861\\ud862\\ud863\\ud864\\ud865\\ud866\\ud867\\ud868\\ud869\\ud86a\\ud86b\\ud86c\\ud86d\\ud86e\\ud86f', 'High surrogates group 7 are correctly escaped');
		st.equal(escape(highSurrogatesGroup8), '\\ud870\\ud871\\ud872\\ud873\\ud874\\ud875\\ud876\\ud877\\ud878\\ud879\\ud87a\\ud87b\\ud87c\\ud87d\\ud87e\\ud87f', 'High surrogates group 8 are correctly escaped');
		st.equal(escape(highSurrogatesGroup9), '\\ud880\\ud881\\ud882\\ud883\\ud884\\ud885\\ud886\\ud887\\ud888\\ud889\\ud88a\\ud88b\\ud88c\\ud88d\\ud88e\\ud88f', 'High surrogates group 9 are correctly escaped');
		st.equal(escape(highSurrogatesGroup10), '\\ud890\\ud891\\ud892\\ud893\\ud894\\ud895\\ud896\\ud897\\ud898\\ud899\\ud89a\\ud89b\\ud89c\\ud89d\\ud89e\\ud89f', 'High surrogates group 10 are correctly escaped');
		st.equal(escape(highSurrogatesGroup11), '\\ud8a0\\ud8a1\\ud8a2\\ud8a3\\ud8a4\\ud8a5\\ud8a6\\ud8a7\\ud8a8\\ud8a9\\ud8aa\\ud8ab\\ud8ac\\ud8ad\\ud8ae\\ud8af', 'High surrogates group 11 are correctly escaped');
		st.equal(escape(highSurrogatesGroup12), '\\ud8b0\\ud8b1\\ud8b2\\ud8b3\\ud8b4\\ud8b5\\ud8b6\\ud8b7\\ud8b8\\ud8b9\\ud8ba\\ud8bb\\ud8bc\\ud8bd\\ud8be\\ud8bf', 'High surrogates group 12 are correctly escaped');
		st.equal(escape(highSurrogatesGroup13), '\\ud8c0\\ud8c1\\ud8c2\\ud8c3\\ud8c4\\ud8c5\\ud8c6\\ud8c7\\ud8c8\\ud8c9\\ud8ca\\ud8cb\\ud8cc\\ud8cd\\ud8ce\\ud8cf', 'High surrogates group 13 are correctly escaped');
		st.equal(escape(highSurrogatesGroup14), '\\ud8d0\\ud8d1\\ud8d2\\ud8d3\\ud8d4\\ud8d5\\ud8d6\\ud8d7\\ud8d8\\ud8d9\\ud8da\\ud8db\\ud8dc\\ud8dd\\ud8de\\ud8df', 'High surrogates group 14 are correctly escaped');
		st.equal(escape(highSurrogatesGroup15), '\\ud8e0\\ud8e1\\ud8e2\\ud8e3\\ud8e4\\ud8e5\\ud8e6\\ud8e7\\ud8e8\\ud8e9\\ud8ea\\ud8eb\\ud8ec\\ud8ed\\ud8ee\\ud8ef', 'High surrogates group 15 are correctly escaped');
		st.equal(escape(highSurrogatesGroup16), '\\ud8f0\\ud8f1\\ud8f2\\ud8f3\\ud8f4\\ud8f5\\ud8f6\\ud8f7\\ud8f8\\ud8f9\\ud8fa\\ud8fb\\ud8fc\\ud8fd\\ud8fe\\ud8ff', 'High surrogates group 16 are correctly escaped');

		// Trailing Surrogates
		var lowSurrogatesGroup1 = '\uDC00\uDC01\uDC02\uDC03\uDC04\uDC05\uDC06\uDC07\uDC08\uDC09\uDC0A\uDC0B\uDC0C\uDC0D\uDC0E\uDC0F';
		var lowSurrogatesGroup2 = '\uDC10\uDC11\uDC12\uDC13\uDC14\uDC15\uDC16\uDC17\uDC18\uDC19\uDC1A\uDC1B\uDC1C\uDC1D\uDC1E\uDC1F';
		var lowSurrogatesGroup3 = '\uDC20\uDC21\uDC22\uDC23\uDC24\uDC25\uDC26\uDC27\uDC28\uDC29\uDC2A\uDC2B\uDC2C\uDC2D\uDC2E\uDC2F';
		var lowSurrogatesGroup4 = '\uDC30\uDC31\uDC32\uDC33\uDC34\uDC35\uDC36\uDC37\uDC38\uDC39\uDC3A\uDC3B\uDC3C\uDC3D\uDC3E\uDC3F';
		var lowSurrogatesGroup5 = '\uDC40\uDC41\uDC42\uDC43\uDC44\uDC45\uDC46\uDC47\uDC48\uDC49\uDC4A\uDC4B\uDC4C\uDC4D\uDC4E\uDC4F';
		var lowSurrogatesGroup6 = '\uDC50\uDC51\uDC52\uDC53\uDC54\uDC55\uDC56\uDC57\uDC58\uDC59\uDC5A\uDC5B\uDC5C\uDC5D\uDC5E\uDC5F';
		var lowSurrogatesGroup7 = '\uDC60\uDC61\uDC62\uDC63\uDC64\uDC65\uDC66\uDC67\uDC68\uDC69\uDC6A\uDC6B\uDC6C\uDC6D\uDC6E\uDC6F';
		var lowSurrogatesGroup8 = '\uDC70\uDC71\uDC72\uDC73\uDC74\uDC75\uDC76\uDC77\uDC78\uDC79\uDC7A\uDC7B\uDC7C\uDC7D\uDC7E\uDC7F';
		var lowSurrogatesGroup9 = '\uDC80\uDC81\uDC82\uDC83\uDC84\uDC85\uDC86\uDC87\uDC88\uDC89\uDC8A\uDC8B\uDC8C\uDC8D\uDC8E\uDC8F';
		var lowSurrogatesGroup10 = '\uDC90\uDC91\uDC92\uDC93\uDC94\uDC95\uDC96\uDC97\uDC98\uDC99\uDC9A\uDC9B\uDC9C\uDC9D\uDC9E\uDC9F';
		var lowSurrogatesGroup11 = '\uDCA0\uDCA1\uDCA2\uDCA3\uDCA4\uDCA5\uDCA6\uDCA7\uDCA8\uDCA9\uDCAA\uDCAB\uDCAC\uDCAD\uDCAE\uDCAF';
		var lowSurrogatesGroup12 = '\uDCB0\uDCB1\uDCB2\uDCB3\uDCB4\uDCB5\uDCB6\uDCB7\uDCB8\uDCB9\uDCBA\uDCBB\uDCBC\uDCBD\uDCBE\uDCBF';
		var lowSurrogatesGroup13 = '\uDCC0\uDCC1\uDCC2\uDCC3\uDCC4\uDCC5\uDCC6\uDCC7\uDCC8\uDCC9\uDCCA\uDCCB\uDCCC\uDCCD\uDCCE\uDCCF';
		var lowSurrogatesGroup14 = '\uDCD0\uDCD1\uDCD2\uDCD3\uDCD4\uDCD5\uDCD6\uDCD7\uDCD8\uDCD9\uDCDA\uDCDB\uDCDC\uDCDD\uDCDE\uDCDF';
		var lowSurrogatesGroup15 = '\uDCE0\uDCE1\uDCE2\uDCE3\uDCE4\uDCE5\uDCE6\uDCE7\uDCE8\uDCE9\uDCEA\uDCEB\uDCEC\uDCED\uDCEE\uDCEF';
		var lowSurrogatesGroup16 = '\uDCF0\uDCF1\uDCF2\uDCF3\uDCF4\uDCF5\uDCF6\uDCF7\uDCF8\uDCF9\uDCFA\uDCFB\uDCFC\uDCFD\uDCFE\uDCFF';

		st.equal(escape(lowSurrogatesGroup1), '\\udc00\\udc01\\udc02\\udc03\\udc04\\udc05\\udc06\\udc07\\udc08\\udc09\\udc0a\\udc0b\\udc0c\\udc0d\\udc0e\\udc0f', 'Low surrogates group 1 are correctly escaped');
		st.equal(escape(lowSurrogatesGroup2), '\\udc10\\udc11\\udc12\\udc13\\udc14\\udc15\\udc16\\udc17\\udc18\\udc19\\udc1a\\udc1b\\udc1c\\udc1d\\udc1e\\udc1f', 'Low surrogates group 2 are correctly escaped');
		st.equal(escape(lowSurrogatesGroup3), '\\udc20\\udc21\\udc22\\udc23\\udc24\\udc25\\udc26\\udc27\\udc28\\udc29\\udc2a\\udc2b\\udc2c\\udc2d\\udc2e\\udc2f', 'Low surrogates group 3 are correctly escaped');
		st.equal(escape(lowSurrogatesGroup4), '\\udc30\\udc31\\udc32\\udc33\\udc34\\udc35\\udc36\\udc37\\udc38\\udc39\\udc3a\\udc3b\\udc3c\\udc3d\\udc3e\\udc3f', 'Low surrogates group 4 are correctly escaped');
		st.equal(escape(lowSurrogatesGroup5), '\\udc40\\udc41\\udc42\\udc43\\udc44\\udc45\\udc46\\udc47\\udc48\\udc49\\udc4a\\udc4b\\udc4c\\udc4d\\udc4e\\udc4f', 'Low surrogates group 5 are correctly escaped');
		st.equal(escape(lowSurrogatesGroup6), '\\udc50\\udc51\\udc52\\udc53\\udc54\\udc55\\udc56\\udc57\\udc58\\udc59\\udc5a\\udc5b\\udc5c\\udc5d\\udc5e\\udc5f', 'Low surrogates group 6 are correctly escaped');
		st.equal(escape(lowSurrogatesGroup7), '\\udc60\\udc61\\udc62\\udc63\\udc64\\udc65\\udc66\\udc67\\udc68\\udc69\\udc6a\\udc6b\\udc6c\\udc6d\\udc6e\\udc6f', 'Low surrogates group 7 are correctly escaped');
		st.equal(escape(lowSurrogatesGroup8), '\\udc70\\udc71\\udc72\\udc73\\udc74\\udc75\\udc76\\udc77\\udc78\\udc79\\udc7a\\udc7b\\udc7c\\udc7d\\udc7e\\udc7f', 'Low surrogates group 8 are correctly escaped');
		st.equal(escape(lowSurrogatesGroup9), '\\udc80\\udc81\\udc82\\udc83\\udc84\\udc85\\udc86\\udc87\\udc88\\udc89\\udc8a\\udc8b\\udc8c\\udc8d\\udc8e\\udc8f', 'Low surrogates group 9 are correctly escaped');
		st.equal(escape(lowSurrogatesGroup10), '\\udc90\\udc91\\udc92\\udc93\\udc94\\udc95\\udc96\\udc97\\udc98\\udc99\\udc9a\\udc9b\\udc9c\\udc9d\\udc9e\\udc9f', 'Low surrogates group 10 are correctly escaped');
		st.equal(escape(lowSurrogatesGroup11), '\\udca0\\udca1\\udca2\\udca3\\udca4\\udca5\\udca6\\udca7\\udca8\\udca9\\udcaa\\udcab\\udcac\\udcad\\udcae\\udcaf', 'Low surrogates group 11 are correctly escaped');
		st.equal(escape(lowSurrogatesGroup12), '\\udcb0\\udcb1\\udcb2\\udcb3\\udcb4\\udcb5\\udcb6\\udcb7\\udcb8\\udcb9\\udcba\\udcbb\\udcbc\\udcbd\\udcbe\\udcbf', 'Low surrogates group 12 are correctly escaped');
		st.equal(escape(lowSurrogatesGroup13), '\\udcc0\\udcc1\\udcc2\\udcc3\\udcc4\\udcc5\\udcc6\\udcc7\\udcc8\\udcc9\\udcca\\udccb\\udccc\\udccd\\udcce\\udccf', 'Low surrogates group 13 are correctly escaped');
		st.equal(escape(lowSurrogatesGroup14), '\\udcd0\\udcd1\\udcd2\\udcd3\\udcd4\\udcd5\\udcd6\\udcd7\\udcd8\\udcd9\\udcda\\udcdb\\udcdc\\udcdd\\udcde\\udcdf', 'Low surrogates group 14 are correctly escaped');
		st.equal(escape(lowSurrogatesGroup15), '\\udce0\\udce1\\udce2\\udce3\\udce4\\udce5\\udce6\\udce7\\udce8\\udce9\\udcea\\udceb\\udcec\\udced\\udcee\\udcef', 'Low surrogates group 15 are correctly escaped');
		st.equal(escape(lowSurrogatesGroup16), '\\udcf0\\udcf1\\udcf2\\udcf3\\udcf4\\udcf5\\udcf6\\udcf7\\udcf8\\udcf9\\udcfa\\udcfb\\udcfc\\udcfd\\udcfe\\udcff', 'Low surrogates group 16 are correctly escaped');

		st.end();
	});

	t.test('test262: test/built-ins/RegExp/escape/escaped-syntax-characters-mixed', function (st) {
		st.equal(escape('.a.b'), '\\.a\\.b', 'mixed string with dot character is escaped correctly');
		st.equal(escape('.1+2'), '\\.1\\+2', 'mixed string with plus character is escaped correctly');
		st.equal(escape('.a(b)c'), '\\.a\\(b\\)c', 'mixed string with parentheses is escaped correctly');
		st.equal(escape('.a*b+c'), '\\.a\\*b\\+c', 'mixed string with asterisk and plus characters is escaped correctly');
		st.equal(escape('.a?b^c'), '\\.a\\?b\\^c', 'mixed string with question mark and caret characters is escaped correctly');
		st.equal(escape('.a{2}'), '\\.a\\{2\\}', 'mixed string with curly braces is escaped correctly');
		st.equal(escape('.a|b'), '\\.a\\|b', 'mixed string with pipe character is escaped correctly');
		st.equal(escape('.a\\b'), '\\.a\\\\b', 'mixed string with backslash is escaped correctly');
		st.equal(escape('.a\\\\b'), '\\.a\\\\\\\\b', 'mixed string with backslash is escaped correctly');
		st.equal(escape('.a^b'), '\\.a\\^b', 'mixed string with caret character is escaped correctly');
		st.equal(escape('.a$b'), '\\.a\\$b', 'mixed string with dollar sign is escaped correctly');
		st.equal(escape('.a[b]'), '\\.a\\[b\\]', 'mixed string with square brackets is escaped correctly');
		st.equal(escape('.a.b(c)'), '\\.a\\.b\\(c\\)', 'mixed string with dot and parentheses is escaped correctly');
		st.equal(escape('.a*b+c?d^e$f|g{2}h[i]j\\k'), '\\.a\\*b\\+c\\?d\\^e\\$f\\|g\\{2\\}h\\[i\\]j\\\\k', 'complex string with multiple special characters is escaped correctly');

		st.equal(
			escape('^$\\.*+?()[]{}|'),
			'\\^\\$\\\\\\.\\*\\+\\?\\(\\)\\[\\]\\{\\}\\|',
			'Syntax characters are correctly escaped'
		);

		st.end();
	});

	t.test('test262: test/built-ins/RegExp/escape/non-string-inputs', function (st) {
		st['throws'](function () { RegExp.escape(123); }, TypeError, 'non-string input (number) throws TypeError');
		st['throws'](function () { RegExp.escape({}); }, TypeError, 'non-string input (object) throws TypeError');
		st['throws'](function () { RegExp.escape([]); }, TypeError, 'non-string input (array) throws TypeError');
		st['throws'](function () { RegExp.escape(null); }, TypeError, 'non-string input (null) throws TypeError');
		st['throws'](function () { RegExp.escape(undefined); }, TypeError, 'non-string input (undefined) throws TypeError');

		st.end();
	});
};
'use strict';

var test = require('tape');
var defineProperties = require('define-properties');
var callBind = require('call-bind');

var isEnumerable = Object.prototype.propertyIsEnumerable;
var functionsHaveNames = require('functions-have-names')();
var functionsHaveConfigurableNames = require('functions-have-names').functionsHaveConfigurableNames();
var hasStrictMode = require('has-strict-mode')();

var runTests = require('./tests');

test('builtin', function (t) {
	var descriptor = Object.getOwnPropertyDescriptor(RegExp.prototype, 'flags');

	t.equal(descriptor.get.length, 0, 'RegExp#flags getter has a length of 0');

	t.test('Function name', { skip: !functionsHaveNames }, function (st) {
		st.equal(descriptor.get.name, functionsHaveConfigurableNames ? 'get flags' : 'flags', 'RegExp#flags getter has name "get flags" (or "flags" if function names are not configurable)');
		st.end();
	});

	t.test('enumerability', { skip: !defineProperties.supportsDescriptors }, function (et) {
		et.equal(false, isEnumerable.call(RegExp.prototype, 'flags'), 'RegExp#flags is not enumerable');
		et.end();
	});

	t.test('bad array/this value', { skip: !hasStrictMode }, function (st) {
		st['throws'](function () { return descriptor.get.call(undefined); }, TypeError, 'undefined is not an object');
		st['throws'](function () { return descriptor.get.call(null); }, TypeError, 'null is not an object');
		st.end();
	});

	t.test('has the correct descriptor', function (st) {
		st.equal(descriptor.configurable, true);
		st.equal(descriptor.enumerable, false);
		st.equal(typeof descriptor.get, 'function');
		st.equal(descriptor.set, undefined);
		st.end();
	});

	runTests(callBind(descriptor.get), t);

	t.end();
});
'use strict';

var flags = require('../implementation');
var callBind = require('call-bind');
var test = require('tape');
var hasStrictMode = require('has-strict-mode')();
var runTests = require('./tests');

test('as a function', function (t) {
	t.test('bad array/this value', { skip: !hasStrictMode }, function (st) {
		/* eslint no-useless-call: 0 */
		st['throws'](function () { flags.call(undefined); }, TypeError, 'undefined is not an object');
		st['throws'](function () { flags.call(null); }, TypeError, 'null is not an object');
		st.end();
	});

	runTests(callBind(flags), t);

	t.end();
});
'use strict';

var flags = require('../');
var test = require('tape');
var runTests = require('./tests');

test('as a function', function (t) {
	t.test('bad array/this value', function (st) {
		st['throws'](function () { flags(undefined); }, TypeError, 'undefined is not an object');
		st['throws'](function () { flags(null); }, TypeError, 'null is not an object');
		st.end();
	});

	runTests(flags, t);

	t.end();
});
'use strict';

require('../auto');

var test = require('tape');
var defineProperties = require('define-properties');
var callBind = require('call-bind');

var isEnumerable = Object.prototype.propertyIsEnumerable;
var functionsHaveNames = require('functions-have-names')();
var functionsHaveConfigurableNames = require('functions-have-names').functionsHaveConfigurableNames();
var hasStrictMode = require('has-strict-mode')();

var runTests = require('./tests');

test('shimmed', function (t) {
	var descriptor = Object.getOwnPropertyDescriptor(RegExp.prototype, 'flags');

	t.equal(descriptor.get.length, 0, 'RegExp#flags getter has a length of 0');

	t.test('Function name', { skip: !functionsHaveNames }, function (st) {
		st.equal(descriptor.get.name, functionsHaveConfigurableNames ? 'get flags' : 'flags', 'RegExp#flags getter has name "get flags" (or "flags" if function names are not configurable)');
		st.end();
	});

	t.test('enumerability', { skip: !defineProperties.supportsDescriptors }, function (et) {
		et.equal(false, isEnumerable.call(RegExp.prototype, 'flags'), 'RegExp#flags is not enumerable');
		et.end();
	});

	t.test('bad array/this value', { skip: !hasStrictMode }, function (st) {
		st['throws'](function () { return descriptor.get.call(undefined); }, TypeError, 'undefined is not an object');
		st['throws'](function () { return descriptor.get.call(null); }, TypeError, 'null is not an object');
		st.end();
	});

	t.test('has the correct descriptor', function (st) {
		st.equal(descriptor.configurable, true);
		st.equal(descriptor.enumerable, false);
		st.equal(typeof descriptor.get, 'function');
		st.equal(descriptor.set, undefined);
		st.end();
	});

	runTests(callBind(descriptor.get), t);

	t.end();
});
'use strict';

var hasOwn = require('hasown');
var inspect = require('object-inspect');
var supportsDescriptors = require('define-properties').supportsDescriptors;
var v = require('es-value-fixtures');

var forEach = require('for-each');
var availableFlags = require('available-regexp-flags');
var regexProperties = require('available-regexp-flags/properties');

var sortedFlags = availableFlags.slice().sort(function (a, b) { return a.localeCompare(b); }).join('');

var getRegexLiteral = function (stringRegex) {
	try {
		// eslint-disable-next-line no-new-func
		return Function('return ' + stringRegex + ';')();
	} catch (e) { /**/ }
	return null;
};

module.exports = function runTests(flags, t) {
	forEach(v.primitives, function (nonObject) {
		t['throws'](
			function () { flags(nonObject); },
			TypeError,
			'throws when called with a non-object receiver: ' + inspect(nonObject)
		);
	});

	t.equal(flags(/a/g), 'g', 'flags(/a/g) !== "g"');
	t.equal(flags(/a/gmi), 'gim', 'flags(/a/gmi) !== "gim"');
	t.equal(flags(new RegExp('a', 'gmi')), 'gim', 'flags(new RegExp("a", "gmi")) !== "gim"');
	t.equal(flags(/a/), '', 'flags(/a/) !== ""');
	t.equal(flags(new RegExp('a')), '', 'flags(new RegExp("a")) !== ""');

	forEach(availableFlags, function (flag) {
		var property = regexProperties[flag];
		t.test(property + ' flag', function (st) {
			st.equal(flags(getRegexLiteral('/a/' + flag)), flag, 'flags(/a/' + flag + ') !== ' + inspect(flag));
			st.equal(flags(new RegExp('a', flag)), flag, 'flags(new RegExp("a", ' + inspect(flag) + ')) !== ' + inspect(flag));
			st.end();
		});
	});

	t.test('sorting', function (st) {
		st.equal(flags(/a/gim), 'gim', 'flags(/a/gim) !== "gim"');
		st.equal(flags(/a/mig), 'gim', 'flags(/a/mig) !== "gim"');
		st.equal(flags(/a/mgi), 'gim', 'flags(/a/mgi) !== "gim"');
		if (hasOwn(RegExp.prototype, 'sticky')) {
			st.equal(flags(getRegexLiteral('/a/gyim')), 'gimy', 'flags(/a/gyim) !== "gimy"');
		}
		if (hasOwn(RegExp.prototype, 'unicode')) {
			st.equal(flags(getRegexLiteral('/a/ugmi')), 'gimu', 'flags(/a/ugmi) !== "gimu"');
		}
		if (hasOwn(RegExp.prototype, 'dotAll')) {
			st.equal(flags(getRegexLiteral('/a/sgmi')), 'gims', 'flags(/a/sgmi) !== "gims"');
		}

		var randomFlags = availableFlags.slice().sort(function () { return Math.random() > 0.5 ? 1 : -1; }).join('').replace('v', '');
		st.equal(
			flags(getRegexLiteral('/a/' + randomFlags)),
			sortedFlags.replace('v', ''),
			'random: flags(/a/' + randomFlags + ') === ' + inspect(sortedFlags)
		);

		st.end();
	});

	t.test('basic examples', function (st) {
		st.equal(flags(/a/g), 'g', '(/a/g).flags !== "g"');
		st.equal(flags(/a/gmi), 'gim', '(/a/gmi).flags !== "gim"');
		st.equal(flags(new RegExp('a', 'gmi')), 'gim', 'new RegExp("a", "gmi").flags !== "gim"');
		st.equal(flags(/a/), '', '(/a/).flags !== ""');
		st.equal(flags(new RegExp('a')), '', 'new RegExp("a").flags !== ""');

		st.end();
	});

	t.test('generic flags', function (st) {
		st.equal(flags({}), '');
		st.equal(flags({ ignoreCase: true }), 'i');
		st.equal(flags({ dotAll: 1, global: 0, sticky: 1, unicode: 1 }), 'suy');
		st.equal(flags({ __proto__: { multiline: true } }), 'm');

		var obj = {};
		forEach(availableFlags, function (flag) {
			if (flag !== 'v') {
				obj[regexProperties[flag]] = true;
			}
		});
		st.equal(flags(obj), sortedFlags.replace('v', ''), 'an object with every available flag: ' + sortedFlags);

		st.end();
	});

	t.test('getters', { skip: !supportsDescriptors }, function (st) {
		/* eslint getter-return: 0 */
		var calls = '';
		var re = {};
		Object.defineProperty(re, 'hasIndices', {
			get: function () {
				calls += 'd';
			}
		});
		Object.defineProperty(re, 'global', {
			get: function () {
				calls += 'g';
			}
		});
		Object.defineProperty(re, 'ignoreCase', {
			get: function () {
				calls += 'i';
			}
		});
		Object.defineProperty(re, 'multiline', {
			get: function () {
				calls += 'm';
			}
		});
		Object.defineProperty(re, 'dotAll', {
			get: function () {
				calls += 's';
			}
		});
		Object.defineProperty(re, 'unicode', {
			get: function () {
				calls += 'u';
			}
		});
		Object.defineProperty(re, 'sticky', {
			get: function () {
				calls += 'y';
			}
		});

		flags(re);

		st.equal(calls, 'dgimsuy', 'getters are called in expected order');

		st.end();
	});
};
'use strict';

var test = require('tape');
var mockProperty = require('mock-property');
var hasSymbols = require('has-symbols/shams')();
var isConcatSpreadable = hasSymbols && Symbol.isConcatSpreadable;
var species = hasSymbols && Symbol.species;

var boundFnsHaveConfigurableLengths = require('set-function-length/env').boundFnsHaveConfigurableLengths;

var safeConcat = require('../');

test('safe-array-concat', function (t) {
	t.equal(typeof safeConcat, 'function', 'is a function');
	t.equal(
		safeConcat.length,
		boundFnsHaveConfigurableLengths ? 1 : 0,
		'has a length of ' + (boundFnsHaveConfigurableLengths ? 1 : '0 (function lengths are not configurable)')
	);

	t.deepEqual(
		// eslint-disable-next-line no-extra-parens
		safeConcat(/** @type {(string | number | number[])[]} */ ([1, 2]), [3, 4], 'foo', 5, 6, [[7]]),
		[1, 2, 3, 4, 'foo', 5, 6, [7]],
		'works with flat and nested arrays'
	);

	t.deepEqual(
		safeConcat(undefined, 1, 2),
		[undefined, 1, 2],
		'first item as undefined is not the concat receiver, which would throw via ToObject'
	);
	t.deepEqual(
		safeConcat(null, 1, 2),
		[null, 1, 2],
		'first item as null is not the concat receiver, which would throw via ToObject'
	);

	var arr = [1, 2];
	arr.constructor = function C() {
		return { args: arguments };
	};
	t.deepEqual(
		safeConcat(arr, 3, 4),
		[1, 2, 3, 4],
		'first item as an array with a nonArray .constructor; ignores constructor'
	);

	t.test('has Symbol.species', { skip: !species }, function (st) {
		var speciesArr = [1, 2];
		// @ts-expect-error ts(2740) TS's `constructor` type requires a function
		speciesArr.constructor = {};
		// @ts-expect-error ts(2538) TS can't type narrow from tape's `skip`
		speciesArr.constructor[species] = function Species() {
			return { args: arguments };
		};

		st.deepEqual(
			safeConcat(speciesArr, 3, 4),
			[1, 2, 3, 4],
			'first item as an array with a .constructor object with a Symbol.species; ignores constructor and species'
		);

		st.end();
	});

	t.test('has isConcatSpreadable', { skip: !isConcatSpreadable }, function (st) {
		// TS can't type narrow from tape's `skip`
		if (isConcatSpreadable) {
			st.teardown(mockProperty(
				// eslint-disable-next-line no-extra-parens
				/** @type {Record<PropertyKey, unknown>} */ (/** @type {unknown} */ (String.prototype)),
				isConcatSpreadable,
				{ value: true }
			));

			var nonSpreadable = [1, 2];
			// @ts-expect-error ts(7015) TS can't handle expandos on an array
			nonSpreadable[isConcatSpreadable] = false;

			st.deepEqual(
				safeConcat(nonSpreadable, 3, 4, 'foo', Object('bar')),
				[1, 2, 3, 4, 'foo', Object('bar')],
				'a non-concat-spreadable array is spreaded, and a concat-spreadable String is not spreaded'
			);

			st.teardown(mockProperty(Array.prototype, isConcatSpreadable, { value: false }));

			st.deepEqual(
				safeConcat([1, 2], 3, 4, 'foo', Object('bar')),
				[1, 2, 3, 4, 'foo', Object('bar')],
				'all arrays marked non-concat-spreadable are still spreaded, and a concat-spreadable String is not spreaded'
			);
		}

		st.end();
	});

	t.end();
});
'use strict';

var test = require('tape');

var safePushApply = require('../');

test('safe-push-apply', function (t) {
	t.equal(typeof safePushApply, 'function', 'is a function');
	t.equal(safePushApply.length, 2, 'has a length of 2');

	t['throws'](
		// @ts-expect-error
		function () { safePushApply({}, []); },
		TypeError,
		'throws if target is not an array'
	);

	var a = [1, 2];
	var b = [3, 4];
	safePushApply(a, b);
	t.deepEqual(a, [1, 2, 3, 4], 'b is pushed into a');
	t.deepEqual(b, [3, 4], 'b is not modified');

	var c = '567';
	// @ts-expect-error TS ArrayLike doesn't accept strings for some reason
	safePushApply(a, c);
	t.deepEqual(a, [1, 2, 3, 4, '5', '6', '7'], 'works with arraylike source');

	t.end();
});
'use strict';

var test = require('tape');
var v = require('es-value-fixtures');
var forEach = require('for-each');
var inspect = require('object-inspect');

var regexTester = require('../');

test('regex tester', function (t) {
	t.equal(typeof regexTester, 'function', 'is a function');

	t.test('non-regexes', function (st) {
		forEach([].concat(
			// @ts-expect-error TS sucks with concat
			v.primitives,
			v.objects
		), function (val) {
			st['throws'](
				function () { regexTester(val); },
				TypeError,
				inspect(val) + ' is not a regex'
			);
		});

		st.end();
	});

	t.test('regexes', function (st) {
		var tester = regexTester(/a/);

		st.equal(typeof tester, 'function', 'returns a function');
		st.equal(tester('a'), true, 'returns true for a match');
		st.equal(tester('b'), false, 'returns false for a non-match');
		st.equal(tester('a'), true, 'returns true for a match again');

		st.end();
	});

	t.end();
});
'use strict';

var test = require('tape');

var setProto = require('../');

var isPrototypeOf = Object.prototype.isPrototypeOf;

test('setProto', function (t) {
	t.equal(typeof setProto, 'function', 'is a function');

	t.test('can set', { skip: !setProto }, function (st) {
		var obj = { a: 1 };
		var proto = { b: 2 };

		st.ok(isPrototypeOf.call(Object.prototype, obj), 'Object.prototype is isPrototypeOf obj');
		st.notOk(isPrototypeOf.call(proto, obj), 'proto is not isPrototypeOf obj');
		st.ok('a' in obj, 'a is in obj');
		st.notOk('b' in obj, 'b is not in obj');

		// eslint-disable-next-line no-extra-parens
		st.equal(/** @type {NonNullable<typeof setProto>} */ (setProto)(obj, proto), obj, 'returns the object');

		st.ok(isPrototypeOf.call(Object.prototype, obj), 'Object.prototype is isPrototypeOf obj');
		st.ok(isPrototypeOf.call(proto, obj), 'proto is isPrototypeOf obj');
		st.ok('a' in obj, 'a is in obj');
		st.ok('b' in obj, 'b is in obj');

		st.equal(Object.getPrototypeOf(obj), proto, 'sets the prototype');
		st.end();
	});

	t.test('can not set', { skip: !!setProto }, function (st) {
		st.equal(setProto, null);

		st.end();
	});

	t.end();
});
'use strict';

var test = require('tape');

var getSideChannelList = require('../');

test('getSideChannelList', function (t) {
	t.test('export', function (st) {
		st.equal(typeof getSideChannelList, 'function', 'is a function');

		st.equal(getSideChannelList.length, 0, 'takes no arguments');

		var channel = getSideChannelList();
		st.ok(channel, 'is truthy');
		st.equal(typeof channel, 'object', 'is an object');
		st.end();
	});

	t.test('assert', function (st) {
		var channel = getSideChannelList();
		st['throws'](
			function () { channel.assert({}); },
			TypeError,
			'nonexistent value throws'
		);

		var o = {};
		channel.set(o, 'data');
		st.doesNotThrow(function () { channel.assert(o); }, 'existent value noops');

		st.end();
	});

	t.test('has', function (st) {
		var channel = getSideChannelList();
		/** @type {unknown[]} */ var o = [];

		st.equal(channel.has(o), false, 'nonexistent value yields false');

		channel.set(o, 'foo');
		st.equal(channel.has(o), true, 'existent value yields true');

		st.equal(channel.has('abc'), false, 'non object value non existent yields false');

		channel.set('abc', 'foo');
		st.equal(channel.has('abc'), true, 'non object value that exists yields true');

		st.end();
	});

	t.test('get', function (st) {
		var channel = getSideChannelList();
		var o = {};
		st.equal(channel.get(o), undefined, 'nonexistent value yields undefined');

		var data = {};
		channel.set(o, data);
		st.equal(channel.get(o), data, '"get" yields data set by "set"');

		st.end();
	});

	t.test('set', function (st) {
		var channel = getSideChannelList();
		var o = function () {};
		st.equal(channel.get(o), undefined, 'value not set');

		channel.set(o, 42);
		st.equal(channel.get(o), 42, 'value was set');

		channel.set(o, Infinity);
		st.equal(channel.get(o), Infinity, 'value was set again');

		var o2 = {};
		channel.set(o2, 17);
		st.equal(channel.get(o), Infinity, 'o is not modified');
		st.equal(channel.get(o2), 17, 'o2 is set');

		channel.set(o, 14);
		st.equal(channel.get(o), 14, 'o is modified');
		st.equal(channel.get(o2), 17, 'o2 is not modified');

		st.end();
	});

	t.test('delete', function (st) {
		var channel = getSideChannelList();
		var o = {};
		st.equal(channel['delete']({}), false, 'nonexistent value yields false');

		channel.set(o, 42);
		st.equal(channel.has(o), true, 'value is set');

		st.equal(channel['delete']({}), false, 'nonexistent value still yields false');

		st.equal(channel['delete'](o), true, 'deleted value yields true');

		st.equal(channel.has(o), false, 'value is no longer set');

		st.end();
	});

	t.end();
});
'use strict';

var test = require('tape');

var getSideChannelMap = require('../');

test('getSideChannelMap', { skip: typeof Map !== 'function' }, function (t) {
	var getSideChannel = getSideChannelMap || function () {
		throw new EvalError('should never happen');
	};

	t.test('export', function (st) {
		st.equal(typeof getSideChannel, 'function', 'is a function');

		st.equal(getSideChannel.length, 0, 'takes no arguments');

		var channel = getSideChannel();
		st.ok(channel, 'is truthy');
		st.equal(typeof channel, 'object', 'is an object');
		st.end();
	});

	t.test('assert', function (st) {
		var channel = getSideChannel();
		st['throws'](
			function () { channel.assert({}); },
			TypeError,
			'nonexistent value throws'
		);

		var o = {};
		channel.set(o, 'data');
		st.doesNotThrow(function () { channel.assert(o); }, 'existent value noops');

		st.end();
	});

	t.test('has', function (st) {
		var channel = getSideChannel();
		/** @type {unknown[]} */ var o = [];

		st.equal(channel.has(o), false, 'nonexistent value yields false');

		channel.set(o, 'foo');
		st.equal(channel.has(o), true, 'existent value yields true');

		st.equal(channel.has('abc'), false, 'non object value non existent yields false');

		channel.set('abc', 'foo');
		st.equal(channel.has('abc'), true, 'non object value that exists yields true');

		st.end();
	});

	t.test('get', function (st) {
		var channel = getSideChannel();
		var o = {};
		st.equal(channel.get(o), undefined, 'nonexistent value yields undefined');

		var data = {};
		channel.set(o, data);
		st.equal(channel.get(o), data, '"get" yields data set by "set"');

		st.end();
	});

	t.test('set', function (st) {
		var channel = getSideChannel();
		var o = function () {};
		st.equal(channel.get(o), undefined, 'value not set');

		channel.set(o, 42);
		st.equal(channel.get(o), 42, 'value was set');

		channel.set(o, Infinity);
		st.equal(channel.get(o), Infinity, 'value was set again');

		var o2 = {};
		channel.set(o2, 17);
		st.equal(channel.get(o), Infinity, 'o is not modified');
		st.equal(channel.get(o2), 17, 'o2 is set');

		channel.set(o, 14);
		st.equal(channel.get(o), 14, 'o is modified');
		st.equal(channel.get(o2), 17, 'o2 is not modified');

		st.end();
	});

	t.test('delete', function (st) {
		var channel = getSideChannel();
		var o = {};
		st.equal(channel['delete']({}), false, 'nonexistent value yields false');

		channel.set(o, 42);
		st.equal(channel.has(o), true, 'value is set');

		st.equal(channel['delete']({}), false, 'nonexistent value still yields false');

		st.equal(channel['delete'](o), true, 'deleted value yields true');

		st.equal(channel.has(o), false, 'value is no longer set');

		st.end();
	});

	t.end();
});

test('getSideChannelMap, no Maps', { skip: typeof Map === 'function' }, function (t) {
	t.equal(getSideChannelMap, false, 'is false');

	t.end();
});
'use strict';

var test = require('tape');

var getSideChannel = require('../');

test('getSideChannel', function (t) {
	t.test('export', function (st) {
		st.equal(typeof getSideChannel, 'function', 'is a function');

		st.equal(getSideChannel.length, 0, 'takes no arguments');

		var channel = getSideChannel();
		st.ok(channel, 'is truthy');
		st.equal(typeof channel, 'object', 'is an object');
		st.end();
	});

	t.test('assert', function (st) {
		var channel = getSideChannel();
		st['throws'](
			function () { channel.assert({}); },
			TypeError,
			'nonexistent value throws'
		);

		var o = {};
		channel.set(o, 'data');
		st.doesNotThrow(function () { channel.assert(o); }, 'existent value noops');

		st.end();
	});

	t.test('has', function (st) {
		var channel = getSideChannel();
		/** @type {unknown[]} */ var o = [];

		st.equal(channel.has(o), false, 'nonexistent value yields false');

		channel.set(o, 'foo');
		st.equal(channel.has(o), true, 'existent value yields true');

		st.equal(channel.has('abc'), false, 'non object value non existent yields false');

		channel.set('abc', 'foo');
		st.equal(channel.has('abc'), true, 'non object value that exists yields true');

		st.end();
	});

	t.test('get', function (st) {
		var channel = getSideChannel();
		var o = {};
		st.equal(channel.get(o), undefined, 'nonexistent value yields undefined');

		var data = {};
		channel.set(o, data);
		st.equal(channel.get(o), data, '"get" yields data set by "set"');

		st.end();
	});

	t.test('set', function (st) {
		var channel = getSideChannel();
		var o = function () {};
		st.equal(channel.get(o), undefined, 'value not set');

		channel.set(o, 42);
		st.equal(channel.get(o), 42, 'value was set');

		channel.set(o, Infinity);
		st.equal(channel.get(o), Infinity, 'value was set again');

		var o2 = {};
		channel.set(o2, 17);
		st.equal(channel.get(o), Infinity, 'o is not modified');
		st.equal(channel.get(o2), 17, 'o2 is set');

		channel.set(o, 14);
		st.equal(channel.get(o), 14, 'o is modified');
		st.equal(channel.get(o2), 17, 'o2 is not modified');

		st.end();
	});

	t.test('delete', function (st) {
		var channel = getSideChannel();
		var o = {};
		st.equal(channel['delete']({}), false, 'nonexistent value yields false');

		channel.set(o, 42);
		st.equal(channel.has(o), true, 'value is set');

		st.equal(channel['delete']({}), false, 'nonexistent value still yields false');

		st.equal(channel['delete'](o), true, 'deleted value yields true');

		st.equal(channel.has(o), false, 'value is no longer set');

		st.end();
	});

	t.end();
});
'use strict';

var test = require('tape');

var getSideChannelWeakMap = require('../');

test('getSideChannelMap', { skip: typeof WeakMap !== 'function' && typeof Map !== 'function' }, function (t) {
	var getSideChannel = getSideChannelWeakMap || function () {
		throw new EvalError('should never happen');
	};

	t.test('export', function (st) {
		st.equal(typeof getSideChannel, 'function', 'is a function');

		st.equal(getSideChannel.length, 0, 'takes no arguments');

		var channel = getSideChannel();
		st.ok(channel, 'is truthy');
		st.equal(typeof channel, 'object', 'is an object');
		st.end();
	});

	t.test('assert', function (st) {
		var channel = getSideChannel();
		st['throws'](
			function () { channel.assert({}); },
			TypeError,
			'nonexistent value throws'
		);

		var o = {};
		channel.set(o, 'data');
		st.doesNotThrow(function () { channel.assert(o); }, 'existent value noops');

		st.end();
	});

	t.test('has', function (st) {
		var channel = getSideChannel();
		/** @type {unknown[]} */ var o = [];

		st.equal(channel.has(o), false, 'nonexistent value yields false');

		channel.set(o, 'foo');
		st.equal(channel.has(o), true, 'existent value yields true');

		st.equal(channel.has('abc'), false, 'non object value non existent yields false');

		channel.set('abc', 'foo');
		st.equal(channel.has('abc'), true, 'non object value that exists yields true');

		st.end();
	});

	t.test('get', function (st) {
		var channel = getSideChannel();
		var o = {};
		st.equal(channel.get(o), undefined, 'nonexistent value yields undefined');

		var data = {};
		channel.set(o, data);
		st.equal(channel.get(o), data, '"get" yields data set by "set"');

		st.end();
	});

	t.test('set', function (st) {
		var channel = getSideChannel();
		var o = function () {};
		st.equal(channel.get(o), undefined, 'value not set');

		channel.set(o, 42);
		st.equal(channel.get(o), 42, 'value was set');

		channel.set(o, Infinity);
		st.equal(channel.get(o), Infinity, 'value was set again');

		var o2 = {};
		channel.set(o2, 17);
		st.equal(channel.get(o), Infinity, 'o is not modified');
		st.equal(channel.get(o2), 17, 'o2 is set');

		channel.set(o, 14);
		st.equal(channel.get(o), 14, 'o is modified');
		st.equal(channel.get(o2), 17, 'o2 is not modified');

		st.end();
	});

	t.test('delete', function (st) {
		var channel = getSideChannel();
		var o = {};
		st.equal(channel['delete']({}), false, 'nonexistent value yields false');

		channel.set(o, 42);
		st.equal(channel.has(o), true, 'value is set');

		st.equal(channel['delete']({}), false, 'nonexistent value still yields false');

		st.equal(channel['delete'](o), true, 'deleted value yields true');

		st.equal(channel.has(o), false, 'value is no longer set');

		st.end();
	});

	t.end();
});

test('getSideChannelMap, no WeakMaps and/or Maps', { skip: typeof WeakMap === 'function' || typeof Map === 'function' }, function (t) {
	t.equal(getSideChannelWeakMap, false, 'is false');

	t.end();
});
'use strict';

var test = require('tape');

var stopIterationIterator = require('../');

test('stopIterationIterator', function (t) {
	t.equal(typeof stopIterationIterator, 'function', 'stopIterationIterator is a function');

	t.test('no StopIteration support', { skip: typeof StopIteration === 'object' }, function (st) {
		st['throws'](
			// @ts-expect-error
			function () { stopIterationIterator(); },
			SyntaxError,
			'throws a SyntaxError when StopIteration is not supported'
		);

		st.end();
	});

	t.test('StopIteration support', { skip: typeof StopIteration !== 'object' }, function (st) {
		// eslint-disable-next-line no-extra-parens
		var s = /** @type {Set<number> & { iterator(): SetIterator<number>}} */ (new Set([1, 2]));

		var i = s.iterator();
		st.equal(i.next(), 1, 'first item is 1');
		st.equal(i.next(), 2, 'second item is 2');
		try {
			i.next();
			st.fail();
		} catch (e) {
			st.equal(e, StopIteration, 'StopIteration thrown');
		}

		// eslint-disable-next-line no-extra-parens
		var m = /** @type {Map<number, string> & { iterator(): MapIterator<[string, number]>}} */ (new Map([[1, 'a'], [2, 'b']]));
		var mi = m.iterator();
		st.deepEqual(mi.next(), [1, 'a'], 'first item is 1 and a');
		st.deepEqual(mi.next(), [2, 'b'], 'second item is 2 and b');
		try {
			mi.next();
			st.fail();
		} catch (e) {
			st.equal(e, StopIteration, 'StopIteration thrown');
		}

		st.end();
	});

	t.end();
});
'use strict';

var implementation = require('../implementation');
var callBind = require('call-bind');
var test = require('tape');
var hasStrictMode = require('has-strict-mode')();
var runTests = require('./tests');

test('as a function', function (t) {
	t.test('bad array/this value', { skip: !hasStrictMode }, function (st) {
		/* eslint no-useless-call: 0 */
		st['throws'](function () { implementation.call(undefined); }, TypeError, 'undefined is not an object');
		st['throws'](function () { implementation.call(null); }, TypeError, 'null is not an object');
		st.end();
	});

	runTests(callBind(implementation), t);

	t.end();
});
'use strict';

var trimEnd = require('../');
var test = require('tape');
var runTests = require('./tests');

test('as a function', function (t) {
	t.test('bad array/this value', function (st) {
		st['throws'](function () { trimEnd(undefined, 'a'); }, TypeError, 'undefined is not an object');
		st['throws'](function () { trimEnd(null, 'a'); }, TypeError, 'null is not an object');
		st.end();
	});

	runTests(trimEnd, t);

	t.end();
});
'use strict';

require('../auto');

var runTests = require('./tests');

var test = require('tape');
var defineProperties = require('define-properties');
var callBind = require('call-bind');
var isEnumerable = Object.prototype.propertyIsEnumerable;
var functionsHaveNames = require('functions-have-names')();

test('shimmed', function (t) {
	t.equal(String.prototype.trimEnd.length, 0, 'String#trimEnd has a length of 0');
	t.test('Function name', { skip: !functionsHaveNames }, function (st) {
		st.equal((/^(?:trimRight|trimEnd)$/).test(String.prototype.trimEnd.name), true, 'String#trimEnd has name "trimRight" or "trimEnd"');
		st.end();
	});

	t.test('enumerability', { skip: !defineProperties.supportsDescriptors }, function (et) {
		et.equal(false, isEnumerable.call(String.prototype, 'trimEnd'), 'String#trimEnd is not enumerable');
		et.end();
	});

	var supportsStrictMode = (function () { return typeof this === 'undefined'; }());

	t.test('bad string/this value', { skip: !supportsStrictMode }, function (st) {
		st['throws'](function () { return String.prototype.trimEnd.call(undefined, 'a'); }, TypeError, 'undefined is not an object');
		st['throws'](function () { return String.prototype.trimEnd.call(null, 'a'); }, TypeError, 'null is not an object');
		st.end();
	});

	runTests(callBind(String.prototype.trimEnd), t);

	t.end();
});
'use strict';

module.exports = function (trimEnd, t) {
	t.test('normal cases', function (st) {
		st.equal(trimEnd(' \t\na \t\n'), ' \t\na', 'strips whitespace off the left side');
		st.equal(trimEnd('a'), 'a', 'noop when no whitespace');

		var allWhitespaceChars = '\x09\x0A\x0B\x0C\x0D\x20\xA0\u1680\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200A\u202F\u205F\u3000\u2028\u2029\uFEFF';
		st.equal(trimEnd(allWhitespaceChars + 'a' + allWhitespaceChars), allWhitespaceChars + 'a', 'all expected whitespace chars are trimmed');

		st.end();
	});

	// see https://codeblog.jonskeet.uk/2014/12/01/when-is-an-identifier-not-an-identifier-attack-of-the-mongolian-vowel-separator/
	var mongolianVowelSeparator = '\u180E';
	var mvsIsWS = (/^\s$/).test(mongolianVowelSeparator);
	t.test('mongolian vowel separator: unicode >= 4 && < 6.3', function (st) {
		st.equal(
			trimEnd(mongolianVowelSeparator + 'a' + mongolianVowelSeparator),
			mongolianVowelSeparator + 'a' + (mvsIsWS ? '' : mongolianVowelSeparator),
			'mongolian vowel separator is ' + (mvsIsWS ? '' : 'not ') + 'whitespace'
		);
		st.end();
	});

	t.test('zero-width spaces', function (st) {
		var zeroWidth = '\u200b';
		st.equal(trimEnd(zeroWidth), zeroWidth, 'zero width space does not trim');
		st.end();
	});
};
'use strict';

var implementation = require('../implementation');
var callBind = require('call-bind');
var test = require('tape');
var hasStrictMode = require('has-strict-mode')();
var runTests = require('./tests');

test('as a function', function (t) {
	t.test('bad array/this value', { skip: !hasStrictMode }, function (st) {
		/* eslint no-useless-call: 0 */
		st['throws'](function () { implementation.call(undefined); }, TypeError, 'undefined is not an object');
		st['throws'](function () { implementation.call(null); }, TypeError, 'null is not an object');
		st.end();
	});

	runTests(callBind(implementation), t);

	t.end();
});
'use strict';

var trimStart = require('../');
var test = require('tape');

var runTests = require('./tests');

test('as a function', function (t) {
	t.test('bad array/this value', function (st) {
		st['throws'](function () { trimStart(undefined, 'a'); }, TypeError, 'undefined is not an object');
		st['throws'](function () { trimStart(null, 'a'); }, TypeError, 'null is not an object');
		st.end();
	});

	runTests(trimStart, t);

	t.end();
});
'use strict';

require('../auto');

var runTests = require('./tests');

var test = require('tape');
var defineProperties = require('define-properties');
var callBind = require('call-bind');
var isEnumerable = Object.prototype.propertyIsEnumerable;
var functionsHaveNames = require('functions-have-names')();

test('shimmed', function (t) {
	t.equal(String.prototype.trimStart.length, 0, 'String#trimStart has a length of 0');
	t.test('Function name', { skip: !functionsHaveNames }, function (st) {
		st.equal((/^(?:trimLeft|trimStart)$/).test(String.prototype.trimStart.name), true, 'String#trimStart has name "trimLeft" or "trimStart"');
		st.end();
	});

	t.test('enumerability', { skip: !defineProperties.supportsDescriptors }, function (et) {
		et.equal(false, isEnumerable.call(String.prototype, 'trimStart'), 'String#trimStart is not enumerable');
		et.end();
	});

	var supportsStrictMode = (function () { return typeof this === 'undefined'; }());

	t.test('bad string/this value', { skip: !supportsStrictMode }, function (st) {
		st['throws'](function () { return String.prototype.trimStart.call(undefined, 'a'); }, TypeError, 'undefined is not an object');
		st['throws'](function () { return String.prototype.trimStart.call(null, 'a'); }, TypeError, 'null is not an object');
		st.end();
	});

	runTests(callBind(String.prototype.trimStart), t);

	t.end();
});
'use strict';

module.exports = function (trimStart, t) {
	t.test('normal cases', function (st) {
		st.equal(trimStart(' \t\na \t\n'), 'a \t\n', 'strips whitespace off the left side');
		st.equal(trimStart('a'), 'a', 'noop when no whitespace');

		var allWhitespaceChars = '\x09\x0A\x0B\x0C\x0D\x20\xA0\u1680\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200A\u202F\u205F\u3000\u2028\u2029\uFEFF';
		st.equal(trimStart(allWhitespaceChars + 'a' + allWhitespaceChars), 'a' + allWhitespaceChars, 'all expected whitespace chars are trimmed');

		st.end();
	});

	// see https://codeblog.jonskeet.uk/2014/12/01/when-is-an-identifier-not-an-identifier-attack-of-the-mongolian-vowel-separator/
	var mongolianVowelSeparator = '\u180E';
	var mvsIsWS = (/^\s$/).test(mongolianVowelSeparator);
	t.test('mongolian vowel separator: unicode >= 4 && < 6.3', function (st) {
		st.equal(
			trimStart(mongolianVowelSeparator + 'a' + mongolianVowelSeparator),
			(mvsIsWS ? '' : mongolianVowelSeparator) + 'a' + mongolianVowelSeparator,
			'mongolian vowel separator is ' + (mvsIsWS ? '' : 'not ') + 'whitespace'
		);
		st.end();
	});

	t.test('zero-width spaces', function (st) {
		var zeroWidth = '\u200b';
		st.equal(trimStart(zeroWidth), zeroWidth, 'zero width space does not trim');
		st.end();
	});
};
'use strict';

var trim = require('../implementation');
var test = require('tape');
var hasStrictMode = require('has-strict-mode')();
var callBind = require('call-bind');

var runTests = require('./tests');

test('as a function', function (t) {
	t.test('bad array/this value', { skip: !hasStrictMode }, function (st) {
		/* eslint no-useless-call: 0 */
		st['throws'](function () { trim.call(undefined, 'a'); }, TypeError, 'undefined is not an object');
		st['throws'](function () { trim.call(null, 'a'); }, TypeError, 'null is not an object');
		st.end();
	});

	runTests(callBind(trim), t);

	t.end();
});
'use strict';

var trim = require('../');
var test = require('tape');
var runTests = require('./tests');

test('as a function', function (t) {
	t.test('bad array/this value', function (st) {
		st['throws'](function () { trim(undefined, 'a'); }, TypeError, 'undefined is not an object');
		st['throws'](function () { trim(null, 'a'); }, TypeError, 'null is not an object');
		st.end();
	});

	runTests(trim, t);

	t.end();
});
'use strict';

require('../auto');

var test = require('tape');
var defineProperties = require('define-properties');
var callBind = require('call-bind');
var isEnumerable = Object.prototype.propertyIsEnumerable;
var functionsHaveNames = require('functions-have-names')();

var runTests = require('./tests');

test('shimmed', function (t) {
	t.equal(String.prototype.trim.length, 0, 'String#trim has a length of 0');
	t.test('Function name', { skip: !functionsHaveNames }, function (st) {
		st.equal(String.prototype.trim.name, 'trim', 'String#trim has name "trim"');
		st.end();
	});

	t.test('enumerability', { skip: !defineProperties.supportsDescriptors }, function (et) {
		et.equal(false, isEnumerable.call(String.prototype, 'trim'), 'String#trim is not enumerable');
		et.end();
	});

	var supportsStrictMode = (function () { return typeof this === 'undefined'; }());

	t.test('bad string/this value', { skip: !supportsStrictMode }, function (st) {
		st['throws'](function () { return String.prototype.trim.call(undefined, 'a'); }, TypeError, 'undefined is not an object');
		st['throws'](function () { return String.prototype.trim.call(null, 'a'); }, TypeError, 'null is not an object');
		st.end();
	});

	runTests(callBind(String.prototype.trim), t);

	t.end();
});
'use strict';

var forEach = require('for-each');

module.exports = function (trim, t) {
	t.test('normal cases', function (st) {
		st.equal(trim(' \t\na \t\n'), 'a', 'strips whitespace off left and right sides');
		st.equal(trim('a'), 'a', 'noop when no whitespace');

		var allWhitespaceChars = '\x09\x0A\x0B\x0C\x0D\x20\xA0\u1680\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200A\u202F\u205F\u3000\u2028\u2029\uFEFF';
		st.equal(trim(allWhitespaceChars + 'a' + allWhitespaceChars), 'a', 'all expected whitespace chars are trimmed');

		st.end();
	});

	// see https://codeblog.jonskeet.uk/2014/12/01/when-is-an-identifier-not-an-identifier-attack-of-the-mongolian-vowel-separator/
	var mongolianVowelSeparator = '\u180E';
	var mvsIsWS = (/^\s$/).test('\u180E');
	t.test('unicode >= 4 && < 6.3', function (st) {
		st.equal(
			trim(mongolianVowelSeparator + 'a' + mongolianVowelSeparator),
			mvsIsWS ? 'a' : mongolianVowelSeparator + 'a' + mongolianVowelSeparator,
			'mongolian vowel separator is' + (mvsIsWS ? '' : ' not') + ' whitespace'
		);

		st.equal(
			trim(mongolianVowelSeparator),
			mvsIsWS ? '' : mongolianVowelSeparator
		);
		st.equal(
			trim('_' + mongolianVowelSeparator),
			'_' + (mvsIsWS ? '' : mongolianVowelSeparator)
		);
		st.equal(
			trim(mongolianVowelSeparator + '_'),
			(mvsIsWS ? '' : mongolianVowelSeparator) + '_'
		);

		st.end();
	});

	t.test('zero-width spaces', function (st) {
		var zeroWidth = '\u200b';
		st.equal(trim(zeroWidth), zeroWidth, 'zero width space does not trim');
		st.end();
	});

	t.test('non-whitespace characters', function (st) {
		// Zero-width space (zws), next line character (nel), and non-character (bom) are not whitespace.
		var nonWhitespaces = {
			'\\u0085': '\u0085',
			'\\u200b': '\u200b',
			'\\ufffe': '\ufffe'
		};

		forEach(nonWhitespaces, function (nonWhitespace, name) {
			st.equal(trim(nonWhitespace), nonWhitespace, name + ' does not trim');
		});

		st.end();
	});
};
'use strict';

var test = require('tape');
var availableTypedArrays = require('available-typed-arrays')();
var forEach = require('for-each');
var v = require('es-value-fixtures');
var inspect = require('object-inspect');

var typedArrayBuffer = require('../');

test('typedArrayBuffer', function (t) {
	// @ts-expect-error TS sucks at concat
	forEach([].concat(v.primitives, v.objects), function (nonTA) {
		t['throws'](function () { typedArrayBuffer(nonTA); }, TypeError, inspect(nonTA) + ' is not a Typed Array');
	});

	forEach(availableTypedArrays, function (TA) {
		var ta = new global[TA](0);
		t.equal(typedArrayBuffer(ta), ta.buffer, inspect(ta) + ' has the same buffer as its own buffer property');
	});

	t.end();
});
'use strict';

var test = require('tape');
var typedArrayByteLength = require('../');
var isCallable = require('is-callable');
var generators = require('make-generator-function')();
var arrowFn = require('make-arrow-function')();
var forEach = require('for-each');
var inspect = require('object-inspect');
var availableTypedArrays = require('available-typed-arrays')();

test('not arrays', function (t) {
	t.test('non-number/string primitives', function (st) {
		// @ts-expect-error
		st.equal(false, typedArrayByteLength(), 'undefined is not typed array');
		st.equal(false, typedArrayByteLength(null), 'null is not typed array');
		st.equal(false, typedArrayByteLength(false), 'false is not typed array');
		st.equal(false, typedArrayByteLength(true), 'true is not typed array');
		st.end();
	});

	t.equal(false, typedArrayByteLength({}), 'object is not typed array');
	t.equal(false, typedArrayByteLength(/a/g), 'regex literal is not typed array');
	t.equal(false, typedArrayByteLength(new RegExp('a', 'g')), 'regex object is not typed array');
	t.equal(false, typedArrayByteLength(new Date()), 'new Date() is not typed array');

	t.test('numbers', function (st) {
		st.equal(false, typedArrayByteLength(42), 'number is not typed array');
		st.equal(false, typedArrayByteLength(Object(42)), 'number object is not typed array');
		st.equal(false, typedArrayByteLength(NaN), 'NaN is not typed array');
		st.equal(false, typedArrayByteLength(Infinity), 'Infinity is not typed array');
		st.end();
	});

	t.test('strings', function (st) {
		st.equal(false, typedArrayByteLength('foo'), 'string primitive is not typed array');
		st.equal(false, typedArrayByteLength(Object('foo')), 'string object is not typed array');
		st.end();
	});

	t.end();
});

test('Functions', function (t) {
	t.equal(false, typedArrayByteLength(function () {}), 'function is not typed array');
	t.end();
});

test('Generators', { skip: generators.length === 0 }, function (t) {
	forEach(generators, function (genFn) {
		t.equal(false, typedArrayByteLength(genFn), 'generator function ' + inspect(genFn) + ' is not typed array');
	});
	t.end();
});

test('Arrow functions', { skip: !arrowFn }, function (t) {
	t.equal(false, typedArrayByteLength(arrowFn), 'arrow function is not typed array');
	t.end();
});

test('Typed Arrays', { skip: availableTypedArrays.length === 0 }, function (t) {
	var length = 64;
	var byteLength = 32;

	forEach(availableTypedArrays, function (typedArray) {
		var buffer = new ArrayBuffer(length);
		var TypedArray = global[typedArray];
		if (isCallable(TypedArray)) {
			// @ts-expect-error TS doesn't seem to know about the second TA arg
			var arr = new TypedArray(buffer, byteLength);
			t.equal(typedArrayByteLength(arr), byteLength, 'new ' + typedArray + '(new ArrayBuffer(' + length + '), ' + byteLength + ') is typed array of byte Length ' + byteLength);
		} else {
			t.comment('# SKIP ' + typedArray + ' is not supported');
		}
	});

	var buffer = new ArrayBuffer(8);
	var uint8 = new Uint8Array(buffer, 2);

	t.equal(typedArrayByteLength(uint8), 6, 'byteLength is as expected');

	t.end();
});
'use strict';

var test = require('tape');
var typedArrayByteOffset = require('../');
var isCallable = require('is-callable');
var generators = require('make-generator-function')();
var arrowFn = require('make-arrow-function')();
var forEach = require('for-each');
var inspect = require('object-inspect');

var typedArrayNames = require('possible-typed-array-names');

test('not arrays', function (t) {
	t.test('non-number/string primitives', function (st) {
		// @ts-expect-error
		st.equal(false, typedArrayByteOffset(), 'undefined is not typed array');
		st.equal(false, typedArrayByteOffset(null), 'null is not typed array');
		st.equal(false, typedArrayByteOffset(false), 'false is not typed array');
		st.equal(false, typedArrayByteOffset(true), 'true is not typed array');
		st.end();
	});

	t.equal(false, typedArrayByteOffset({}), 'object is not typed array');
	t.equal(false, typedArrayByteOffset(/a/g), 'regex literal is not typed array');
	t.equal(false, typedArrayByteOffset(new RegExp('a', 'g')), 'regex object is not typed array');
	t.equal(false, typedArrayByteOffset(new Date()), 'new Date() is not typed array');

	t.test('numbers', function (st) {
		st.equal(false, typedArrayByteOffset(42), 'number is not typed array');
		st.equal(false, typedArrayByteOffset(Object(42)), 'number object is not typed array');
		st.equal(false, typedArrayByteOffset(NaN), 'NaN is not typed array');
		st.equal(false, typedArrayByteOffset(Infinity), 'Infinity is not typed array');
		st.end();
	});

	t.test('strings', function (st) {
		st.equal(false, typedArrayByteOffset('foo'), 'string primitive is not typed array');
		st.equal(false, typedArrayByteOffset(Object('foo')), 'string object is not typed array');
		st.end();
	});

	t.end();
});

test('Functions', function (t) {
	t.equal(false, typedArrayByteOffset(function () {}), 'function is not typed array');
	t.end();
});

test('Generators', { skip: generators.length === 0 }, function (t) {
	forEach(generators, function (genFn) {
		t.equal(false, typedArrayByteOffset(genFn), 'generator function ' + inspect(genFn) + ' is not typed array');
	});
	t.end();
});

test('Arrow functions', { skip: !arrowFn }, function (t) {
	t.equal(false, typedArrayByteOffset(arrowFn), 'arrow function is not typed array');
	t.end();
});

test('Typed Arrays', function (t) {
	var length = 32;
	var byteOffset = 16;

	forEach(typedArrayNames, function (typedArray) {
		var buffer = new ArrayBuffer(length);
		var TypedArray = global[typedArray];
		if (isCallable(TypedArray)) {
			// @ts-expect-error hush, TS, TAs can take an optional byte offset arg
			var arr = new TypedArray(buffer, byteOffset);
			t.equal(typedArrayByteOffset(arr), byteOffset, 'new ' + typedArray + '(new ArrayBuffer(' + length + '), ' + byteOffset + ') is typed array of byte offset ' + byteOffset);
		} else {
			t.comment('# SKIP ' + typedArray + ' is not supported');
		}
	});
	t.end();
});
'use strict';

var test = require('tape');
var typedArrayLength = require('../');
var isCallable = require('is-callable');
var generators = require('make-generator-function')();
var arrowFn = require('make-arrow-function')();
var forEach = require('for-each');
var inspect = require('object-inspect');
var typedArrayNames = require('possible-typed-array-names');

test('not arrays', function (t) {
	t.test('non-number/string primitives', function (st) {
		// @ts-expect-error
		st.equal(false, typedArrayLength(), 'undefined is not typed array');
		st.equal(false, typedArrayLength(null), 'null is not typed array');
		st.equal(false, typedArrayLength(false), 'false is not typed array');
		st.equal(false, typedArrayLength(true), 'true is not typed array');
		st.end();
	});

	t.equal(false, typedArrayLength({}), 'object is not typed array');
	t.equal(false, typedArrayLength(/a/g), 'regex literal is not typed array');
	t.equal(false, typedArrayLength(new RegExp('a', 'g')), 'regex object is not typed array');
	t.equal(false, typedArrayLength(new Date()), 'new Date() is not typed array');

	t.test('numbers', function (st) {
		st.equal(false, typedArrayLength(42), 'number is not typed array');
		st.equal(false, typedArrayLength(Object(42)), 'number object is not typed array');
		st.equal(false, typedArrayLength(NaN), 'NaN is not typed array');
		st.equal(false, typedArrayLength(Infinity), 'Infinity is not typed array');
		st.end();
	});

	t.test('strings', function (st) {
		st.equal(false, typedArrayLength('foo'), 'string primitive is not typed array');
		st.equal(false, typedArrayLength(Object('foo')), 'string object is not typed array');
		st.end();
	});

	t.end();
});

test('Functions', function (t) {
	t.equal(false, typedArrayLength(function () {}), 'function is not typed array');
	t.end();
});

test('Generators', { skip: generators.length === 0 }, function (t) {
	forEach(generators, function (genFn) {
		t.equal(false, typedArrayLength(genFn), 'generator function ' + inspect(genFn) + ' is not typed array');
	});
	t.end();
});

test('Arrow functions', { skip: !arrowFn }, function (t) {
	t.equal(false, typedArrayLength(arrowFn), 'arrow function is not typed array');
	t.end();
});

test('Typed Arrays', function (t) {
	forEach(typedArrayNames, function (typedArray) {
		/** @type {Int8ArrayConstructor | Uint8ArrayConstructor | Uint8ClampedArrayConstructor | Int16ArrayConstructor | Uint16ArrayConstructor | Int32ArrayConstructor | Uint32ArrayConstructor | Float32ArrayConstructor | Float64ArrayConstructor | BigInt64ArrayConstructor | BigUint64ArrayConstructor} */
		var TypedArray = global[typedArray];
		if (isCallable(TypedArray)) {
			var length = 10;
			var arr = new TypedArray(length);
			t.equal(typedArrayLength(arr), length, 'new ' + typedArray + '(10) is typed array of length ' + length);
		} else {
			t.comment('# SKIP ' + typedArray + ' is not supported');
		}
	});
	t.end();
});
'use strict';

var test = require('tape');
var inspect = require('object-inspect');
var is = require('object-is');
var forEach = require('for-each');
var v = require('es-value-fixtures');

var unboxPrimitive = require('..');

test('primitives', function (t) {
	forEach([null, undefined], function (nullValue) {
		t['throws'](
			// @ts-expect-error
			function () { unboxPrimitive(nullValue); },
			TypeError,
			inspect(nullValue) + ' is not a primitive'
		);
	});

	// eslint-disable-next-line no-extra-parens
	forEach(/** @type {typeof v.nonNullPrimitives} */ ([].concat(
		// @ts-expect-error TS sucks with concat
		v.nonNullPrimitives,
		v.zeroes,
		v.infinities,
		NaN
	)), function (primitive) {
		var obj = Object(primitive);
		t.ok(
			is(unboxPrimitive(obj), primitive),
			inspect(obj) + 'unboxes to ' + inspect(primitive)
		);
	});

	t.end();
});

test('objects', function (t) {
	// eslint-disable-next-line no-extra-parens
	forEach(/** @type {typeof v.objects} */ (/** @type {unknown} */ ([].concat(
		// @ts-expect-error TS sucks with concat
		v.objects,
		{},
		[],
		function () {},
		/a/g,
		new Date()
	))), function (object) {
		t['throws'](
			// @ts-expect-error
			function () { unboxPrimitive(object); },
			TypeError,
			inspect(object) + ' is not a primitive'
		);
	});

	t.end();
});
'use strict';

var test = require('tape');
var inspect = require('object-inspect');
var forEach = require('for-each');
var v = require('es-value-fixtures');

var whichBoxedPrimitive = require('../');

var objects = [
	/a/g,
	new Date(),
	function () {},
	[],
	{}
].concat(v.objects);

test('isBoxedPrimitive', function (t) {
	t.test('unboxed primitives', function (st) {
		forEach(v.primitives, function (primitive) {
			st.equal(null, whichBoxedPrimitive(primitive), inspect(primitive) + ' is a primitive, but not a boxed primitive');
		});
		st.end();
	});

	t.test('boxed primitives', function (st) {
		forEach(v.primitives, function (primitive) {
			if (primitive != null) { // eslint-disable-line eqeqeq
				var boxed = Object(primitive);
				var expected = boxed.constructor.name;
				st.equal(typeof expected, 'string', 'expected is string');
				st.equal(whichBoxedPrimitive(boxed), expected, inspect(boxed) + ' is a boxed primitive: ' + expected);
			}
		});
		st.end();
	});

	t.test('non-primitive objects', function (st) {
		forEach(objects, function (object) {
			st.equal(undefined, whichBoxedPrimitive(object), inspect(object) + ' is not a primitive, boxed or otherwise');
		});
		st.end();
	});

	t.end();
});
'use strict';

var test = require('tape');
var inspect = require('object-inspect');
var assign = require('object.assign');
var forEach = require('for-each');
var arrows = require('make-arrow-function').list();
var generators = require('make-generator-function')();
var asyncs = require('make-async-function').list();
var hasSymbols = require('has-symbols')();
var hasToStringTag = require('has-tostringtag/shams')();
var hasBigInts = require('has-bigints')();
var availableTypedArrays = require('available-typed-arrays');

var which = require('../');

if (typeof process !== 'undefined') {
	process.on('unhandledRejection', function () {});
}

test('nullish', function (t) {
	t.equal(which(null), null, 'null is null');
	t.equal(which(undefined), undefined, 'undefined is undefined');
	// @ts-expect-error
	t.equal(which(), undefined, 'absent is undefined');

	t.end();
});

test('non-nullish', function (t) {
	/** @constructor */
	var F = function Foo() {};

	var tests = {
		Number: [
			0,
			-0,
			42,
			Infinity,
			-Infinity,
			NaN,
			0.5
		],
		Boolean: [
			true,
			false
		],
		String: [
			'',
			'foo'
		],
		Date: [
			new Date(),
			new Date(NaN),
			assign(new Date(), { constructor: Object })
		],
		RegExp: [
			/(?:)/,
			/a/g,
			assign(/constructor/, { constructor: Object })
		],
		Array: [
			[],
			[42],
			assign([], { constructor: Object })
		],
		Function: [
			function () {},
			function f() {},
			assign(function constructor() {}, { constructor: Object })
		].concat(arrows),
		GeneratorFunction: generators,
		AsyncFunction: asyncs,
		// eslint-disable-next-line no-extra-parens
		Object: /** @type {object[]} */ ([
			{},
			{ constructor: null },
			Math
		]),
		Symbol: hasSymbols ? [
			Symbol.iterator,
			Symbol(),
			Symbol('foo'),
			Symbol['for'] ? Symbol['for']('bar') : Symbol('no "for" support') // eslint-disable-line no-restricted-properties
		] : [],
		BigInt: hasBigInts ? [
			BigInt(0),
			BigInt(42)
		] : [],
		Foo: [
			new F()
		],
		Map: typeof Map === 'function' ? [
			new Map(),
			new Map([[1, 2], [3, 4]]),
			assign(new Map(), { constructor: Object })
		] : [],
		WeakMap: typeof WeakMap === 'function' ? [
			new WeakMap(),
			assign(new WeakMap(), { constructor: Object })
		] : [],
		Set: typeof Set === 'function' ? [
			new Set(),
			new Set([1, 2, 3, 4]),
			assign(new Set(), { constructor: Object })
		] : [],
		WeakSet: typeof WeakSet === 'function' ? [
			new WeakSet(),
			assign(new WeakSet(), { constructor: Object })
		] : [],
		WeakRef: typeof WeakRef === 'function' ? [
			new WeakRef({}),
			assign(new WeakRef({}), { constructor: Object })
		] : [],
		FinalizationRegistry: typeof FinalizationRegistry === 'function' ? [
			new FinalizationRegistry(function () {}),
			assign(new FinalizationRegistry(function () {}), { constructor: Object })
		] : [],
		Promise: typeof Promise === 'function' ? [
			Promise.resolve(42),
			Promise.reject(NaN),
			new Promise(function () {})
		] : []
	};
	forEach(availableTypedArrays(), function (TypedArray) {
		// @ts-expect-error not sure how to infer this as being spreaded into the above object literal
		tests[TypedArray] = [
			new global[TypedArray](0),
			new global[TypedArray](2)
		];
	});
	forEach(tests, function (values, expected) {
		forEach(values, function (value) {
			t.equal(which(value), expected, inspect(value) + ' is ' + inspect(expected));
			var obj = Object(value);
			if (value !== obj) {
				t.equal(which(obj), expected, inspect(obj) + ' is ' + inspect(expected));
			}
			if (
				expected !== 'Object' // the fallback can't fall back
				&& expected !== 'Foo' // not a builtin
			) {
				if (hasToStringTag) {
					/** @type {{ [k in typeof Symbol.toStringTag]?: string }} */
					var fakerTag = {};
					fakerTag[Symbol.toStringTag] = expected;
					t.equal(
						which(fakerTag),
						'Object',
						inspect(fakerTag) + ' lies and claims it is a ' + expected + ', but instead it is Object'
					);
				}

				/** @typedef {Exclude<typeof expected, 'GeneratorFunction' | 'AsyncFunction' | 'Foo'>} GlobalKey */

				var fakerConstructor = {
					// eslint-disable-next-line no-extra-parens
					constructor: global[/** @type {GlobalKey} */ (expected)] || tests[expected]
				};
				t.equal(
					which(fakerConstructor),
					'Object',
					inspect(fakerConstructor) + ' lies and claims it is a ' + expected + ', but instead it is Object'
				);

				if (hasToStringTag) {
					/** @type {{ constructor: Function } & { [k in typeof Symbol.toStringTag]?: string }} */
					var fakerConstructorTag = {
						// eslint-disable-next-line no-extra-parens
						constructor: global[/** @type {GlobalKey} */ (expected)] || tests[expected]
					};
					fakerConstructorTag[Symbol.toStringTag] = expected;
					t.equal(
						which(fakerConstructorTag),
						'Object',
						inspect(fakerConstructorTag) + ' lies with a tag and claims it is a ' + expected + ', but instead it is Object'
					);
				}
			}
		});
	});

	t.end();
});
'use strict';

var test = require('tape');
var debug = require('object-inspect');
var forEach = require('for-each');

var whichCollection = require('..');

test('non-collections', function (t) {
	forEach([
		null,
		undefined,
		true,
		false,
		42,
		0,
		-0,
		NaN,
		Infinity,
		'',
		'foo',
		/a/g,
		[],
		{},
		function () {}
	], function (nonCollection) {
		t.equal(whichCollection(nonCollection), false, debug(nonCollection) + ' is not a collection');
	});

	t.end();
});

test('Maps', { skip: typeof Map !== 'function' }, function (t) {
	var m = new Map();
	t.equal(whichCollection(m), 'Map', debug(m) + ' is a Map');

	t.end();
});

test('Sets', { skip: typeof Set !== 'function' }, function (t) {
	var s = new Set();
	t.equal(whichCollection(s), 'Set', debug(s) + ' is a Set');

	t.end();
});

test('WeakMaps', { skip: typeof WeakMap !== 'function' }, function (t) {
	var wm = new WeakMap();
	t.equal(whichCollection(wm), 'WeakMap', debug(wm) + ' is a WeakMap');

	t.end();
});

test('WeakSets', { skip: typeof WeakSet !== 'function' }, function (t) {
	var ws = new WeakSet();
	t.equal(whichCollection(ws), 'WeakSet', debug(ws) + ' is a WeakSet');

	t.end();
});
'use strict';

var test = require('tape');
var whichTypedArray = require('../');
var isCallable = require('is-callable');
var hasToStringTag = require('has-tostringtag/shams')();
var generators = require('make-generator-function')();
var arrows = require('make-arrow-function').list();
var forEach = require('for-each');

var typedArrayNames = [
	'Int8Array',
	'Uint8Array',
	'Uint8ClampedArray',
	'Int16Array',
	'Uint16Array',
	'Int32Array',
	'Uint32Array',
	'Float32Array',
	'Float64Array',
	'BigInt64Array',
	'BigUint64Array'
];

test('not arrays', function (t) {
	t.test('non-number/string primitives', function (st) {
		// @ts-expect-error
		st.equal(false, whichTypedArray(), 'undefined is not typed array');
		st.equal(false, whichTypedArray(null), 'null is not typed array');
		st.equal(false, whichTypedArray(false), 'false is not typed array');
		st.equal(false, whichTypedArray(true), 'true is not typed array');
		st.end();
	});

	t.equal(false, whichTypedArray({}), 'object is not typed array');
	t.equal(false, whichTypedArray(/a/g), 'regex literal is not typed array');
	t.equal(false, whichTypedArray(new RegExp('a', 'g')), 'regex object is not typed array');
	t.equal(false, whichTypedArray(new Date()), 'new Date() is not typed array');

	t.test('numbers', function (st) {
		st.equal(false, whichTypedArray(42), 'number is not typed array');
		st.equal(false, whichTypedArray(Object(42)), 'number object is not typed array');
		st.equal(false, whichTypedArray(NaN), 'NaN is not typed array');
		st.equal(false, whichTypedArray(Infinity), 'Infinity is not typed array');
		st.end();
	});

	t.test('strings', function (st) {
		st.equal(false, whichTypedArray('foo'), 'string primitive is not typed array');
		st.equal(false, whichTypedArray(Object('foo')), 'string object is not typed array');
		st.end();
	});

	t.end();
});

test('Functions', function (t) {
	t.equal(false, whichTypedArray(function () {}), 'function is not typed array');
	t.end();
});

test('Generators', { skip: generators.length === 0 }, function (t) {
	forEach(generators, function (genFn) {
		t.equal(false, whichTypedArray(genFn), 'generator function ' + genFn + ' is not typed array');
	});
	t.end();
});

test('Arrow functions', { skip: arrows.length === 0 }, function (t) {
	forEach(arrows, function (arrowFn) {
		t.equal(false, whichTypedArray(arrowFn), 'arrow function ' + arrowFn + ' is not typed array');
	});
	t.end();
});

test('@@toStringTag', { skip: !hasToStringTag }, function (t) {
	forEach(typedArrayNames, function (typedArray) {
		// @ts-expect-error TODO: fix
		if (typeof global[typedArray] === 'function') {
			// @ts-expect-error TODO: fix
			var fakeTypedArray = [];
			// @ts-expect-error TODO: fix
			fakeTypedArray[Symbol.toStringTag] = typedArray;
			// @ts-expect-error TODO: fix
			t.equal(false, whichTypedArray(fakeTypedArray), 'faked ' + typedArray + ' is not typed array');
		} else {
			t.comment('# SKIP ' + typedArray + ' is not supported');
		}
	});
	t.end();
});

test('Typed Arrays', function (t) {
	forEach(typedArrayNames, function (typedArray) {
		// @ts-expect-error TODO: fix
		/** @type {import('../').TypedArrayConstructor} */ var TypedArray = global[typedArray];
		if (isCallable(TypedArray)) {
			var arr = new TypedArray(10);
			t.equal(whichTypedArray(arr), typedArray, 'new ' + typedArray + '(10) is typed array of type ' + typedArray);
		} else {
			t.comment('# SKIP ' + typedArray + ' is not supported');
		}
	});
	t.end();
});
# Installation
> `npm install --save @types/node`

# Summary
This package contains type definitions for node (https://nodejs.org/).

# Details
Files were exported from https://github.com/DefinitelyTyped/DefinitelyTyped/tree/master/types/node.

### Additional Details
 * Last updated: Fri, 30 May 2025 18:40:02 GMT
 * Dependencies: [undici-types](https://npmjs.com/package/undici-types)

# Credits
These definitions were written by [Microsoft TypeScript](https://github.com/Microsoft), [Alberto Schiabel](https://github.com/jkomyno), [Alvis HT Tang](https://github.com/alvis), [Andrew Makarov](https://github.com/r3nya), [Benjamin Toueg](https://github.com/btoueg), [Chigozirim C.](https://github.com/smac89), [David Junger](https://github.com/touffy), [Deividas Bakanas](https://github.com/DeividasBakanas), [Eugene Y. Q. Shen](https://github.com/eyqs), [Hannes Magnusson](https://github.com/Hannes-Magnusson-CK), [Huw](https://github.com/hoo29), [Kelvin Jin](https://github.com/kjin), [Klaus Meinhardt](https://github.com/ajafff), [Lishude](https://github.com/islishude), [Mariusz Wiktorczyk](https://github.com/mwiktorczyk), [Mohsen Azimi](https://github.com/mohsen1), [Nikita Galkin](https://github.com/galkin), [Parambir Singh](https://github.com/parambirs), [Sebastian Silbermann](https://github.com/eps1lon), [Thomas den Hollander](https://github.com/ThomasdenH), [Wilco Bakker](https://github.com/WilcoBakker), [wwwy3y3](https://github.com/wwwy3y3), [Samuel Ainsworth](https://github.com/samuela), [Kyle Uehlein](https://github.com/kuehlein), [Thanik Bhongbhibhat](https://github.com/bhongy), [Marcin Kopacz](https://github.com/chyzwar), [Trivikram Kamat](https://github.com/trivikr), [Junxiao Shi](https://github.com/yoursunny), [Ilia Baryshnikov](https://github.com/qwelias), [ExE Boss](https://github.com/ExE-Boss), [Piotr Błażejewicz](https://github.com/peterblazejewicz), [Anna Henningsen](https://github.com/addaleax), [Victor Perin](https://github.com/victorperin), [NodeJS Contributors](https://github.com/NodeJS), [Linus Unnebäck](https://github.com/LinusU), [wafuwafu13](https://github.com/wafuwafu13), [Matteo Collina](https://github.com/mcollina), [Dmitry Semigradsky](https://github.com/Semigradsky), and [René](https://github.com/Renegade334).
